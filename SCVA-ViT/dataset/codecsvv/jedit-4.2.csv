metric_name,file
bsh.BlockNameSpace,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package	bsh;
/**
    A specialized namespace	for Blocks (e.g. the body of a ""for"" statement).
	The Block acts like a child namespace but only for typed variables 
	declared within it (block local scope) or untyped variables explicitly set 
	in it via setBlockVariable().  Otherwise variable assignment 
	(including untyped variable usage) acts like it is part of the containing
	block.  
	<p>
*/
/*
	Note: This class essentially just delegates most of its methods to its
	parent.  The setVariable() indirection is very small.  We could probably
	fold this functionality back into the base NameSpace as a special case.
	But this has changed a few times so I'd like to leave this abstraction for
	now.
*/
class BlockNameSpace extends NameSpace 
{
    public BlockNameSpace( NameSpace parent ) 
		throws EvalError
	{
		super( parent, parent.getName()+ ""/BlockNameSpace"" );
    }
	/**
		Override the standard namespace behavior to make assignments
		happen in our parent (enclosing) namespace, unless the variable has
		already been assigned here via a typed declaration or through
		the special setBlockVariable() (used for untyped args in try/catch).
		<p>
		i.e. only allow typed var declaration to happen in this namespace.
		Typed vars are handled in the ordinary way local scope.  All untyped
		assignments are delegated to the enclosing context.
	*/
	/*
		Note: it may see like with the new 1.3 scoping this test could be
		removed, but it cannot.  When recurse is false we still need to set the
		variable in our parent, not here.
	*/
    public void	setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		if ( weHaveVar( name ) ) 
			// set the var here in the block namespace
			super.setVariable( name, value, strictJava, false );
		else
			// set the var in the enclosing (parent) namespace
			getParent().setVariable( name, value, strictJava, recurse );
    }
	/**
		Set an untyped variable in the block namespace.
		The BlockNameSpace would normally delegate this set to the parent.
		Typed variables are naturally set locally.
		This is used in try/catch block argument. 
	*/
    public void	setBlockVariable( String name, Object value ) 
		throws UtilEvalError 
	{
		super.setVariable( name, value, false/*strict?*/, false );
	}
	/**
		We have the variable: either it was declared here with a type, giving
		it block local scope or an untyped var was explicitly set here via
		setBlockVariable().
	*/
	private boolean weHaveVar( String name ) 
	{
		// super.variables.containsKey( name ) not any faster, I checked
		try {
			return super.getVariableImpl( name, false ) != null;
		} catch ( UtilEvalError e ) { return false; }
	}
/**
		Get the actual BlockNameSpace 'this' reference.
		<p/>
		Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )
		resolves to the parent namespace (e.g. the namespace containing the
		""if"" statement).  However when code inside the BlockNameSpace needs to
		resolve things relative to 'this' we must use the actual block's 'this'
		reference.  Name.java is smart enough to handle this using
		getBlockThis().
		@see #getThis( Interpreter )
    This getBlockThis( Interpreter declaringInterpreter ) 
	{
		return super.getThis( declaringInterpreter );
	}
*/
	//
	// Begin methods which simply delegate to our parent (enclosing scope) 
	//
	/**
		This method recurses to find the nearest non-BlockNameSpace parent.
	public NameSpace getParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return parent.getParent();
		else
			return parent;
	}
*/
	/** do we need this? */
	private NameSpace getNonBlockParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return ((BlockNameSpace)parent).getNonBlockParent();
		else
			return parent;
	}
	/**
		Get a 'this' reference is our parent's 'this' for the object closure.
		e.g. Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )
		resolves to the parent namespace (e.g. the namespace containing the
		""if"" statement). 
		@see #getBlockThis( Interpreter )
	*/
    This getThis( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getThis( declaringInterpreter );
	}
	/**
		super is our parent's super
	*/
    public This getSuper( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getSuper( declaringInterpreter );
	}
	/**
		delegate import to our parent
	*/
    public void	importClass(String name) {
		getParent().importClass( name );
	}
	/**
		delegate import to our parent
	*/
    public void	importPackage(String name) {
		getParent().importPackage( name );
	}
    public void	setMethod(String name, BshMethod method) 
		throws UtilEvalError
	{
		getParent().setMethod( name, method );
	}
}
"
bsh.BSHAllocationExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
/**
	New object, new array, or inner class style allocation with body.
*/
class BSHAllocationExpression extends SimpleNode
{
    BSHAllocationExpression(int id) { super(id); }
	private static int innerClassCount = 0;
    public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        // type is either a class name or a primitive type
        SimpleNode type = (SimpleNode)jjtGetChild(0);
        // args is either constructor arguments or array dimensions
        SimpleNode args = (SimpleNode)jjtGetChild(1);
        if ( type instanceof BSHAmbiguousName )
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;
            if (args instanceof BSHArguments)
                return objectAllocation(name, (BSHArguments)args, 
					callstack, interpreter );
            else
                return objectArrayAllocation(name, (BSHArrayDimensions)args, 
					callstack, interpreter );
        }
        else
            return primitiveArrayAllocation((BSHPrimitiveType)type,
                (BSHArrayDimensions)args, callstack, interpreter );
    }
    private Object objectAllocation(
		BSHAmbiguousName nameNode, BSHArguments argumentsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
		NameSpace namespace = callstack.top();
        Object[] args = argumentsNode.getArguments( callstack, interpreter );
        if ( args == null)
            throw new EvalError( ""Null args in new."", this, callstack );
		// Look for scripted class object
        Object obj = nameNode.toObject( 
			callstack, interpreter, false/* force class*/ );
		// Try regular class
        obj = nameNode.toObject( 
			callstack, interpreter, true/*force class*/ );
        Class type = null;
		if ( obj instanceof ClassIdentifier )
        	type = ((ClassIdentifier)obj).getTargetClass();
		else
			throw new EvalError( 
				""Unknown class: ""+nameNode.text, this, callstack );
		// Is an inner class style object allocation
		boolean hasBody = jjtGetNumChildren() > 2;
		if ( hasBody ) 
		{
        	BSHBlock body = (BSHBlock)jjtGetChild(2);
			if ( type.isInterface() )
				return constructWithInterfaceBody( 
					type, args, body, callstack, interpreter );
			else
				return constructWithClassBody( 
					type, args, body, callstack, interpreter );
		} else
			return constructObject( type, args, callstack );
    }
	private Object constructObject( 
		Class type, Object[] args, CallStack callstack ) 
		throws EvalError
	{
		Object obj;
        try {
            obj = Reflect.constructObject( type, args );
        } catch ( ReflectError e) {
            throw new EvalError(
				""Constructor error: "" + e.getMessage(), this, callstack );
        } catch(InvocationTargetException e) {
			// No need to wrap this debug
			Interpreter.debug(""The constructor threw an exception:\n\t"" +
				e.getTargetException());
            throw new TargetError(
				""Object constructor"", e.getTargetException(), 
				this, callstack, true);
        }
		String className = type.getName();
		// Is it an inner class?
		if ( className.indexOf(""$"") == -1 )
			return obj;
		// Temporary hack to support inner classes 
		// If the obj is a non-static inner class then import the context...
		// This is not a sufficient emulation of inner classes.
		// Replace this later...
		// work through to class 'this'
		This ths = callstack.top().getThis( null );
		NameSpace instanceNameSpace = 
			Name.getClassNameSpace( ths.getNameSpace() );
		// Change the parent (which was the class static) to the class instance
		// We really need to check if we're a static inner class here first...
		// but for some reason Java won't show the static modifier on our
		// fake inner classes...  could generate a flag field.
		if ( instanceNameSpace != null 
			&& className.startsWith( instanceNameSpace.getName() +""$"") 
		)
		{
			try {
				ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(
					obj, className, instanceNameSpace );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack );
			}
		}
		return obj;
	}
	private Object constructWithClassBody( 
		Class type, Object[] args, BSHBlock block,
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		String name = callstack.top().getName() + ""$"" + (++innerClassCount);
		Modifiers modifiers = new Modifiers();
		modifiers.addModifier( Modifiers.CLASS, ""public"" );
		Class clas;
		try {
			clas = ClassGenerator.getClassGenerator() .generateClass( 
				name, modifiers, null/*interfaces*/, type/*superClass*/, 
				block, false/*isInterface*/, callstack, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
		try {
			return Reflect.constructObject( clas, args );
		} catch ( Exception e ) {
			if ( e instanceof InvocationTargetException )
				e = (Exception)((InvocationTargetException)e)
					.getTargetException();
			throw new EvalError(
				""Error constructing inner class instance: ""+e, this, callstack
			);
		}
	}
	private Object constructWithInterfaceBody( 
		Class type, Object[] args, BSHBlock body,
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		NameSpace local = new NameSpace(namespace, ""AnonymousBlock"");
		callstack.push(local);
		body.eval( callstack, interpreter, true/*overrideNamespace*/ );
		callstack.pop();
		// statical import fields from the interface so that code inside
		// can refer to the fields directly (e.g. HEIGHT)
		local.importStatic( type );
		try {
			return local.getThis(interpreter).getInterface( type );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}
    private Object objectArrayAllocation(
		BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class type = nameNode.toClass( callstack, interpreter );
        if ( type == null )
            throw new EvalError( ""Class "" + nameNode.getName(namespace) 
				+ "" not found."", this, callstack );
		return arrayAllocation( dimensionsNode, type, callstack, interpreter );
    }
    private Object primitiveArrayAllocation(
		BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
        Class type = typeNode.getType();
		return arrayAllocation( dimensionsNode, type, callstack, interpreter );
    }
	private Object arrayAllocation( 
		BSHArrayDimensions dimensionsNode, Class type, 
		CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		/*
			dimensionsNode can return either a fully intialized array or VOID.
			when VOID the prescribed array dimensions (defined and undefined)
			are contained in the node.
		*/
        Object result = dimensionsNode.eval( type, callstack, interpreter );
        if ( result != Primitive.VOID )
            return result;
		else
			return arrayNewInstance( type, dimensionsNode, callstack );
	}
	/**
		Create an array of the dimensions specified in dimensionsNode.
		dimensionsNode may contain a number of ""undefined"" as well as ""defined""
		dimensions.
		<p>
		Background: in Java arrays are implemented in arrays-of-arrays style
		where, for example, a two dimensional array is a an array of arrays of
		some base type.  Each dimension-type has a Java class type associated 
		with it... so if foo = new int[5][5] then the type of foo is 
		int [][] and the type of foo[0] is int[], etc.  Arrays may also be 
		specified with undefined trailing dimensions - meaning that the lower 
		order arrays are not allocated as objects. e.g.  
		if foo = new int [5][]; then foo[0] == null //true; and can later be 
		assigned with the appropriate type, e.g. foo[0] = new int[5];
		(See Learning Java, O'Reilly & Associates more background).
		<p>
		To create an array with undefined trailing dimensions using the
		reflection API we must use an array type to represent the lower order
		(undefined) dimensions as the ""base"" type for the array creation... 
		Java will then create the correct type by adding the dimensions of the 
		base type to specified allocated dimensions yielding an array of
		dimensionality base + specified with the base dimensons unallocated.  
		To create the ""base"" array type we simply create a prototype, zero 
		length in each dimension, array and use it to get its class 
		(Actually, I think there is a way we could do it with Class.forName() 
		but I don't trust this).   The code is simpler than the explanation...
		see below.
	*/
	private Object arrayNewInstance( 
		Class type, BSHArrayDimensions dimensionsNode, CallStack callstack )
		throws EvalError
	{
		if ( dimensionsNode.numUndefinedDims > 0 )
		{
            Object proto = Array.newInstance( 
				type, new int [dimensionsNode.numUndefinedDims] ); // zeros
			type = proto.getClass();
		}
        try {
            return Array.newInstance( 
				type, dimensionsNode.definedDimensions);
        } catch( NegativeArraySizeException e1 ) {
			throw new TargetError( e1, this, callstack );
        } catch( Exception e ) {
            throw new EvalError(""Can't construct primitive array: "" +
                e.getMessage(), this, callstack);
        }
	}
}
"
bsh.BSHAmbiguousName,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHAmbiguousName extends SimpleNode
{
    public String text;
    BSHAmbiguousName(int id) { super(id); }
    public Name getName( NameSpace namespace )
    {
        return namespace.getNameResolver( text );
    }
    public Object toObject( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		return toObject( callstack, interpreter, false );
    }
    Object toObject( 
		CallStack callstack, Interpreter interpreter, boolean forceClass ) 
		throws EvalError
    {
		try {
        	return 
				getName( callstack.top() ).toObject( 
					callstack, interpreter, forceClass );
		} catch ( UtilEvalError e ) {
//e.printStackTrace();
			throw e.toEvalError( this, callstack );
		}
    }
    public Class toClass( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		try {
        	return getName( callstack.top() ).toClass();
		} catch ( ClassNotFoundException e ) {
			throw new EvalError( e.getMessage(), this, callstack );
		} catch ( UtilEvalError e2 ) {
			// ClassPathException is a type of UtilEvalError
			throw e2.toEvalError( this, callstack );
		}
    }
    public LHS toLHS( CallStack callstack, Interpreter interpreter)
		throws EvalError
    {
		try {
			return getName( callstack.top() ).toLHS( callstack, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
    }
	/*
		The interpretation of an ambiguous name is context sensitive.
		We disallow a generic eval( ).
	*/
    public Object eval( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		throw new InterpreterError( 
			""Don't know how to eval an ambiguous name!""
			+""  Use toObject() if you want an object."" );
    }
	public String toString() {
		return ""AmbigousName: ""+text;
	}
}
"
bsh.BSHArguments,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHArguments extends SimpleNode
{
    BSHArguments(int id) { super(id); }
	/**
		This node holds a set of arguments for a method invocation or
		constructor call.
		Note: arguments are not currently allowed to be VOID.
	*/
	/*
		Disallowing VOIDs here was an easy way to support the throwing of a 
		more descriptive error message on use of an undefined argument to a 
		method call (very common).  If it ever turns out that we need to 
		support that for some reason we'll have to re-evaluate how we get 
		""meta-information"" about the arguments in the various invoke() methods 
		that take Object [].  We could either pass BSHArguments down to 
		overloaded forms of the methods or throw an exception subtype 
		including the argument position back up, where the error message would
		be compounded.
	*/
    public Object[] getArguments( CallStack callstack, Interpreter interpreter)
		throws EvalError
    {
        // evaluate each child
        Object[] args = new Object[jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
		{
            args[i] = ((SimpleNode)jjtGetChild(i)).eval(callstack, interpreter);
			if ( args[i] == Primitive.VOID )
				throw new EvalError( ""Undefined argument: "" + 
					((SimpleNode)jjtGetChild(i)).getText(), this, callstack );
		}
        return args;
    }
}
"
bsh.BSHArrayDimensions,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
/**
	The name of this class is somewhat misleading.  This covers both the case
	where there is an array initializer and 
*/
class BSHArrayDimensions extends SimpleNode
{
	public Class baseType;
    public int numDefinedDims;
    public int numUndefinedDims;
	/** 
		The Length in each defined dimension.  This value set by the eval() 
		Since the values can come from Expressions we should be re-eval()d each
		time.
	*/
	public int [] definedDimensions;  
    BSHArrayDimensions(int id) { super(id); }
    public void addDefinedDimension() { numDefinedDims++; }
    public void addUndefinedDimension() { numUndefinedDims++; }
    public Object eval( 
			Class type, CallStack callstack, Interpreter interpreter ) 
		throws EvalError 
	{
		if ( Interpreter.DEBUG ) Interpreter.debug(""array base type = ""+type);
		baseType = type;
		return eval( callstack, interpreter );
	}
	/**
		Evaluate the structure of the array in one of two ways:
			a) an initializer exists, evaluate it and return
			the fully constructed array object, also record the dimensions
			of that array
			b) evaluate and record the lengths in each dimension and 
			return void.
		The structure of the array dims is maintained in dimensions.
	*/
    public Object eval( CallStack callstack, Interpreter interpreter )  
		throws EvalError
    {
		SimpleNode child = (SimpleNode)jjtGetChild(0);
		/*
			Child is array initializer.  Evaluate it and fill in the 
			dimensions it returns.  Initialized arrays are always fully defined
			(no undefined dimensions to worry about).  
			The syntax uses the undefinedDimension count.
			e.g. int [][] { 1, 2 };
		*/
		if (child instanceof BSHArrayInitializer)
		{
			if ( baseType == null )
				throw new EvalError( 
					""Internal Array Eval err:  unknown base type"", 
					this, callstack );
			Object initValue = ((BSHArrayInitializer)child).eval(
				baseType, numUndefinedDims, callstack, interpreter);
			Class arrayClass = initValue.getClass();
			int actualDimensions = Reflect.getArrayDimensions(arrayClass);
			definedDimensions = new int[ actualDimensions ];
			// Compare with number of dimensions actually created with the
			// number specified (syntax uses the undefined ones here)
			if ( definedDimensions.length != numUndefinedDims )
				throw new EvalError(
				""Incompatible initializer. Allocation calls for a "" + 
				numUndefinedDims+ "" dimensional array, but initializer is a "" +
					actualDimensions + "" dimensional array"", this, callstack );
			// fill in definedDimensions [] lengths
			Object arraySlice = initValue;
			for ( int i = 0; i < definedDimensions.length; i++ ) {
				definedDimensions[i] = Array.getLength( arraySlice );
				if ( definedDimensions[i] > 0 )
					arraySlice = Array.get(arraySlice, 0);
			}
			return initValue;
		}
		else 
		// Evaluate the defined dimensions of the array
		{
			definedDimensions = new int[ numDefinedDims ];
			for(int i = 0; i < numDefinedDims; i++)
			{
				try {
					Object length = ((SimpleNode)jjtGetChild(i)).eval(
						callstack, interpreter);
					definedDimensions[i] = ((Primitive)length).intValue();
				}
				catch(Exception e)
				{
					throw new EvalError(
						""Array index: "" + i + 
						"" does not evaluate to an integer"", this, callstack );
				}
			}
		}
        return Primitive.VOID;
    }
}
"
bsh.BSHArrayInitializer,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
class BSHArrayInitializer extends SimpleNode
{
    BSHArrayInitializer(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError 
	{
		throw new EvalError( ""Array initializer has no base type."", 
			this, callstack );
	}
	/**
		Construct the array from the initializer syntax.
		@param baseType the base class type of the array (no dimensionality)
		@param dimensions the top number of dimensions of the array 
			e.g. 2 for a String [][];
	*/
    public Object eval( Class baseType, int dimensions, 
						CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
        int numInitializers = jjtGetNumChildren();
		// allocate the array to store the initializers
		int [] dima = new int [dimensions]; // description of the array
		// The other dimensions default to zero and are assigned when 
		// the values are set.
		dima[0] = numInitializers;
        Object initializers = 
			Array.newInstance( baseType, dima );
		// Evaluate the initializers
        for (int i = 0; i < numInitializers; i++)
        {
			SimpleNode node = (SimpleNode)jjtGetChild(i);
            Object currentInitializer;
			if ( node instanceof BSHArrayInitializer ) {
				if ( dimensions < 2 )
					throw new EvalError(
						""Invalid Location for Intializer, position: ""+i, 
						this, callstack );
            	currentInitializer = 
					((BSHArrayInitializer)node).eval( 
						baseType, dimensions-1, callstack, interpreter);
			} else
            	currentInitializer = node.eval( callstack, interpreter);
			if ( currentInitializer == Primitive.VOID )
				throw new EvalError(
					""Void in array initializer, position""+i, this, callstack );
			// unwrap primitive to the wrapper type
			Object value;
			if ( currentInitializer instanceof Primitive )
			{
				Primitive primValue = (Primitive)currentInitializer;
				/*
				TODO:
					to get cast and boxing working e.g.
					e.g. Byte [] ia = { 1, 2 }
					If the baseType is a wrapper type then we need to get the 
					primitive TYPE class for the base type here in order for 
					the cast to allow it... Then boxing will happen naturally in
					the Array.set().
					e.g. Integer [] ia = { 1, 2 }
				*/
				/*
				if ( Primitive.isWrapperType( baseType ) )
					baseType = Primitive.getPrimitiveTypeForType( baseType );
				*/
				// don't deal with object types here... unless above
				if ( baseType.isPrimitive() )
					try {
						primValue = primValue.castToType( 
							baseType, Types.CAST );
					} catch ( UtilEvalError e ) {
					e.printStackTrace();
						Interpreter.debug(""error:""+e);
						throwTypeError( baseType, primValue, i, callstack );
					}
				value = primValue.getValue();
			}
			else
				value = currentInitializer;
			// store the value in the array
            try {
				Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
				Interpreter.debug(""illegal arg""+e);
				throwTypeError( baseType, currentInitializer, i, callstack );
            } catch( ArrayStoreException e ) { // I think this can happen
				Interpreter.debug(""arraystore""+e);
				throwTypeError( baseType, currentInitializer, i, callstack );
            }
        }
        return initializers;
    }
	private void throwTypeError( 
		Class baseType, Object initializer, int argNum, CallStack callstack ) 
		throws EvalError
	{
		String rhsType;
		if (initializer instanceof Primitive)
			rhsType = 
				((Primitive)initializer).getType().getName();
		else
			rhsType = Reflect.normalizeClassName(
				initializer.getClass());
		throw new EvalError ( ""Incompatible type: "" + rhsType 
			+"" in initializer of array type: ""+ baseType
			+"" at position: ""+argNum, this, callstack );
	}
}
"
bsh.BSHAssignment,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHAssignment extends SimpleNode implements ParserConstants
{
    public int operator;
    BSHAssignment(int id) { super(id); }
    public Object eval(
		CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        BSHPrimaryExpression lhsNode = 
			(BSHPrimaryExpression)jjtGetChild(0);
		if ( lhsNode == null )
			throw new InterpreterError( ""Error, null LHSnode"" );
		boolean strictJava = interpreter.getStrictJava();
        LHS lhs = lhsNode.toLHS( callstack, interpreter);
        if ( lhs == null )
            throw new InterpreterError( ""Error, null LHS"" );
		// For operator-assign operations save the lhs value before evaluating
		// the rhs.  This is correct Java behavior for postfix operations
		// e.g. i=1; i+=i++; // should be 2 not 3
		Object lhsValue = null;
		if ( operator != ASSIGN ) // assign doesn't need the pre-value
			try {
				lhsValue = lhs.getValue();
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack );
			}
        SimpleNode rhsNode = (SimpleNode)jjtGetChild(1);
        Object rhs;
		// implement ""blocks"" foo = { };
		// if ( rhsNode instanceof BSHBlock )
		//    rsh =
		// else
        rhs = rhsNode.eval(callstack, interpreter);
        if ( rhs == Primitive.VOID )
            throw new EvalError(""Void assignment."", this, callstack );
		try {
			switch(operator)
			{
				case ASSIGN:
					return lhs.assign( rhs, strictJava );
				case PLUSASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, PLUS), strictJava );
	            case MINUSASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, MINUS), strictJava );
				case STARASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, STAR), strictJava );
	            case SLASHASSIGN:
					return lhs.assign( 
						operation(lhsValue, rhs, SLASH), strictJava );
	            case ANDASSIGN:
				case ANDASSIGNX:
					return lhs.assign( 
						operation(lhsValue, rhs, BIT_AND), strictJava );
	            case ORASSIGN:
	            case ORASSIGNX:
	                return lhs.assign( 
						operation(lhsValue, rhs, BIT_OR), strictJava );
	            case XORASSIGN:
	                return lhs.assign( 
						operation(lhsValue, rhs, XOR), strictJava );
	            case MODASSIGN:
	                return lhs.assign( 
						operation(lhsValue, rhs, MOD), strictJava );
	            case LSHIFTASSIGN:
	            case LSHIFTASSIGNX:
	                return lhs.assign( 
						operation(lhsValue, rhs, LSHIFT), strictJava );
	            case RSIGNEDSHIFTASSIGN:
	            case RSIGNEDSHIFTASSIGNX:
	                return lhs.assign( 
					operation(lhsValue, rhs, RSIGNEDSHIFT ), strictJava );
	            case RUNSIGNEDSHIFTASSIGN:
	            case RUNSIGNEDSHIFTASSIGNX:
	                return lhs.assign( 
						operation(lhsValue, rhs, RUNSIGNEDSHIFT), 
						strictJava );
				default:
					throw new InterpreterError(
						""unimplemented operator in assignment BSH"");
			}
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
    }
    private Object operation( Object lhs, Object rhs, int kind ) 
		throws UtilEvalError
    {
		/*
			Implement String += value;
			According to the JLS, value may be anything.
			In BeanShell, we'll disallow VOID (undefined) values.
			(or should we map them to the empty string?)
		*/
		if ( lhs instanceof String && rhs != Primitive.VOID ) {
			if ( kind != PLUS )
				throw new UtilEvalError(
					""Use of non + operator with String LHS"" );
			return (String)lhs + rhs;
		}
        if ( lhs instanceof Primitive || rhs instanceof Primitive )
            if(lhs == Primitive.VOID || rhs == Primitive.VOID)
                throw new UtilEvalError(
					""Illegal use of undefined object or 'void' literal"" );
            else if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                throw new UtilEvalError(
					""Illegal use of null object or 'null' literal"" );
        if( (lhs instanceof Boolean || lhs instanceof Character ||
             lhs instanceof Number || lhs instanceof Primitive) &&
            (rhs instanceof Boolean || rhs instanceof Character ||
             rhs instanceof Number || rhs instanceof Primitive) )
        {
            return Primitive.binaryOperation(lhs, rhs, kind);
        }
        throw new UtilEvalError(""Non primitive value in operator: "" +
            lhs.getClass() + "" "" + tokenImage[kind] + "" "" + rhs.getClass() );
    }
}
"
bsh.BSHBinaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Implement binary expressions...
	Note: this is too complicated... need some cleanup and simplification.
	@see Primitive.binaryOperation
*/
class BSHBinaryExpression extends SimpleNode 
	implements ParserConstants 
{
    public int kind;
    BSHBinaryExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        Object lhs = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		/*
			Doing instanceof?  Next node is a type.
		*/
        if (kind == INSTANCEOF)
        {
			// null object ref is not instance of any type
			if ( lhs == Primitive.NULL )
				return new Primitive(false);
            Class rhs = ((BSHType)jjtGetChild(1)).getType( 
				callstack, interpreter );
		/*
			// primitive (number or void) cannot be tested for instanceof
            if (lhs instanceof Primitive)
				throw new EvalError(""Cannot be instance of primitive type."" );
		*/
			/*
				Primitive (number or void) is not normally an instanceof
				anything.  But for internal use we'll test true for the
				bsh.Primitive class.  
				i.e. (5 instanceof bsh.Primitive) will be true
			*/
			if ( lhs instanceof Primitive )
				if ( rhs == bsh.Primitive.class )
					return new Primitive(true);
				else
					return new Primitive(false);
			// General case - performe the instanceof based on assignability
            boolean ret = Types.isJavaAssignable( rhs, lhs.getClass() );
            return new Primitive(ret);
        }
		// The following two boolean checks were tacked on.
		// This could probably be smoothed out.
		/*
			Look ahead and short circuit evaluation of the rhs if:
				we're a boolean AND and the lhs is false.
		*/
		if ( kind == BOOL_AND || kind == BOOL_ANDX ) {
			Object obj = lhs;
			if ( isPrimitiveValue(lhs) )
				obj = ((Primitive)lhs).getValue();
			if ( obj instanceof Boolean && 
				( ((Boolean)obj).booleanValue() == false ) )
				return new Primitive(false);
		}
		/*
			Look ahead and short circuit evaluation of the rhs if:
				we're a boolean AND and the lhs is false.
		*/
		if ( kind == BOOL_OR || kind == BOOL_ORX ) {
			Object obj = lhs;
			if ( isPrimitiveValue(lhs) )
				obj = ((Primitive)lhs).getValue();
			if ( obj instanceof Boolean && 
				( ((Boolean)obj).booleanValue() == true ) )
				return new Primitive(true);
		}
		// end stuff that was tacked on for boolean short-circuiting.
		/*
			Are both the lhs and rhs either wrappers or primitive values?
			do binary op
		*/
		boolean isLhsWrapper = isWrapper( lhs );
        Object rhs = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
		boolean isRhsWrapper = isWrapper( rhs );
		if ( 
			( isLhsWrapper || isPrimitiveValue( lhs ) )
			&& ( isRhsWrapper || isPrimitiveValue( rhs ) )
		)
        {
			// Special case for EQ on two wrapper objects
			if ( (isLhsWrapper && isRhsWrapper && kind == EQ)) 
			{
				/*  
					Don't auto-unwrap wrappers (preserve identity semantics)
					FALL THROUGH TO OBJECT OPERATIONS BELOW.
				*/
			} else
				try {
					return Primitive.binaryOperation(lhs, rhs, kind);
				} catch ( UtilEvalError e ) {
					throw e.toEvalError( this, callstack  );
				}
        }
	/*
	Doing the following makes it hard to use untyped vars...
	e.g. if ( arg == null ) ...what if arg is a primitive?
	The answer is that we should test only if the var is typed...?
	need to get that info here...
		else
		{
		// Do we have a mixture of primitive values and non-primitives ?  
		// (primitiveValue = not null, not void)
		int primCount = 0;
		if ( isPrimitiveValue( lhs ) )
			++primCount;
		if ( isPrimitiveValue( rhs ) )
			++primCount;
		if ( primCount > 1 )
			// both primitive types, should have been handled above
			throw new InterpreterError(""should not be here"");
		else 
		if ( primCount == 1 )
			// mixture of one and the other
			throw new EvalError(""Operator: '"" + tokenImage[kind]
				+""' inappropriate for object / primitive combination."", 
				this, callstack );
		// else fall through to handle both non-primitive types
		// end check for primitive and non-primitive mix 
		}
	*/
		/*
			Treat lhs and rhs as arbitrary objects and do the operation.
			(including NULL and VOID represented by their Primitive types)
		*/
		//System.out.println(""binary op arbitrary obj: {""+lhs+""}, {""+rhs+""}"");
        switch(kind)
        {
            case EQ:
                return new Primitive((lhs == rhs));
            case NE:
                return new Primitive((lhs != rhs));
            case PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();
            // FALL THROUGH TO DEFAULT CASE!!!
            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )
                        throw new EvalError(
				""illegal use of undefined variable, class, or 'void' literal"", 
							this, callstack );
                    else 
					if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                        throw new EvalError(
				""illegal use of null value or 'null' literal"", this, callstack);
                throw new EvalError(""Operator: '"" + tokenImage[kind] +
                    ""' inappropriate for objects"", this, callstack );
        }
    }
	/*
		object is a non-null and non-void Primitive type
	*/
	private boolean isPrimitiveValue( Object obj ) {
        return ( (obj instanceof Primitive) 
			&& (obj != Primitive.VOID) && (obj != Primitive.NULL) );
	}
	/*
		object is a java.lang wrapper for boolean, char, or number type
	*/
	private boolean isWrapper( Object obj ) {
        return ( obj instanceof Boolean || 
			obj instanceof Character || obj instanceof Number );
	}
}
"
bsh.BSHBlock,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHBlock extends SimpleNode
{
	public boolean isSynchronized = false;
	BSHBlock(int id) { super(id); }
	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		return eval( callstack, interpreter, false );
	}
	/**
		@param overrideNamespace if set to true the block will be executed
		in the current namespace (not a subordinate one).
		<p>
		If true *no* new BlockNamespace will be swapped onto the stack and 
		the eval will happen in the current
		top namespace.  This is used by BshMethod, TryStatement, etc.  
		which must intialize the block first and also for those that perform 
		multiple passes in the same block.
	*/
	public Object eval( 
		CallStack callstack, Interpreter interpreter, 
		boolean overrideNamespace ) 
		throws EvalError
	{
		Object syncValue = null;
		if ( isSynchronized ) 
		{
			// First node is the expression on which to sync
			SimpleNode exp = ((SimpleNode)jjtGetChild(0));
			syncValue = exp.eval(callstack, interpreter);
		}
		Object ret;
		if ( isSynchronized ) // Do the actual synchronization
			synchronized( syncValue )
			{
				ret = evalBlock( 
					callstack, interpreter, overrideNamespace, null/*filter*/);
			}
		else
				ret = evalBlock( 
					callstack, interpreter, overrideNamespace, null/*filter*/ );
		return ret;
	}
	Object evalBlock( 
		CallStack callstack, Interpreter interpreter, 
		boolean overrideNamespace, NodeFilter nodeFilter ) 
		throws EvalError
	{	
		Object ret = Primitive.VOID;
		NameSpace enclosingNameSpace = null;
		if ( !overrideNamespace ) 
		{
			enclosingNameSpace= callstack.top();
			BlockNameSpace bodyNameSpace = 
				new BlockNameSpace( enclosingNameSpace );
			callstack.swap( bodyNameSpace );
		}
		int startChild = isSynchronized ? 1 : 0;
		int numChildren = jjtGetNumChildren();
		try {
			/*
				Evaluate block in two passes: 
				First do class declarations then do everything else.
			*/
			for(int i=startChild; i<numChildren; i++)
			{
				SimpleNode node = ((SimpleNode)jjtGetChild(i));
				if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
					continue;
				if ( node instanceof BSHClassDeclaration )
					node.eval( callstack, interpreter );
			}
			for(int i=startChild; i<numChildren; i++)
			{
				SimpleNode node = ((SimpleNode)jjtGetChild(i));
				if ( node instanceof BSHClassDeclaration )
					continue;
				// filter nodes
				if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
					continue;
				ret = node.eval( callstack, interpreter );
				// statement or embedded block evaluated a return statement
				if ( ret instanceof ReturnControl )
					break;
			}
		} finally {
			// make sure we put the namespace back when we leave.
			if ( !overrideNamespace ) 
				callstack.swap( enclosingNameSpace );
		}
		return ret;
	}
	public interface NodeFilter {
		public boolean isVisible( SimpleNode node );
	}
}
"
bsh.BSHCastExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Implement casts.
	I think it should be possible to simplify some of the code here by
	using the Types.getAssignableForm() method, but I haven't looked 
	into it.
*/
class BSHCastExpression extends SimpleNode {
    public BSHCastExpression(int id) { super(id); }
	/**
		@return the result of the cast.
	*/
	public Object eval(
		CallStack callstack, Interpreter interpreter ) throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class toType = ((BSHType)jjtGetChild(0)).getType( 
			callstack, interpreter );
		SimpleNode expression = (SimpleNode)jjtGetChild(1);
        // evaluate the expression
        Object fromValue = expression.eval(callstack, interpreter);
        Class fromType = fromValue.getClass();
		try {
			return Types.castObject( fromValue, toType, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack  );
		}
    }
}
"
bsh.BSHClassDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
*/
class BSHClassDeclaration extends SimpleNode
{
	/**
		The class instance initializer method name.
		A BshMethod by this name is installed by the class delcaration into 
		the static class body namespace.  
		It is called once to initialize the static members of the class space 
		and each time an instances is created to initialize the instance
		members.
	*/
	static final String CLASSINITNAME = ""_bshClassInit"";
	String name;
	Modifiers modifiers;
	int numInterfaces;
	boolean extend;
	boolean isInterface;
	BSHClassDeclaration(int id) { super(id); }
	/**
	*/
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		int child = 0;
		// resolve superclass if any
		Class superClass = null;
		if ( extend ) 
		{
			BSHAmbiguousName superNode = (BSHAmbiguousName)jjtGetChild(child++);
			superClass = superNode.toClass( callstack, interpreter );
		}
		// Get interfaces
		Class [] interfaces = new Class[numInterfaces];
		for( int i=0; i<numInterfaces; i++) {
			BSHAmbiguousName node = (BSHAmbiguousName)jjtGetChild(child++);
			interfaces[i] = node.toClass(callstack, interpreter);
			if ( !interfaces[i].isInterface() )
				throw new EvalError(
					""Type: ""+node.text+"" is not an interface!"", 
					this, callstack );
		}
		BSHBlock block;
		// Get the class body BSHBlock
		if ( child < jjtGetNumChildren() )
			block = (BSHBlock)jjtGetChild(child);
		else
			block = new BSHBlock( ParserTreeConstants.JJTBLOCK );
		try {
			return ClassGenerator.getClassGenerator().generateClass( 
				name, modifiers, interfaces, superClass, block, isInterface,
				callstack, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}
	public String toString() {
		return ""ClassDeclaration: ""+name;
	}
}
"
bsh.BshClassManager,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.net.*;
import java.util.*;
import java.io.IOException;
import java.io.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
/**
	BshClassManager manages all classloading in BeanShell.
	It also supports a dynamically loaded extension (bsh.classpath package)
	which allows classpath extension and class file reloading.
	Currently the extension relies on 1.2 for BshClassLoader and weak 
	references.  
	See http://www.beanshell.org/manual/classloading.html for details
	on the bsh classloader architecture.
	<p>
	Bsh has a multi-tiered class loading architecture.  No class loader is
	used unless/until the classpath is modified or a class is reloaded.
	<p>
*/
/*
	Implementation notes:
	Note: we may need some synchronization in here
	Note on version dependency:  This base class is JDK 1.1 compatible,
	however we are forced to use weak references in the full featured
	implementation (the optional bsh.classpath package) to accomodate all of
	the fleeting namespace listeners as they fall out of scope.  (NameSpaces
	must be informed if the class space changes so that they can un-cache
	names).  
	<p>
	Perhaps a simpler idea would be to have entities that reference cached
	types always perform a light weight check with a counter / reference
	value and use that to detect changes in the namespace.  This puts the 
	burden on the consumer to check at appropriate times, but could eliminate
	the need for the listener system in many places and the necessity of weak 
	references in this package.
	<p>
*/
public class BshClassManager
{
	/** Identifier for no value item.  Use a hashtable as a Set. */
	private static Object NOVALUE = new Object(); 
	/** 
		The interpreter which created the class manager 
		This is used to load scripted classes from source files.
	*/
	private Interpreter declaringInterpreter;
	/**
		An external classloader supplied by the setClassLoader() command.
	*/
	private ClassLoader externalClassLoader;
	/**
		Global cache for things we know are classes.
		Note: these should probably be re-implemented with Soft references.
		(as opposed to strong or Weak)
	*/
    protected transient Hashtable absoluteClassCache = new Hashtable();
	/**
		Global cache for things we know are *not* classes.
		Note: these should probably be re-implemented with Soft references.
		(as opposed to strong or Weak)
	*/
    protected transient Hashtable absoluteNonClasses = new Hashtable();
	/**
		Caches for resolved object and static methods.
		We keep these maps separate to support fast lookup in the general case
		where the method may be either.
	*/
	protected transient Hashtable resolvedObjectMethods = new Hashtable();
	protected transient Hashtable resolvedStaticMethods = new Hashtable();
	protected transient Hashtable definingClasses = new Hashtable();
	protected transient Hashtable definingClassesBaseNames = new Hashtable();
	/**
		Create a new instance of the class manager.  
		Class manager instnaces are now associated with the interpreter.
		@see bsh.Interpreter.getClassManager()
		@see bsh.Interpreter.setClassLoader( ClassLoader )
	*/
	public static BshClassManager createClassManager( Interpreter interpreter ) 
	{
		BshClassManager manager;
		// Do we have the necessary jdk1.2 packages and optional package?
		if ( Capabilities.classExists(""java.lang.ref.WeakReference"") 
			&& Capabilities.classExists(""java.util.HashMap"") 
			&& Capabilities.classExists(""bsh.classpath.ClassManagerImpl"") 
		) 
			try {
				// Try to load the module
				// don't refer to it directly here or we're dependent upon it
				Class clas = Class.forName( ""bsh.classpath.ClassManagerImpl"" );
				manager = (BshClassManager)clas.newInstance();
			} catch ( Exception e ) {
				throw new InterpreterError(""Error loading classmanager: ""+e);
			}
		else 
			manager = new BshClassManager();
		if ( interpreter == null )
			interpreter = new Interpreter();
		manager.declaringInterpreter = interpreter;
		return manager;
	}
	public boolean classExists( String name ) {
		return ( classForName( name ) != null );
	}
	/**
		Load the specified class by name, taking into account added classpath
		and reloaded classes, etc.
		@return the class or null
	*/
	public Class classForName( String name ) 
	{
		if ( isClassBeingDefined( name ) )
			throw new InterpreterError(
				""Attempting to load class in the process of being defined: ""
				+name );
		Class clas = null;
		try {
			clas = plainClassForName( name );
		} catch ( ClassNotFoundException e ) { /*ignore*/ }
		// try scripted class
		if ( clas == null ) 
			clas = loadSourceClass( name );
		return clas;
	}
	// Move me to classpath/ClassManagerImpl???
	protected Class loadSourceClass( String name )
	{
		String fileName = ""/""+name.replace('.','/')+"".java"";
		InputStream in = getResourceAsStream( fileName );
		if ( in == null )
			return null;
		try {
			System.out.println(""Loading class from source file: ""+fileName);
			declaringInterpreter.eval( new InputStreamReader(in) );
		} catch ( EvalError e ) {
			// ignore
			System.err.println( e );
		}
		try {
			return plainClassForName( name );
		} catch ( ClassNotFoundException e ) {
			System.err.println(""Class not found in source file: ""+name );
			return null;
		}
	}
	/**
		Perform a plain Class.forName() or call the externally provided
		classloader.
		If a BshClassManager implementation is loaded the call will be 
		delegated to it, to allow for additional hooks.
		<p/>
		This simply wraps that bottom level class lookup call and provides a 
		central point for monitoring and handling certain Java version 
		dependent bugs, etc.
		@see #classForName( String )
		@return the class
	*/
	public Class plainClassForName( String name ) 
		throws ClassNotFoundException
	{
		Class c = null;
		try {
			if ( externalClassLoader != null )
				c = externalClassLoader.loadClass( name );
			else
				c = Class.forName( name );
			cacheClassInfo( name, c );
		/*
			Original note: Jdk under Win is throwing these to
			warn about lower case / upper case possible mismatch.
			e.g. bsh.console bsh.Console
			Update: Prior to 1.3 we were squeltching NoClassDefFoundErrors 
			which was very annoying.  I cannot reproduce the original problem 
			and this was never a valid solution.  If there are legacy VMs that
			have problems we can include a more specific test for them here.
		*/
		} catch ( NoClassDefFoundError e ) {
			throw noClassDefFound( name, e );
		}
		return c;
	}
	/**
		Get a resource URL using the BeanShell classpath
		@param path should be an absolute path
	*/
	public URL getResource( String path ) 
	{
		if ( externalClassLoader != null )
		{
			// classloader wants no leading slash
			return externalClassLoader.getResource( path.substring(1) );
		} else
			return Interpreter.class.getResource( path );
	}
	/**
		Get a resource stream using the BeanShell classpath
		@param path should be an absolute path
	*/
	public InputStream getResourceAsStream( String path ) 
	{
		if ( externalClassLoader != null )
		{
			// classloader wants no leading slash
			return externalClassLoader.getResourceAsStream( path.substring(1) );
		} else
			return Interpreter.class.getResourceAsStream( path );
	}
	/**
		Cache info about whether name is a class or not.
		@param value 
			if value is non-null, cache the class
			if value is null, set the flag that it is *not* a class to
			speed later resolution
	*/
	public void cacheClassInfo( String name, Class value ) {
		if ( value != null )
			absoluteClassCache.put( name, value );
		else
			absoluteNonClasses.put( name, NOVALUE );
	}
	/**
		Cache a resolved (possibly overloaded) method based on the 
		argument types used to invoke it, subject to classloader change.
		Static and Object methods are cached separately to support fast lookup
		in the general case where either will do.
	*/
	public void cacheResolvedMethod( 
		Class clas, Class [] types, Method method ) 
	{
		if ( Interpreter.DEBUG )
			Interpreter.debug(
				""cacheResolvedMethod putting: "" + clas +"" ""+ method );
		SignatureKey sk = new SignatureKey( clas, method.getName(), types );
		if ( Modifier.isStatic( method.getModifiers() ) )
			resolvedStaticMethods.put( sk, method );
		else
			resolvedObjectMethods.put( sk, method );
	}
	/**
		Return a previously cached resolved method.
		@param onlyStatic specifies that only a static method may be returned.
		@return the Method or null
	*/
	protected Method getResolvedMethod( 
		Class clas, String methodName, Class [] types, boolean onlyStatic  ) 
	{
		SignatureKey sk = new SignatureKey( clas, methodName, types );
		// Try static and then object, if allowed
		// Note that the Java compiler should not allow both.
		Method method = (Method)resolvedStaticMethods.get( sk );
		if ( method == null && !onlyStatic)
			method = (Method)resolvedObjectMethods.get( sk );
		if ( Interpreter.DEBUG )
		{
			if ( method == null )
				Interpreter.debug(
					""getResolvedMethod cache MISS: "" + clas +"" - ""+methodName );
			else
				Interpreter.debug(
					""getResolvedMethod cache HIT: "" + clas +"" - "" +method );
		}
		return method;
	}
	/**
		Clear the caches in BshClassManager
		@see public void #reset() for external usage
	*/
	protected void clearCaches() 
	{
    	absoluteNonClasses = new Hashtable();
    	absoluteClassCache = new Hashtable();
    	resolvedObjectMethods = new Hashtable();
    	resolvedStaticMethods = new Hashtable();
	}
	/**
		Set an external class loader.  BeanShell will use this at the same 
		point it would otherwise use the plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
	*/
	public void setClassLoader( ClassLoader externalCL ) 
	{
		externalClassLoader = externalCL;
		classLoaderChanged();
	}
	public void addClassPath( URL path )
		throws IOException {
	}
	/**
		Clear all loaders and start over.  No class loading.
	*/
	public void reset() { 
		clearCaches();
	}
	/**
		Set a new base classpath and create a new base classloader.
		This means all types change. 
	*/
	public void setClassPath( URL [] cp ) 
		throws UtilEvalError
	{
		throw cmUnavailable();
	}
	/**
		Overlay the entire path with a new class loader.
		Set the base path to the user path + base path.
		No point in including the boot class path (can't reload thos).
	*/
	public void reloadAllClasses() throws UtilEvalError {
		throw cmUnavailable();
	}
	/**
		Reloading classes means creating a new classloader and using it
		whenever we are asked for classes in the appropriate space.
		For this we use a DiscreteFilesClassLoader
	*/
	public void reloadClasses( String [] classNames )
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	/**
		Reload all classes in the specified package: e.g. ""com.sun.tools""
		The special package name ""<unpackaged>"" can be used to refer 
		to unpackaged classes.
	*/
	public void reloadPackage( String pack ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	/**
		This has been removed from the interface to shield the core from the
		rest of the classpath package. If you need the classpath you will have
		to cast the classmanager to its impl.
		public BshClassPath getClassPath() throws ClassPathException;
	*/
	/**
		Support for ""import *;""
		Hide details in here as opposed to NameSpace.
	*/
	protected void doSuperImport() 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	/**
		A ""super import"" (""import *"") operation has been performed.
	*/
	protected boolean hasSuperImport() 
	{
		return false;
	}
	/**
		Return the name or null if none is found,
		Throw an ClassPathException containing detail if name is ambigous.
	*/
	protected String getClassNameByUnqName( String name ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	public void addListener( Listener l ) { }
	public void removeListener( Listener l ) { }
	public void dump( PrintWriter pw ) { 
		pw.println(""BshClassManager: no class manager.""); 
	}
	/**
		Flag the class name as being in the process of being defined.
		The class manager will not attempt to load it.
	*/
	/*
		Note: this implementation is temporary. We currently keep a flat
		namespace of the base name of classes.  i.e. BeanShell cannot be in the
		process of defining two classes in different packages with the same
		base name.  To remove this limitation requires that we work through
		namespace imports in an analogous (or using the same path) as regular
		class import resolution.  This workaround should handle most cases 
		so we'll try it for now.
	*/
	protected void definingClass( String className ) {
		String baseName = Name.suffix(className,1);
		int i = baseName.indexOf(""$"");
		if ( i != -1 )
			baseName = baseName.substring(i+1);
		String cur = (String)definingClassesBaseNames.get( baseName );
		if ( cur != null )
			throw new InterpreterError(""Defining class problem: ""+className 
				+"": BeanShell cannot yet simultaneously define two or more ""
				+""dependant classes of the same name.  Attempt to define: ""
				+ className +"" while defining: ""+cur 
			);
		definingClasses.put( className, NOVALUE );
		definingClassesBaseNames.put( baseName, className );
	}
	protected boolean isClassBeingDefined( String className ) {
		return definingClasses.get( className ) != null;
	}
	/**
		This method is a temporary workaround used with definingClass.
		It is to be removed at some point.
	*/
	protected String getClassBeingDefined( String className ) {
		String baseName = Name.suffix(className,1);
		return (String)definingClassesBaseNames.get( baseName );
	}
	/**
		Indicate that the specified class name has been defined and may be
		loaded normally.
	*/
	protected void doneDefiningClass( String className ) {
		String baseName = Name.suffix(className,1);
		definingClasses.remove( className );
		definingClassesBaseNames.remove( baseName );
	}
	/*
		Issues to resolve here...
		1) In which classloader should we define the class?
		if there is a BshClassLoader should we define it there?
		2) should we use reflection to set it in a non-bsh classloader
		if there is one or should we always create a bsh classloader
		(and expose its defineClass)?
	*/
	public Class defineClass( String name, byte [] code ) 
	{
		ClassLoader cl = this.getClass().getClassLoader();
		Class clas;
		try {
			clas = (Class)Reflect.invokeObjectMethod( 
				cl, ""defineClass"", 
				new Object [] { 
					name, code, 
					new Primitive( (int)0 )/*offset*/, 
					new Primitive( code.length )/*len*/ 
				}, 
				(Interpreter)null, (CallStack)null, (SimpleNode)null 
			);
		} catch ( Exception e ) {
			e.printStackTrace();
			throw new InterpreterError(""Unable to define class: ""+ e );
		}
		absoluteNonClasses.remove( name ); // may have been axed previously
		return clas;
	}
	protected void classLoaderChanged() { }
	/**
		Annotate the NoClassDefFoundError with some info about the class
		we were trying to load.
	*/
	protected static Error noClassDefFound( String className, Error e ) {
		return new NoClassDefFoundError(
			""A class required by class: ""+className +"" could not be loaded:\n""
			+e.toString() );
	}
	protected static UtilEvalError cmUnavailable() {
		return new Capabilities.Unavailable(
			""ClassLoading features unavailable."");
	}
	public static interface Listener 
	{
		public void classLoaderChanged();
	}
	/**
		SignatureKey serves as a hash of a method signature on a class 
		for fast lookup of overloaded and general resolved Java methods. 
		<p>
	*/
	/*
		Note: is using SignatureKey in this way dangerous?  In the pathological
		case a user could eat up memory caching every possible combination of
		argument types to an untyped method.  Maybe we could be smarter about
		it by ignoring the types of untyped parameter positions?  The method
		resolver could return a set of ""hints"" for the signature key caching?
		There is also the overhead of creating one of these for every method
		dispatched.  What is the alternative?
	*/
	static class SignatureKey
	{
		Class clas;
		Class [] types;
		String methodName;
		int hashCode = 0;
		SignatureKey( Class clas, String methodName, Class [] types ) {
			this.clas = clas;
			this.methodName = methodName;
			this.types = types;
		}
		public int hashCode() 
		{ 
			if ( hashCode == 0 ) 
			{
				hashCode = clas.hashCode() * methodName.hashCode();
				if ( types == null ) // no args method
					return hashCode; 
				for( int i =0; i < types.length; i++ ) {
					int hc = types[i] == null ? 21 : types[i].hashCode();
					hashCode = hashCode*(i+1) + hc;
				}
			}
			return hashCode;
		}
		public boolean equals( Object o ) { 
			SignatureKey target = (SignatureKey)o;
			if ( types == null )
				return target.types == null;
			if ( clas != target.clas )
				return false;
			if ( !methodName.equals( target.methodName ) )
				return false;
			if ( types.length != target.types.length )
				return false;
			for( int i =0; i< types.length; i++ )
			{
				if ( types[i]==null ) 
				{
					if ( !(target.types[i]==null) )
						return false;
				} else 
					if ( !types[i].equals( target.types[i] ) )
						return false;
			}
			return true;
		}
	}
}
"
bsh.BSHEnhancedForStatement,"package bsh;
// Just testing...
import java.util.*;
/**
	 Implementation of the enhanced for(:) statement.  
	 This statement uses BshIterable to support iteration over a wide variety
	 of iterable types.  Under JDK 1.1 this statement supports primitive and 
	 Object arrays, Vectors, and enumerations.  Under JDK 1.2 and later it 
	 additionally supports collections.
	 @author Daniel Leuck 
	 @author Pat Niemeyer
*/
class BSHEnhancedForStatement extends SimpleNode implements ParserConstants 
{
	String varName;
    BSHEnhancedForStatement(int id) { super(id); }
    public Object eval( CallStack callstack , Interpreter interpreter )
		throws EvalError 
	{
		Class elementType = null;
		SimpleNode expression, statement=null;
		NameSpace enclosingNameSpace = callstack.top();
		SimpleNode firstNode =((SimpleNode)jjtGetChild(0));
		int nodeCount = jjtGetNumChildren();
		if ( firstNode instanceof BSHType ) 
		{
			elementType=((BSHType)firstNode).getType( callstack, interpreter );
			expression=((SimpleNode)jjtGetChild(1));
			if ( nodeCount>2 )
				statement=((SimpleNode)jjtGetChild(2));
		} else 
		{
			expression=firstNode;
			if ( nodeCount>1 )
				statement=((SimpleNode)jjtGetChild(1));
		}
		BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );
		callstack.swap( eachNameSpace );
		final Object iteratee = expression.eval( callstack, interpreter );
		if ( iteratee == Primitive.NULL )
			throw new EvalError(""The collection, array, map, iterator, or "" +
				""enumeration portion of a for statement cannot be null."", 
				this, callstack );
		CollectionManager cm = CollectionManager.getCollectionManager();
		if ( !cm.isBshIterable( iteratee ) )
			throw new EvalError(""Can't iterate over type: ""
				+iteratee.getClass(), this, callstack );
		BshIterator iterator = cm.getBshIterator( iteratee );
		Object returnControl = Primitive.VOID;
        while( iterator.hasNext() )
        {
			try {
			if ( elementType != null )
				eachNameSpace.setTypedVariable(
					varName, elementType, iterator.next(), false );
			else
				eachNameSpace.setVariable( varName, iterator.next(), false );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					""for loop iterator variable:""+ varName, this, callstack );
			}
            boolean breakout = false; // switch eats a multi-level break here?
            if ( statement != null ) // not empty statement
            {
                Object ret = statement.eval( callstack, interpreter );
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case RETURN:
							returnControl = ret;
							breakout = true;
                            break;
                        case CONTINUE:
                            break;
                        case BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if (breakout)
                break;
        }
		callstack.swap(enclosingNameSpace);
        return returnControl;
    }
}
"
bsh.BSHFormalComment,"/* Generated By:JJTree: Do not edit this line. BSHFormalComment.java */
package bsh;
public class BSHFormalComment extends SimpleNode 
{
	public String text;
	public BSHFormalComment(int id) {
		super(id);
	}
}
"
bsh.BSHFormalParameter,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	A formal parameter declaration.
	For loose variable declaration type is null.
*/
class BSHFormalParameter extends SimpleNode
{
	public static final Class UNTYPED = null;
	public String name;
	// unsafe caching of type here
	public Class type;
	BSHFormalParameter(int id) { super(id); }
	public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
	{
		if ( jjtGetNumChildren() > 0 )
			return ((BSHType)jjtGetChild(0)).getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
		else
			// this will probably not get used
			return ""Ljava/lang/Object;"";  // Object type
	}
	/**
		Evaluate the type.
	*/
	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		if ( jjtGetNumChildren() > 0 )
			type = ((BSHType)jjtGetChild(0)).getType( callstack, interpreter );
		else
			type = UNTYPED;
		return type;
	}
}
"
bsh.BSHFormalParameters,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHFormalParameters extends SimpleNode
{
	private String [] paramNames;
	/**
		For loose type parameters the paramTypes are null.
	*/
	// unsafe caching of types
	Class [] paramTypes;
	int numArgs;
	String [] typeDescriptors;
	BSHFormalParameters(int id) { super(id); }
	void insureParsed() 
	{
		if ( paramNames != null )
			return;
		this.numArgs = jjtGetNumChildren();
		String [] paramNames = new String[numArgs];
		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			paramNames[i] = param.name;
		}
		this.paramNames = paramNames;
	}
	public String [] getParamNames() { 
		insureParsed();
		return paramNames;
	}
	public String [] getTypeDescriptors( 
		CallStack callstack, Interpreter interpreter, String defaultPackage )
	{
		if ( typeDescriptors != null )
			return typeDescriptors;
		insureParsed();
		String [] typeDesc = new String[numArgs];
		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			typeDesc[i] = param.getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
		}
		this.typeDescriptors = typeDesc;
		return typeDesc;
	}
	/**
		Evaluate the types.  
		Note that type resolution does not require the interpreter instance.
	*/
	public Object eval( CallStack callstack, Interpreter interpreter )  
		throws EvalError
	{
		if ( paramTypes != null )
			return paramTypes;
		insureParsed();
		Class [] paramTypes = new Class[numArgs];
		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			paramTypes[i] = (Class)param.eval( callstack, interpreter );
		}
		this.paramTypes = paramTypes;
		return paramTypes;
	}
}
"
bsh.BSHForStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Implementation of the for(;;) statement.
*/
class BSHForStatement extends SimpleNode implements ParserConstants
{
    public boolean hasForInit;
    public boolean hasExpression;
    public boolean hasForUpdate;
    private SimpleNode forInit;
    private SimpleNode expression;
    private SimpleNode forUpdate;
    private SimpleNode statement;
    private boolean parsed;
    BSHForStatement(int id) { super(id); }
    public Object eval(CallStack callstack , Interpreter interpreter)  
		throws EvalError
    {
        int i = 0;
        if(hasForInit)
            forInit = ((SimpleNode)jjtGetChild(i++));
        if(hasExpression)
            expression = ((SimpleNode)jjtGetChild(i++));
        if(hasForUpdate)
            forUpdate = ((SimpleNode)jjtGetChild(i++));
        if(i < jjtGetNumChildren()) // should normally be
            statement = ((SimpleNode)jjtGetChild(i));
		NameSpace enclosingNameSpace= callstack.top();
		BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );
		/*
			Note: some interesting things are going on here.
			1) We swap instead of push...  The primary mode of operation 
			acts like we are in the enclosing namespace...  (super must be 
			preserved, etc.)
			2) We do *not* call the body block eval with the namespace 
			override.  Instead we allow it to create a second subordinate 
			BlockNameSpace child of the forNameSpace.  Variable propogation 
			still works through the chain, but the block's child cleans the 
			state between iteration.  
			(which is correct Java behavior... see forscope4.bsh)
		*/
		// put forNameSpace it on the top of the stack
		// Note: it's important that there is only one exit point from this
		// method so that we can swap back the namespace.
		callstack.swap( forNameSpace );
        // Do the for init
        if ( hasForInit ) 
            forInit.eval( callstack, interpreter );
		Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( hasExpression ) 
			{
				boolean cond = BSHIfStatement.evaluateCondition(
					expression, callstack, interpreter );
				if ( !cond ) 
					break;
			}
            boolean breakout = false; // switch eats a multi-level break here?
            if ( statement != null ) // not empty statement
            {
				// do *not* invoke special override for block... (see above)
                Object ret = statement.eval( callstack, interpreter );
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case RETURN:
							returnControl = ret;
							breakout = true;
                            break;
                        case CONTINUE:
                            break;
                        case BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if ( breakout )
                break;
            if ( hasForUpdate )
                forUpdate.eval( callstack, interpreter );
        }
		callstack.swap( enclosingNameSpace );  // put it back
        return returnControl;
    }
}
"
bsh.BSHIfStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHIfStatement extends SimpleNode
{
    BSHIfStatement(int id) { super(id); }
    public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        Object ret = null;
        if( evaluateCondition( 
			(SimpleNode)jjtGetChild(0), callstack, interpreter ) )
            ret = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
        else
            if(jjtGetNumChildren() > 2)
                ret = ((SimpleNode)jjtGetChild(2)).eval(callstack, interpreter);
        if(ret instanceof ReturnControl)
            return ret;
        else    
            return Primitive.VOID;
    }
    public static boolean evaluateCondition(
		SimpleNode condExp, CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        Object obj = condExp.eval(callstack, interpreter);
        if(obj instanceof Primitive) {
			if ( obj == Primitive.VOID )
				throw new EvalError(""Condition evaluates to void type"", 
					condExp, callstack );
            obj = ((Primitive)obj).getValue();
		}
        if(obj instanceof Boolean)
            return ((Boolean)obj).booleanValue();
        else
            throw new EvalError(
				""Condition must evaluate to a Boolean or boolean."", 
				condExp, callstack );
    }
}
"
bsh.BSHImportDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHImportDeclaration extends SimpleNode
{
	public boolean importPackage;
	public boolean staticImport;
	public boolean superImport;
	BSHImportDeclaration(int id) { super(id); }
	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		if ( superImport )
			try {
				namespace.doSuperImport();
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack  );
			}
		else 
		{
			if ( staticImport )
			{
				if ( importPackage )
				{
					Class clas = ((BSHAmbiguousName)jjtGetChild(0)).toClass( 
						callstack, interpreter );
					namespace.importStatic( clas );
				} else
					throw new EvalError( 
						""static field imports not supported yet"", 
						this, callstack );
			} else 
			{
				String name = ((BSHAmbiguousName)jjtGetChild(0)).text;
				if ( importPackage )
					namespace.importPackage(name);
				else
					namespace.importClass(name);
			}
		}
        return Primitive.VOID;
	}
}
"
bsh.BshIterator,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	An interface implemented by classes wrapping instances of iterators,
	enumerations, collections, etc.
	@see CollectionManager.getBshIterator(Object)
*/
public interface BshIterator 
{
	/**
	 * Fetch the next object in the iteration
	 *
	 * @return The next object
	 */
	public Object next();
	/**
	 * Returns true if and only if there are more objects available
	 * via the <code>next()</code> method
	 *
	 * @return The next object
	 */
	public boolean hasNext();
}
"
bsh.BSHLiteral,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHLiteral extends SimpleNode
{
    public Object value;
    BSHLiteral(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
    {
		if ( value == null )
			throw new InterpreterError(""Null in bsh literal: ""+value);
        return value;
    }
    private char getEscapeChar(char ch)
    {
        switch(ch)
        {
            case 'b':
                ch = '\b';
                break;
            case 't':
                ch = '\t';
                break;
            case 'n':
                ch = '\n';
                break;
            case 'f':
                ch = '\f';
                break;
            case 'r':
                ch = '\r';
                break;
            // do nothing - ch already contains correct character
            case '""':
            case '\'':
            case '\\':
                break;
        }
        return ch;
    }
    public void charSetup(String str)
    {
        char ch = str.charAt(0);
        if(ch == '\\')
        {
            // get next character
            ch = str.charAt(1);
            if(Character.isDigit(ch))
                ch = (char)Integer.parseInt(str.substring(1), 8);
            else
                ch = getEscapeChar(ch);
        }
        value = new Primitive(new Character(ch).charValue());
    }
    void stringSetup(String str)
    {
        StringBuffer buffer = new StringBuffer();
        for(int i = 0; i < str.length(); i++)
        {
            char ch = str.charAt(i);
            if(ch == '\\')
            {
                // get next character
                ch = str.charAt(++i);
                if(Character.isDigit(ch))
                {
                    int endPos = i;
                    // check the next two characters
                    while(endPos < i + 2)
                    {
                        if(Character.isDigit(str.charAt(endPos + 1)))
                            endPos++;
                        else
                            break;
                    }
                    ch = (char)Integer.parseInt(str.substring(i, endPos + 1), 8);
                    i = endPos;
                }
                else
                    ch = getEscapeChar(ch);
            }
            buffer.append(ch);
        }
        value = buffer.toString();
    }
}
"
bsh.BshMethod,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
/**
	This represents an instance of a bsh method declaration in a particular
	namespace.  This is a thin wrapper around the BSHMethodDeclaration
	with a pointer to the declaring namespace.
	<p>
	When a method is located in a subordinate namespace or invoked from an 
	arbitrary namespace it must nontheless execute with its 'super' as the 
	context in which it was declared.
	<p/>
*/
/*
	Note: this method incorrectly caches the method structure.  It needs to
	be cleared when the classloader changes.
*/
public class BshMethod 
	implements java.io.Serializable 
{
	/* 
		This is the namespace in which the method is set.
		It is a back-reference for the node, which needs to execute under this 
		namespace.  It is not necessary to declare this transient, because 
		we can only be saved as part of our namespace anyway... (currently).
	*/
	NameSpace declaringNameSpace;
	// Begin Method components
	Modifiers modifiers;
	private String name;
	private Class creturnType;
	// Arguments
	private String [] paramNames;
	private int numArgs;
	private Class [] cparamTypes;
	// Scripted method body
	BSHBlock methodBody;
	// Java Method
	private Method javaMethod;
	private Object javaObject;
	// End method components
	BshMethod( 
		BSHMethodDeclaration method, 
		NameSpace declaringNameSpace, Modifiers modifiers ) 
	{
		this( method.name, method.returnType, method.paramsNode.getParamNames(),
			method.paramsNode.paramTypes, method.blockNode, declaringNameSpace,
			modifiers );
	}
	BshMethod( 
		String name, Class returnType, String [] paramNames,
		Class [] paramTypes, BSHBlock methodBody, 
		NameSpace declaringNameSpace, Modifiers modifiers
	) {
		this.name = name;
		this.creturnType = returnType;
		this.paramNames = paramNames;
		if ( paramNames != null )
			this.numArgs = paramNames.length;
		this.cparamTypes = paramTypes;
		this.methodBody = methodBody;
		this.declaringNameSpace = declaringNameSpace;
		this.modifiers = modifiers;
	}
	BshMethod( Method method, Object object )
	{
		this( method.getName(), method.getReturnType(), null/*paramNames*/,
			method.getParameterTypes(), null/*method.block*/, 
			null/*declaringNameSpace*/, null/*modifiers*/ );
		this.javaMethod = method;
		this.javaObject = object;
	}
	/**
		Get the argument types of this method.
		loosely typed (untyped) arguments will be represented by null argument
		types.
	*/
	/*
		Note: bshmethod needs to re-evaluate arg types here
		This is broken.
	*/
	public Class [] getParameterTypes() { return cparamTypes; }
	public String [] getParameterNames() { return paramNames; }
	/**
		Get the return type of the method.
		@return Returns null for a loosely typed return value, 
			Void.TYPE for a void return type, or the Class of the type.
	*/
	/*
		Note: bshmethod needs to re-evaluate the method return type here.
		This is broken.
	*/
	public Class getReturnType() { return creturnType; }
	public Modifiers getModifiers() { return modifiers; }
	public String getName() { return name; }
	/**
		Invoke the declared method with the specified arguments and interpreter
		reference.  This is the simplest form of invoke() for BshMethod 
		intended to be used in reflective style access to bsh scripts.
	*/
	public Object invoke( 
		Object[] argValues, Interpreter interpreter ) 
		throws EvalError 
	{
		return invoke( argValues, interpreter, null, null, false );
	}
	/**
		Invoke the declared method with the specified arguments, interpreter
		reference, and callstack.
		<p/>
		Note: this form of invoke() uses a null Node for the caller and a null
		node for the CallStack.  This method is for scripts performing 
		relective style access to scripted methods.
	 */
	public Object invoke( 
		Object[] argValues, Interpreter interpreter, CallStack callstack ) 
		throws EvalError 
	{
		return invoke( argValues, interpreter, callstack, null, false );
	}
	public Object invoke( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo ) 
		throws EvalError 
	{
		return invoke( argValues, interpreter, callstack, callerInfo, false );
	}
	/**
		Invoke the bsh method with the specified args, interpreter ref,
		and callstack.
		callerInfo is the node representing the method invocation
		It is used primarily for debugging in order to provide access to the 
		text of the construct that invoked the method through the namespace.
		@param callerInfo is the BeanShell AST node representing the method 
			invocation.  It is used to print the line number and text of 
			errors in EvalError exceptions.  If the node is null here error
			messages may not be able to point to the precise location and text
			of the error.
		@param callstack is the callstack.  If callstack is null a new one
			will be created with the declaring namespace of the method on top
			of the stack (i.e. it will look for purposes of the method 
			invocation like the method call occurred in the declaring 
			(enclosing) namespace in which the method is defined).
		@param overrideNameSpace 
			When true the method is executed in the namespace on the top of the
			stack instead of creating its own local namespace.  This allows it
			to be used in constructors.
	*/
	Object invoke( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		if ( javaMethod != null )
			try {
				return Reflect.invokeOnMethod( 
					javaMethod, javaObject, argValues ); 
			} catch ( ReflectError e ) {
				throw new EvalError(
					""Error invoking Java method: ""+e, callerInfo, callstack );
			} catch ( InvocationTargetException e2 ) {
				throw new TargetError( 
					""Exception invoking imported object method."", 
					e2, callerInfo, callstack, true/*isNative*/ );
			}
		// is this a syncrhonized method?
		if ( modifiers != null && modifiers.hasModifier(""synchronized"") )
		{
			// The lock is our declaring namespace's This reference
			// (the method's 'super').  Or in the case of a class it's the
			// class instance.
			Object lock;
			if ( declaringNameSpace.isClass )
			{
				try {
					lock = declaringNameSpace.getClassInstance();
				} catch ( UtilEvalError e ) {
					throw new InterpreterError(
						""Can't get class instance for synchronized method."");
				}
			} else
				lock = declaringNameSpace.getThis(interpreter); // ???
			synchronized( lock ) 
			{
				return invokeImpl( 
					argValues, interpreter, callstack, 
					callerInfo, overrideNameSpace );
			}
		} else
			return invokeImpl( argValues, interpreter, callstack, callerInfo,
				overrideNameSpace );
	}
	private Object invokeImpl( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		Class returnType = getReturnType();
		Class [] paramTypes = getParameterTypes();
		// If null callstack
		if ( callstack == null )
			callstack = new CallStack( declaringNameSpace );
		if ( argValues == null )
			argValues = new Object [] { };
		// Cardinality (number of args) mismatch
		if ( argValues.length != numArgs ) 
		{
		/*
			// look for help string
			try {
				// should check for null namespace here
				String help = 
					(String)declaringNameSpace.get(
					""bsh.help.""+name, interpreter );
				interpreter.println(help);
				return Primitive.VOID;
			} catch ( Exception e ) {
				throw eval error
			}
		*/
			throw new EvalError( 
				""Wrong number of arguments for local method: "" 
				+ name, callerInfo, callstack );
		}
		// Make the local namespace for the method invocation
		NameSpace localNameSpace;
		if ( overrideNameSpace )
			localNameSpace = callstack.top();
		else
		{
			localNameSpace = new NameSpace( declaringNameSpace, name );
			localNameSpace.isMethod = true;
		}
		// should we do this for both cases above?
		localNameSpace.setNode( callerInfo );
		// set the method parameters in the local namespace
		for(int i=0; i<numArgs; i++)
		{
			// Set typed variable
			if ( paramTypes[i] != null ) 
			{
				try {
					argValues[i] = Types.getAssignableForm(
						argValues[i], paramTypes[i] );
				}
				catch( UtilEvalError e) {
					throw new EvalError(
						""Invalid argument: "" 
						+ ""`""+paramNames[i]+""'"" + "" for method: "" 
						+ name + "" : "" + 
						e.getMessage(), callerInfo, callstack );
				}
				try {
					localNameSpace.setTypedVariable( paramNames[i], 
						paramTypes[i], argValues[i], null/*modifiers*/);
				} catch ( UtilEvalError e2 ) {
					throw e2.toEvalError( ""Typed method parameter assignment"", 
						callerInfo, callstack  );
				}
			} 
			// Set untyped variable
			else  // untyped param
			{
				// getAssignable would catch this for typed param
				if ( argValues[i] == Primitive.VOID)
					throw new EvalError(
						""Undefined variable or class name, parameter: "" +
						paramNames[i] + "" to method: "" 
						+ name, callerInfo, callstack );
				else
					try {
						localNameSpace.setLocalVariable(
							paramNames[i], argValues[i],
							interpreter.getStrictJava() );
					} catch ( UtilEvalError e3 ) {
						throw e3.toEvalError( callerInfo, callstack );
					}
			}
		}
		// Push the new namespace on the call stack
		if ( !overrideNameSpace )
			callstack.push( localNameSpace );
		// Invoke the block, overriding namespace with localNameSpace
		Object ret = methodBody.eval( 
			callstack, interpreter, true/*override*/ );
		// save the callstack including the called method, just for error mess
		CallStack returnStack = callstack.copy();
		// Get back to caller namespace
		if ( !overrideNameSpace )
			callstack.pop();
		ReturnControl retControl = null;
		if ( ret instanceof ReturnControl )
		{
			retControl = (ReturnControl)ret;
			// Method body can only use 'return' statment type return control.
			if ( retControl.kind == retControl.RETURN )
				ret = ((ReturnControl)ret).value;
			else 
				// retControl.returnPoint is the Node of the return statement
				throw new EvalError(""'continue' or 'break' in method body"", 
					retControl.returnPoint, returnStack );
			// Check for explicit return of value from void method type.
			// retControl.returnPoint is the Node of the return statement
			if ( returnType == Void.TYPE && ret != Primitive.VOID )
				throw new EvalError( ""Cannot return value from void method"", 
				retControl.returnPoint, returnStack);
		}
		if ( returnType != null )
		{
			// If return type void, return void as the value.
			if ( returnType == Void.TYPE )
				return Primitive.VOID;
			// return type is a class
			try {
				ret = Types.getAssignableForm( ret, (Class)returnType );
			} catch( UtilEvalError e ) 
			{
				// Point to return statement point if we had one.
				// (else it was implicit return? What's the case here?)
				SimpleNode node = callerInfo;
				if ( retControl != null )
					node = retControl.returnPoint;
				throw e.toEvalError(
					""Incorrect type returned from method: "" 
					+ name + e.getMessage(), node, callstack );
			}
		}
		return ret;
	}
	public boolean hasModifier( String name ) {
		return modifiers != null && modifiers.hasModifier(name);
	}
	public String toString() {
		return ""Scripted Method: ""
			+ StringUtil.methodString( name, getParameterTypes() ); 
	}
}
"
bsh.BSHMethodDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHMethodDeclaration extends SimpleNode
{
	public String name;
	// Begin Child node structure evaluated by insureNodesParsed
	BSHReturnType returnTypeNode;
	BSHFormalParameters paramsNode;
	BSHBlock blockNode;
	// index of the first throws clause child node
	int firstThrowsClause;
	// End Child node structure evaluated by insureNodesParsed
	public Modifiers modifiers;
	// Unsafe caching of type here.
	Class returnType;  // null (none), Void.TYPE, or a Class
	int numThrows = 0;
	BSHMethodDeclaration(int id) { super(id); }
	/**
		Set the returnTypeNode, paramsNode, and blockNode based on child
		node structure.  No evaluation is done here.
	*/
	synchronized void insureNodesParsed() 
	{
		if ( paramsNode != null ) // there is always a paramsNode
			return;
		Object firstNode = jjtGetChild(0);
		firstThrowsClause = 1;
		if ( firstNode instanceof BSHReturnType )
		{
			returnTypeNode = (BSHReturnType)firstNode;
			paramsNode = (BSHFormalParameters)jjtGetChild(1);
			if ( jjtGetNumChildren() > 2+numThrows )
				blockNode = (BSHBlock)jjtGetChild(2+numThrows); // skip throws
			++firstThrowsClause;
		}
		else
		{
			paramsNode = (BSHFormalParameters)jjtGetChild(0);
			blockNode = (BSHBlock)jjtGetChild(1+numThrows); // skip throws
		}
	}
	/**
		Evaluate the return type node.
		@return the type or null indicating loosely typed return
	*/
	Class evalReturnType( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		insureNodesParsed();
		if ( returnTypeNode != null )
			return returnTypeNode.evalReturnType( callstack, interpreter );
		else 
			return null;
	}
	String getReturnTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage )
	{
		insureNodesParsed();
		if ( returnTypeNode == null )
			return null;
		else
			return returnTypeNode.getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
	}
	BSHReturnType getReturnTypeNode() {
		insureNodesParsed();
		return returnTypeNode;
	}
	/**
		Evaluate the declaration of the method.  That is, determine the
		structure of the method and install it into the caller's namespace.
	*/
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		returnType = evalReturnType( callstack, interpreter );
		evalNodes( callstack, interpreter );
		// Install an *instance* of this method in the namespace.
		// See notes in BshMethod 
// This is not good...
// need a way to update eval without re-installing...
// so that we can re-eval params, etc. when classloader changes
// look into this
		NameSpace namespace = callstack.top();
		BshMethod bshMethod = new BshMethod( this, namespace, modifiers );
		try {
			namespace.setMethod( name, bshMethod );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(this,callstack);
		}
		return Primitive.VOID;
	}
	private void evalNodes( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		insureNodesParsed();
		// validate that the throws names are class names
		for(int i=firstThrowsClause; i<numThrows+firstThrowsClause; i++)
			((BSHAmbiguousName)jjtGetChild(i)).toClass( 
				callstack, interpreter );
		paramsNode.eval( callstack, interpreter );
		// if strictJava mode, check for loose parameters and return type
		if ( interpreter.getStrictJava() )
		{
			for(int i=0; i<paramsNode.paramTypes.length; i++)
				if ( paramsNode.paramTypes[i] == null )
					// Warning: Null callstack here.  Don't think we need
					// a stack trace to indicate how we sourced the method.
					throw new EvalError(
				""(Strict Java Mode) Undeclared argument type, parameter: "" +
					paramsNode.getParamNames()[i] + "" in method: "" 
					+ name, this, null );
			if ( returnType == null )
				// Warning: Null callstack here.  Don't think we need
				// a stack trace to indicate how we sourced the method.
				throw new EvalError(
				""(Strict Java Mode) Undeclared return type for method: ""
					+ name, this, null );
		}
	}
	public String toString() {
		return ""MethodDeclaration: ""+name;
	}
}
"
bsh.BSHMethodInvocation,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.InvocationTargetException;
class BSHMethodInvocation extends SimpleNode
{
	BSHMethodInvocation (int id) { super(id); }
	BSHAmbiguousName getNameNode() {
		return (BSHAmbiguousName)jjtGetChild(0);
	}
	BSHArguments getArgsNode() {
		return (BSHArguments)jjtGetChild(1);
	}
	/**
		Evaluate the method invocation with the specified callstack and 
		interpreter
	*/
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		BSHAmbiguousName nameNode = getNameNode();
		// Do not evaluate methods this() or super() in class instance space
		// (i.e. inside a constructor)
		if ( namespace.getParent() != null && namespace.getParent().isClass
			&& ( nameNode.text.equals(""super"") || nameNode.text.equals(""this"") )
		)
			return Primitive.VOID;
		Name name = nameNode.getName(namespace);
		Object[] args = getArgsNode().getArguments(callstack, interpreter);
		try {
			return name.invokeMethod( interpreter, args, callstack, this);
		} catch ( ReflectError e ) {
// XXX
//e.printStackTrace();
			throw new EvalError(
				""Error in method invocation: "" + e.getMessage(), 
				this, callstack );
		} catch ( InvocationTargetException e ) 
		{
			String msg = ""Method Invocation ""+name;
			Throwable te = e.getTargetException();
			/*
				Try to squeltch the native code stack trace if the exception
				was caused by a reflective call back into the bsh interpreter
				(e.g. eval() or source()
			*/
			boolean isNative = true;
			if ( te instanceof EvalError ) 
				if ( te instanceof TargetError )
					isNative = ((TargetError)te).inNativeCode();
				else
					isNative = false;
			throw new TargetError( msg, te, this, callstack, isNative );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}
}
"
bsh.BSHPackageDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
public class BSHPackageDeclaration extends SimpleNode 
{
  public BSHPackageDeclaration(int id) {
    super(id);
  }
	public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		BSHAmbiguousName name = (BSHAmbiguousName)jjtGetChild(0);
		NameSpace namespace = callstack.top();
		namespace.setPackage( name.text );
		// import the package we're in by default...
		namespace.importPackage( name.text );
		return Primitive.VOID;
	}
}
"
bsh.BSHPrimaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHPrimaryExpression extends SimpleNode
{
	BSHPrimaryExpression(int id) { super(id); }
	/**
		Evaluate to a value object.
	*/
	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		return eval( false, callstack, interpreter );
	}
	/**
		Evaluate to a value object.
	*/
	public LHS toLHS( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = eval( true, callstack, interpreter );
		if ( ! (obj instanceof LHS) )
			throw new EvalError(""Can't assign to:"", this, callstack );
		else
			return (LHS)obj;
	}
	/*
		Our children are a prefix expression and any number of suffixes.
		<p>
		We don't eval() any nodes until the suffixes have had an
		opportunity to work through them.  This lets the suffixes decide
		how to interpret an ambiguous name (e.g. for the .class operation).
	*/
	private Object eval( boolean toLHS, 
		CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = jjtGetChild(0);
		int numChildren = jjtGetNumChildren(); 
		for(int i=1; i<numChildren; i++)
			obj = ((BSHPrimarySuffix)jjtGetChild(i)).doSuffix(
				obj, toLHS, callstack, interpreter);
		/*
			If the result is a Node eval() it to an object or LHS
			(as determined by toLHS)
		*/
		if ( obj instanceof SimpleNode )
			if ( obj instanceof BSHAmbiguousName )
				if ( toLHS )
					obj = ((BSHAmbiguousName)obj).toLHS(
						callstack, interpreter);
				else
					obj = ((BSHAmbiguousName)obj).toObject(
						callstack, interpreter);
			else 
				// Some arbitrary kind of node
				if ( toLHS )
					// is this right?
					throw new EvalError(""Can't assign to prefix."", 
						this, callstack );
				else
					obj = ((SimpleNode)obj).eval(callstack, interpreter);	
		// return LHS or value object as determined by toLHS
		if ( obj instanceof LHS )
			if ( toLHS )
				return obj;
			else
				try {
					return ((LHS)obj).getValue();
				} catch ( UtilEvalError e ) {
					throw e.toEvalError( this, callstack );
				}
		else
			return obj;
	}
}
"
bsh.BSHPrimarySuffix,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Hashtable;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
class BSHPrimarySuffix extends SimpleNode
{
	public static final int
		CLASS = 0,
		INDEX = 1,
		NAME = 2,
		PROPERTY = 3;
	public int operation;
	Object index;
	public String field;
	BSHPrimarySuffix(int id) { super(id); }
	/*
		Perform a suffix operation on the given object and return the 
		new value.
		<p>
		obj will be a Node when suffix evaluation begins, allowing us to
		interpret it contextually. (e.g. for .class) Thereafter it will be 
		an value object or LHS (as determined by toLHS).
		<p>
		We must handle the toLHS case at each point here.
		<p>
	*/
	public Object doSuffix(
		Object obj, boolean toLHS, 
		CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		// Handle "".class"" suffix operation
		// Prefix must be a BSHType
		if ( operation == CLASS )
			if ( obj instanceof BSHType ) {
				if ( toLHS )
					throw new EvalError(""Can't assign .class"", 
						this, callstack );
				NameSpace namespace = callstack.top();
				return ((BSHType)obj).getType( callstack, interpreter );
			} else
				throw new EvalError(
					""Attempt to use .class suffix on non class."", 
					this, callstack );
		/*
			Evaluate our prefix if it needs evaluating first.
			If this is the first evaluation our prefix mayb be a Node 
			(directly from the PrimaryPrefix) - eval() it to an object.  
			If it's an LHS, resolve to a value.
			Note: The ambiguous name construct is now necessary where the node 
			may be an ambiguous name.  If this becomes common we might want to 
			make a static method nodeToObject() or something.  The point is 
			that we can't just eval() - we need to direct the evaluation to 
			the context sensitive type of result; namely object, class, etc.
		*/
		if ( obj instanceof SimpleNode )
			if ( obj instanceof BSHAmbiguousName )
				obj = ((BSHAmbiguousName)obj).toObject(callstack, interpreter);
			else
				obj = ((SimpleNode)obj).eval(callstack, interpreter);	
		else
			if ( obj instanceof LHS )
				try {
					obj = ((LHS)obj).getValue();
				} catch ( UtilEvalError e ) {
					throw e.toEvalError( this, callstack );
				}
		try
		{
			switch(operation)
			{
				case INDEX:
					return doIndex( obj, toLHS, callstack, interpreter );
				case NAME:
					return doName( obj, toLHS, callstack, interpreter );
				case PROPERTY:
					return doProperty( toLHS, obj, callstack, interpreter );
				default:
					throw new InterpreterError( ""Unknown suffix type"" );
			} 
		}
		catch(ReflectError e)
		{
			throw new EvalError(""reflection error: "" + e, this, callstack );
		}
		catch(InvocationTargetException e)
		{
			throw new TargetError( ""target exception"", e.getTargetException(), 
				this, callstack, true);
		}
	}
	/*
		Field access, .length on array, or a method invocation
		Must handle toLHS case for each.
	*/
	private Object doName(
		Object obj, boolean toLHS, 
		CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError, InvocationTargetException
	{
		try {
			// .length on array
			if ( field.equals(""length"") && obj.getClass().isArray() )
				if ( toLHS )
					throw new EvalError(
						""Can't assign array length"", this, callstack );
				else
					return new Primitive(Array.getLength(obj));
			// field access
			if ( jjtGetNumChildren() == 0 ) 
				if ( toLHS )
					return Reflect.getLHSObjectField(obj, field);
				else
					return Reflect.getObjectField( obj, field );
			// Method invocation
			// (LHS or non LHS evaluation can both encounter method calls)
			Object[] oa = ((BSHArguments)jjtGetChild(0)).getArguments(
				callstack, interpreter);
			return Reflect.invokeObjectMethod( 
				obj, field, oa, interpreter, callstack, this );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
	}
	/**
	*/
	static int getIndexAux(
		Object obj, CallStack callstack, Interpreter interpreter, 
		SimpleNode callerInfo ) 
		throws EvalError
	{
		if ( !obj.getClass().isArray() )
			throw new EvalError(""Not an array"", callerInfo, callstack );
		int index;
		try {
			Object indexVal = 
				((SimpleNode)callerInfo.jjtGetChild(0)).eval( 
					callstack, interpreter );
			if ( !(indexVal instanceof Primitive) )
				indexVal = Types.getAssignableForm( indexVal, Integer.TYPE);
			index = ((Primitive)indexVal).intValue();
		} catch( UtilEvalError e ) {
			Interpreter.debug(""doIndex: ""+e);
			throw e.toEvalError( 
				""Arrays may only be indexed by integer types."", 
				callerInfo, callstack );
		}
		return index;
	}
	/**
		array index.
		Must handle toLHS case.
	*/
	private Object doIndex( 
		Object obj, boolean toLHS, 
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError, ReflectError
	{
		int index = getIndexAux( obj, callstack, interpreter, this );
		if ( toLHS )
			return new LHS(obj, index);
		else
			try {
				return Reflect.getIndex(obj, index);
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( this, callstack );
			}
	}
	/**
		Property access.
		Must handle toLHS case.
	*/
	private Object doProperty( boolean toLHS,
		Object obj, CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		if(obj == Primitive.VOID)
			throw new EvalError( 
			""Attempt to access property on undefined variable or class name"", 
				this, callstack );
		if ( obj instanceof Primitive )
			throw new EvalError(""Attempt to access property on a primitive"", 
				this, callstack );
		Object value = ((SimpleNode)jjtGetChild(0)).eval(
			callstack, interpreter);
		if ( !( value instanceof String ) )
			throw new EvalError(
				""Property expression must be a String or identifier."", 
				this, callstack );
		if ( toLHS )
			return new LHS(obj, (String)value);
		// Property style access to Hashtable or Map
		CollectionManager cm = CollectionManager.getCollectionManager();
		if ( cm.isMap( obj ) )
		{
			Object val = cm.getFromMap( obj, value/*key*/ );
			return ( val == null ?  val = Primitive.NULL : val );
		}
		try {
			return Reflect.getObjectProperty( obj, (String)value );
		}
		catch ( UtilEvalError e)  
		{
			throw e.toEvalError( ""Property: ""+value, this, callstack );
		}
		catch (ReflectError e) 
		{
			throw new EvalError(""No such property: "" + value, this, callstack );
		}
	}
}
"
bsh.BSHPrimitiveType,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHPrimitiveType extends SimpleNode
{
	public Class type;
	BSHPrimitiveType(int id) { super(id); }
	public Class getType() { return type; }
}
"
bsh.BSHReturnStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHReturnStatement extends SimpleNode implements ParserConstants
{
	public int kind;
	BSHReturnStatement(int id) { super(id); }
	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object value;
		if(jjtGetNumChildren() > 0)
			value = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		else
			value = Primitive.VOID;
		return new ReturnControl( kind, value, this );
	}
}
"
bsh.BSHReturnType,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHReturnType extends SimpleNode
{
	public boolean isVoid;
	BSHReturnType(int id) { super(id); }
	BSHType getTypeNode() { 
		return (BSHType)jjtGetChild(0);
	}
	public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
	{
		if ( isVoid )
			return ""V"";
		else
			return getTypeNode().getTypeDescriptor( 
				callstack, interpreter, defaultPackage );
	}
	public Class evalReturnType( 
		CallStack callstack, Interpreter interpreter ) throws EvalError
	{
		if ( isVoid )
			return Void.TYPE;
		else
			return getTypeNode().getType( callstack, interpreter );
	}
}
"
bsh.BSHStatementExpressionList,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHStatementExpressionList extends SimpleNode
{
	BSHStatementExpressionList(int id) { super(id); }
	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		int n = jjtGetNumChildren();
		for(int i=0; i<n; i++)
		{
			SimpleNode node = ((SimpleNode)jjtGetChild(i));
			node.eval(callstack, interpreter);
		}
		return Primitive.VOID;
	}
}
"
bsh.BSHSwitchLabel,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHSwitchLabel extends SimpleNode {
	boolean isDefault;
	public BSHSwitchLabel(int id) { super(id); }
	public Object eval(
		CallStack callstack, Interpreter interpreter) throws EvalError
	{
		if ( isDefault )
			return null; // should probably error
		SimpleNode label = ((SimpleNode)jjtGetChild(0));
		return label.eval( callstack, interpreter );
	}
}
"
bsh.BSHSwitchStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHSwitchStatement 
	extends SimpleNode 
	implements ParserConstants 
{
	public BSHSwitchStatement(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		int numchild = jjtGetNumChildren();
		int child = 0;
		SimpleNode switchExp = ((SimpleNode)jjtGetChild(child++));
		Object switchVal = switchExp.eval( callstack, interpreter );
		/*
			Note: this could be made clearer by adding an inner class for the
			cases and an object context for the child traversal.
		*/
		// first label
		BSHSwitchLabel label;
		Object node;
		ReturnControl returnControl=null;
		// get the first label
		if ( child >= numchild )
			throw new EvalError(""Empty switch statement."", this, callstack );
		label = ((BSHSwitchLabel)jjtGetChild(child++));
		// while more labels or blocks and haven't hit return control
		while ( child < numchild && returnControl == null ) 
		{
			// if label is default or equals switchVal
			if ( label.isDefault 
				|| primitiveEquals( 
					switchVal, label.eval( callstack, interpreter ), 
					callstack, switchExp )
				)
			{
				// execute nodes, skipping labels, until a break or return
				while ( child < numchild ) 
				{
					node = jjtGetChild(child++);
					if ( node instanceof BSHSwitchLabel )
						continue;
					// eval it
					Object value = 
						((SimpleNode)node).eval( callstack, interpreter ); 
					// should check to disallow continue here?
					if ( value instanceof ReturnControl ) {
						returnControl = (ReturnControl)value;
						break;
					}
				}
			} else 
			{
				// skip nodes until next label
				while ( child < numchild ) 
				{
					node = jjtGetChild(child++);
					if ( node instanceof BSHSwitchLabel ) {
						label = (BSHSwitchLabel)node;
						break;
					}
				}
			}
		}
		if ( returnControl != null && returnControl.kind == RETURN )
			return returnControl;
		else
			return Primitive.VOID;
	}
	/**
		Helper method for testing equals on two primitive or boxable objects.
		yuck: factor this out into Primitive.java
	*/
	private boolean primitiveEquals( 
		Object switchVal, Object targetVal, 
		CallStack callstack, SimpleNode switchExp  ) 
		throws EvalError
	{
		if ( switchVal instanceof Primitive || targetVal instanceof Primitive )
			try {
				// binaryOperation can return Primitive or wrapper type 
				Object result = Primitive.binaryOperation( 
					switchVal, targetVal, ParserConstants.EQ );
				result = Primitive.unwrap( result ); 
				return result.equals( Boolean.TRUE ); 
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					""Switch value: ""+switchExp.getText()+"": "", 
					this, callstack );
			}
		else
			return switchVal.equals( targetVal );
	}
}
"
bsh.BSHTernaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	This class needs logic to prevent the right hand side of boolean logical
	expressions from being naively evaluated...  e.g. for ""foo && bar"" bar 
	should not be evaluated in the case where foo is true.
*/
class BSHTernaryExpression extends SimpleNode {
    BSHTernaryExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        SimpleNode
			cond = (SimpleNode)jjtGetChild(0),
			evalTrue = (SimpleNode)jjtGetChild(1),
			evalFalse = (SimpleNode)jjtGetChild(2);
		if ( BSHIfStatement.evaluateCondition( cond, callstack, interpreter ) )
			return evalTrue.eval( callstack, interpreter );
		else
			return evalFalse.eval( callstack, interpreter );
    }
}
"
bsh.BSHThrowStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHThrowStatement extends SimpleNode
{
	BSHThrowStatement(int id) { super(id); }
	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		// need to loosen this to any throwable... do we need to handle
		// that in interpreter somewhere?  check first...
		if(!(obj instanceof Exception))
			throw new EvalError(""Expression in 'throw' must be Exception type"",
				this, callstack );
		// wrap the exception in a TargetException to propogate it up
		throw new TargetError( (Exception)obj, this, callstack );
	}
}
"
bsh.BSHTryStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
class BSHTryStatement extends SimpleNode
{
	BSHTryStatement(int id)
	{
		super(id);
	}
	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		BSHBlock tryBlock = ((BSHBlock)jjtGetChild(0));
		Vector catchParams = new Vector();
		Vector catchBlocks = new Vector();
		int nchild = jjtGetNumChildren();
		Node node = null;
		int i=1;
		while((i < nchild) && ((node = jjtGetChild(i++)) instanceof BSHFormalParameter))
		{
			catchParams.addElement(node);
			catchBlocks.addElement(jjtGetChild(i++));
			node = null;
		}
		// finaly block
		BSHBlock finallyBlock = null;
		if(node != null)
			finallyBlock = (BSHBlock)node;
// Why both of these?
		TargetError target = null;
		Throwable thrown = null;
		Object ret = null;
		/*
			Evaluate the contents of the try { } block and catch any resulting
			TargetErrors generated by the script.
			We save the callstack depth and if an exception is thrown we pop
			back to that depth before contiuing.  The exception short circuited
			any intervening method context pops.
			Note: we the stack info... what do we do with it?  append
			to exception message?
		*/
		int callstackDepth = callstack.depth();
		try {
			ret = tryBlock.eval(callstack, interpreter);
		}
		catch( TargetError e ) {
			target = e;
			String stackInfo = ""Bsh Stack: "";
			while ( callstack.depth() > callstackDepth )
				stackInfo += ""\t"" + callstack.pop() +""\n"";
		}
		// unwrap the target error
		if ( target != null )
			thrown = target.getTarget();
		// If we have an exception, find a catch
		if (thrown != null) 
		{
			int n = catchParams.size();
			for(i=0; i<n; i++)
			{
				// Get catch block
				BSHFormalParameter fp = 
					(BSHFormalParameter)catchParams.elementAt(i);
				// Should cache this subject to classloader change message
				// Evaluation of the formal parameter simply resolves its
				// type via the specified namespace.. it doesn't modify the
				// namespace.
				fp.eval( callstack, interpreter );
				if ( fp.type == null && interpreter.getStrictJava() )
					throw new EvalError(
						""(Strict Java) Untyped catch block"", this, callstack );
				// If the param is typed check assignability
				if ( fp.type != null ) 
					try {
						thrown = (Throwable)Types.getAssignableForm(
							thrown, fp.type);
					} catch( UtilEvalError e ) {
						/* 
							Catch the mismatch and continue to try the next
							Note: this is innefficient, should have an 
							isAssignableFrom() that doesn't throw 
						*/
						continue;
					}
				// Found match, execute catch block
				BSHBlock cb = (BSHBlock)(catchBlocks.elementAt(i));
				// Prepare to execute the block.
				// We must create a new BlockNameSpace to hold the catch
				// parameter and swap it on the stack after initializing it.
				NameSpace enclosingNameSpace = callstack.top();
				BlockNameSpace cbNameSpace = 
					new BlockNameSpace( enclosingNameSpace );
				try {
					if ( fp.type == BSHFormalParameter.UNTYPED )
						// set an untyped variable directly in the block
						cbNameSpace.setBlockVariable( fp.name, thrown );
					else
						// set a typed variable (directly in the block)
						cbNameSpace.setTypedVariable(
							fp.name, fp.type, thrown, false);
				} catch ( UtilEvalError e ) {
					throw new InterpreterError(
						""Unable to set var in catch block namespace."" );
				}
				// put cbNameSpace on the top of the stack
				callstack.swap( cbNameSpace );
				try {
					ret = cb.eval( callstack, interpreter );
				} finally {
					// put it back
					callstack.swap( enclosingNameSpace );
				}
				target = null;  // handled target
				break;
			}
		}
		// evaluate finally block
		if(finallyBlock != null)
			ret = finallyBlock.eval(callstack, interpreter);
		// exception fell through, throw it upward...
		if(target != null)
			throw target;
		if(ret instanceof ReturnControl)
			return ret;
		else	
			return Primitive.VOID;
	}
}
"
bsh.BSHType,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
class BSHType extends SimpleNode 
	implements BshClassManager.Listener
{
	/**
		baseType is used during evaluation of full type and retained for the
		case where we are an array type.
		In the case where we are not an array this will be the same as type.
	*/
	private Class baseType;
	/** 
		If we are an array type this will be non zero and indicate the 
		dimensionality of the array.  e.g. 2 for String[][];
	*/
    private int arrayDims;
	/** 
		Internal cache of the type.  Cleared on classloader change.
	*/
    private Class type;
	String descriptor;
    BSHType(int id) { 
		super(id); 
	}
	/**
		Used by the grammar to indicate dimensions of array types 
		during parsing.
	*/
    public void addArrayDimension() { 
		arrayDims++; 
	}
	SimpleNode getTypeNode() {
        return (SimpleNode)jjtGetChild(0);
	}
    /**
		 Returns a class descriptor for this type.
		 If the type is an ambiguous name (object type) evaluation is 
		 attempted through the namespace in order to resolve imports.
		 If it is not found and the name is non-compound we assume the default
		 package for the name.
	*/
    public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
    {
        // return cached type if available
		if ( descriptor != null )
			return descriptor;
		String descriptor;
        //  first node will either be PrimitiveType or AmbiguousName
        SimpleNode node = getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            descriptor = getTypeDescriptor( ((BSHPrimitiveType)node).type );
        else 
		{
            String clasName = ((BSHAmbiguousName)node).text;
			BshClassManager bcm = interpreter.getClassManager();
			// Note: incorrect here - we are using the hack in bsh class
			// manager that allows lookup by base name.  We need to eliminate
			// this limitation by working through imports.  See notes in class
			// manager.
			String definingClass = bcm.getClassBeingDefined( clasName );
            Class clas = null;
			if ( definingClass == null )
			{
				try {
					clas = ((BSHAmbiguousName)node).toClass( 
						callstack, interpreter );
				} catch ( EvalError e ) {
					//throw new InterpreterError(""unable to resolve type: ""+e);
					// ignore and try default package
					//System.out.println(""BSHType: ""+node+"" class not found"");
				}
			} else
				clasName = definingClass;
			if ( clas != null )
			{
				//System.out.println(""found clas: ""+clas);
            	descriptor = getTypeDescriptor( clas );
			}else
			{
				if ( defaultPackage == null || Name.isCompound( clasName ) )
            		descriptor = ""L"" + clasName.replace('.','/') + "";"";
				else
            		descriptor = 
						""L""+defaultPackage.replace('.','/')+""/""+clasName + "";"";
			}
		}
		for(int i=0; i<arrayDims; i++)
			descriptor = ""[""+descriptor;
		this.descriptor = descriptor;
	//System.out.println(""BSHType: returning descriptor: ""+descriptor);
        return descriptor;
    }
    public Class getType( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
        // return cached type if available
		if ( type != null )
			return type;
        //  first node will either be PrimitiveType or AmbiguousName
        SimpleNode node = getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            baseType = ((BSHPrimitiveType)node).getType();
        else 
            baseType = ((BSHAmbiguousName)node).toClass( 
				callstack, interpreter );
        if ( arrayDims > 0 ) {
            try {
                // Get the type by constructing a prototype array with
				// arbitrary (zero) length in each dimension.
                int[] dims = new int[arrayDims]; // int array default zeros
                Object obj = Array.newInstance(baseType, dims);
                type = obj.getClass(); 
            } catch(Exception e) {
                throw new EvalError(""Couldn't construct array type"", 
					this, callstack );
            }
        } else
            type = baseType;
		// hack... sticking to first interpreter that resolves this
		// see comments on type instance variable
		interpreter.getClassManager().addListener(this);
        return type;
    }
	/**
		baseType is used during evaluation of full type and retained for the
		case where we are an array type.
		In the case where we are not an array this will be the same as type.
	*/
	public Class getBaseType() {
		return baseType;
	}
	/** 
		If we are an array type this will be non zero and indicate the 
		dimensionality of the array.  e.g. 2 for String[][];
	*/
	public int getArrayDims() {
		return arrayDims;
	}
	public void classLoaderChanged() {
		type = null;
		baseType = null;
	}
	public static String getTypeDescriptor( Class clas ) 
	{
		if ( clas == Boolean.TYPE ) return ""Z"";
		if ( clas == Character.TYPE ) return ""C""; 
		if ( clas == Byte.TYPE ) return ""B"";
		if ( clas == Short.TYPE ) return ""S"";
		if ( clas == Integer.TYPE ) return ""I"";
		if ( clas == Long.TYPE ) return ""J"";
		if ( clas == Float.TYPE ) return ""F"";
		if ( clas == Double.TYPE ) return ""D"";
		if ( clas == Void.TYPE ) return ""V"";
	// Is getName() ok?  test with 1.1
		String name = clas.getName().replace('.','/');
		if ( name.startsWith(""["") || name.endsWith("";"") )
			return name;
		else
			return ""L""+ name.replace('.','/') +"";"";
	}
}
"
bsh.BSHTypedVariableDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHTypedVariableDeclaration extends SimpleNode
{
	public Modifiers modifiers;
    BSHTypedVariableDeclaration(int id) { super(id); }
	private BSHType getTypeNode() {
		return ((BSHType)jjtGetChild(0));
	}
	Class evalType( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		BSHType typeNode = getTypeNode();
		return typeNode.getType( callstack, interpreter );
	}
	BSHVariableDeclarator [] getDeclarators() 
	{
		int n = jjtGetNumChildren();
		int start=1;
		BSHVariableDeclarator [] bvda = new BSHVariableDeclarator[ n-start ];
		for (int i = start; i < n; i++)
		{
			bvda[i-start] = (BSHVariableDeclarator)jjtGetChild(i);
		}
		return bvda;
	}
	/**
		evaluate the type and one or more variable declarators, e.g.:
			int a, b=5, c;
	*/
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		try {
			NameSpace namespace = callstack.top();
			BSHType typeNode = getTypeNode();
			Class type = typeNode.getType( callstack, interpreter );
			BSHVariableDeclarator [] bvda = getDeclarators();
			for (int i = 0; i < bvda.length; i++)
			{
				BSHVariableDeclarator dec = bvda[i];
				// Type node is passed down the chain for array initializers
				// which need it under some circumstances
				Object value = dec.eval( typeNode, callstack, interpreter);
				try {
					namespace.setTypedVariable( 
						dec.name, type, value, modifiers );
				} catch ( UtilEvalError e ) { 
					throw e.toEvalError( this, callstack ); 
				}
			}
		} catch ( EvalError e ) {
			e.reThrow( ""Typed variable declaration"" );
		}
        return Primitive.VOID;
    }
	public String getTypeDescriptor( 
		CallStack callstack, Interpreter interpreter, String defaultPackage ) 
	{ 
		return getTypeNode().getTypeDescriptor( 
			callstack, interpreter, defaultPackage );
	}
}
"
bsh.BSHUnaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHUnaryExpression extends SimpleNode implements ParserConstants
{
    public int kind;
	public boolean postfix = false;
    BSHUnaryExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        SimpleNode node = (SimpleNode)jjtGetChild(0);
		// If this is a unary increment of decrement (either pre or postfix)
		// then we need an LHS to which to assign the result.  Otherwise
		// just do the unary operation for the value.
		try {
			if ( kind == INCR || kind == DECR ) {
				LHS lhs = ((BSHPrimaryExpression)node).toLHS( 
					callstack, interpreter );
				return lhsUnaryOperation( lhs, interpreter.getStrictJava() );
			} else
				return 
					unaryOperation( node.eval(callstack, interpreter), kind );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( this, callstack );
		}
    }
    private Object lhsUnaryOperation( LHS lhs, boolean strictJava ) 
		throws UtilEvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug(""lhsUnaryOperation"");
        Object prevalue, postvalue;
        prevalue = lhs.getValue();
        postvalue = unaryOperation(prevalue, kind);
		Object retVal;
		if ( postfix )
			retVal = prevalue;
		else
			retVal = postvalue;
		lhs.assign( postvalue, strictJava );
		return retVal;
    }
    private Object unaryOperation( Object op, int kind ) throws UtilEvalError
    {
        if (op instanceof Boolean || op instanceof Character 
			|| op instanceof Number)
            return primitiveWrapperUnaryOperation( op, kind );
        if ( !(op instanceof Primitive) )
            throw new UtilEvalError( ""Unary operation "" + tokenImage[kind]
                + "" inappropriate for object"" );
        return Primitive.unaryOperation((Primitive)op, kind);
    }
    private Object primitiveWrapperUnaryOperation(Object val, int kind)
        throws UtilEvalError
    {
        Class operandType = val.getClass();
        Object operand = Primitive.promoteToInteger(val);
        if ( operand instanceof Boolean )
			return new Boolean(
				Primitive.booleanUnaryOperation((Boolean)operand, kind));
        else 
		if ( operand instanceof Integer )
        {
            int result = Primitive.intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Byte((byte)result);
                if(operandType == Short.TYPE)
                    return new Short((short)result);
                if(operandType == Character.TYPE)
                    return new Character((char)result);
            }
            return new Integer(result);
        }
        else if(operand instanceof Long)
            return new Long(Primitive.longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Float(Primitive.floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Double(Primitive.doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(""An error occurred.  Please call technical support."");
    }
}
"
bsh.BSHVariableDeclarator,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	name [ = initializer ]
	evaluate name and return optional initializer
*/
class BSHVariableDeclarator extends SimpleNode
{
	// The token.image text of the name... never changes.
    public String name;
    BSHVariableDeclarator(int id) { super(id); }
	/**
		Evaluate the optional initializer value.  
		(The name was set at parse time.)
		A variable declarator can be evaluated with or without preceding
		type information. Currently the type info is only used by array 
		initializers in the case where there is no explicitly declared type.
		@param typeNode is the BSHType node.  Its info is passed through to any
		variable intializer children for the case where the array initializer
		does not declare the type explicitly. e.g.
			int [] a = { 1, 2 };
		typeNode may be null to indicate no type information available.
	*/
    public Object eval( 
		BSHType typeNode, CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		// null value means no value
		Object value = null;
        if ( jjtGetNumChildren() > 0 ) 
		{
            SimpleNode initializer = (SimpleNode)jjtGetChild(0);
			/*
				If we have type info and the child is an array initializer
				pass it along...  Else use the default eval style.
				(This allows array initializer to handle the problem... 
				allowing for future enhancements in loosening types there).	
			*/
			if ( (typeNode != null) 
				&& initializer instanceof BSHArrayInitializer 
			)
            	value = ((BSHArrayInitializer)initializer).eval( 
					typeNode.getBaseType(), typeNode.getArrayDims(), 
					callstack, interpreter);
			else
				value = initializer.eval( callstack, interpreter);
		}
		if ( value == Primitive.VOID )
            throw new EvalError(""Void initializer."", this, callstack );
        return value;
    }
	public String toString() { return ""BSHVariableDeclarator ""+name; }
}
"
bsh.BSHWhileStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	This class handles both while(){} statements and do{}while() statements.
*/
class BSHWhileStatement extends SimpleNode implements ParserConstants
{
	public boolean isDoStatement;
    BSHWhileStatement(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		int numChild = jjtGetNumChildren();
		// Order of body and condition is swapped for do / while
        SimpleNode condExp, body = null;
		if ( isDoStatement ) {
			condExp = (SimpleNode)jjtGetChild(1);
			body =(SimpleNode)jjtGetChild(0);
		} else {
			condExp = (SimpleNode)jjtGetChild(0);
			if ( numChild > 1 )	// has body, else just for side effects
				body =(SimpleNode)jjtGetChild(1);
		}
		boolean doOnceFlag = isDoStatement;
        while( 
			doOnceFlag || 
			BSHIfStatement.evaluateCondition(condExp, callstack, interpreter )
		)
		{
			if ( body == null ) // no body?
				continue;
			Object ret = body.eval(callstack, interpreter);
			boolean breakout = false;
			if(ret instanceof ReturnControl)
			{
				switch(((ReturnControl)ret).kind )
				{
					case RETURN:
						return ret;
					case CONTINUE:
						continue;
					case BREAK:
						breakout = true;
						break;
				}
			}
			if(breakout)
				break;
			doOnceFlag = false;
		}
        return Primitive.VOID;
    }
}
"
bsh.CallStack,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
/**
	A stack of NameSpaces representing the call path.
	Each method invocation, for example, pushes a new NameSpace onto the stack.
	The top of the stack is always the current namespace of evaluation.
	<p>
	This is used to support the this.caller magic reference and to print
	script ""stack traces"" when evaluation errors occur.
	<p>
	Note: it would be awefully nice to use the java.util.Stack here.
	Sigh... have to stay 1.1 compatible.
	<p>
	Note: How can this be thread safe, you might ask?  Wouldn't a thread 
	executing various beanshell methods be mutating the callstack?  Don't we 
	need one CallStack per Thread in the interpreter?  The answer is that we do.
	Any java.lang.Thread enters our script via an external (hard) Java 
	reference via a This type interface, e.g.  the Runnable interface 
	implemented by This or an arbitrary interface implemented by XThis.  
	In that case the This invokeMethod() method (called by any interface that 
	it exposes) creates a new CallStack for each external call.
	<p>
*/
public class CallStack 
{
	private Vector stack = new Vector(2);
	public CallStack() { }
	public CallStack( NameSpace namespace ) { 
		push( namespace );
	}
	public void clear() {
		stack.removeAllElements();
	}
	public void push( NameSpace ns ) {
		stack.insertElementAt( ns, 0 );
	}
	public NameSpace top() {
		return get(0);
	}
	/**
		zero based.
	*/
	public NameSpace get(int depth) {
		if ( depth >= depth() )
			return NameSpace.JAVACODE;
		else
			return (NameSpace)(stack.elementAt(depth));
	}
	/**
		This is kind of crazy, but used by the setNameSpace command.
		zero based.
	*/
	public void set(int depth, NameSpace ns) {
		stack.setElementAt(ns, depth );
	}
	public NameSpace pop() {
		if ( depth() < 1 )
			throw new InterpreterError(""pop on empty CallStack"");
		NameSpace top = top();
		stack.removeElementAt(0);
		return top;
	}
	/**
		Swap in the value as the new top of the stack and return the old
		value.
	*/
	public NameSpace swap( NameSpace newTop ) {
		NameSpace oldTop = (NameSpace)(stack.elementAt(0));
		stack.setElementAt( newTop, 0 );
		return oldTop;
	}
	public int depth() {
		return stack.size();
	}
	public NameSpace [] toArray() {
		NameSpace [] nsa = new NameSpace [ depth() ];
		stack.copyInto( nsa );
		return nsa;
	}
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(""CallStack:\n"");
		NameSpace [] nsa = toArray();
		for(int i=0; i<nsa.length; i++)
			sb.append(""\t""+nsa[i]+""\n"");
		return sb.toString();
	}
	/**
		Occasionally we need to freeze the callstack for error reporting
		purposes, etc.
	*/
	public CallStack copy() {
		CallStack cs = new CallStack();
		cs.stack = (Vector)this.stack.clone();
		return cs;
	}
}
"
bsh.Capabilities,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Hashtable;
/**
	The map of extended features supported by the runtime in which we live.
	<p>
	This class should be independent of all other bsh classes!
	<p>
	Note that tests for class existence here do *not* use the 
	BshClassManager, as it may require other optional class files to be 
	loaded.  
*/
public class Capabilities 
{
	private static boolean accessibility = false;
	public static boolean haveSwing() {
		// classExists caches info for us
		return classExists( ""javax.swing.JButton"" );
	}
	public static boolean canGenerateInterfaces() {
		// classExists caches info for us
		return classExists( ""java.lang.reflect.Proxy"" );
	}
	/**
		If accessibility is enabled
		determine if the accessibility mechanism exists and if we have
		the optional bsh package to use it.
		Note that even if both are true it does not necessarily mean that we 
		have runtime permission to access the fields... Java security has
	 	a say in it.
		@see bsh.ReflectManager
	*/
	public static boolean haveAccessibility() 
	{
		// classExists caches the tests for us
		return ( accessibility 
			&& classExists( ""java.lang.reflect.AccessibleObject"" )
			&& classExists(""bsh.reflect.ReflectManagerImpl"") 
		);
	}
	public static void setAccessibility( boolean b ) { accessibility = b; }
	private static Hashtable classes = new Hashtable();
	/**
		Use direct Class.forName() to test for the existence of a class.
		We should not use BshClassManager here because:
			a) the systems using these tests would probably not load the
			classes through it anyway.
			b) bshclassmanager is heavy and touches other class files.  
			this capabilities code must be light enough to be used by any
			system **including the remote applet**.
	*/
	public static boolean classExists( String name ) 
	{
		Object c = classes.get( name );
		if ( c == null ) {
			try {
				/*
					Note: do *not* change this to 
					BshClassManager plainClassForName() or equivalent.
					This class must not touch any other bsh classes.
				*/
				c = Class.forName( name );
			} catch ( ClassNotFoundException e ) { }
			if ( c != null )
				classes.put(c,""unused"");
		}
		return c != null;
	}
	/**
		An attempt was made to use an unavailable capability supported by
		an optional package.  The normal operation is to test before attempting
		to use these packages... so this is runtime exception.
	*/
	public static class Unavailable extends UtilEvalError
	{
		public Unavailable(String s ){ super(s); }
	}
}
"
bsh.ClassGenerator,"package bsh;
import bsh.Capabilities.Unavailable;
import java.lang.reflect.InvocationTargetException;
public abstract class ClassGenerator
{
	private static ClassGenerator cg;
	public static ClassGenerator getClassGenerator() 
		throws UtilEvalError
	{
		if ( cg == null ) 
		{
			try {
				Class clas = Class.forName( ""bsh.ClassGeneratorImpl"" );
				cg = (ClassGenerator)clas.newInstance();
			} catch ( Exception e ) {
				throw new Unavailable(""ClassGenerator unavailable: ""+e);
			}
		}
		return cg;
	}
	/**
		Parse the BSHBlock for the class definition and generate the class.
	*/
	public abstract Class generateClass( 
		String name, Modifiers modifiers, 
		Class [] interfaces, Class superClass, BSHBlock block, 
		boolean isInterface, CallStack callstack, Interpreter interpreter 
	)
		throws EvalError;
	/**
		Invoke a super.method() style superclass method on an object instance.
		This is not a normal function of the Java reflection API and is
		provided by generated class accessor methods.
	*/
	public abstract Object invokeSuperclassMethod(
		BshClassManager bcm, Object instance, String methodName, Object [] args
	)
        throws UtilEvalError, ReflectError, InvocationTargetException;
	/**
		Change the parent of the class instance namespace.
		This is currently used for inner class support.
		Note: This method will likely be removed in the future.
	*/
	public abstract void setInstanceNameSpaceParent( 
		Object instance, String className, NameSpace parent );
}
"
bsh.ClassGeneratorImpl,"package bsh;
import java.io.*;
import java.util.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
/**
	@author Pat Niemeyer (pat@pat.net)
*/
public class ClassGeneratorImpl extends ClassGenerator
{
	public Class generateClass( 
		String name, Modifiers modifiers, 
		Class [] interfaces, Class superClass, BSHBlock block, 
		boolean isInterface, CallStack callstack, Interpreter interpreter 
	)
		throws EvalError
	{
		// Delegate to the static method
		return generateClassImpl( name, modifiers, interfaces, superClass,
			block, isInterface, callstack, interpreter );
	}
	public Object invokeSuperclassMethod(
		BshClassManager bcm, Object instance, String methodName, Object [] args
	)
        throws UtilEvalError, ReflectError, InvocationTargetException
	{
		// Delegate to the static method
		return invokeSuperclassMethodImpl( bcm, instance, methodName, args );
	}
	/**
		Change the parent of the class instance namespace.
		This is currently used for inner class support.
		Note: This method will likely be removed in the future.
	*/
	// This could be static
	public void setInstanceNameSpaceParent( 
		Object instance, String className, NameSpace parent )
	{
		This ithis = 
			ClassGeneratorUtil.getClassInstanceThis( instance, className );
		ithis.getNameSpace().setParent( parent );
	}
	/**
		Parse the BSHBlock for for the class definition and generate the class
		using ClassGenerator.
	*/
	public static Class generateClassImpl( 
		String name, Modifiers modifiers, 
		Class [] interfaces, Class superClass, BSHBlock block, 
		boolean isInterface, CallStack callstack, Interpreter interpreter 
	)
		throws EvalError
	{
		// Scripting classes currently requires accessibility
		// This can be eliminated with a bit more work.
		Capabilities.setAccessibility( true );	
		if ( !Capabilities.haveAccessibility() )
			throw new InterpreterError(
				""Defining classes currently requires reflect Accessibility."");
		NameSpace enclosingNameSpace = callstack.top();
		String packageName = enclosingNameSpace.getPackage();
		String className =  enclosingNameSpace.isClass ?  
			( enclosingNameSpace.getName()+""$""+name ) : name;
		String fqClassName = 
			packageName == null ? className : packageName + ""."" + className;
		BshClassManager bcm = interpreter.getClassManager();
		// Race condition here...
		bcm.definingClass( fqClassName );
		// Create the class static namespace
		NameSpace classStaticNameSpace = 
			new NameSpace( enclosingNameSpace, className);
		classStaticNameSpace.isClass = true;
		callstack.push( classStaticNameSpace );
		// Evaluate any inner class class definitions in the block 
		// effectively recursively call this method for contained classes first
		block.evalBlock( 
			callstack, interpreter, true/*override*/, 
			ClassNodeFilter.CLASSCLASSES );
		// Generate the type for our class
		Variable [] variables = 
			getDeclaredVariables( block, callstack, interpreter, packageName );
		DelayedEvalBshMethod [] methods =
			getDeclaredMethods( block, callstack, interpreter, packageName );
		ClassGeneratorUtil classGenerator = new ClassGeneratorUtil( 
			modifiers, className, packageName, superClass, interfaces, 
			variables, methods, classStaticNameSpace, isInterface );
		byte [] code = classGenerator.generateClass();
		// if debug, write out the class file to debugClasses directory
		String dir = System.getProperty(""debugClasses"");
		if ( dir != null )
		try {
			FileOutputStream out= 
				new FileOutputStream( dir+""/""+className+"".class"" );
			out.write(code);
			out.close();
		} catch ( IOException e ) { }
		// Define the new class in the classloader
		Class genClass = bcm.defineClass( fqClassName, code );
//bcm.doneDefiningClass( fqClassName );
		// import the unq name into parent
		enclosingNameSpace.importClass( fqClassName.replace('$','.') );
		// Also cache the class so that no import resolution must occur
		// this avoids having to load our enclosing class which isn't
		// finished being generated yet... oy.
// caching is not correct and doesn't seem to help...
//	enclosingNameSpace.cacheClass( name, genClass );
// Also cache it in the static namespace...
//classStaticNameSpace.cacheClass( name, genClass );
//classStaticNameSpace.importClass( fqClassName.replace('$','.') );
		try {
			classStaticNameSpace.setLocalVariable( 
				ClassGeneratorUtil.BSHINIT, block, false/*strictJava*/ );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError(""unable to init static: ""+e );
		}
		// Give the static space its class static import
		// important to do this after all classes are defined
		classStaticNameSpace.setClassStatic( genClass );
		// evaluate the static portion of the block in the static space
		block.evalBlock( 
			callstack, interpreter, true/*override*/, 
			ClassNodeFilter.CLASSSTATIC );
		callstack.pop();
		if ( !genClass.isInterface() )
		{
		// Set the static bsh This callback 
		String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC+className;
		try {
			LHS lhs = Reflect.getLHSStaticField( genClass, bshStaticFieldName );
			lhs.assign( 
				classStaticNameSpace.getThis( interpreter ), false/*strict*/ );
		} catch ( Exception e ) {
			throw new InterpreterError(""Error in class gen setup: ""+e );
		}
		}
		bcm.doneDefiningClass( fqClassName );
		return genClass;
	}
	static Variable [] getDeclaredVariables( 
		BSHBlock body, CallStack callstack, Interpreter interpreter, 
		String defaultPackage 
	) 
		throws EvalError
	{
		List vars = new ArrayList();
		for( int child=0; child<body.jjtGetNumChildren(); child++ )
		{
			SimpleNode node = (SimpleNode)body.jjtGetChild(child);
			if ( node instanceof BSHTypedVariableDeclaration )
			{
				BSHTypedVariableDeclaration tvd = 
					(BSHTypedVariableDeclaration)node;
				Modifiers modifiers = tvd.modifiers;
				String type = tvd.getTypeDescriptor( 
					callstack, interpreter, defaultPackage );
				BSHVariableDeclarator [] vardec = tvd.getDeclarators();
				for( int i = 0; i< vardec.length; i++)
				{
					String name = vardec[i].name;
					try {
						Variable var = new Variable( 
							name, type, null/*value*/, modifiers );
						vars.add( var );
					} catch ( UtilEvalError e ) {
						// value error shouldn't happen
					}
				}
			}
		}
		return (Variable [])vars.toArray( new Variable[0] );
	}
	static DelayedEvalBshMethod [] getDeclaredMethods( 
		BSHBlock body, CallStack callstack, Interpreter interpreter,
		String defaultPackage 
	)
		throws EvalError
	{
		List methods = new ArrayList();
		for( int child=0; child<body.jjtGetNumChildren(); child++ )
		{
			SimpleNode node = (SimpleNode)body.jjtGetChild(child);
			if ( node instanceof BSHMethodDeclaration )
			{
				BSHMethodDeclaration md = (BSHMethodDeclaration)node;
				md.insureNodesParsed();
				Modifiers modifiers = md.modifiers;
				String name = md.name;
				String returnType = md.getReturnTypeDescriptor( 
					callstack, interpreter, defaultPackage );
				BSHReturnType returnTypeNode = md.getReturnTypeNode();
				BSHFormalParameters paramTypesNode = md.paramsNode;
				String [] paramTypes = paramTypesNode.getTypeDescriptors( 
					callstack, interpreter, defaultPackage );
				DelayedEvalBshMethod bm = new DelayedEvalBshMethod( 
					name, 
					returnType, returnTypeNode,
					md.paramsNode.getParamNames(), 
					paramTypes, paramTypesNode,
					md.blockNode, null/*declaringNameSpace*/,
					modifiers, callstack, interpreter 
				);
				methods.add( bm );
			}
		}
		return (DelayedEvalBshMethod [])methods.toArray( 
			new DelayedEvalBshMethod[0] );
	}
	/**
		A node filter that filters nodes for either a class body static 
		initializer or instance initializer.  In the static case only static 
		members are passed, etc.  
	*/
	static class ClassNodeFilter implements BSHBlock.NodeFilter
	{
		public static final int STATIC=0, INSTANCE=1, CLASSES=2;
		public static ClassNodeFilter CLASSSTATIC = 
			new ClassNodeFilter( STATIC );
		public static ClassNodeFilter CLASSINSTANCE = 
			new ClassNodeFilter( INSTANCE );
		public static ClassNodeFilter CLASSCLASSES = 
			new ClassNodeFilter( CLASSES );
		int context;
		private ClassNodeFilter( int context ) { this.context = context; }
		public boolean isVisible( SimpleNode node ) 
		{
			if ( context == CLASSES )
				return node instanceof BSHClassDeclaration;
			// Only show class decs in CLASSES
			if ( node instanceof BSHClassDeclaration )
				return false;
			if ( context == STATIC )
				return isStatic( node );
			if ( context == INSTANCE )
				return !isStatic( node );
			// ALL
			return true;
		}
		boolean isStatic( SimpleNode node ) 
		{
			if ( node instanceof BSHTypedVariableDeclaration )
				return ((BSHTypedVariableDeclaration)node).modifiers != null
					&& ((BSHTypedVariableDeclaration)node).modifiers
						.hasModifier(""static"");
			if ( node instanceof BSHMethodDeclaration )
				return ((BSHMethodDeclaration)node).modifiers != null
					&& ((BSHMethodDeclaration)node).modifiers
						.hasModifier(""static"");
			// need to add static block here
			if ( node instanceof BSHBlock)
				return false;
			return false;
		}
	}
	public static Object invokeSuperclassMethodImpl(
		BshClassManager bcm, Object instance, String methodName, Object [] args
	)
        throws UtilEvalError, ReflectError, InvocationTargetException
	{
		String superName = ClassGeneratorUtil.BSHSUPER+methodName;
		// look for the specially named super delegate method
		Class clas = instance.getClass();
		Method superMethod = Reflect.resolveJavaMethod(
			bcm, clas, superName, Types.getTypes(args), false/*onlyStatic*/ );
		if ( superMethod != null )
			return Reflect.invokeOnMethod( 
				superMethod, instance, args );
		// No super method, try to invoke regular method
		// could be a superfluous ""super."" which is legal.
		Class superClass = clas.getSuperclass();
		superMethod = Reflect.resolveExpectedJavaMethod(
			bcm, superClass, instance, methodName, args, 
			false/*onlyStatic*/ );
		return Reflect.invokeOnMethod( superMethod, instance, args );
	}
}
"
bsh.ClassGeneratorUtil,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import org.objectweb.asm.Constants;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.CodeVisitor;
import org.objectweb.asm.Type;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
/**
	ClassGeneratorUtil utilizes the ASM (www.objectweb.org) bytecode generator 
	by Eric Bruneton in order to generate class ""stubs"" for BeanShell at
	runtime.  
	<p>
	Stub classes contain all of the fields of a BeanShell scripted class
	as well as two ""callback"" references to BeanShell namespaces: one for
	static methods and one for instance methods.  Methods of the class are
	delegators which invoke corresponding methods on either the static or
	instance bsh object and then unpack and return the results.  The static
	namespace utilizes a static import to delegate variable access to the
	class' static fields.  The instance namespace utilizes a dynamic import
	(i.e. mixin) to delegate variable access to the class' instance variables.
	<p>
	Constructors for the class delegate to the static initInstance() method of 
	ClassGeneratorUtil to initialize new instances of the object.  initInstance()
	invokes the instance intializer code (init vars and instance blocks) and
	then delegates to the corresponding scripted constructor method in the
	instance namespace.  Constructors contain special switch logic which allows
	the BeanShell to control the calling of alternate constructors (this() or
	super() references) at runtime.
	<p>
	Specially named superclass delegator methods are also generated in order to
	allow BeanShell to access overridden methods of the superclass (which
	reflection does not normally allow).
	<p>
	@author Pat Niemeyer
*/
/*
	Notes:
	It would not be hard to eliminate the use of org.objectweb.asm.Type from
	this class, making the distribution a tiny bit smaller.
*/
public class ClassGeneratorUtil implements Constants 
{
	/** The name of the static field holding the reference to the bsh
	 	 static This (the callback namespace for static methods) */
	static final String BSHSTATIC=""_bshStatic"";
	/** The name of the instance field holding the reference to the bsh
	 	 instance This (the callback namespace for instance methods) */
	static final String BSHTHIS=""_bshThis"";
	/** The prefix for the name of the super delegate methods. e.g.
	 	_bshSuperfoo() is equivalent to super.foo() */
	static final String BSHSUPER=""_bshSuper"";
	/** The bsh static namespace variable name of the instance initializer */
	static final String BSHINIT=""_bshInstanceInitializer"";
	/** The bsh static namespace variable that holds the constructor methods */
	static final String BSHCONSTRUCTORS=""_bshConstructors"";
	/** The switch branch number for the default constructor. 
		The value -1 will cause the default branch to be taken. */
	static final int DEFAULTCONSTRUCTOR = -1;
	static final String OBJECT= ""Ljava/lang/Object;"";
	String className;
	/** fully qualified class name (with package) e.g. foo/bar/Blah */
	String fqClassName;
	Class superClass; 
	String superClassName;
	Class [] interfaces;
	Variable [] vars;
	Constructor [] superConstructors;
	DelayedEvalBshMethod [] constructors;
	DelayedEvalBshMethod [] methods;
	NameSpace classStaticNameSpace;
	Modifiers classModifiers;
	boolean isInterface;
	/**
		@param packageName e.g. ""com.foo.bar""
	*/
	public ClassGeneratorUtil(
		Modifiers classModifiers, String className, String packageName, 
		Class superClass, Class [] interfaces, Variable [] vars, 
		DelayedEvalBshMethod [] bshmethods, NameSpace classStaticNameSpace,
		boolean isInterface
	) 
	{
		this.classModifiers = classModifiers;
		this.className = className;
		if ( packageName != null ) 
			this.fqClassName = packageName.replace('.','/') + ""/"" + className;
		else
			this.fqClassName = className;
		if ( superClass == null )
			superClass = Object.class;
		this.superClass = superClass;
		this.superClassName = Type.getInternalName( superClass );
		if ( interfaces == null )
			interfaces = new Class[0];
		this.interfaces = interfaces;
		this.vars = vars;
		this.classStaticNameSpace = classStaticNameSpace;
		this.superConstructors = superClass.getDeclaredConstructors();
		// Split the methods into constructors and regular method lists
		List consl = new ArrayList();
		List methodsl = new ArrayList();
		String classBaseName = getBaseName( className ); // for inner classes
		for( int i=0; i< bshmethods.length; i++ )
			if ( bshmethods[i].getName().equals( classBaseName ) )
				consl.add( bshmethods[i] );
			else
				methodsl.add( bshmethods[i] );
		this.constructors = (DelayedEvalBshMethod [])consl.toArray( 
			new DelayedEvalBshMethod[0] );
		this.methods = (DelayedEvalBshMethod [])methodsl.toArray( 
			new DelayedEvalBshMethod[0] );
		try {
			classStaticNameSpace.setLocalVariable( 
				BSHCONSTRUCTORS, constructors, false/*strict*/ );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError(""can't set cons var"");
		}
		this.isInterface = isInterface;
	}
	/**
		Generate the class bytecode for this class.
		@param className should be a path style name, e.g. 
			""TestClass"" or ""mypackage/TestClass""
	*/
	public byte [] generateClass() 
	{
		// Force the class public for now...
		int classMods = getASMModifiers( classModifiers ) | ACC_PUBLIC;
		if ( isInterface )
			classMods |= ACC_INTERFACE;
		String [] interfaceNames = new String [interfaces.length];
		for(int i=0; i<interfaces.length; i++)
			interfaceNames[i]=Type.getInternalName( interfaces[i] );
		String sourceFile = ""BeanShell Generated via ASM (www.objectweb.org)"";
		ClassWriter cw = new ClassWriter(false);
		cw.visit( classMods, fqClassName, superClassName, 
			interfaceNames, sourceFile );
		if ( !isInterface )
		{
			// Generate the bsh instance 'This' reference holder field
			generateField( 
				BSHTHIS+className, ""Lbsh/This;"", ACC_PUBLIC, cw);
			// Generate the static bsh static reference holder field
			generateField( 
				BSHSTATIC+className, ""Lbsh/This;"", ACC_PUBLIC+ACC_STATIC, cw);
		}
		// Generate the fields
		for( int i=0; i<vars.length; i++)
		{
			String type = vars[i].getTypeDescriptor();
			// Don't generate private or loosely typed fields
			// Note: loose types aren't currently parsed anyway...
			if ( vars[i].hasModifier(""private"") || type == null )
				continue;
			int modifiers;
			if ( isInterface )
				modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;
			else
				modifiers = getASMModifiers( vars[i].getModifiers() );
			generateField( vars[i].getName(), type, modifiers , cw );
		}
		// Generate the constructors
		boolean hasConstructor = false;
		for( int i=0; i<constructors.length; i++)
		{
			// Don't generate private constructors
			if ( constructors[i].hasModifier(""private"") )
				continue;
			int modifiers = getASMModifiers( constructors[i].getModifiers() );
			generateConstructor( 
				i, constructors[i].getParamTypeDescriptors(), modifiers, cw );
			hasConstructor = true;
		}
		// If no other constructors, generate a default constructor
		if ( !isInterface && !hasConstructor )
			generateConstructor( 
				DEFAULTCONSTRUCTOR/*index*/, new String [0], ACC_PUBLIC, cw );
		// Generate the delegate methods
		for( int i=0; i<methods.length; i++)
		{
			String returnType = methods[i].getReturnTypeDescriptor();
			// Don't generate private /*or loosely return typed */ methods
			if ( methods[i].hasModifier(""private"") /*|| returnType == null*/ )
				continue;
			int modifiers = getASMModifiers( methods[i].getModifiers() );
			if ( isInterface )
				modifiers |= ( ACC_PUBLIC | ACC_ABSTRACT );
			generateMethod( className, fqClassName, 
				methods[i].getName(), returnType,
				methods[i].getParamTypeDescriptors(), modifiers, cw );
			boolean isStatic = (modifiers & ACC_STATIC) > 0 ;
			boolean overridden = classContainsMethod( 
				superClass, methods[i].getName(), 
				methods[i].getParamTypeDescriptors() ) ;
			if ( !isStatic && overridden )
				generateSuperDelegateMethod( superClass, superClassName,
					methods[i].getName(), returnType,
					methods[i].getParamTypeDescriptors(), modifiers, cw );
		}
		return cw.toByteArray();
	}
	/**
		Translate bsh.Modifiers into ASM modifier bitflags.
	*/
	static int getASMModifiers( Modifiers modifiers ) 
	{
		int mods = 0;
		if ( modifiers == null )
			return mods;
		if ( modifiers.hasModifier(""public"") )
			mods += ACC_PUBLIC;
		if ( modifiers.hasModifier(""protected"") )
			mods += ACC_PROTECTED;
		if ( modifiers.hasModifier(""static"") )
			mods += ACC_STATIC;
		if ( modifiers.hasModifier(""synchronized"") )
			mods += ACC_SYNCHRONIZED;
		if ( modifiers.hasModifier(""abstract"") )
			mods += ACC_ABSTRACT;
		return mods;
	}
	/**
		Generate a field - static or instance.
	*/
	static void generateField( 
		String fieldName, String type, int modifiers, ClassWriter cw ) 
	{
		cw.visitField( modifiers, fieldName, type, null/*value*/ );
	}
	/**
		Generate a delegate method - static or instance.
		The generated code packs the method arguments into an object array
		(wrapping primitive types in bsh.Primitive), invokes the static or
		instance namespace invokeMethod() method, and then unwraps / returns
		the result.
	*/
	static void generateMethod( 
		String className, String fqClassName, String methodName, 
		String returnType, String[] paramTypes, int modifiers, ClassWriter cw ) 
	{
		String [] exceptions = null;
		boolean isStatic = (modifiers & ACC_STATIC) != 0 ;
		if ( returnType == null ) // map loose return type to Object
			returnType = OBJECT;
		String methodDescriptor = getMethodDescriptor( returnType, paramTypes );
		// Generate method body
		CodeVisitor cv = cw.visitMethod( 
			modifiers, methodName, methodDescriptor, exceptions );
		if ( (modifiers & ACC_ABSTRACT) != 0 )
			return;
		// Generate code to push the BSHTHIS or BSHSTATIC field 
		if ( isStatic )
		{
			cv.visitFieldInsn( 
				GETSTATIC, fqClassName, BSHSTATIC+className, ""Lbsh/This;"" );
		}else
		{
			// Push 'this'
			cv.visitVarInsn( ALOAD, 0 );
			// Get the instance field
			cv.visitFieldInsn( 
				GETFIELD, fqClassName, BSHTHIS+className, ""Lbsh/This;"" );
		}
		// Push the name of the method as a constant
    	cv.visitLdcInsn( methodName );
		// Generate code to push arguments as an object array
		generateParameterReifierCode( paramTypes, isStatic, cv );
		// Push nulls for various args of invokeMethod
		cv.visitInsn(ACONST_NULL); // interpreter
		cv.visitInsn(ACONST_NULL); // callstack
		cv.visitInsn(ACONST_NULL); // callerinfo
		// Push the boolean constant 'true' (for declaredOnly)
		cv.visitInsn(ICONST_1);
		// Invoke the method This.invokeMethod( name, Class [] sig, boolean )
		cv.visitMethodInsn(
			INVOKEVIRTUAL, ""bsh/This"", ""invokeMethod"", 
			Type.getMethodDescriptor( 
				Type.getType(Object.class),
				new Type [] { 
					Type.getType(String.class), 
					Type.getType(Object [].class),
					Type.getType(Interpreter.class),
					Type.getType(CallStack.class),
					Type.getType(SimpleNode.class),
					Type.getType(Boolean.TYPE) 
				} 
			)
		);
		// Generate code to unwrap bsh Primitive types
		cv.visitMethodInsn(
		  INVOKESTATIC, ""bsh/Primitive"", ""unwrap"", 
		  ""(Ljava/lang/Object;)Ljava/lang/Object;"" );
		// Generate code to return the value
		generateReturnCode( returnType, cv );
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs( 20, 20 );
	}
	/**
		Generate a constructor.
	*/
	void generateConstructor( 
		int index, String [] paramTypes, int modifiers, ClassWriter cw ) 
	{
		/** offset after params of the args object [] var */
		final int argsVar = paramTypes.length+1;
		/** offset after params of the ConstructorArgs var */
		final int consArgsVar = paramTypes.length+2;
		String [] exceptions = null;
		String methodDescriptor = getMethodDescriptor( ""V"", paramTypes );
		// Create this constructor method
		CodeVisitor cv = 
			cw.visitMethod( modifiers, ""<init>"", methodDescriptor, exceptions );
		// Generate code to push arguments as an object array
		generateParameterReifierCode( paramTypes, false/*isStatic*/, cv );
		cv.visitVarInsn( ASTORE, argsVar );
		// Generate the code implementing the alternate constructor switch
		generateConstructorSwitch( index, argsVar, consArgsVar, cv );
		// Generate code to invoke the ClassGeneratorUtil initInstance() method
		// push 'this' 
		cv.visitVarInsn( ALOAD, 0 );
		// Push the class/constructor name as a constant
    	cv.visitLdcInsn( className );
		// Push arguments as an object array
		cv.visitVarInsn( ALOAD, argsVar );
		// invoke the initInstance() method
		cv.visitMethodInsn(
			INVOKESTATIC, ""bsh/ClassGeneratorUtil"", ""initInstance"",
			""(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V"");
		cv.visitInsn( RETURN );
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs( 20, 20 );
	}
	/**
		Generate a switch with a branch for each possible alternate
		constructor.  This includes all superclass constructors and all 
		constructors of this class.  The default branch of this switch is the
		default superclass constructor.
		<p>
		This method also generates the code to call the static
		ClassGeneratorUtil
		getConstructorArgs() method which inspects the scripted constructor to
		find the alternate constructor signature (if any) and evalute the
		arguments at runtime.  The getConstructorArgs() method returns the
		actual arguments as well as the index of the constructor to call. 
	*/
	void generateConstructorSwitch( 
		int consIndex, int argsVar, int consArgsVar, CodeVisitor cv )
	{
		Label defaultLabel = new Label();
		Label endLabel = new Label();
		int cases = superConstructors.length + constructors.length ;
		Label [] labels = new Label[ cases ];
		for(int i=0; i<cases; i++)
			labels[i]=new Label();
		// Generate code to call ClassGeneratorUtil to get our switch index 
		// and give us args...
		// push super class name
    	cv.visitLdcInsn( superClass.getName() ); // use superClassName var?
		// push class static This object
		cv.visitFieldInsn( 
			GETSTATIC, fqClassName, BSHSTATIC+className, ""Lbsh/This;"" );
		// push args
		cv.visitVarInsn( ALOAD, argsVar );
		// push this constructor index number onto stack
		cv.visitIntInsn( BIPUSH, consIndex );
		// invoke the ClassGeneratorUtil getConstructorsArgs() method
		cv.visitMethodInsn(
			INVOKESTATIC, ""bsh/ClassGeneratorUtil"", ""getConstructorArgs"",
			""(Ljava/lang/String;Lbsh/This;[Ljava/lang/Object;I)""
			+""Lbsh/ClassGeneratorUtil$ConstructorArgs;""
		);
		// store ConstructorArgs in consArgsVar
		cv.visitVarInsn( ASTORE, consArgsVar );
		// Get the ConstructorArgs selector field from ConstructorArgs
		// push ConstructorArgs 
		cv.visitVarInsn( ALOAD, consArgsVar );
		cv.visitFieldInsn( 
			GETFIELD, ""bsh/ClassGeneratorUtil$ConstructorArgs"", ""selector"", ""I"" );
		// start switch
		cv.visitTableSwitchInsn( 
			0/*min*/, cases-1/*max*/, defaultLabel, labels );
		// generate switch body
		int index = 0;
		for( int i=0; i< superConstructors.length; i++, index++)
			doSwitchBranch( index, superClassName, 
				getTypeDescriptors( superConstructors[i].getParameterTypes() ), 
				endLabel, labels, consArgsVar, cv );
		for( int i=0; i< constructors.length; i++, index++)
			doSwitchBranch( index, fqClassName, 
				constructors[i].getParamTypeDescriptors(), 
				endLabel, labels, consArgsVar, cv );
		// generate the default branch of switch
		cv.visitLabel( defaultLabel );
		// default branch always invokes no args super
		cv.visitVarInsn( ALOAD, 0 ); // push 'this' 
		cv.visitMethodInsn( INVOKESPECIAL, superClassName, ""<init>"", ""()V"" );
		// done with switch
		cv.visitLabel( endLabel );
	}
	/*
		Generate a branch of the constructor switch.  This method is called by
		generateConstructorSwitch.
		The code generated by this method assumes that the argument array is 
		on the stack.
	*/
	static void doSwitchBranch( 
		int index, String targetClassName, String [] paramTypes,
		Label endLabel, Label [] labels, int consArgsVar, CodeVisitor cv
	)
	{
		cv.visitLabel( labels[index] );
		//cv.visitLineNumber( index, labels[index] );
		cv.visitVarInsn( ALOAD, 0 ); // push this before args
		// Unload the arguments from the ConstructorArgs object
		for (int i=0; i<paramTypes.length; i++)
		{
			String type = paramTypes[i];
			String method = null;
			if      ( type.equals(""Z"") )
				method = ""getBoolean"";
			else if ( type.equals(""B"") )
				method = ""getByte"";
			else if ( type.equals(""C"") )
				method = ""getChar"";
			else if ( type.equals(""S"") )
				method = ""getShort"";
			else if ( type.equals(""I"") )
				method = ""getInt"";
			else if ( type.equals(""J"") )
				method = ""getLong"";
			else if ( type.equals(""D"") )
				method = ""getDouble"";
			else if ( type.equals(""F"") )
				method = ""getFloat"";
			else 
				method = ""getObject"";
			// invoke the iterator method on the ConstructorArgs
			cv.visitVarInsn( ALOAD, consArgsVar ); // push the ConstructorArgs
			String className = ""bsh/ClassGeneratorUtil$ConstructorArgs"";
			String retType;
			if ( method.equals(""getObject"") )
				retType = OBJECT;
			else
				retType = type; 
			cv.visitMethodInsn(INVOKEVIRTUAL, className, method, ""()""+retType);
			// if it's an object type we must do a check cast
			if ( method.equals(""getObject"") )
				cv.visitTypeInsn( CHECKCAST, descriptorToClassName(type) ); 
		}
		// invoke the constructor for this branch
		String descriptor = getMethodDescriptor( ""V"", paramTypes );
		cv.visitMethodInsn( 
			INVOKESPECIAL, targetClassName, ""<init>"", descriptor );
		cv.visitJumpInsn( GOTO, endLabel );
	}
	static String getMethodDescriptor( String returnType, String [] paramTypes )
	{
		StringBuffer sb = new StringBuffer(""("");
		for(int i=0; i<paramTypes.length; i++)
			sb.append(paramTypes[i]);
		sb.append("")""+returnType);
		return sb.toString();
	}
	/**
		Generate a superclass method delegate accessor method.
		These methods are specially named methods which allow access to
		overridden methods of the superclass (which the Java reflection API
		normally does not allow).
	*/
	// Maybe combine this with generateMethod()
	static void generateSuperDelegateMethod( 
		Class superClass, String superClassName, String methodName, 
		String returnType, String [] paramTypes, int modifiers, ClassWriter cw) 
	{
		String [] exceptions = null;
		if ( returnType == null ) // map loose return to Object
			returnType = OBJECT;
		String methodDescriptor = getMethodDescriptor( returnType, paramTypes );
		// Add method body
		CodeVisitor cv = cw.visitMethod( 
			modifiers, ""_bshSuper""+methodName, methodDescriptor, exceptions );
		cv.visitVarInsn(ALOAD, 0);
		// Push vars
		int localVarIndex = 1;
		for (int i = 0; i < paramTypes.length; ++i) 
		{
			if ( isPrimitive( paramTypes[i]) )
				cv.visitVarInsn(ILOAD, localVarIndex);
			else
				cv.visitVarInsn(ALOAD, localVarIndex);
			localVarIndex += 
				( (paramTypes[i].equals(""D"") || paramTypes[i].equals(""J"")) 
					? 2 : 1 );
		}
		cv.visitMethodInsn( INVOKESPECIAL, 
			superClassName, methodName, methodDescriptor );
		generatePlainReturnCode( returnType, cv );
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs( 20, 20 );
	}
	boolean classContainsMethod(
		Class clas, String methodName, String [] paramTypes )
	{
		while( clas != null )
		{
			Method [] methods = clas.getDeclaredMethods();
			for( int i =0; i<methods.length; i++ )
			{
				if ( methods[i].getName().equals(methodName) )
				{
					String [] methodParamTypes = 
						getTypeDescriptors( methods[i].getParameterTypes() );
					boolean found = true;
					for( int j=0; j<methodParamTypes.length; j++)
					{
						if ( ! paramTypes[j].equals( methodParamTypes[j] ) ) {
							found = false;
							break;
						}
					}
					if ( found )
						return true;
				}
			}
			clas = clas.getSuperclass();
		}
		return false;
	}
	/**
		Generate return code for a normal bytecode
	*/
	static void generatePlainReturnCode( String returnType, CodeVisitor cv )
	{
		if ( returnType.equals(""V"") )
			cv.visitInsn( RETURN );
		else 
		if ( isPrimitive( returnType ) )
		{
			int opcode = IRETURN;
			if ( returnType.equals(""D"") )
				opcode = DRETURN;
			else if ( returnType.equals(""F"") )
				opcode = FRETURN;
			else if ( returnType.equals(""J"") )  //long
				opcode = LRETURN;
			cv.visitInsn(opcode);
		}
		else {
			cv.visitTypeInsn( CHECKCAST, descriptorToClassName(returnType) );
			cv.visitInsn( ARETURN );
		}
	}
	/**
		Generates the code to reify the arguments of the given method.
		For a method ""int m (int i, String s)"", this code is the bytecode
		corresponding to the ""new Object[] { new bsh.Primitive(i), s }"" 
		expression.
		@param cv the code visitor to be used to generate the bytecode.
		@param isStatic the enclosing methods is static
		@author Eric Bruneton
		@author Pat Niemeyer
	*/
	public static void generateParameterReifierCode (
		String [] paramTypes, boolean isStatic, final CodeVisitor cv )
	{
		cv.visitIntInsn(SIPUSH, paramTypes.length);
		cv.visitTypeInsn(ANEWARRAY, ""java/lang/Object"");
		int localVarIndex = isStatic ? 0 : 1;
		for (int i = 0; i < paramTypes.length; ++i) 
		{
			String param = paramTypes[i];
			cv.visitInsn(DUP);
			cv.visitIntInsn(SIPUSH, i);
			if ( isPrimitive( param ) ) 
			{
				int opcode = ILOAD;
				String type = ""bsh/Primitive"";
				cv.visitTypeInsn( NEW, type );
				cv.visitInsn(DUP);
				cv.visitVarInsn(opcode, localVarIndex);
				String desc = param; // ok?
				cv.visitMethodInsn(
					INVOKESPECIAL, type, ""<init>"", ""("" + desc + "")V"");
			} else {
				// Technically incorrect here - we need to wrap null values
				// as bsh.Primitive.NULL.  However the This.invokeMethod()
				// will do that much for us.
				// We need to generate a conditional here to test for null
				// and return Primitive.NULL
				cv.visitVarInsn( ALOAD, localVarIndex );
			}
			cv.visitInsn(AASTORE);
			localVarIndex += 
				( (param.equals(""D"") || param.equals(""J"")) ? 2 : 1 );
		}
  }
  /**
		Generates the code to unreify the result of the given method.  For a
		method ""int m (int i, String s)"", this code is the bytecode
		corresponding to the ""((Integer)...).intValue()"" expression.
		@param m a method object.
		@param cv the code visitor to be used to generate the bytecode.
		@author Eric Bruneton
		@author Pat Niemeyer
   */
	public static void generateReturnCode (
		String returnType, CodeVisitor cv ) 
	{
		if ( returnType.equals(""V"") ) 
		{
			cv.visitInsn(POP);
			cv.visitInsn(RETURN);
		} 
		else if ( isPrimitive( returnType ) ) 
		{
			int opcode = IRETURN;
			String type;
			String meth;
			if ( returnType.equals(""B"") ) {
				type = ""java/lang/Byte"";
				meth = ""byteValue"";
		 	} else if (returnType.equals(""I"") ) {
				type = ""java/lang/Integer"";
				meth = ""intValue"";
			} else if (returnType.equals(""Z"") ) {
				type = ""java/lang/Boolean"";
				meth = ""booleanValue"";
			} else if (returnType.equals(""D"") ) {
				opcode = DRETURN;
				type = ""java/lang/Double"";
				meth = ""doubleValue"";
		 	} else if (returnType.equals(""F"") ) {
				opcode = FRETURN;
				type = ""java/lang/Float"";
				meth = ""floatValue"";
			} else if (returnType.equals(""J"") ) {
				opcode = LRETURN;
				type = ""java/lang/Long"";
				meth = ""longValue"";
			} else if (returnType.equals(""C"") ) {
				type = ""java/lang/Character"";
				meth = ""charValue"";
			} else /*if (returnType.equals(""S"") )*/ {
				type = ""java/lang/Short"";
				meth = ""shortValue"";
			}
			String desc = returnType;
			cv.visitTypeInsn( CHECKCAST, type ); // type is correct here
			cv.visitMethodInsn( INVOKEVIRTUAL, type, meth, ""()"" + desc );
			cv.visitInsn(opcode);
		} else 
		{
			cv.visitTypeInsn( CHECKCAST, descriptorToClassName(returnType) );
			cv.visitInsn(ARETURN);
		}
  }
	/**
		Evaluate the arguments (if any) for the constructor specified by
		the constructor index.  Return the ConstructorArgs object which
		contains the actual arguments to the alternate constructor and also the
		index of that constructor for the constructor switch.
		@param args the arguments to the constructor.  These are necessary in
		the evaluation of the alt constructor args.  e.g. Foo(a) { super(a); }
		@return the ConstructorArgs object containing a constructor selector
			and evaluated arguments for the alternate constructor
	*/
	public static ConstructorArgs getConstructorArgs( 
		String superClassName, This classStaticThis, 
		Object [] consArgs, int index )
	{
		DelayedEvalBshMethod [] constructors;
		try {
			constructors = 
				(DelayedEvalBshMethod [])classStaticThis.getNameSpace()
				.getVariable( BSHCONSTRUCTORS );
		} catch ( Exception e ) {
			throw new InterpreterError(
				""unable to get instance initializer: ""+e );
		}
		if ( index == DEFAULTCONSTRUCTOR ) // auto-gen default constructor
			return ConstructorArgs.DEFAULT; // use default super constructor
		DelayedEvalBshMethod constructor = constructors[index];
		if ( constructor.methodBody.jjtGetNumChildren() == 0 )
			return ConstructorArgs.DEFAULT; // use default super constructor
		// Determine if the constructor calls this() or super()
		String altConstructor = null;
		BSHArguments argsNode = null;
		SimpleNode firstStatement = 
			(SimpleNode)constructor.methodBody.jjtGetChild(0);
		if ( firstStatement instanceof BSHPrimaryExpression )
			firstStatement = (SimpleNode)firstStatement.jjtGetChild(0);
		if ( firstStatement instanceof BSHMethodInvocation )
		{
			BSHMethodInvocation methodNode = 
				(BSHMethodInvocation)firstStatement;
			BSHAmbiguousName methodName = methodNode.getNameNode();
			if ( methodName.text.equals(""super"") 
				|| methodName.text.equals(""this"") 
			) {
				altConstructor = methodName.text;
				argsNode = methodNode.getArgsNode();
			}
		}
		if ( altConstructor == null )
			return ConstructorArgs.DEFAULT; // use default super constructor
		// Make a tmp namespace to hold the original constructor args for
		// use in eval of the parameters node
		NameSpace consArgsNameSpace = 
			new NameSpace( classStaticThis.getNameSpace(), ""consArgs"" );
		String [] consArgNames = constructor.getParameterNames();
		Class [] consArgTypes = constructor.getParameterTypes();
		for( int i=0; i<consArgs.length; i++ )
		{
			try {
				consArgsNameSpace.setTypedVariable( 
					consArgNames[i], consArgTypes[i], consArgs[i], 
					null/*modifiers*/);
			} catch ( UtilEvalError e ) {
				throw new InterpreterError(""err setting local cons arg:""+e);
			}
		}
		// evaluate the args
		CallStack callstack = new CallStack();
		callstack.push( consArgsNameSpace);
		Object [] args = null;
		Interpreter interpreter = classStaticThis.declaringInterpreter;
		try {
			args = argsNode.getArguments( callstack, interpreter );
		} catch ( EvalError e ) {
			throw new InterpreterError(
				""Error evaluating constructor args: ""+e );
		}
		Class [] argTypes  = Types.getTypes( args );
		args = Primitive.unwrap( args );
		Class superClass = 
			interpreter.getClassManager().classForName( superClassName );
		if ( superClass == null )
			throw new InterpreterError(
				""can't find superclass: ""+superClassName );
		Constructor [] superCons = superClass.getDeclaredConstructors();
		// find the matching super() constructor for the args
		if ( altConstructor.equals(""super"") )
		{
			int i = Reflect.findMostSpecificConstructorIndex( 
				argTypes , superCons );
			if ( i == -1 )
				throw new InterpreterError(""can't find constructor for args!"");
			return new ConstructorArgs( i, args );
		}
		// find the matching this() constructor for the args
		Class [][] candidates = new Class [ constructors.length ] [];
		for(int i=0; i< candidates.length; i++ )
			candidates[i] = constructors[i].getParameterTypes();
		int i = Reflect.findMostSpecificSignature( argTypes, candidates );
		if ( i == -1 )
			throw new InterpreterError(""can't find constructor for args 2!"");
		// this() constructors come after super constructors in the table
		int selector = i+superCons.length;
		int ourSelector = index+superCons.length;
		// Are we choosing ourselves recursively through a this() reference?
		if ( selector == ourSelector )
			throw new InterpreterError( ""Recusive constructor call."");
		return new ConstructorArgs( selector, args );
	}
	/**
		Initialize an instance of the class.
		This method is called from the generated class constructor to evaluate
		the instance initializer and scripted constructor in the instance
		namespace.
	*/
	public static void initInstance( 
		Object instance, String className, Object [] args )
	{
		Class [] sig = Types.getTypes( args );
		CallStack callstack = new CallStack();
		Interpreter interpreter;
		NameSpace instanceNameSpace;
		// check to see if the instance has already been initialized
		// (the case if using a this() alternate constuctor)
		This instanceThis = getClassInstanceThis( instance, className );
// XXX clean up this conditional
		if ( instanceThis == null )
		{
			// Create the instance 'This' namespace, set it on the object
			// instance and invoke the instance initializer
			// Get the static This reference from the proto-instance
			This classStaticThis = 
				getClassStaticThis( instance.getClass(), className );
			interpreter = classStaticThis.declaringInterpreter;
			// Get the instance initializer block from the static This 
			BSHBlock instanceInitBlock;
			try {
				instanceInitBlock = (BSHBlock)classStaticThis.getNameSpace()
					.getVariable( BSHINIT );
			} catch ( Exception e ) {
				throw new InterpreterError(
					""unable to get instance initializer: ""+e );
			}
			// Create the instance namespace
			instanceNameSpace = 
				new NameSpace( classStaticThis.getNameSpace(), className );
			instanceNameSpace.isClass = true;
			// Set the instance This reference on the instance
			instanceThis = instanceNameSpace.getThis( interpreter );
			try {
				LHS lhs = 
					Reflect.getLHSObjectField( instance, BSHTHIS+className );
				lhs.assign( instanceThis, false/*strict*/ );
			} catch ( Exception e ) {
				throw new InterpreterError(""Error in class gen setup: ""+e );
			}
			// Give the instance space its object import
			instanceNameSpace.setClassInstance( instance );
			// should use try/finally here to pop ns
			callstack.push( instanceNameSpace );
			// evaluate the instance portion of the block in it
			try { // Evaluate the initializer block
				instanceInitBlock.evalBlock( 
					callstack, interpreter, true/*override*/, 
					ClassGeneratorImpl.ClassNodeFilter.CLASSINSTANCE );
			} catch ( Exception e ) {
				throw new InterpreterError(""Error in class initialization: ""+e);
			}
			callstack.pop();
		} else
		{
			// The object instance has already been initialzed by another
			// constructor.  Fall through to invoke the constructor body below.
			interpreter = instanceThis.declaringInterpreter;
			instanceNameSpace = instanceThis.getNameSpace();
		}
		// invoke the constructor method from the instanceThis 
		String constructorName = getBaseName( className );
		try {
			// Find the constructor (now in the instance namespace)
			BshMethod constructor = instanceNameSpace.getMethod( 
				constructorName, sig, true/*declaredOnly*/ );
			// if args, we must have constructor
			if ( args.length > 0 && constructor == null )
				throw new InterpreterError(
					""Can't find constructor: ""+ className );
			// Evaluate the constructor
			if ( constructor != null )
				constructor.invoke( args, interpreter, callstack,
					null/*callerInfo*/, false/*overrideNameSpace*/ ) ;
		} catch ( Exception e ) {
			if ( e instanceof TargetError )
				e =(Exception)((TargetError)e).getTarget();
			if ( e instanceof InvocationTargetException )
				e = (Exception)((InvocationTargetException)e)
					.getTargetException();
			e.printStackTrace( System.err );
			throw new InterpreterError(""Error in class initialization: ""+e );
		} 
	}
	/**
		Get the static bsh namespace field from the class.
		@param className may be the name of clas itself or a superclass of clas.
	*/
	static This getClassStaticThis( Class clas, String className )
	{
		try {
			return (This)Reflect.getStaticField( 
				clas, BSHSTATIC + className );
		} catch ( Exception e ) {
			throw new InterpreterError(""Unable to get class static space: ""+e);
		}
	}
	/**
		Get the instance bsh namespace field from the object instance.
		@return the class instance This object or null if the object has not
		been initialized.
	*/
	static This getClassInstanceThis( Object instance, String className )
	{
		try {
			Object o = Reflect.getObjectField( instance, BSHTHIS+className );
			return (This)Primitive.unwrap(o); // unwrap Primitive.Null to null
		} catch ( Exception e ) {
			throw new InterpreterError(
				""Generated class: Error getting This""+e );
		}
	}
	/**
		Does the type descriptor string describe a primitive type?
	*/
	private static boolean isPrimitive( String typeDescriptor )
	{
		return typeDescriptor.length() == 1; // right?
	}
	static String[] getTypeDescriptors( Class [] cparams )
	{
		String [] sa = new String [cparams.length];
		for(int i=0; i<sa.length; i++)
			sa[i] = BSHType.getTypeDescriptor( cparams[i] );
		return sa;
	}
	/**
		If a non-array object type, remove the prefix ""L"" and suffix "";"".
	*/
	// Can this be factored out...?  
	// Should be be adding the L...; here instead?
	private static String descriptorToClassName( String s ) 
	{
		if ( s.startsWith(""["") || !s.startsWith(""L"") )
			return s;
		return s.substring( 1, s.length()-1 );
	}
	private static String getBaseName( String className ) 
	{
		int i = className.indexOf(""$"");
		if ( i == -1 )
			return className;
		return className.substring(i+1);
	}
	/**
		A ConstructorArgs object holds evaluated arguments for a constructor
		call as well as the index of a possible alternate selector to invoke.
		This object is used by the constructor switch.
		@see #generateConstructor( int , String [] , int , ClassWriter ) 
	*/
	public static class ConstructorArgs
	{
		/** A ConstructorArgs which calls the default constructor */
		public static ConstructorArgs DEFAULT = new ConstructorArgs();
		public int selector = DEFAULTCONSTRUCTOR;
		Object [] args;
		int arg = 0;
		/**
			The index of the constructor to call.
		*/
		ConstructorArgs() {  }
		ConstructorArgs( int selector, Object [] args ) { 
			this.selector = selector;
			this.args = args; 
		}
		Object next() { return args[arg++]; }
		public boolean getBoolean() { return ((Boolean)next()).booleanValue(); }
		public byte getByte() { return ((Byte)next()).byteValue(); }
		public char getChar() { return ((Character)next()).charValue(); }
		public short getShort() { return ((Short)next()).shortValue(); }
		public int getInt() { return ((Integer)next()).intValue(); }
		public long getLong() { return ((Long)next()).longValue(); }
		public double getDouble() { return ((Double)next()).doubleValue(); }
		public float getFloat() { return ((Float)next()).floatValue(); }
		public Object getObject() { return next(); }
	}
}
"
bsh.ClassIdentifier,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
public class ClassIdentifier 
{
	Class clas;
	public ClassIdentifier( Class clas ) {
		this.clas = clas;
	}
	// Can't call it getClass()
	public Class getTargetClass() {
		return clas;
	}
	public String toString() {
		return ""Class Identifier: ""+clas.getName();
	}
}
"
bsh.ClassPathException,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
public class ClassPathException extends UtilEvalError {
	public ClassPathException( String msg ) { super(msg); }
}
"
bsh.CollectionManager,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Enumeration;
import java.util.Vector;
import java.util.Hashtable;
import java.lang.reflect.Array;
/**
	The default CollectionManager (which remains Java 1.1 compatible) 
	supports iteration over objects of type:
	Enumeration, Vector, String, StringBuffer and array.
	The dynamically loaded CollectionManagerImpl supports additional types when
	it is present.
	@see BshIterable.java
*/
public class CollectionManager
{
	private static CollectionManager manager;
	public synchronized static CollectionManager getCollectionManager()
	{
		if ( manager == null 
			&& Capabilities.classExists(""java.util.Collection"") ) 
		{
			Class clas;
			try {
				clas = Class.forName( ""bsh.collection.CollectionManagerImpl"" );
				manager = (CollectionManager)clas.newInstance();
			} catch ( Exception e ) {
				Interpreter.debug(""unable to load CollectionManagerImpl: ""+e);
			}
		}
		if ( manager == null ) 
			manager = new CollectionManager(); // default impl
		return manager;
	}
	/**
	*/
	public boolean isBshIterable( Object obj ) 
	{
		// This could be smarter...
		try { 
			getBshIterator( obj ); 
			return true;
		} catch( IllegalArgumentException e ) { 
			return false;
		}
	}
	public BshIterator getBshIterator( Object obj ) 
		throws IllegalArgumentException
	{
		return new BasicBshIterator( obj ); 
	}
	public boolean isMap( Object obj ) {
		return obj instanceof Hashtable;
	}
	public Object getFromMap( Object map, Object key ) {
		return ((Hashtable)map).get(key);
	}
	public Object putInMap( Object map, Object key, Object value ) 
	{
		return ((Hashtable)map).put(key, value);
	}
	/**
		Determine dynamically if the target is an iterator by the presence of a
		pair of next() and hasNext() methods.
	public static boolean isIterator() { }
	*/
	/**
	 * An implementation that works with JDK 1.1
	 */
	public static class BasicBshIterator implements BshIterator 
	{
		Enumeration enumeration;
		/**
		 * Construct a basic BasicBshIterator
		 *
		 * @param The object over which we are iterating
		 *
		 * @throws java.lang.IllegalArgumentException If the argument is not a
		 * supported (i.e. iterable) type.
		 *
		 * @throws java.lang.NullPointerException If the argument is null
		 */
		public BasicBshIterator(Object iterateOverMe) {
			enumeration = createEnumeration(iterateOverMe);
		}
		/**
		 * Create an enumeration over the given object
		 *
		 * @param iterateOverMe Object of type Enumeration, Vector, String, 
		 *                      StringBuffer or an array
		 *
		 * @return an enumeration
		 *
		 * @throws java.lang.IllegalArgumentException If the argument is not a
		 * supported (i.e. iterable) type.
		 *
		 * @throws java.lang.NullPointerException If the argument is null
		 */
		protected Enumeration createEnumeration( Object iterateOverMe )
		{
			if(iterateOverMe==null)
				throw new NullPointerException(""Object arguments passed to "" +
					""the BasicBshIterator constructor cannot be null."");
			if (iterateOverMe instanceof Enumeration)
				return (Enumeration)iterateOverMe;
			if (iterateOverMe instanceof Vector)
				return ((Vector)iterateOverMe).elements();
			if (iterateOverMe.getClass().isArray()) {
				final Object array = iterateOverMe;
				return new Enumeration() {
					int index = 0, length = Array.getLength(array);
					public Object nextElement() { 
						return Array.get(array, index++);
					}
					public boolean hasMoreElements() { return index<length; }
				};
			} 
			if (iterateOverMe instanceof String)
				return createEnumeration(((String)iterateOverMe).toCharArray());
			if (iterateOverMe instanceof StringBuffer)
				return createEnumeration(
					iterateOverMe.toString().toCharArray());
			throw new IllegalArgumentException(
				""Cannot enumerate object of type ""+iterateOverMe.getClass());
		}
		/**
		 * Fetch the next object in the iteration
		 *
		 * @return The next object
		 */
		public Object next() {
			return 	enumeration.nextElement();
		}
		/**
		 * Returns true if and only if there are more objects available
		 * via the <code>next()</code> method
		 *
		 * @return The next object
		 */
		public boolean hasNext() {
			return enumeration.hasMoreElements();
		}
	}
}
"
bsh.CommandLineReader,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.*;
/**
	This is a quick hack to turn empty lines entered interactively on the 
	command line into ';\n' empty lines for the interpreter.  It's just more 
	pleasant to be able to hit return on an empty line and see the prompt 
	reappear.
	This is *not* used when text is sourced from a file non-interactively.
*/
class CommandLineReader extends FilterReader {
    public CommandLineReader( Reader in ) {
		super(in);
    }
	static final int 
		normal = 0,
		lastCharNL = 1,
		sentSemi = 2;
	int state = lastCharNL;
    public int read() throws IOException {
		int b;
		if ( state == sentSemi ) {
			state = lastCharNL;
			return '\n';
		}
		// skip CR
        while ( (b = in.read()) == '\r' );
		if ( b == '\n' )
			if ( state == lastCharNL ) {
				b = ';';
				state = sentSemi;
			} else
				state = lastCharNL;
		else
			state = normal;
		return b;
    }
	/**
		This is a degenerate implementation.
		I don't know how to keep this from blocking if we try to read more
		than one char...  There is no available() for Readers ??
	*/
    public int read(char buff[], int off, int len) throws IOException 
	{
		int b = read();
		if ( b == -1 )
			return -1;  // EOF, not zero read apparently
		else {
			buff[off]=(char)b;
			return 1;
		}
    }
	// Test it
	public static void main( String [] args ) throws Exception {
		Reader in = new CommandLineReader( new InputStreamReader(System.in) );
		while ( true )
			System.out.println( in.read() );
	}
}
"
bsh.ConsoleInterface,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.*;
/**
	The capabilities of a minimal console for BeanShell.
	Stream I/O and optimized print for output.
	A simple console may ignore some of these or map them to trivial
	implementations.  e.g. print() with color can be mapped to plain text.
	@see bsh.util.GUIConsoleInterface
*/
public interface ConsoleInterface {
	public Reader getIn();
	public PrintStream getOut();
	public PrintStream getErr();
	public void println( Object o );
	public void print( Object o );
	public void error( Object o );
}
"
bsh.DelayedEvalBshMethod,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
public class DelayedEvalBshMethod extends BshMethod
{
	String returnTypeDescriptor;
	BSHReturnType returnTypeNode;
	String [] paramTypeDescriptors;
	BSHFormalParameters paramTypesNode;
	// used for the delayed evaluation...
	transient CallStack callstack;
	transient Interpreter interpreter;
	/**
		This constructor is used in class generation.  It supplies String type
		descriptors for return and parameter class types and allows delay of 
		the evaluation of those types until they are requested.  It does this
		by holding BSHType nodes, as well as an evaluation callstack, and
		interpreter which are called when the class types are requested. 
	*/
	/*
		Note: technically I think we could get by passing in only the
		current namespace or perhaps BshClassManager here instead of 
		CallStack and Interpreter.  However let's just play it safe in case
		of future changes - anywhere you eval a node you need these.
	*/
	DelayedEvalBshMethod( 
		String name, 
		String returnTypeDescriptor, BSHReturnType returnTypeNode,
		String [] paramNames,
		String [] paramTypeDescriptors, BSHFormalParameters paramTypesNode,
		BSHBlock methodBody, 
		NameSpace declaringNameSpace, Modifiers modifiers,
		CallStack callstack, Interpreter interpreter
	) {
		super( name, null/*returnType*/, paramNames, null/*paramTypes*/,
			methodBody, declaringNameSpace, modifiers );
		this.returnTypeDescriptor = returnTypeDescriptor;
		this.returnTypeNode = returnTypeNode;
		this.paramTypeDescriptors = paramTypeDescriptors;
		this.paramTypesNode = paramTypesNode;
		this.callstack = callstack;
		this.interpreter = interpreter;
	}
	public String getReturnTypeDescriptor() { return returnTypeDescriptor; }
	public Class getReturnType() 
	{ 
		if ( returnTypeNode == null )
			return null;
		// BSHType will cache the type for us
		try {
			return returnTypeNode.evalReturnType( callstack, interpreter );
		} catch ( EvalError e ) {
			throw new InterpreterError(""can't eval return type: ""+e);
		}
	}
	public String [] getParamTypeDescriptors() { return paramTypeDescriptors; }
	public Class [] getParameterTypes() 
	{ 
		// BSHFormalParameters will cache the type for us
		try {
			return (Class [])paramTypesNode.eval( callstack, interpreter );
		} catch ( EvalError e ) {
			throw new InterpreterError(""can't eval param types: ""+e);
		}
	}
}
"
bsh.EvalError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	EvalError indicates that we cannot continue evaluating the script
	or the script has thrown an exception.
	EvalError may be thrown for a script syntax error, an evaluation 
	error such as referring to an undefined variable, an internal error.
	<p>
	@see TargetError
*/
public class EvalError extends Exception 
{
	SimpleNode node;
	// Note: no way to mutate the Throwable message, must maintain our own
	String message;
	CallStack callstack;
	public EvalError( String s, SimpleNode node, CallStack callstack ) {
		setMessage(s);
		this.node = node;
		// freeze the callstack for the stack trace.
		if ( callstack != null )
			this.callstack = callstack.copy();
	}
	/**
		Print the error with line number and stack trace.
	*/
	public String toString() 
	{
		String trace;
		if ( node != null )
			trace = "" : at Line: ""+ node.getLineNumber() 
				+ "" : in file: ""+ node.getSourceFile()
				+ "" : ""+node.getText();
		else
			// Users should not normally see this.
			trace = "": <at unknown location>"";
		if ( callstack != null )
			trace = trace +""\n"" + getScriptStackTrace();
		return getMessage() + trace;
	}
	/**
		Re-throw the error, prepending the specified message.
	*/
	public void reThrow( String msg ) 
		throws EvalError 
	{
		prependMessage( msg );
		throw this;
	}
	/**
		The error has trace info associated with it. 
		i.e. It has an AST node that can print its location and source text.
	*/
	SimpleNode getNode() {
		return node;
	}
	void setNode( SimpleNode node ) {
		this.node = node;
	}
	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return ""<unknown error>"";
	}
	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}
	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return ""<unknown file>"";
	}
	public String getScriptStackTrace() 
	{
		if ( callstack == null )
			return ""<Unknown>"";
		String trace = """";
		CallStack stack = callstack.copy();
		while ( stack.depth() > 0 ) 
		{
			NameSpace ns = stack.pop();
			SimpleNode node = ns.getNode();
			if ( ns.isMethod )
			{
				trace = trace + ""\nCalled from method: "" + ns.getName();
				if ( node != null )
					trace += "" : at Line: ""+ node.getLineNumber() 
						+ "" : in file: ""+ node.getSourceFile()
						+ "" : ""+node.getText();
			}
		}
		return trace;
	}
	/**
		@see #toString() for a full display of the information
	*/
	public String getMessage() { return message; }
	public void setMessage( String s ) { message = s; }
	/**
		Prepend the message if it is non-null.
	*/
	protected void prependMessage( String s ) 
	{ 
		if ( s == null )
			return;
		if ( message == null )
			message = s;
		else
			message = s + "" : ""+ message;
	}
}
"
bsh.Interpreter,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
import java.io.*;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
/**
	The BeanShell script interpreter.
	An instance of Interpreter can be used to source scripts and evaluate 
	statements or expressions.  
	<p>
	Here are some examples:
	<p><blockquote><pre>
		Interpeter bsh = new Interpreter();
		// Evaluate statements and expressions
		bsh.eval(""foo=Math.sin(0.5)"");
		bsh.eval(""bar=foo*5; bar=Math.cos(bar);"");
		bsh.eval(""for(i=0; i<10; i++) { print(\""hello\""); }"");
		// same as above using java syntax and apis only
		bsh.eval(""for(int i=0; i<10; i++) { System.out.println(\""hello\""); }"");
		// Source from files or streams
		bsh.source(""myscript.bsh"");  // or bsh.eval(""source(\""myscript.bsh\"")"");
		// Use set() and get() to pass objects in and out of variables
		bsh.set( ""date"", new Date() );
		Date date = (Date)bsh.get( ""date"" );
		// This would also work:
		Date date = (Date)bsh.eval( ""date"" );
		bsh.eval(""year = date.getYear()"");
		Integer year = (Integer)bsh.get(""year"");  // primitives use wrappers
		// With Java1.3+ scripts can implement arbitrary interfaces...
		// Script an awt event handler (or source it from a file, more likely)
		bsh.eval( ""actionPerformed( e ) { print( e ); }"");
		// Get a reference to the script object (implementing the interface)
		ActionListener scriptedHandler = 
			(ActionListener)bsh.eval(""return (ActionListener)this"");
		// Use the scripted event handler normally...
		new JButton.addActionListener( script );
	</pre></blockquote>
	<p>
	In the above examples we showed a single interpreter instance, however 
	you may wish to use many instances, depending on the application and how
	you structure your scripts.  Interpreter instances are very light weight
	to create, however if you are going to execute the same script repeatedly
	and require maximum performance you should consider scripting the code as 
	a method and invoking the scripted method each time on the same interpreter
	instance (using eval()). 
	<p>
	See the BeanShell User's Manual for more information.
*/
public class Interpreter 
	implements Runnable, ConsoleInterface,Serializable
{
	/* --- Begin static members --- */
	public static final String VERSION = ""2.0b1.1-jedit-1"";
	/*
		Debug utils are static so that they are reachable by code that doesn't
		necessarily have an interpreter reference (e.g. tracing in utils).
		In the future we may want to allow debug/trace to be turned on on
		a per interpreter basis, in which case we'll need to use the parent 
		reference in some way to determine the scope of the command that 
		turns it on or off.
	*/
    public static boolean DEBUG, TRACE, LOCALSCOPING;
	// This should be per instance
    transient static PrintStream debug;
	static String systemLineSeparator = ""\n""; // default
	static { 
		staticInit();
	}
	/** Shared system object visible under bsh.system */
	static This sharedObject;
	/** 
		Strict Java mode 
		@see setStrictJava( boolean )
	*/
	private boolean strictJava = false;
	/* --- End static members --- */
	/* --- Instance data --- */
	transient Parser parser;
    NameSpace globalNameSpace;
    transient Reader in;
    transient PrintStream out;
    transient PrintStream err;
    ConsoleInterface console; 
	/** If this interpeter is a child of another, the parent */
	Interpreter parent;
	/** The name of the file or other source that this interpreter is reading */
	String sourceFileInfo;
	/** by default in interactive mode System.exit() on EOF */
	private boolean exitOnEOF = true;
    protected boolean 
		evalOnly, 		// Interpreter has no input stream, use eval() only
		interactive;	// Interpreter has a user, print prompts, etc.
	/* --- End instance data --- */
	/**
		The main constructor.
		All constructors should now pass through here.
		@param namespace If namespace is non-null then this interpreter's 
		root namespace will be set to the one provided.  If it is null a new 
		one will be created for it.
		@param parent The parent interpreter if this interpreter is a child 
			of another.  May be null.  Children share a BshClassManager with
			their parent instance.
		@param sourceFileInfo An informative string holding the filename 
		or other description of the source from which this interpreter is
		reading... used for debugging.  May be null.
	*/
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
    {
		parser = new Parser( in );
		long t1=System.currentTimeMillis();
        this.in = in;
        this.out = out;
        this.err = err;
        this.interactive = interactive;
		debug = err;
		this.parent = parent;
		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;
		BshClassManager bcm = BshClassManager.createClassManager( this );
		if ( namespace == null )
        	this.globalNameSpace = new NameSpace( bcm, ""global"");
		else
			this.globalNameSpace = namespace;
		// now done in NameSpace automatically when root
		// The classes which are imported by default
		//globalNameSpace.loadDefaultImports();
		/* 
			Create the root ""bsh"" system object if it doesn't exist.
		*/
		if ( ! ( getu(""bsh"") instanceof bsh.This ) )
			initRootSystemObject();
		if ( interactive )
			loadRCFiles();
		long t2=System.currentTimeMillis();
		if ( Interpreter.DEBUG ) 
			Interpreter.debug(""Time to initialize interpreter: ""+(t2-t1));
    }
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
    {
		this( in, out, err, interactive, namespace, null, null );
	}
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
    {
        this(in, out, err, interactive, null);
    }
	/**
		Construct a new interactive interpreter attached to the specified 
		console using the specified parent namespace.
	*/
    public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {
        this( console.getIn(), console.getOut(), console.getErr(), 
			true, globalNameSpace );
		setConsole( console );
    }
	/**
		Construct a new interactive interpreter attached to the specified 
		console.
	*/
    public Interpreter(ConsoleInterface console) {
        this(console, null);
    }
	/**
		Create an interpreter for evaluation only.
	*/
    public Interpreter()
    {
		this( new StringReader(""""), 
			System.out, System.err, false, null );
        evalOnly = true;
		setu( ""bsh.evalOnly"", new Primitive(true) );
    }
	// End constructors
	/**
		Attach a console
		Note: this method is incomplete.
	*/
	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( ""bsh.console"", console );
		// redundant with constructor
		setOut( console.getOut() );
		setErr( console.getErr() );
		// need to set the input stream - reinit the parser?
	}
	private void initRootSystemObject() 
	{
		BshClassManager bcm = getClassManager();
		// bsh
		setu(""bsh"", new NameSpace( bcm, ""Bsh Object"" ).getThis( this ) );
		// init the static shared sharedObject if it's not there yet
		if ( sharedObject == null )
			sharedObject = new NameSpace( 
				bcm, ""Bsh Shared System Object"" ).getThis( this );
		// bsh.system
		setu( ""bsh.system"", sharedObject );
		setu( ""bsh.shared"", sharedObject ); // alias
		// bsh.help
		This helpText = new NameSpace( 
			bcm, ""Bsh Command Help Text"" ).getThis( this );
		setu( ""bsh.help"", helpText );
		// bsh.cwd
		try {
			setu( ""bsh.cwd"", System.getProperty(""user.dir"") );
		} catch ( SecurityException e ) { 
			// applets can't see sys props
			setu( ""bsh.cwd"", ""."" );
		}
		// bsh.interactive
		setu( ""bsh.interactive"", new Primitive(interactive) );
		// bsh.evalOnly
		setu( ""bsh.evalOnly"", new Primitive(evalOnly) );
	}
	/**
		Set the global namespace for this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other 
		than the debug status is stored in the interpreter.
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}
	/**
		Get the global namespace of this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other than 
		the debug status is stored in the interpreter.  
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public NameSpace getNameSpace() {
		return globalNameSpace;
	}
	/**
		Run the text only interpreter on the command line or specify a file.
	*/
    public static void main( String [] args ) 
	{
        if ( args.length > 0 ) {
			String filename = args[0];
			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];
            Interpreter interpreter = new Interpreter();
			interpreter.setu( ""bsh.args"", bshArgs );
			try {
				Object result = 
					interpreter.source( filename, interpreter.globalNameSpace );
				if ( result instanceof Class )
					try {
						invokeMain( (Class)result, bshArgs );
					} catch ( Exception e ) 
					{
						Object o = e;
						if ( e instanceof InvocationTargetException )
							o = ((InvocationTargetException)e)
								.getTargetException();
						System.err.println(
							""Class: ""+result+"" main method threw exception:""+o);
					}
			} catch ( FileNotFoundException e ) {
				System.out.println(""File not found: ""+e);
			} catch ( TargetError e ) {
				System.out.println(""Script threw exception: ""+e);
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, System.err );
			} catch ( EvalError e ) {
				System.out.println(""Evaluation Error: ""+e);
			} catch ( IOException e ) {
				System.out.println(""I/O Error: ""+e);
			}
        } else 
		{
			// Workaround for JDK bug 4071281, where system.in.available() 
			// returns too large a value. This bug has been fixed in JDK 1.2.
			InputStream src;
			if ( System.getProperty(""os.name"").startsWith(""Windows"") 
				&& System.getProperty(""java.version"").startsWith(""1.1.""))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;
            Reader in = new CommandLineReader( new InputStreamReader(src));
            Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
        	interpreter.run();
        }
    }
	public static void invokeMain( Class clas, String [] args ) 
		throws Exception
	{
    	Method main = Reflect.resolveJavaMethod(
			null/*BshClassManager*/, clas, ""main"", 
			new Class [] { String [].class }, true/*onlyStatic*/ );
		if ( main != null )
			main.invoke( null, new Object [] { args } );
	}
	/**
		Run interactively.  (printing prompts, etc.)
	*/
    public void run() 
	{
        if(evalOnly)
            throw new RuntimeException(""bsh Interpreter: No stream"");
        /*
          We'll print our banner using eval(String) in order to
          exercise the parser and get the basic expression classes loaded...
          This ameliorates the delay after typing the first statement.
        */
        if ( interactive )
			try { 
				eval(""printBanner();""); 
			} catch ( EvalError e ) {
				println(
					""BeanShell ""+VERSION+"" - by Pat Niemeyer (pat@pat.net)"");
			}
		// init the callstack.  
		CallStack callstack = new CallStack( globalNameSpace );
        boolean eof = false;
        while( !eof )
        {
            try
            {
                // try to sync up the console
                System.out.flush();
                System.err.flush();
                Thread.yield();  // this helps a little
                if ( interactive )
                    print( getBshPrompt() );
                eof = Line();
                if( get_jjtree().nodeArity() > 0 )  // number of child nodes 
                {
                    SimpleNode node = (SimpleNode)(get_jjtree().rootNode());
                    if(DEBUG)
                        node.dump("">"");
                    Object ret = node.eval( callstack, this );
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							""Callstack growing: ""+callstack);
                    if(ret instanceof ReturnControl)
                        ret = ((ReturnControl)ret).value;
                    if(ret != Primitive.VOID)
                    {
                        setu(""$_"", ret);
                        Object show = getu(""bsh.show"");
                        if(show instanceof Boolean &&
                            ((Boolean)show).booleanValue() == true)
                            println(""<"" + ret + "">"");
                    }
                }
            }
            catch(ParseException e)
            {
                error(""Parser Error: "" + e.getMessage(DEBUG));
				if ( DEBUG )
                	e.printStackTrace();
                if(!interactive)
                    eof = true;
                parser.reInitInput(in);
            }
            catch(InterpreterError e)
            {
                error(""Internal Error: "" + e.getMessage());
                e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TargetError e)
            {
                error(""// Uncaught Exception: "" + e );
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, err );
                if(!interactive)
                    eof = true;
				setu(""$_e"", e.getTarget());
            }
            catch (EvalError e)
            {
				if ( interactive )
					error( ""EvalError: ""+e.toString() );
				else
					error( ""EvalError: ""+e.getMessage() );
                if(DEBUG)
                    e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(Exception e)
            {
                error(""Unknown error: "" + e);
				if ( DEBUG )
                	e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TokenMgrError e)
            {
				error(""Error parsing input: "" + e);
				/*
					We get stuck in infinite loops here when unicode escapes
					fail.  Must re-init the char stream reader 
					(ASCII_UCodeESC_CharStream.java)
				*/
				parser.reInitTokenInput( in );
                if(!interactive)
                    eof = true;
            }
            finally
            {
                get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
            }
        }
		if ( interactive && exitOnEOF )
			System.exit(0);
    }
	// begin source and eval
	/**
		Read text from fileName and eval it.
	*/
    public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		File file = pathToFile( filename );
		if ( Interpreter.DEBUG ) debug(""Sourcing file: ""+file);
		Reader sourceIn = new BufferedReader( new FileReader(file) );
		try {
			return eval( sourceIn, nameSpace, filename );
		} finally {
			sourceIn.close();
		}
	}
	/**
		Read text from fileName and eval it.
		Convenience method.  Use the global namespace.
	*/
    public Object source( String filename ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		return source( filename, globalNameSpace );
	}
    /**
        Spawn a non-interactive local interpreter to evaluate text in the 
		specified namespace.  
		Return value is the evaluated object (or corresponding primitive 
		wrapper).
		@param sourceFileInfo is for information purposes only.  It is used to
		display error messages (and in the future may be made available to
		the script).
		@throws EvalError on script problems
		@throws TargetError on unhandled exceptions from the script
    */
	/*
		Note: we need a form of eval that passes the callstack through...
	*/
	/*
	Can't this be combined with run() ?
	run seems to have stuff in it for interactive vs. non-interactive...
	compare them side by side and see what they do differently, aside from the
	exception handling.
	*/
    public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFileInfo
			/*, CallStack callstack */ ) 
		throws EvalError 
	{
		Object retVal = null;
		if ( Interpreter.DEBUG ) debug(""eval: nameSpace = ""+nameSpace);
		/* 
			Create non-interactive local interpreter for this namespace
			with source from the input stream and out/err same as 
			this interpreter.
		*/
        Interpreter localInterpreter = 
			new Interpreter( 
				in, out, err, false, nameSpace, this, sourceFileInfo  );
		CallStack callstack = new CallStack( nameSpace );
        boolean eof = false;
        while(!eof)
        {
			SimpleNode node = null;
            try
            {
                eof = localInterpreter.Line();
                if (localInterpreter.get_jjtree().nodeArity() > 0)
                {
                    node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
					// nodes remember from where they were sourced
					node.setSourceFile( sourceFileInfo );
					if ( TRACE )
						println( ""// "" +node.getText() );
                    retVal = node.eval( callstack, localInterpreter );
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							""Callstack growing: ""+callstack);
                    if ( retVal instanceof ReturnControl ) {
                        retVal = ((ReturnControl)retVal).value;
						break; // non-interactive, return control now
					}
                }
            } catch(ParseException e) {
				/*
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" parser Error: "" 
					+ e.getMessage( DEBUG ), node, callstack );
				*/
				if ( DEBUG )
					// show extra ""expecting..."" info
					error( e.getMessage(DEBUG) );
				// add the source file info and throw again
				e.setErrorSourceFile( sourceFileInfo );
				throw e;
            } catch ( InterpreterError e ) {
                e.printStackTrace();
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" internal Error: "" 
					+ e.getMessage(), node, callstack);
            } catch ( TargetError e ) {
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow(""Sourced file: ""+sourceFileInfo);
            } catch ( EvalError e) {
                if ( DEBUG)
                    e.printStackTrace();
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( ""Sourced file: ""+sourceFileInfo );
            } catch ( Exception e) {
                if ( DEBUG)
                	e.printStackTrace();
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" unknown error: "" 
					+ e.getMessage(), node, callstack);
            } catch(TokenMgrError e) {
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" Token Parsing Error: "" 
					+ e.getMessage(), node, callstack );
            } finally {
                localInterpreter.get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
            }
        }
		return Primitive.unwrap( retVal );
    }
	/**
		Evaluate the inputstream in this interpreter's global namespace.
	*/
    public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, ""eval stream"" );
	}
	/**
		Evaluate the string in this interpreter's global namespace.
	*/
    public Object eval( String statements ) throws EvalError {
		if ( Interpreter.DEBUG ) debug(""eval(String): ""+statements);
		return eval(statements, globalNameSpace);
	}
	/**
		Evaluate the string in the specified namespace.
	*/
    public Object eval( String statements, NameSpace nameSpace ) 
		throws EvalError 
	{
		String s = ( statements.endsWith("";"") ? statements : statements+"";"" );
        return eval( 
			new StringReader(s), nameSpace, 
			""inline evaluation of: ``""+ showEvalString(s)+""''"" );
    }
	private String showEvalString( String s ) {
		s = s.replace('\n', ' ');
		s = s.replace('\r', ' ');
		if ( s.length() > 80 )
			s = s.substring( 0, 80 ) + "" . . . "";
		return s;
	}
	// end source and eval
	/**
		Print an error message in a standard format on the output stream
		associated with this interpreter. On the GUI console this will appear 
		in red, etc.
	*/
    public final void error( Object o ) {
		if ( console != null )
				console.error( ""// Error: "" + o +""\n"" );
		else {
			err.println(""// Error: "" + o );
			err.flush();
		}
    }
	// ConsoleInterface
	// The interpreter reflexively implements the console interface that it 
	// uses.  Should clean this up by using an inner class to implement the
	// console for us.
	/** 
		Get the input stream associated with this interpreter.
		This may be be stdin or the GUI console.
	*/
	public Reader getIn() { return in; }
	/** 
		Get the outptut stream associated with this interpreter.
		This may be be stdout or the GUI console.
	*/
	public PrintStream getOut() { return out; }
	/** 
		Get the error output stream associated with this interpreter.
		This may be be stderr or the GUI console.
	*/
	public PrintStream getErr() { return err; }
    public final void println( Object o )
    {
        print( String.valueOf(o) + systemLineSeparator );
    }
    public final void print( Object o )
    {
		if (console != null) {
            console.print(o);
        } else {
            out.print(o);
            out.flush();
        }
    }
	// End ConsoleInterface
	/**
		Print a debug message on debug stream associated with this interpreter
		only if debugging is turned on.
	*/
    public final static void debug(String s)
    {
        if ( DEBUG )
            debug.println(""// Debug: "" + s);
    }
	/* 
		Primary interpreter set and get variable methods
		Note: These are squeltching errors... should they?
	*/
	/**
		Get the value of the name.
		name may be any value. e.g. a variable or field
	*/
    public Object get( String name ) throws EvalError {
		try {
			Object ret = globalNameSpace.get( name, this );
			return Primitive.unwrap( ret );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() ); 
		}
	}
	/**
		Unchecked get for internal use
	*/
    Object getu( String name ) {
		try { 
			return get( name );
		} catch ( EvalError e ) { 
			throw new InterpreterError(""set: ""+e);
		}
	}
	/**
		Assign the value to the name.	
		name may evaluate to anything assignable. e.g. a variable or field.
	*/
    public void set( String name, Object value )
		throws EvalError 
	{
		// map null to Primtive.NULL coming in...
		if ( value == null )
			value = Primitive.NULL;
		CallStack callstack = new CallStack();
		try {
			if ( Name.isCompound( name ) ) 
			{
				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
					callstack, this );
				lhs.assign( value, false );
			} else // optimization for common case
				globalNameSpace.setVariable( name, value, false );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
		}
	}
	/**
		Unchecked set for internal use
	*/
    void setu(String name, Object value) {
		try { 
			set(name, value);
		} catch ( EvalError e ) { 
			throw new InterpreterError(""set: ""+e);
		}
	}
    public void set(String name, long value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, int value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, double value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, float value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, boolean value) throws EvalError {
        set(name, new Primitive(value));
	}
	/**
		Unassign the variable name.	
		Name should evaluate to a variable.
	*/
    public void unset( String name ) 
		throws EvalError 
	{
		/*
			We jump through some hoops here to handle arbitrary cases like
			unset(""bsh.foo"");
		*/
		CallStack callstack = new CallStack();
		try {
			LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
				callstack, this );
			if ( lhs.type != LHS.VARIABLE )
				throw new EvalError(""Can't unset, not a variable: ""+name, 
					SimpleNode.JAVACODE, new CallStack() );
			//lhs.assign( null, false );
			lhs.nameSpace.unsetVariable( name );
		} catch ( UtilEvalError e ) {
			throw new EvalError( e.getMessage(), 
				SimpleNode.JAVACODE, new CallStack() );
		}
	}
	// end primary set and get methods
	/**
		Get a reference to the interpreter (global namespace), cast 
		to the specified interface type.  Assuming the appropriate 
		methods of the interface are defined in the interpreter, then you may 
		use this interface from Java, just like any other Java object.
		<p>
		For example:
		<pre>
			Interpreter interpreter = new Interpreter();
			// define a method called run()
			interpreter.eval(""run() { ... }"");
			// Fetch a reference to the interpreter as a Runnable
			Runnable runnable = 
				(Runnable)interpreter.getInterface( Runnable.class );
		</pre>
		<p>
		Note that the interpreter does *not* require that any or all of the
		methods of the interface be defined at the time the interface is
		generated.  However if you attempt to invoke one that is not defined
		you will get a runtime exception.
		<p>
		Note also that this convenience method has exactly the same effect as 
		evaluating the script:
		<pre>
			(Type)this;
		</pre>
		<p>
		For example, the following is identical to the previous example:
		<p>
		<pre>
			// Fetch a reference to the interpreter as a Runnable
			Runnable runnable = 
				(Runnable)interpreter.eval( ""(Runnable)this"" );
		</pre>
		<p>
		<em>Version requirement</em> Although standard Java interface types 
		are always available, to be used with arbitrary interfaces this 
		feature requires that you are using Java 1.3 or greater.
		<p>
		@throws EvalError if the interface cannot be generated because the
		version of Java does not support the proxy mechanism. 
	*/
	public Object getInterface( Class interf ) throws EvalError
	{
		try {
			return globalNameSpace.getThis( this ).getInterface( interf );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() );
		}
	}
	/*	Methods for interacting with Parser */
	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}
  	private JavaCharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}
  	private boolean Line() throws ParseException {
		return parser.Line();
	}
	/*	End methods for interacting with Parser */
	void loadRCFiles() {
		try {
			String rcfile = 
				// Default is c:\windows under win98, $HOME under Unix
				System.getProperty(""user.home"") + File.separator + "".bshrc"";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 
			// squeltch security exception, filenotfoundexception
			if ( Interpreter.DEBUG ) debug(""Could not find rc file: ""+e);
		}
	}
	/**
		Localize a path to the file name based on the bsh.cwd interpreter 
		working directory.
	*/
    public File pathToFile( String fileName ) 
		throws IOException
	{
		File file = new File( fileName );
		// if relative, fix up to bsh.cwd
		if ( !file.isAbsolute() ) {
			String cwd = (String)getu(""bsh.cwd"");
			file = new File( cwd + File.separator + fileName );
		}
		// The canonical file name is also absolute.
		// No need for getAbsolutePath() here...
		return new File( file.getCanonicalPath() );
	}
	public static void redirectOutputToFile( String filename ) 
	{
		try {
			PrintStream pout = new PrintStream( 
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println(""Can't redirect output to file: ""+filename );
		}
	}
	/**
		Set an external class loader to be used for all basic class loading
		in BeanShell.  
		<p>
		BeanShell will use this at the same point it would otherwise use the 
		plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.  
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
		<p>
		@see BshClassManager#setClassLoader( ClassLoader )
	*/
	public void setClassLoader( ClassLoader externalCL ) {
		getClassManager().setClassLoader( externalCL );
	}
	/**
		Get the class manager associated with this interpreter
		(the BshClassManager of this interpreter's global namespace).
		This is primarily a convenience method.
	*/
	public BshClassManager getClassManager() 
	{
		return getNameSpace().getClassManager();
	}
	/**
		Set strict Java mode on or off.  
		This mode attempts to make BeanShell syntax behave as Java
		syntax, eliminating conveniences like loose variables, etc.
		When enabled, variables are required to be declared or initialized 
		before use and method arguments are reqired to have types. 
		<p>
		This mode will become more strict in a future release when 
		classes are interpreted and there is an alternative to scripting
		objects as method closures.
	*/
	public void setStrictJava( boolean b ) { 
		this.strictJava = b; 
	}
	/**
		@see #setStrictJava( boolean )
	*/
	public boolean getStrictJava() { 
		return this.strictJava;
	}
	static void staticInit() 
	{
	/* 
		Apparently in some environments you can't catch the security exception
		at all...  e.g. as an applet in IE  ... will probably have to work 
		around 
	*/
		try {
			systemLineSeparator = System.getProperty(""line.separator"");
    		debug = System.err;
    		DEBUG = Boolean.getBoolean(""debug"");
    		TRACE = Boolean.getBoolean(""trace"");
    		LOCALSCOPING = Boolean.getBoolean(""localscoping"");
			String outfilename = System.getProperty(""outfile"");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) { 
			System.err.println(""Could not init static:""+e);
		} catch ( Exception e ) {
			System.err.println(""Could not init static(2):""+e);
		} catch ( Throwable e ) { 
			System.err.println(""Could not init static(3):""+e);
		}
	}
	/**
		Specify the source of the text from which this interpreter is reading.
		Note: there is a difference between what file the interrpeter is 
		sourcing and from what file a method was originally parsed.  One
		file may call a method sourced from another file.  See SimpleNode
		for origination file info.
		@see bsh.SimpleNode#getSourceFile()
	*/
	public String getSourceFileInfo() { 
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return ""<unknown source>"";
	}
	/**
		Get the parent Interpreter of this interpreter, if any.
		Currently this relationship implies the following:
			1) Parent and child share a BshClassManager
			2) Children indicate the parent's source file information in error
			reporting.
		When created as part of a source() / eval() the child also shares
		the parent's namespace.  But that is not necessary in general.
	*/
	public Interpreter getParent() {
		return parent;
	}
	public void setOut( PrintStream out ) {
		this.out = out;
	}
	public void setErr( PrintStream err ) {
		this.err = err;
	}
	/**
		De-serialization setup.
		Default out and err streams to stdout, stderr if they are null.
	*/
	private void readObject(ObjectInputStream stream) 
		throws java.io.IOException, ClassNotFoundException
	{
		stream.defaultReadObject();
		// set transient fields
		if ( console != null ) {
			setOut( console.getOut() );
			setErr( console.getErr() );
		} else {
			setOut( System.out );
			setErr( System.err );
		}
	}
	/**
		Get the prompt string defined by the getBshPrompt() method in the
		global namespace.  This may be from the getBshPrompt() command or may
		be defined by the user as with any other method.
		Defaults to ""bsh % "" if the method is not defined or there is an error.
	*/
	private String getBshPrompt() 
	{
		try {
			return (String)eval(""getBshPrompt()"");
		} catch ( Exception e ) {
			return ""bsh % "";
		}
	}
	/**
		Specify whether, in interactive mode, the interpreter exits Java upon
		end of input.  If true, when in interactive mode the interpreter will
		issue a System.exit(0) upon eof.  If false the interpreter no
		System.exit() will be done.
		<p/>
		Note: if you wish to cause an EOF externally you can try closing the
		input stream.  This is not guaranteed to work in older versions of Java
		due to Java limitations, but should work in newer JDK/JREs.  (That was
		the motivation for the Java NIO package).
	*/
	public void setExitOnEOF( boolean value ) {
		exitOnEOF = value; // ug
	}
}
"
bsh.InterpreterError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	An internal error in the interpreter has occurred.
*/
public class InterpreterError extends RuntimeException
{
	public InterpreterError(String s)
	{
		super(s);
	}
}
"
bsh.JavaCharStream,"/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */
package bsh;
/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (with java-like unicode escape processing).
 */
public class JavaCharStream
{
  public static final boolean staticFlag = false;
  static final int hexval(char c) throws java.io.IOException {
    switch(c)
    {
       case '0' :
          return 0;
       case '1' :
          return 1;
       case '2' :
          return 2;
       case '3' :
          return 3;
       case '4' :
          return 4;
       case '5' :
          return 5;
       case '6' :
          return 6;
       case '7' :
          return 7;
       case '8' :
          return 8;
       case '9' :
          return 9;
       case 'a' :
       case 'A' :
          return 10;
       case 'b' :
       case 'B' :
          return 11;
       case 'c' :
       case 'C' :
          return 12;
       case 'd' :
       case 'D' :
          return 13;
       case 'e' :
       case 'E' :
          return 14;
       case 'f' :
       case 'F' :
          return 15;
    }
    throw new java.io.IOException(); // Should never come here
  }
  public int bufpos = -1;
  int bufsize;
  int available;
  int tokenBegin;
  protected int bufline[];
  protected int bufcolumn[];
  protected int column = 0;
  protected int line = 1;
  protected boolean prevCharIsCR = false;
  protected boolean prevCharIsLF = false;
  protected java.io.Reader inputStream;
  protected char[] nextCharBuf;
  protected char[] buffer;
  protected int maxNextCharInd = 0;
  protected int nextCharInd = -1;
  protected int inBuf = 0;
  protected void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];
     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;
           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;
           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;
           bufpos += (bufsize - tokenBegin);
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;
           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;
           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;
           bufpos -= tokenBegin;
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }
     available = (bufsize += 2048);
     tokenBegin = 0;
  }
  protected void FillBuff() throws java.io.IOException
  {
     int i;
     if (maxNextCharInd == 4096)
        maxNextCharInd = nextCharInd = 0;
     try {
        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
                                            4096 - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        if (bufpos != 0)
        {
           --bufpos;
           backup(0);
        }
        else
        {
           bufline[bufpos] = line;
           bufcolumn[bufpos] = column;
        }
        throw e;
     }
  }
  protected char ReadByte() throws java.io.IOException
  {
     if (++nextCharInd >= maxNextCharInd)
        FillBuff();
     return nextCharBuf[nextCharInd];
  }
  public char BeginToken() throws java.io.IOException
  {     
     if (inBuf > 0)
     {
        --inBuf;
        if (++bufpos == bufsize)
           bufpos = 0;
        tokenBegin = bufpos;
        return buffer[bufpos];
     }
     tokenBegin = 0;
     bufpos = -1;
     return readChar();
  }     
  protected void AdjustBuffSize()
  {
     if (available == bufsize)
     {
        if (tokenBegin > 2048)
        {
           bufpos = 0;
           available = tokenBegin;
        }
        else
           ExpandBuff(false);
     }
     else if (available > tokenBegin)
        available = bufsize;
     else if ((tokenBegin - available) < 2048)
        ExpandBuff(true);
     else
        available = tokenBegin;
  }
  protected void UpdateLineColumn(char c)
  {
     column++;
     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }
     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (8 - (column & 07));
           break;
        default :
           break;
     }
     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }
  public char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;
        if (++bufpos == bufsize)
           bufpos = 0;
        return buffer[bufpos];
     }
     char c;
     if (++bufpos == available)
        AdjustBuffSize();
     if ((buffer[bufpos] = c = ReadByte()) == '\\')
     {
        UpdateLineColumn(c);
        int backSlashCnt = 1;
        for (;;) // Read all the backslashes
        {
           if (++bufpos == available)
              AdjustBuffSize();
           try
           {
              if ((buffer[bufpos] = c = ReadByte()) != '\\')
              {
                 UpdateLineColumn(c);
                 // found a non-backslash char.
                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
                 {
                    if (--bufpos < 0)
                       bufpos = bufsize - 1;
                    break;
                 }
                 backup(backSlashCnt);
                 return '\\';
              }
           }
           catch(java.io.IOException e)
           {
              if (backSlashCnt > 1)
                 backup(backSlashCnt);
              return '\\';
           }
           UpdateLineColumn(c);
           backSlashCnt++;
        }
        // Here, we have seen an odd number of backslash's followed by a 'u'
        try
        {
           while ((c = ReadByte()) == 'u')
              ++column;
           buffer[bufpos] = c = (char)(hexval(c) << 12 |
                                       hexval(ReadByte()) << 8 |
                                       hexval(ReadByte()) << 4 |
                                       hexval(ReadByte()));
           column += 4;
        }
        catch(java.io.IOException e)
        {
           throw new Error(""Invalid escape character at line "" + line +
                                         "" column "" + column + ""."");
        }
        if (backSlashCnt == 1)
           return c;
        else
        {
           backup(backSlashCnt - 1);
           return '\\';
        }
     }
     else
     {
        UpdateLineColumn(c);
        return (c);
     }
  }
  /**
   * @deprecated 
   * @see #getEndColumn
   */
  public int getColumn() {
     return bufcolumn[bufpos];
  }
  /**
   * @deprecated 
   * @see #getEndLine
   */
  public int getLine() {
     return bufline[bufpos];
  }
  public int getEndColumn() {
     return bufcolumn[bufpos];
  }
  public int getEndLine() {
     return bufline[bufpos];
  }
  public int getBeginColumn() {
     return bufcolumn[tokenBegin];
  }
  public int getBeginLine() {
     return bufline[tokenBegin];
  }
  public void backup(int amount) {
    inBuf += amount;
    if ((bufpos -= amount) < 0)
       bufpos += bufsize;
  }
  public JavaCharStream(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;
    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
    nextCharBuf = new char[4096];
  }
  public JavaCharStream(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }
  public JavaCharStream(java.io.Reader dstream)
  {
     this(dstream, 1, 1, 4096);
  }
  public void ReInit(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;
    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
      nextCharBuf = new char[4096];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    nextCharInd = bufpos = -1;
  }
  public void ReInit(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.Reader dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }
  public JavaCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public JavaCharStream(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }
  public JavaCharStream(java.io.InputStream dstream)
  {
     this(dstream, 1, 1, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }
  public String GetImage()
  {
     if (bufpos >= tokenBegin)
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
     else
        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                              new String(buffer, 0, bufpos + 1);
  }
  public char[] GetSuffix(int len)
  {
     char[] ret = new char[len];
     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
     }
     return ret;
  }
  public void Done()
  {
     nextCharBuf = null;
     buffer = null;
     bufline = null;
     bufcolumn = null;
  }
  /**
   * Method to adjust line and column numbers for the start of a token.<BR>
   */
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;
     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }
     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;
     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 
     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;
        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }
     line = bufline[j];
     column = bufcolumn[j];
  }
}
"
bsh.JJTParserState,"/* Generated By:JJTree: Do not edit this line. src/bsh/JJTParserState.java */
package bsh;
class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;
  private int sp;		// number of nodes on stack
  private int mk;		// current mark
  private boolean node_created;
  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }
  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  boolean nodeCreated() {
    return node_created;
  }
  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }
  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }
  /* Pushes a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }
  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }
  /* Returns the node currently on the top of the stack. */
  Node peekNode() {
    return (Node)nodes.peek();
  }
  /* Returns the number of children on the stack in the current node
     scope. */
  int nodeArity() {
    return sp - mk;
  }
  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }
  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }
  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }
  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
"
bsh.JThis,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.beans.*;
/**
	JThis is a dynamically loaded extension which extends This and adds 
	explicit support for AWT and JFC events, etc.  This is a backwards 
	compatability measure for JDK 1.2.  With 1.3+ there is a general 
	reflection proxy mechanism that allows the base This to implement 
	arbitrary interfaces.
	The NameSpace getThis() method will produce instances of JThis if 
	the java version is prior to 1.3 and swing is available...  (e.g. 1.2
	or 1.1 + swing installed)  
	Users of 1.1 without swing will have minimal interface support (just run()).
	Bsh doesn't run on 1.02 and below because there is no reflection! 
	Note: This module relies on features of Swing and will only compile
	with JDK1.2 or JDK1.1 + the swing package.  For other environments simply 
	do not compile this class.
*/
class JThis extends This implements
	// All core AWT listeners
	ActionListener, AdjustmentListener, ComponentListener,
	ContainerListener, FocusListener, ItemListener, KeyListener,
	MouseListener, MouseMotionListener, TextListener, WindowListener,
	PropertyChangeListener, 
	// All listeners in javax.swing.event as of Swing 1.1
	AncestorListener, CaretListener, CellEditorListener, ChangeListener,
	DocumentListener, HyperlinkListener, 
	InternalFrameListener, ListDataListener, ListSelectionListener, 
	MenuDragMouseListener, MenuKeyListener, MenuListener, MouseInputListener, 
	PopupMenuListener, TableColumnModelListener, TableModelListener, 
	TreeExpansionListener, TreeModelListener, TreeSelectionListener, 
	TreeWillExpandListener, UndoableEditListener
{
	JThis( NameSpace namespace, Interpreter declaringInterp ) { 
		super( namespace, declaringInterp );
	}
	public String toString() {
		return ""'this' reference (JThis) to Bsh object: "" + namespace.getName();
	}
	void event(String name, Object event)
	{
		CallStack callstack = new CallStack( namespace );
		BshMethod method = null;
		// handleEvent gets all events
		try {
			method = namespace.getMethod( 
				""handleEvent"", new Class [] { null } );
		} catch ( UtilEvalError e ) {/*squeltch*/  }
		if (method != null)
			try {
				method.invoke( 
					new Object[] { event }, declaringInterpreter, callstack, null );
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event hander method invocation error:"" + e );
			}
		// send to specific event handler
		try {
			method = namespace.getMethod( name, new Class [] { null } );
		} catch ( UtilEvalError e ) { /*squeltch*/ }
		if (method != null)
			try {
				method.invoke( 
					new Object[] { event }, declaringInterpreter, callstack, null );
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event hander method invocation error:"" + e );
			}
	}
	// Listener interfaces
    public void ancestorAdded(AncestorEvent e) { event(""ancestorAdded"", e); }
    public void ancestorRemoved(AncestorEvent e) { event(""ancestorRemoved"", e); }
    public void ancestorMoved(AncestorEvent e) { event(""ancestorMoved"", e); }
    public void caretUpdate(CaretEvent e) { event(""caretUpdate"", e); }
    public void editingStopped(ChangeEvent e) { event(""editingStopped"", e); }
    public void editingCanceled(ChangeEvent e) { event(""editingCanceled"", e); }
    public void stateChanged(ChangeEvent e) { event(""stateChanged"", e); }
    public void insertUpdate(DocumentEvent e) { event(""insertUpdate"", e); }
    public void removeUpdate(DocumentEvent e) { event(""removeUpdate"", e); }
    public void changedUpdate(DocumentEvent e) { event(""changedUpdate"", e); }
    public void hyperlinkUpdate(HyperlinkEvent e) { event(""internalFrameOpened"", e); }
    public void internalFrameOpened(InternalFrameEvent e) { event(""internalFrameOpened"", e); }
    public void internalFrameClosing(InternalFrameEvent e) { event(""internalFrameClosing"", e); }
    public void internalFrameClosed(InternalFrameEvent e) { event(""internalFrameClosed"", e); }
    public void internalFrameIconified(InternalFrameEvent e) { event(""internalFrameIconified"", e); }
    public void internalFrameDeiconified(InternalFrameEvent e) { event(""internalFrameDeiconified"", e); }
    public void internalFrameActivated(InternalFrameEvent e) { event(""internalFrameActivated"", e); }
    public void internalFrameDeactivated(InternalFrameEvent e) { event(""internalFrameDeactivated"", e); }
    public void intervalAdded(ListDataEvent e) { event(""intervalAdded"", e); }
    public void intervalRemoved(ListDataEvent e) { event(""intervalRemoved"", e); }
    public void contentsChanged(ListDataEvent e) { event(""contentsChanged"", e); }
  	public void valueChanged(ListSelectionEvent e) { event(""valueChanged"", e); }
    public void menuDragMouseEntered(MenuDragMouseEvent e) { event(""menuDragMouseEntered"", e); }
    public void menuDragMouseExited(MenuDragMouseEvent e) { event(""menuDragMouseExited"", e); }
    public void menuDragMouseDragged(MenuDragMouseEvent e) { event(""menuDragMouseDragged"", e); }
    public void menuDragMouseReleased(MenuDragMouseEvent e) { event(""menuDragMouseReleased"", e); }
    public void menuKeyTyped(MenuKeyEvent e) { event(""menuKeyTyped"", e); }
    public void menuKeyPressed(MenuKeyEvent e) { event(""menuKeyPressed"", e); }
    public void menuKeyReleased(MenuKeyEvent e) { event(""menuKeyReleased"", e); }
    public void menuSelected(MenuEvent e) { event(""menuSelected"", e); }
    public void menuDeselected(MenuEvent e) { event(""menuDeselected"", e); }
    public void menuCanceled(MenuEvent e) { event(""menuCanceled"", e); }
    public void popupMenuWillBecomeVisible(PopupMenuEvent e) { event(""popupMenuWillBecomeVisible"", e); }
    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) { event(""popupMenuWillBecomeInvisible"", e); }
    public void popupMenuCanceled(PopupMenuEvent e) { event(""popupMenuCanceled"", e); }
    public void columnAdded(TableColumnModelEvent e) { event(""columnAdded"", e); }
    public void columnRemoved(TableColumnModelEvent e) { event(""columnRemoved"", e); }
    public void columnMoved(TableColumnModelEvent e) { event(""columnMoved"", e); }
    public void columnMarginChanged(ChangeEvent e) { event(""columnMarginChanged"", e); }
    public void columnSelectionChanged(ListSelectionEvent e) { event(""columnSelectionChanged"", e); }
    public void tableChanged(TableModelEvent e) { event(""tableChanged"", e); }
    public void treeExpanded(TreeExpansionEvent e) { event(""treeExpanded"", e); }
    public void treeCollapsed(TreeExpansionEvent e) { event(""treeCollapsed"", e); }
    public void treeNodesChanged(TreeModelEvent e) { event(""treeNodesChanged"", e); }
    public void treeNodesInserted(TreeModelEvent e) { event(""treeNodesInserted"", e); }
    public void treeNodesRemoved(TreeModelEvent e) { event(""treeNodesRemoved"", e); }
    public void treeStructureChanged(TreeModelEvent e) { event(""treeStructureChanged"", e); }
    public void valueChanged(TreeSelectionEvent e) { event(""valueChanged"", e); }
    public void treeWillExpand(TreeExpansionEvent e) { event(""treeWillExpand"", e); }
    public void treeWillCollapse(TreeExpansionEvent e) { event(""treeWillCollapse"", e); }
    public void undoableEditHappened(UndoableEditEvent e) { event(""undoableEditHappened"", e); }
	// Listener interfaces
	public void actionPerformed(ActionEvent e) { event(""actionPerformed"", e); }
	public void adjustmentValueChanged(AdjustmentEvent e) { event(""adjustmentValueChanged"", e); }
	public void componentResized(ComponentEvent e) { event(""componentResized"", e); }
	public void componentMoved(ComponentEvent e) { event(""componentMoved"", e); }
	public void componentShown(ComponentEvent e) { event(""componentShown"", e); }
	public void componentHidden(ComponentEvent e) { event(""componentHidden"", e); }
	public void componentAdded(ContainerEvent e) { event(""componentAdded"", e); }
	public void componentRemoved(ContainerEvent e) { event(""componentRemoved"", e); }
	public void focusGained(FocusEvent e) { event(""focusGained"", e); }
	public void focusLost(FocusEvent e) { event(""focusLost"", e); }
	public void itemStateChanged(ItemEvent e) { event(""itemStateChanged"", e); }
	public void keyTyped(KeyEvent e) { event(""keyTyped"", e); }
	public void keyPressed(KeyEvent e) { event(""keyPressed"", e); }
	public void keyReleased(KeyEvent e) { event(""keyReleased"", e); }
	public void mouseClicked(MouseEvent e) { event(""mouseClicked"", e); }
	public void mousePressed(MouseEvent e) { event(""mousePressed"", e); }
	public void mouseReleased(MouseEvent e) { event(""mouseReleased"", e); }
	public void mouseEntered(MouseEvent e) { event(""mouseEntered"", e); }
	public void mouseExited(MouseEvent e) { event(""mouseExited"", e); }
	public void mouseDragged(MouseEvent e) { event(""mouseDragged"", e); }
	public void mouseMoved(MouseEvent e) { event(""mouseMoved"", e); }
	public void textValueChanged(TextEvent e) { event(""textValueChanged"", e); }
	public void windowOpened(WindowEvent e) { event(""windowOpened"", e); }
	public void windowClosing(WindowEvent e) { event(""windowClosing"", e); }
	public void windowClosed(WindowEvent e) { event(""windowClosed"", e); }
	public void windowIconified(WindowEvent e) { event(""windowIconified"", e); }
	public void windowDeiconified(WindowEvent e) { event(""windowDeiconified"", e); }
	public void windowActivated(WindowEvent e) { event(""windowActivated"", e); }
	public void windowDeactivated(WindowEvent e) { event(""windowDeactivated"", e); }
	public void propertyChange(PropertyChangeEvent e) { 
		event(""propertyChange"", e ); }
    public void vetoableChange(PropertyChangeEvent e) {
		event(""vetoableChange"", e ); }
    public boolean imageUpdate(java.awt.Image img, int infoflags,
                               int x, int y, int width, int height) {
		BshMethod method = null;
		try {
			method = namespace.getMethod( ""imageUpdate"",
				new Class [] { null, null, null, null, null, null } );
		} catch ( UtilEvalError e ) {/*squeltch*/ }
		if(method != null)
			try {
				CallStack callstack = new CallStack( namespace );
				method.invoke( 
					new Object[] { 
						img, new Primitive(infoflags), new Primitive(x), 
						new Primitive(y), new Primitive(width), 
						new Primitive(height) }, 
					declaringInterpreter, callstack, null
				);
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event handler imageUpdate: method invocation error:"" + e );
			}
		return true;
	}
}
"
bsh.LHS,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Field;
import java.util.Hashtable;
/**
	An LHS is a wrapper for an variable, field, or property.  It ordinarily 
	holds the ""left hand side"" of an assignment and may be either resolved to 
	a value or assigned a value.
	<p>
	There is one special case here termed METHOD_EVAL where the LHS is used
	in an intermediate evaluation of a chain of suffixes and wraps a method
	invocation.  In this case it may only be resolved to a value and cannot be 
	assigned.  (You can't assign a value to the result of a method call e.g.
	""foo() = 5;"").
	<p>
*/
class LHS implements ParserConstants, java.io.Serializable
{
	NameSpace nameSpace;
	/** The assignment should be to a local variable */
	boolean localVar;
	/**
		Identifiers for the various types of LHS.
	*/
	static final int
		VARIABLE = 0,
		FIELD = 1,
		PROPERTY = 2,
		INDEX = 3,
		METHOD_EVAL = 4;
	int type;
	String varName;
	String propName;
	Field field;
	Object object;
	int index;
/**
		Variable LHS constructor.
*/
	LHS( NameSpace nameSpace, String varName )
	{
throw new Error(""namespace lhs"");
/*
		type = VARIABLE;
		this.varName = varName;
		this.nameSpace = nameSpace;
*/
	}
	/**
		@param localVar if true the variable is set directly in the This
		reference's local scope.  If false recursion to look for the variable
		definition in parent's scope is allowed. (e.g. the default case for
		undefined vars going to global).
	*/
	LHS( NameSpace nameSpace, String varName, boolean localVar )
	{
		type = VARIABLE;
		this.localVar = localVar;
		this.varName = varName;
		this.nameSpace = nameSpace;
	}
	/**
		Static field LHS Constructor.
		This simply calls Object field constructor with null object.
	*/
	LHS( Field field )
	{
		type = FIELD;
		this.object = null;
		this.field = field;
	}
	/**
		Object field LHS Constructor.
	*/
	LHS( Object object, Field field )
	{
		if ( object == null)
			throw new NullPointerException(""constructed empty LHS"");
		type = FIELD;
		this.object = object;
		this.field = field;
	}
	/**
		Object property LHS Constructor.
	*/
	LHS( Object object, String propName )
	{
		if(object == null)
			throw new NullPointerException(""constructed empty LHS"");
		type = PROPERTY;
		this.object = object;
		this.propName = propName;
	}
	/**
		Array index LHS Constructor.
	*/
	LHS( Object array, int index )
	{
		if(array == null)
			throw new NullPointerException(""constructed empty LHS"");
		type = INDEX;
		this.object = array;
		this.index = index;
	}
	public Object getValue() throws UtilEvalError
	{
		if ( type == VARIABLE )
			return nameSpace.getVariable( varName );
		if (type == FIELD)
			try {
				Object o = field.get( object );
				return Primitive.wrap( o, field.getType() );
			} catch(IllegalAccessException e2) {
				throw new UtilEvalError(""Can't read field: "" + field);
			}
		if ( type == PROPERTY )
			try {
				return Reflect.getObjectProperty(object, propName);
			}
			catch(ReflectError e) {
				Interpreter.debug(e.getMessage());
				throw new UtilEvalError(""No such property: "" + propName);
			}
		if ( type == INDEX )
			try {
				return Reflect.getIndex(object, index);
			}
			catch(Exception e) {
				throw new UtilEvalError(""Array access: "" + e);
			}
		throw new InterpreterError(""LHS type"");
	}
	/**
		Assign a value to the LHS.
	*/
	public Object assign( Object val, boolean strictJava ) 
		throws UtilEvalError
	{
		if ( type == VARIABLE )
		{
			// Set the variable in namespace according to localVar flag
			if ( localVar )
				nameSpace.setLocalVariable( varName, val, strictJava );
			else
				nameSpace.setVariable( varName, val, strictJava );
		} else 
		if ( type == FIELD )
		{
			try {
				Object fieldVal = val instanceof Primitive ?  
					((Primitive)val).getValue() : val;
				// This should probably be in Reflect.java
				ReflectManager.RMSetAccessible( field );
				field.set( object, fieldVal );
				return val;
			}
			catch( NullPointerException e) {   
    			throw new UtilEvalError(
					""LHS (""+field.getName()+"") not a static field."");
			}     
   			catch( IllegalAccessException e2) {   
				throw new UtilEvalError(
					""LHS (""+field.getName()+"") can't access field: ""+e2);
			}     
			catch( IllegalArgumentException e3) 
			{
				String type = val instanceof Primitive ?
					((Primitive)val).getType().getName()
					: val.getClass().getName();
				throw new UtilEvalError(
					""Argument type mismatch. "" + (val == null ? ""null"" : type )
					+ "" not assignable to field ""+field.getName());
			}
		}
		else 
		if ( type == PROPERTY )
		{
			/*
			if ( object instanceof Hashtable )
				((Hashtable)object).put(propName, val);
			*/
			CollectionManager cm = CollectionManager.getCollectionManager();
			if ( cm.isMap( object ) )
				cm.putInMap( object/*map*/, propName, val );
			else
				try {
					Reflect.setObjectProperty(object, propName, val);
				}
				catch(ReflectError e) {
					Interpreter.debug(""Assignment: "" + e.getMessage());
					throw new UtilEvalError(""No such property: "" + propName);
				}
		} else 
		if ( type == INDEX )
			try {
				Reflect.setIndex(object, index, val);
			} catch ( UtilTargetError e1 ) { // pass along target error
				throw e1;
			} catch ( Exception e ) {
				throw new UtilEvalError(""Assignment: "" + e.getMessage());
			}
		else
			throw new InterpreterError(""unknown lhs"");
		return val;
	}
	public String toString() { 
		return ""LHS: ""
			+((field!=null)? ""field = ""+field.toString():"""")
			+(varName!=null ? "" varName = ""+varName: """")
			+(nameSpace!=null ? "" nameSpace = ""+nameSpace.toString(): """");
	}
}
"
bsh.Modifiers,"package bsh;
import java.util.Hashtable;
/**
	@author Pat Niemeyer (pat@pat.net)
*/
/*
	Note: which of these things should be checked at parse time vs. run time?
*/
public class Modifiers implements java.io.Serializable
{
	public static final int CLASS=0, METHOD=1, FIELD=2;
	Hashtable modifiers;
	/**
		@param context is METHOD or FIELD
	*/
	public void addModifier( int context, String name ) 
	{
		if ( modifiers == null )
			modifiers = new Hashtable();
		Object got = modifiers.put( name, Void.TYPE/*arbitrary flag*/ );
		if ( got != null )
			throw new IllegalStateException(""Duplicate modifier: ""+ name );
		int count = 0;
		if ( hasModifier(""private"") ) ++count;
		if ( hasModifier(""protected"") ) ++count;
		if ( hasModifier(""public"") ) ++count;
		if ( count > 1 )
			throw new IllegalStateException(
				""public/private/protected cannot be used in combination."" );
		switch( context ) 
		{
		case CLASS:
			validateForClass();
			break;
		case METHOD:
			validateForMethod();
			break;
		case FIELD:
			validateForField();
			break;
		}
	}
	public boolean hasModifier( String name ) 
	{
		if ( modifiers == null )
			modifiers = new Hashtable();
		return modifiers.get(name) != null;
	}
	// could refactor these a bit
	private void validateForMethod() 
	{ 
		insureNo(""volatile"", ""Method"");
		insureNo(""transient"", ""Method"");
	}
	private void validateForField() 
	{ 
		insureNo(""synchronized"", ""Variable"");
		insureNo(""native"", ""Variable"");
		insureNo(""abstract"", ""Variable"");
	}
	private void validateForClass() 
	{ 
		validateForMethod(); // volatile, transient
		insureNo(""native"", ""Class"");
		insureNo(""synchronized"", ""Class"");
	}
	private void insureNo( String modifier, String context )
	{
		if ( hasModifier( modifier ) )
			throw new IllegalStateException(
				context + "" cannot be declared '""+modifier+""'"");
	}
	public String toString()
	{
		return ""Modifiers: ""+modifiers;
	}
}
"
bsh.Name,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
import java.util.Hashtable;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
/**
	What's in a name?  I'll tell you...
	Name() is a somewhat ambiguous thing in the grammar and so is this.
	<p>
	This class is a name resolver.  It holds a possibly ambiguous dot 
	separated name and reference to a namespace in which it allegedly lives.  
	It provides methods that attempt to resolve the name to various types of 
	entities: e.g. an Object, a Class, a declared scripted BeanShell method.
	<p>
	Name objects are created by the factory method NameSpace getNameResolver(), 
	which caches them subject to a class namespace change.  This means that 
	we can cache information about various types of resolution here.
	Currently very little if any information is cached.  However with a future
	""optimize"" setting that defeats certain dynamic behavior we might be able
	to cache quite a bit.
*/
/*
	<strong>Implementation notes</strong>
	<pre>
	Thread safety: all of the work methods in this class must be synchronized
	because they share the internal intermediate evaluation state.
	Note about invokeMethod():  We could simply use resolveMethod and return
	the MethodInvoker (BshMethod or JavaMethod) however there is no easy way
	for the AST (BSHMehodInvocation) to use this as it doesn't have type
	information about the target to resolve overloaded methods.
	(In Java, overloaded methods are resolved at compile time... here they
	are, of necessity, dynamic).  So it would have to do what we do here
	and cache by signature.  We now do that for the client in Reflect.java.
	Note on this.caller resolution:
	Although references like these do work:
		this.caller.caller.caller...   // works
	the equivalent using successive calls:
		// does *not* work
		for( caller=this.caller; caller != null; caller = caller.caller );
	is prohibited by the restriction that you can only call .caller on a 
	literal	this or caller reference.  The effect is that magic caller 
	reference only works through the current 'this' reference.
	The real explanation is that This referernces do not really know anything
	about their depth on the call stack.  It might even be hard to define
	such a thing...
	For those purposes we provide :
		this.callstack
	</pre>
*/
class Name implements java.io.Serializable
{
	// These do not change during evaluation
	public NameSpace namespace;
	String value = null;
	// ---------------------------------------------------------
	// The following instance variables mutate during evaluation and should
	// be reset by the reset() method where necessary
	// For evaluation
	/** Remaining text to evaluate */
	private String evalName;
	/** 
		The last part of the name evaluated.  This is really only used for
	 	this, caller, and super resolution.
	*/
	private String lastEvalName;
	private static String FINISHED = null; // null evalname and we're finished
	private Object evalBaseObject;	// base object for current eval
	private int callstackDepth;		// number of times eval hit 'this.caller'
	//  
	//  End mutable instance variables.
	// ---------------------------------------------------------
	// Begin Cached result structures
	// These are optimizations 
	// Note: it's ok to cache class resolution here because when the class
	// space changes the namespace will discard cached names.
	/** 
		The result is a class 
	*/
	Class asClass;
	/** 
		The result is a static method call on the following class 
	*/
	Class classOfStaticMethod;
	// End Cached result structures
	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
	}
	/**
		This constructor should *not* be used in general. 
		Use NameSpace getNameResolver() which supports caching.
		@see NameSpace getNameResolver().
	*/
	// I wish I could make this ""friendly"" to only NameSpace
	Name( NameSpace namespace, String s )
	{
		this.namespace = namespace;
		value = s;
	}
	/**
		Resolve possibly complex name to an object value.
		Throws EvalError on various failures.
		A null object value is indicated by a Primitive.NULL.
		A return type of Primitive.VOID comes from attempting to access
		an undefined variable.
		Some cases:
			myVariable
			myVariable.foo
			myVariable.foo.bar
			java.awt.GridBagConstraints.BOTH
			my.package.stuff.MyClass.someField.someField...
		Interpreter reference is necessary to allow resolution of 
		""this.interpreter"" magic field.
		CallStack reference is necessary to allow resolution of 
		""this.caller"" magic field.
		""this.callstack"" magic field.
	*/
	public Object toObject( CallStack callstack, Interpreter interpreter ) 
		throws UtilEvalError
	{
		return toObject( callstack, interpreter, false );
	}
	/**
		@see toObject()
		@param forceClass if true then resolution will only produce a class.
		This is necessary to disambiguate in cases where the grammar knows
		that we want a class; where in general the var path may be taken.
	*/
	synchronized public Object toObject( 
		CallStack callstack, Interpreter interpreter, boolean forceClass ) 
		throws UtilEvalError
	{
		reset();
		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField( 
				callstack, interpreter, forceClass, false/*autoalloc*/  );
		if ( obj == null )
			throw new InterpreterError(""null value in toObject()"");
		return obj;
	}
	private Object completeRound( 
		String lastEvalName, String nextEvalName, Object returnObject )
	{
		if ( returnObject == null )
			throw new InterpreterError(""lastEvalName = ""+lastEvalName);
		this.lastEvalName = lastEvalName;
		this.evalName = nextEvalName;
		this.evalBaseObject = returnObject;
		return returnObject;
	}
	/**
		Get the next object by consuming one or more components of evalName.  
		Often this consumes just one component, but if the name is a classname 
		it will consume all of the components necessary to make the class 
		identifier.
	*/
	private Object consumeNextObjectField( 	
		CallStack callstack, Interpreter interpreter, 
		boolean forceClass, boolean autoAllocateThis ) 
		throws UtilEvalError
	{
		/*
			Is it a simple variable name?
			Doing this first gives the correct Java precedence for vars 
			vs. imported class names (at least in the simple case - see
			tests/precedence1.bsh).  It should also speed things up a bit.
		*/
		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( 
				callstack, namespace, interpreter, evalName, false );
			if ( obj != Primitive.VOID )
				return completeRound( evalName, FINISHED, obj );
		}
		/*
			Is it a bsh script variable reference?
			If we're just starting the eval of name (no base object)
			or we're evaluating relative to a This type reference check.
		*/
		String varName = prefix(evalName, 1);
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug(""trying to resolve variable: "" + varName);
			Object obj;
			// switch namespace and special var visibility
			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference( 
					callstack, namespace, interpreter, varName, false );
			} else {
				obj = resolveThisFieldReference( 
					callstack, ((This)evalBaseObject).namespace, 
					interpreter, varName, true );
			}
			if ( obj != Primitive.VOID ) 
			{
				// Resolved the variable
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( ""resolved variable: "" + varName + 
					"" in namespace: ""+namespace);
				return completeRound( varName, suffix(evalName), obj );
			}
		}
		/*
			Is it a class name?
			If we're just starting eval of name try to make it, else fail.
		*/
		if ( evalBaseObject == null ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( ""trying class: "" + evalName);
			/*
				Keep adding parts until we have a class 
			*/
			Class clas = null;
			int i = 1;
			String className = null;
			for(; i <= countParts(evalName); i++)
			{
				className = prefix(evalName, i);
				if ( (clas = namespace.getClass(className)) != null )
					break;
			}
			if ( clas != null )  {
				return completeRound(
					className,
					suffix( evalName, countParts(evalName)-i ),
					new ClassIdentifier(clas) 
				);
			}
			// not a class (or variable per above)
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( ""not a class, trying var prefix ""+evalName );
		}
		// No variable or class found in 'this' type ref.
		// if autoAllocateThis then create one; a child 'this'.
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass && autoAllocateThis )
		{
			NameSpace targetNameSpace = 
				( evalBaseObject == null ) ?  
					namespace : ((This)evalBaseObject).namespace;
			Object obj = new NameSpace( 
				targetNameSpace, ""auto: ""+varName ).getThis( interpreter );
			targetNameSpace.setVariable( varName, obj, false );
			return completeRound( varName, suffix(evalName), obj );
		}
		/*
			If we didn't find a class or variable name (or prefix) above
			there are two possibilities:
			- If we are a simple name then we can pass as a void variable 
			reference.
			- If we are compound then we must fail at this point.
		*/
		if ( evalBaseObject == null ) {
			if ( !isCompound(evalName) ) {
				return completeRound( evalName, FINISHED, Primitive.VOID );
			} else
				throw new UtilEvalError(
					""Class or variable not found: "" + evalName);
		}
		/*
			--------------------------------------------------------
			After this point we're definitely evaluating relative to
			a base object.
			--------------------------------------------------------
		*/
		/*
			Do some basic validity checks.
		*/
		if ( evalBaseObject == Primitive.NULL) // previous round produced null
			throw new UtilTargetError( new NullPointerException( 
				""Null Pointer while evaluating: "" +value ) );
		if ( evalBaseObject == Primitive.VOID) // previous round produced void
			throw new UtilEvalError(
				""Undefined variable or class name while evaluating: ""+value);
		if ( evalBaseObject instanceof Primitive)
			throw new UtilEvalError(""Can't treat primitive like an object. ""+
			""Error while evaluating: ""+value);
		/* 
			Resolve relative to a class type
			static field, inner class, ?
		*/
		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);
			// Class qualified 'this' reference from inner class.
			// e.g. 'MyOuterClass.this'
			if ( field.equals(""this"") )
			{
				// find the enclosing class instance space of the class name
				NameSpace ns = namespace;
				while ( ns != null )
				{
					// getClassInstance() throws exception if not there
					if ( ns.classInstance != null 
						&& ns.classInstance.getClass() == clas 
					)
						return completeRound( 
							field, suffix(evalName), ns.classInstance );
					ns=ns.getParent();
				}
				throw new UtilEvalError(
					""Can't find enclosing 'this' instance of class: ""+clas);
			}
			Object obj = null;
			// static field?
			try {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug(""Name call to getStaticField, class: "" 
						+clas+"", field:""+field);
				obj = Reflect.getStaticField(clas, field);
			} catch( ReflectError e ) { 
				if ( Interpreter.DEBUG ) 
					Interpreter.debug(""field reflect error: ""+e);
			}
			// inner class?
			if ( obj == null ) {
				String iclass = clas.getName()+""$""+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}
			if ( obj == null )
				throw new UtilEvalError(
					""No static field or inner class: "" 
					+ field + "" of "" + clas );
			return completeRound( field, suffix(evalName), obj );
		}
		/*
			If we've fallen through here we are no longer resolving to
			a class type.
		*/
		if ( forceClass )
			throw new UtilEvalError( 
				value +"" does not resolve to a class name."" );
		/* 
			Some kind of field access?
		*/
		String field = prefix(evalName, 1);
		// length access on array? 
		if ( field.equals(""length"") && evalBaseObject.getClass().isArray() )
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			return completeRound( field, suffix(evalName), obj );
		}
		// Check for field on object 
		// Note: could eliminate throwing the exception somehow
		try {
			Object obj = Reflect.getObjectField(evalBaseObject, field);
			return completeRound( field, suffix(evalName), obj );
		} catch(ReflectError e) { /* not a field */ }
		// if we get here we have failed
		throw new UtilEvalError(
			""Cannot access field: "" + field + "", on object: "" + evalBaseObject);
	}
	/**
		Resolve a variable relative to a This reference.
		This is the general variable resolution method, accomodating special
		fields from the This context.  Together the namespace and interpreter
		comprise the This context.  The callstack, if available allows for the
		this.caller construct.  
		Optionally interpret special ""magic"" field names: e.g. interpreter.
		<p/>
		@param callstack may be null, but this is only legitimate in special
		cases where we are sure resolution will not involve this.caller.
		@param namespace the namespace of the this reference (should be the
		same as the top of the stack?
	*/
	Object resolveThisFieldReference( 
		CallStack callstack, NameSpace thisNameSpace, Interpreter interpreter, 
		String varName, boolean specialFieldsVisible ) 
		throws UtilEvalError
	{
		if ( varName.equals(""this"") ) 
		{
			/*
				Somewhat of a hack.  If the special fields are visible (we're
				operating relative to a 'this' type already) dissallow further
				.this references to prevent user from skipping to things like
				super.this.caller
			*/
			if ( specialFieldsVisible )
				throw new UtilEvalError(""Redundant to call .this on This type"");
			// Allow getThis() to work through BlockNameSpace to the method
			// namespace
	// XXX re-eval this... do we need it?
			This ths = thisNameSpace.getThis( interpreter );
			thisNameSpace= ths.getNameSpace();
			Object result = ths;
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				if ( isCompound( evalName ) )
					result = classNameSpace.getThis( interpreter );
				else
					result = classNameSpace.getClassInstance();
			}
			return result;
		}
		/*
			Some duplication for ""super"".  See notes for ""this"" above
			If we're in an enclsing class instance and have a superclass
			instance our super is the superclass instance.
		*/
		if ( varName.equals(""super"") ) 
		{
			//if ( specialFieldsVisible )
			//throw new UtilEvalError(""Redundant to call .this on This type"");
			// Allow getSuper() to through BlockNameSpace to the method's super
			This ths = thisNameSpace.getSuper( interpreter );
			thisNameSpace = ths.getNameSpace();
			// super is now the closure's super or class instance
	// XXXX re-evaluate this
	// can getSuper work by itself now?
			// If we're a class instance and the parent is also a class instance
			// then super means our parent.
			if ( 
				thisNameSpace.getParent() != null 
				&& thisNameSpace.getParent().isClass
			)
				ths = thisNameSpace.getParent().getThis( interpreter );
			return ths;
		}
		Object obj = null;
		if ( varName.equals(""global"") )
			obj = thisNameSpace.getGlobal( interpreter );
		if ( obj == null && specialFieldsVisible ) 
		{
			if (varName.equals(""namespace""))
				obj = thisNameSpace;
			else if (varName.equals(""variables""))
				obj = thisNameSpace.getVariableNames();
			else if (varName.equals(""methods""))
				obj = thisNameSpace.getMethodNames();
			else if ( varName.equals(""interpreter"") )
				if ( lastEvalName.equals(""this"") )
					obj = interpreter;
				else
					throw new UtilEvalError(
						""Can only call .interpreter on literal 'this'"");
		}
		if ( obj == null && specialFieldsVisible && varName.equals(""caller"") )
		{
			if ( lastEvalName.equals(""this"") || lastEvalName.equals(""caller"") ) 
			{
				// get the previous context (see notes for this class)
				if ( callstack == null )
					throw new InterpreterError(""no callstack"");
				obj = callstack.get( ++callstackDepth ).getThis( 
					interpreter ); 
			}
			else
				throw new UtilEvalError(
				""Can only call .caller on literal 'this' or literal '.caller'"");
			// early return
			return obj;
		}
		if ( obj == null && specialFieldsVisible 
			&& varName.equals(""callstack"") )
		{
			if ( lastEvalName.equals(""this"") ) 
			{
				// get the previous context (see notes for this class)
				if ( callstack == null )
					throw new InterpreterError(""no callstack"");
				obj = callstack;
			}
			else
				throw new UtilEvalError(
				""Can only call .callstack on literal 'this'"");
		}
		if ( obj == null )
			obj = thisNameSpace.getVariable(varName);
		if ( obj == null )
			throw new InterpreterError(""null this field ref:""+varName);
		return obj;
	}
	/**
		@return the enclosing class body namespace or null if not in a class.
	*/
	static NameSpace getClassNameSpace( NameSpace thisNameSpace ) 
	{
		NameSpace classNameSpace = null;
		// is a class instance
		//if ( thisNameSpace.classInstance != null )
		if ( thisNameSpace.isClass )
			return thisNameSpace;
		if ( thisNameSpace.isMethod 
			&& thisNameSpace.getParent() != null 
			//&& thisNameSpace.getParent().classInstance != null
			&& thisNameSpace.getParent().isClass
		)
			return thisNameSpace.getParent();
		return null;
	}
	/**
		Check the cache, else use toObject() to try to resolve to a class
		identifier.  
		@throws ClassNotFoundException on class not found.
		@throws ClassPathException (type of EvalError) on special case of 
		ambiguous unqualified name after super import. 
	*/
	synchronized public Class toClass() 
		throws ClassNotFoundException, UtilEvalError
	{
		if ( asClass != null )
			return asClass;
		reset();
		// ""var"" means untyped, return null class
		if ( evalName.equals(""var"") )
			return asClass = null;
		/* Try straightforward class name first */
		Class clas = namespace.getClass( evalName );
		if ( clas == null ) 
		{
			/* 
				Try toObject() which knows how to work through inner classes
				and see what we end up with 
			*/
			Object obj = null;
			try {
				// Null interpreter and callstack references.
				// class only resolution should not require them.
				obj = toObject( null, null, true );  
			} catch ( UtilEvalError  e ) { }; // couldn't resolve it
			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}
		if ( clas == null )
			throw new ClassNotFoundException(
				""Class: "" + value+ "" not found in namespace"");
		asClass = clas;
		return asClass;
	}
	/*
	*/
	synchronized public LHS toLHS( 
		CallStack callstack, Interpreter interpreter )
		throws UtilEvalError
	{
		// Should clean this up to a single return statement
		reset();
		LHS lhs;
		// Simple (non-compound) variable assignment e.g. x=5;
		if ( !isCompound(evalName) ) 
		{
			if ( evalName.equals(""this"") )
				throw new UtilEvalError(""Can't assign to 'this'."" );
			// Interpreter.debug(""Simple var LHS..."");
			lhs = new LHS( namespace, evalName, false/*bubble up if allowed*/);
			return lhs;
		}
		// Field e.g. foo.bar=5;
		Object obj = null;
		try {
			while( evalName != null && isCompound( evalName ) )
			{
				obj = consumeNextObjectField( callstack, interpreter, 
					false/*forcclass*/, true/*autoallocthis*/ );
			}
		} 
		catch( UtilEvalError e ) {
			throw new UtilEvalError( ""LHS evaluation: "" + e.getMessage() );
		}
		// Finished eval and its a class.
		if ( evalName == null && obj instanceof ClassIdentifier )
			throw new UtilEvalError(""Can't assign to class: "" + value );
		if ( obj == null )
			throw new UtilEvalError(""Error in LHS: "" + value );
		// e.g. this.x=5;  or someThisType.x=5;
		if ( obj instanceof This )
		{
			// dissallow assignment to magic fields
			if ( 
				evalName.equals(""namespace"")
				|| evalName.equals(""variables"")
				|| evalName.equals(""methods"")
				|| evalName.equals(""caller"")
			)
				throw new UtilEvalError(
					""Can't assign to special variable: ""+evalName );
			Interpreter.debug(""found This reference evaluating LHS"");
			/*
				If this was a literal ""super"" reference then we allow recursion
				in setting the variable to get the normal effect of finding the
				nearest definition starting at the super scope.  On any other
				resolution qualified by a 'this' type reference we want to set
				the variable directly in that scope. e.g. this.x=5;  or 
				someThisType.x=5;
				In the old scoping rules super didn't do this.
			*/
			boolean localVar = !lastEvalName.equals(""super"");
			return new LHS( ((This)obj).namespace, evalName, localVar );
		}
		if ( evalName != null )
		{
			try {
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					lhs = Reflect.getLHSStaticField(clas, evalName);
					return lhs;
				} else {
					lhs = Reflect.getLHSObjectField(obj, evalName);
					return lhs;
				}
			} catch(ReflectError e) {
				throw new UtilEvalError(""Field access: ""+e);
			}
		}
		throw new InterpreterError(""Internal error in lhs..."");
	}
    /**
		Invoke the method identified by this name.
		Performs caching of method resolution using SignatureKey.
		<p>
        Name contains a wholely unqualfied messy name; resolve it to 
		( object | static prefix ) + method name and invoke.
		<p>
        The interpreter is necessary to support 'this.interpreter' references
		in the called code. (e.g. debug());
		<p>
		<pre>
        Some cases:
            // dynamic
            local();
            myVariable.foo();
            myVariable.bar.blah.foo();
            // static
            java.lang.Integer.getInteger(""foo"");
		</pre>
    */
    public Object invokeMethod(
		Interpreter interpreter, Object[] args, CallStack callstack,
		SimpleNode callerInfo
	)
        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException
    {
        String methodName = Name.suffix(value, 1);
		BshClassManager bcm = interpreter.getClassManager();
		NameSpace namespace = callstack.top();
		// Optimization - If classOfStaticMethod is set then we have already 
		// been here and determined that this is a static method invocation.
		// Note: maybe factor this out with path below... clean up.
        if ( classOfStaticMethod != null )
		{
			return Reflect.invokeStaticMethod( 
				bcm, classOfStaticMethod, methodName, args );
		}
		if ( !Name.isCompound(value) )
			return invokeLocalMethod( 
				interpreter, args, callstack, callerInfo );
		// Note: if we want methods declared inside blocks to be accessible via
		// this.methodname() inside the block we could handle it here as a
		// special case.  See also resolveThisFieldReference() special handling
		// for BlockNameSpace case.  They currently work via the direct name
		// e.g. methodName().
        String prefix = Name.prefix(value);
		// Superclass method invocation? (e.g. super.foo())
		if ( prefix.equals(""super"") && Name.countParts(value) == 2 )
		{
			NameSpace classNameSpace = getClassNameSpace( namespace );
			if ( classNameSpace != null )
			{
				Object instance = classNameSpace.getClassInstance();
				return ClassGenerator.getClassGenerator()
					.invokeSuperclassMethod( bcm, instance, methodName, args );
			}
		}
        // Find target object or class identifier
        Name targetName = namespace.getNameResolver( prefix );
        Object obj = targetName.toObject( callstack, interpreter );
		if ( obj == Primitive.VOID ) 
			throw new UtilEvalError( ""Attempt to resolve method: ""+methodName
					+""() on undefined variable or class name: ""+targetName);
        // if we've got an object, resolve the method
        if ( !(obj instanceof ClassIdentifier) ) {
            if (obj instanceof Primitive) {
                if (obj == Primitive.NULL)
                    throw new UtilTargetError( new NullPointerException( 
						""Null Pointer in Method Invocation"" ) );
                // some other primitive
                // should avoid calling methods on primitive, as we do
                // in Name (can't treat primitive like an object message)
                // but the hole is useful right now.
				if ( Interpreter.DEBUG )
                	interpreter.debug(
					""Attempt to access method on primitive..."" 
					+ "" allowing bsh.Primitive to peek through for debugging"");
            }
            // found an object and it's not an undefined variable
            return Reflect.invokeObjectMethod(
				obj, methodName, args, interpreter, callstack, callerInfo );
        }
		// It's a class
        // try static method
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug(""invokeMethod: trying static - "" + targetName);
        Class clas = ((ClassIdentifier)obj).getTargetClass();
		// cache the fact that this is a static method invocation on this class
		classOfStaticMethod = clas;
        if ( clas != null )
			return Reflect.invokeStaticMethod( bcm, clas, methodName, args );
        // return null; ???
		throw new UtilEvalError(""invokeMethod: unknown target: "" + targetName);
    }
	/**
		Invoke a locally declared method or a bsh command.
		If the method is not already declared in the namespace then try
		to load it as a resource from the imported command path (e.g.
		/bsh/commands)
	*/
	/*
		Note: the bsh command code should probably not be here...  we need to
		scope it by the namespace that imported the command... so it probably
		needs to be integrated into NameSpace.
	*/
    private Object invokeLocalMethod( 
		Interpreter interpreter, Object[] args, CallStack callstack,
		SimpleNode callerInfo
	)
        throws EvalError/*, ReflectError, InvocationTargetException*/
    {
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug( ""invokeLocalMethod: "" + value );
		if ( interpreter == null )
			throw new InterpreterError(
				""invokeLocalMethod: interpreter = null"");
		String commandName = value;
		Class [] argTypes = Types.getTypes( args );
        // Check for existing method
        BshMethod meth = null;
		try {
			meth = namespace.getMethod( commandName, argTypes );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(
				""Local method invocation"", callerInfo, callstack );
		}
		// If defined, invoke it
        if ( meth != null )
			return meth.invoke( args, interpreter, callstack, callerInfo );
		BshClassManager bcm = interpreter.getClassManager();
		// Look for a BeanShell command
		Object commandObject;
		try {
			commandObject = namespace.getCommand( 
				commandName, argTypes, interpreter );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(""Error loading command: "", 
				callerInfo, callstack );
		}
		// should try to print usage here if nothing found
		if ( commandObject == null )
		{
			// Look for a default invoke() handler method in the namespace
			// Note: this code duplicates that in This.java... should it?
			// Call on 'This' can never be a command
			BshMethod invokeMethod = null;
			try {
				invokeMethod = namespace.getMethod( 
					""invoke"", new Class [] { null, null } );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					""Local method invocation"", callerInfo, callstack );
			}
			if ( invokeMethod != null )
				return invokeMethod.invoke( 
					new Object [] { commandName, args }, 
					interpreter, callstack, callerInfo );
            throw new EvalError( ""Command not found: "" 
				+StringUtil.methodString( commandName, argTypes ), 
				callerInfo, callstack );
		}
		if ( commandObject instanceof BshMethod )
			return ((BshMethod)commandObject).invoke( 
				args, interpreter, callstack, callerInfo );
		if ( commandObject instanceof Class )
			try {
				return Reflect.invokeCompiledCommand( 
					((Class)commandObject), args, interpreter, callstack );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(""Error invoking compiled command: "",
				callerInfo, callstack );
			}
		throw new InterpreterError(""invalid command type"");
    }
/*
	private String getHelp( String name )
		throws UtilEvalError
	{
		try {
			// should check for null namespace here
			return get( ""bsh.help.""+name, null/interpreter/ );
		} catch ( Exception e ) {
			return ""usage: ""+name;
		}
	}
	private String getHelp( Class commandClass )
		throws UtilEvalError
	{
        try {
            return (String)Reflect.invokeStaticMethod(
				null/bcm/, commandClass, ""usage"", null );
        } catch( Exception e )
			return ""usage: ""+name;
		}
	}
*/
	// Static methods that operate on compound ('.' separated) names
	// I guess we could move these to StringUtil someday
	public static boolean isCompound(String value)
	{
		return value.indexOf('.') != -1 ;
		//return countParts(value) > 1;
	}
	static int countParts(String value)
	{
		if(value == null)
			return 0;
		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}
	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;
		return prefix(value, countParts(value) - 1);
	}
	static String prefix(String value, int parts)
	{
		if (parts < 1 )
			return null;
		int count = 0;
		int index = -1;
		while( ((index = value.indexOf('.', index + 1)) != -1) 
			&& (++count < parts) )
		{ ; }
		return (index == -1) ? value : value.substring(0, index);
	}
	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;
		return suffix(name, countParts(name) - 1);
	}
	public static String suffix(String value, int parts)
	{
		if (parts < 1)
			return null;
		int count = 0;
		int index = value.length() + 1;
		while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 
			&& (++count < parts) );
		return (index == -1) ? value : value.substring(index + 1);
	}
	// end compound name routines
	public String toString() { return value; }
}
"
bsh.NameSource,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.*;
/**
	This interface supports name completion, which is used primarily for 
	command line tools, etc.  It provides a flat source of ""names"" in a 
	space.  For example all of the classes in the classpath or all of the 
	variables in a namespace (or all of those).
	<p>
	NameSource is the lightest weight mechanism for sources which wish to
	support name completion.  In the future it might be better for NameSpace
	to implement NameCompletion directly in a more native and efficient 
	fasion.  However in general name competion is used for human interaction
	and therefore does not require high performance.
	<p>
	@see bsh.util.NameCompletion
	@see bsh.util.NameCompletionTable
*/
public interface NameSource 
{
	public String [] getAllNames();
	public void addNameSourceListener( NameSource.Listener listener );
	public static interface Listener {
		public void nameSourceChanged( NameSource src );
		/**
			Provide feedback on the progress of mapping a namespace
			@param msg is an update about what's happening
			@perc is an integer in the range 0-100 indicating percentage done
		public void nameSourceMapping( 
			NameSource src, String msg, int perc );
		*/
	}
}
"
bsh.NameSpace,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package	bsh;
import java.util.*;
import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Field;
/**
    A namespace	in which methods, variables, and imports (class names) live.  
	This is package public because it is used in the implementation of some 
	bsh commands.  However for normal use you should be using methods on 
	bsh.Interpreter to interact with your scripts.
	<p>
	A bsh.This object is a thin layer over a NameSpace that associates it with
	an Interpreter instance.  Together they comprise a Bsh scripted object 
	context.
	<p>
	Note: I'd really like to use collections here, but we have to keep this
	compatible with JDK1.1 
*/
/*
	Thanks to Slava Pestov (of jEdit fame) for import caching enhancements.
	Note: This class has gotten too big.  It should be broken down a bit.
*/
public class NameSpace 
	implements java.io.Serializable, BshClassManager.Listener, 
	NameSource
{
	public static final NameSpace JAVACODE = 
		new NameSpace((BshClassManager)null, ""Called from compiled Java code."");
	static {
		JAVACODE.isMethod = true;
	}
	// Begin instance data
	// Note: if we add something here we should reset it in the clear() method.
	/**
		The name of this namespace.  If the namespace is a method body
		namespace then this is the name of the method.  If it's a class or
		class instance then it's the name of the class.
	*/
	private String nsName; 
    private NameSpace parent;
    private Hashtable variables;
    private Hashtable methods;
    protected Hashtable importedClasses;
    private Vector importedPackages;
	private Vector importedObjects;
	private Vector importedStatic;
    private Vector importedCommands;
	private String packageName;
	transient private BshClassManager classManager;
	// See notes in getThis()
    private This thisReference;
	/** Name resolver objects */
    private Hashtable names;
	/** The node associated with the creation of this namespace.
		This is used support getInvocationLine() and getInvocationText(). */
	SimpleNode callerInfoNode;
	/** 
		Note that the namespace is a method body namespace.  This is used for
		printing stack traces in exceptions.  
	*/
	boolean isMethod;
	/**
		Note that the namespace is a class body or class instance namespace.  
		This is used for controlling static/object import precedence, etc.
	*/
	/*
		Note: We will ll move this behavior out to a subclass of 
		NameSpace, but we'll start here.
	*/
	boolean isClass;
	Class classStatic;	
	Object classInstance;
	void setClassStatic( Class clas ) {
		this.classStatic = clas;
		importStatic( clas );
	}
	void setClassInstance( Object instance ) {
		this.classInstance = instance;
		importObject( instance );
	}
	Object getClassInstance()
		throws UtilEvalError
	{
		if ( classInstance != null )
			return classInstance;
		if ( classStatic != null 
			//|| ( getParent()!=null && getParent().classStatic != null ) 
		)
			throw new UtilEvalError(
				""Can't refer to class instance from static context."");
		else
			throw new InterpreterError( 
				""Can't resolve class instance 'this' in: ""+this);
	}
	/**
		Local class cache for classes resolved through this namespace using 
		getClass() (taking into account imports).  Only unqualified class names
		are cached here (those which might be imported).  Qualified names are 
		always absolute and are cached by BshClassManager.
	*/
    transient private Hashtable classCache;
	// End instance data
	// Begin constructors
	/**
		@parent the parent namespace of this namespace.  Child namespaces
		inherit all variables and methods of their parent and can (of course)
		override / shadow them.
	*/
    public NameSpace( NameSpace parent, String name ) 
	{
		// Note: in this case parent must have a class manager.
		this( parent, null, name );
	}
    public NameSpace( BshClassManager classManager, String name ) 
	{
		this( null, classManager, name );
	}
    public NameSpace( 
		NameSpace parent, BshClassManager classManager, String name ) 
	{
		// We might want to do this here rather than explicitly in Interpreter
		// for global (see also prune())
		//if ( classManager == null && (parent == null ) )
			// create our own class manager?
		setName(name);
		setParent(parent);
		setClassManager( classManager );
		// Register for notification of classloader change
		if ( classManager != null )
			classManager.addListener(this);
    }
	// End constructors
	public void setName( String name ) {
		this.nsName = name;
	}
	/**
		The name of this namespace.  If the namespace is a method body
		namespace then this is the name of the method.  If it's a class or
		class instance then it's the name of the class.
	*/
	public String getName() {
		return this.nsName;
	}
	/**
		Set the node associated with the creation of this namespace.
		This is used in debugging and to support the getInvocationLine()
		and getInvocationText() methods.
	*/
	void setNode( SimpleNode node ) {
		callerInfoNode = node;
	}
	/**
	*/
	SimpleNode getNode() 
	{
		if ( callerInfoNode != null )
			return callerInfoNode;
		if ( parent != null )
			return parent.getNode();
		else
			return null;
	}
	/**
		Resolve name to an object through this namespace.
	*/
	public Object get( String name, Interpreter interpreter ) 
		throws UtilEvalError 
	{
		CallStack callstack = new CallStack( this );
		return getNameResolver( name ).toObject( callstack, interpreter );
	}
	public void setVariable(String name, Object value) throws UtilEvalError
        {
                setVariable(name,value,false);
        }
	/**
		Set the variable through this namespace.
		This method obeys the LOCALSCOPING property to determine how variables
		are set.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		<p>
		Setting a new variable (which didn't exist before) or removing
		a variable causes a namespace change.
		@param strictJava specifies whether strict java rules are applied.
	*/
    public void	setVariable( String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		// if localscoping switch follow strictJava, else recurse
		boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;
		setVariable( name, value, strictJava, recurse );
	}
	/**
		Set a variable explicitly in the local scope.
	*/
    void setLocalVariable( 
		String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		setVariable( name, value, strictJava, false/*recurse*/ );
	}
	/**
		Set the value of a the variable 'name' through this namespace.
		The variable may be an existing or non-existing variable.
		It may live in this namespace or in a parent namespace if recurse is 
		true.
		<p>
		Note: This method is not public and does *not* know about LOCALSCOPING.
		Its caller methods must set recurse intelligently in all situations 
		(perhaps based on LOCALSCOPING).
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		<p>
		Setting a new variable (which didn't exist before) or removing
		a variable causes a namespace change.
		@param strictJava specifies whether strict java rules are applied.
		@param recurse determines whether we will search for the variable in
		  our parent's scope before assigning locally.
	*/
    void setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		if ( variables == null )
			variables =	new Hashtable();
		// primitives should have been wrapped
		if ( value == null ) {
			// don't break jEdit core and plugins!
			//throw new InterpreterError(""null variable value"");
			unsetVariable(name);
			return;
		}
		// Locate the variable definition if it exists.
		Variable existing = getVariableImpl( name, recurse );
		// Found an existing variable here (or above if recurse allowed)
		if ( existing != null )
		{
			try {
				existing.setValue( value, Variable.ASSIGNMENT );
			} catch ( UtilEvalError e ) {
				throw new UtilEvalError(
					""Variable assignment: "" + name + "": "" + e.getMessage());
			}
		} else 
		// No previous variable definition found here (or above if recurse)
		{
			if ( strictJava )
				throw new UtilEvalError(
					""(Strict Java mode) Assignment to undeclared variable: ""
					+name );
			// If recurse, set global untyped var, else set it here.	
			//NameSpace varScope = recurse ? getGlobal() : this;
			// This modification makes default allocation local
			NameSpace varScope = this;
			varScope.variables.put( 
				name, new Variable( name, value, null/*modifiers*/ ) );
			// nameSpaceChanged() on new variable addition
			nameSpaceChanged();
    	}
	}
	/**
		Remove the variable from the namespace.
	*/
	public void unsetVariable( String name )
	{
		variables.remove( name );
		nameSpaceChanged();
	}
	/**
		Get the names of variables defined in this namespace.
		(This does not show variables in parent namespaces).
	*/
	public String [] getVariableNames() {
		if ( variables == null )
			return new String [0];
		else
			return enumerationToStringArray( variables.keys() );
	}
	/**
		Get the names of methods declared in this namespace.
		(This does not include methods in parent namespaces).
	*/
	public String [] getMethodNames() 
	{
		if ( methods == null )
			return new String [0];
		else
			return enumerationToStringArray( methods.keys() );
	}
	/**
		Get the methods defined in this namespace.
		(This does not show methods in parent namespaces).
		Note: This will probably be renamed getDeclaredMethods()
	*/
	public BshMethod [] getMethods() 
	{
		if ( methods == null )
			return new BshMethod [0];
		else
			return flattenMethodCollection( methods.elements() );
	}
	private String [] enumerationToStringArray( Enumeration e ) {
		Vector v = new Vector();
		while ( e.hasMoreElements() )
			v.addElement( e.nextElement() );
		String [] sa = new String [ v.size() ];
		v.copyInto( sa );
		return sa;
	}
	/**
		Flatten the vectors of overloaded methods to a single array.
		@see #getMethods()
	*/
    private BshMethod [] flattenMethodCollection( Enumeration e ) {
        Vector v = new Vector();
        while ( e.hasMoreElements() ) {
            Object o = e.nextElement();
            if ( o instanceof BshMethod )
                v.addElement( o );
            else {
                Vector ov = (Vector)o;
                for(int i=0; i<ov.size(); i++)
                    v.addElement( ov.elementAt( i ) );
            }
        }
        BshMethod [] bma = new BshMethod [ v.size() ];
        v.copyInto( bma );
        return bma;
    }
	/**
		Get the parent namespace.
		Note: this isn't quite the same as getSuper().
		getSuper() returns 'this' if we are at the root namespace.
	*/
	public NameSpace getParent() {
		return parent;
	}
	/**
		Get the parent namespace' This reference or this namespace' This
		reference if we are the top.
	*/
    public This getSuper( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getThis( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
	/**
		Get the top level namespace or this namespace if we are the top.
		Note: this method should probably return type bsh.This to be consistent
		with getThis();
	*/
    public This getGlobal( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getGlobal( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
	/**
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  It handles things like the interface types the bsh object
		supports and aspects of method invocation on it.  
		<p>
		The declaringInterpreter is here to support callbacks from Java through
		generated proxies.  The scripted object ""remembers"" who created it for
		things like printing messages and other per-interpreter phenomenon
		when called externally from Java.
	*/
	/*
		Note: we need a singleton here so that things like 'this == this' work
		(and probably a good idea for speed).
		Caching a single instance here seems technically incorrect,
		considering the declaringInterpreter could be different under some
		circumstances.  (Case: a child interpreter running a source() / eval() 
		command ).  However the effect is just that the main interpreter that
		executes your script should be the one involved in call-backs from Java.
		I do not know if there are corner cases where a child interpreter would
		be the first to use a This reference in a namespace or if that would
		even cause any problems if it did...  We could do some experiments
		to find out... and if necessary we could cache on a per interpreter
		basis if we had weak references...  We might also look at skipping 
		over child interpreters and going to the parent for the declaring 
		interpreter, so we'd be sure to get the top interpreter.
	*/
    This getThis( Interpreter declaringInterpreter ) 
	{
		if ( thisReference == null )
			thisReference = This.getThis( this, declaringInterpreter );
		return thisReference;
    }
	public BshClassManager getClassManager() 
	{
		if ( classManager != null )
			return classManager;
		if ( parent != null && parent != JAVACODE )
			return parent.getClassManager();
System.out.println(""experiment: creating class manager"");
		classManager = BshClassManager.createClassManager( null/*interp*/ );
		//Interpreter.debug(""No class manager namespace:"" +this);
		return classManager;
	}
	void setClassManager( BshClassManager classManager ) {
		this.classManager = classManager;
	}
	/**
		Used for serialization
	*/
	public void prune() 
	{
		// Cut off from parent, we must have our own class manager.
		// Can't do this in the run() command (needs to resolve stuff)
		// Should we do it by default when we create a namespace will no
		// parent of class manager?
		if ( this.classManager == null )
// XXX if we keep the createClassManager in getClassManager then we can axe
// this?
			setClassManager( 
				BshClassManager.createClassManager( null/*interp*/ ) );
		setParent( null );
	}
	public void setParent( NameSpace parent ) 
	{
		this.parent = parent;
		// If we are disconnected from root we need to handle the def imports
		if ( parent == null )
			loadDefaultImports();
	}
	/**
		Get the specified variable in this namespace or a parent namespace.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive#unwrap( Object )
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name ) 
		throws UtilEvalError
	{
		return getVariable( name, true );
	}
	/**
		Get the specified variable in this namespace.
		@param recurse If recurse is true then we recursively search through 
		parent namespaces for the variable.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive#unwrap( Object )
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = getVariableImpl( name, recurse );
		return unwrapVariable( var );
    }
	/**
		Locate a variable and return the Variable object with optional 
		recursion through parent name spaces.
		<p/>
		If this namespace is static, return only static variables.
		@return the Variable value or null if it is not defined
	*/
    protected Variable getVariableImpl( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = null;
		// Change import precedence if we are a class body/instance
		// Get imported first.
		if ( var == null && isClass )
			var = getImportedVar( name );
		if ( var == null && variables != null )
			var	= (Variable)variables.get(name);
		// Change import precedence if we are a class body/instance
		if ( var == null && !isClass )
			var = getImportedVar( name );
		// try parent
		if ( recurse && (var == null) && (parent != null) )
			var	= parent.getVariableImpl( name, recurse );
		return var;
    }
	/*
		Get variables declared in this namespace.
	*/
	public Variable [] getDeclaredVariables() 
	{
		if ( variables == null )
			return new Variable[0];
		Variable [] vars = new Variable [ variables.size() ];
		int i=0;
		for( Enumeration e = variables.elements(); e.hasMoreElements(); )
			vars[i++] = (Variable)e.nextElement();
		return vars;
	}
	/**
		Unwrap a variable to its value.
		@return return the variable value.  A null var is mapped to 
			Primitive.VOID
	*/
	protected Object unwrapVariable( Variable var ) 
		throws UtilEvalError
	{
		return (var == null) ? Primitive.VOID :	var.getValue();
	}
	/**
		@deprecated See #setTypedVariable( String, Class, Object, Modifiers )
	*/
    public void	setTypedVariable(
		String	name, Class type, Object value,	boolean	isFinal )
		throws UtilEvalError 
	{
		Modifiers modifiers = new Modifiers();
		if ( isFinal )
			modifiers.addModifier( Modifiers.FIELD, ""final"" );
		setTypedVariable( name, type, value, modifiers );
	}
    /**
		Declare a variable in the local scope and set its initial value.
		Value may be null to indicate that we would like the default value 
		for the variable type. (e.g.  0 for integer types, null for object 
		types).  An existing typed variable may only be set to the same type.
		If an untyped variable of the same name exists it will be overridden 
		with the new typed var.
		The set will perform a Types.getAssignableForm() on the value if 
		necessary.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		@param value If value is null, you'll get the default value for the type
		@param modifiers may be null
    */
    public void	setTypedVariable(
		String	name, Class type, Object value,	Modifiers modifiers )
		throws UtilEvalError 
	{
		//checkVariableModifiers( name, modifiers );
		if ( variables == null )
			variables =	new Hashtable();
		// Setting a typed variable is always a local operation.
		Variable existing = getVariableImpl( name, false/*recurse*/ );
		// Null value is just a declaration
		// Note: we might want to keep any existing value here instead of reset
	/*
	// Moved to Variable
		if ( value == null )
			value = Primitive.getDefaultValue( type );
	*/
		// does the variable already exist?
		if ( existing != null ) 
		{
			// Is it typed?
			if ( existing.getType() != null ) 
			{
				// If it had a different type throw error.
				// This allows declaring the same var again, but not with
				// a different (even if assignable) type.
				if ( existing.getType() != type )
				{
					throw new UtilEvalError( ""Typed variable: ""+name
						+"" was previously declared with type: "" 
						+ existing.getType() );
				} else 
				{
					// else set it and return
					existing.setValue( value, Variable.DECLARATION );
					return;
				}
			}
			// Careful here:
			// else fall through to override and install the new typed version
		} 
		// Add the new typed var
		variables.put( name, new Variable( name, type, value, modifiers ) );
    }
	/**
		Dissallow static vars outside of a class
		@param name is here just to allow the error message to use it
	protected void checkVariableModifiers( String name, Modifiers modifiers )
		throws UtilEvalError
	{
		if ( modifiers!=null && modifiers.hasModifier(""static"") )
			throw new UtilEvalError(
				""Can't declare static variable outside of class: ""+name );
	}
	*/
	/**
		Note: this is primarily for internal use.
		@see Interpreter#source( String )
		@see Interpreter#eval( String )
	*/
    public void	setMethod( String name, BshMethod method )
		throws UtilEvalError
	{
		//checkMethodModifiers( method );
		if ( methods == null )
			methods = new Hashtable();
		Object m = methods.get(name);
		if ( m == null )
			methods.put(name, method);
		else 
		if ( m instanceof BshMethod ) {
			Vector v = new Vector();
			v.addElement( m );
			v.addElement( method );
			methods.put( name, v );
		} else // Vector
			((Vector)m).addElement( method );
    }
	/**
		@see #getMethod( String, Class [], boolean )
		@see #getMethod( String, Class [] )
	*/
    public BshMethod getMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		return getMethod( name, sig, false/*declaredOnly*/ );
	}
	/**
		Get the bsh method matching the specified signature declared in 
		this name space or a parent.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to be familiar
		with BeanShell's use of the Primitive wrapper class.
		@see bsh.Primitive
		@return the BshMethod or null if not found
		@param declaredOnly if true then only methods declared directly in this
			namespace will be found and no inherited or imported methods will
			be visible.
	*/
    public BshMethod getMethod( 
		String name, Class [] sig, boolean declaredOnly ) 
		throws UtilEvalError
	{
		BshMethod method = null;
		// Change import precedence if we are a class body/instance
		// Get import first.
		if ( method == null && isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		Object m = null;
		if ( method == null && methods != null )
		{
			m = methods.get(name);
			// m contains either BshMethod or Vector of BshMethod
			if ( m != null ) 
			{
				// unwrap 
				BshMethod [] ma;
				if ( m instanceof Vector ) 
				{
					Vector vm = (Vector)m;
					ma = new BshMethod[ vm.size() ];
					vm.copyInto( ma );
				} else
					ma = new BshMethod[] { (BshMethod)m };
				// Apply most specific signature matching
				Class [][] candidates = new Class[ ma.length ][];
				for( int i=0; i< ma.length; i++ )
					candidates[i] = ma[i].getParameterTypes();
				int match = 
					Reflect.findMostSpecificSignature( sig, candidates );
				if ( match != -1 )
					method = ma[match];
			}
		}
		if ( method == null && !isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		// try parent
		if ( !declaredOnly && (method == null) && (parent != null) )
			return parent.getMethod( name, sig );
		return method;
    }
	/**
		Import a class name.
		Subsequent imports override earlier ones
	*/
    public void	importClass(String name)
    {
		if ( importedClasses == null )
			importedClasses = new Hashtable();
		importedClasses.put( Name.suffix(name, 1), name );
		nameSpaceChanged();
    }
	/**
		subsequent imports override earlier ones
	*/
    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new Vector();
		// If it exists, remove it and add it at the end (avoid memory leak)
		if ( importedPackages.contains( name ) )
			importedPackages.remove( name );
		importedPackages.addElement(name);
		nameSpaceChanged();
    }
    static class CommandPathEntry
	{
		String path;
		Class clas;
		CommandPathEntry(String path, Class clas)
		{
			this.path = path;
			this.clas = clas;
		}
	}
	/**
		Adds a URL to the command path.
	*/
	public void addCommandPath(String path, Class clas)
	{
		if(importedCommands == null)
			importedCommands = new Vector();
		if(!path.endsWith(""/""))
			path = path + ""/"";
		importedCommands.addElement(new CommandPathEntry(path,clas));
	}
	/**
		Remove a URLfrom the command path.
	*/
	public void removeCommandPath(String path, Class clas)
	{
		if(importedCommands == null)
			return;
		for(int i = 0; i < importedCommands.size(); i++)
		{
			CommandPathEntry entry = (CommandPathEntry)importedCommands
				.elementAt(i);
			if(entry.path.equals(path) && entry.clas == clas)
			{
				importedCommands.removeElementAt(i);
				return;
			}
		}
	}
	/**
		Looks up a command.
	*/
	public InputStream getCommand(String name)
	{
		if(importedCommands != null)
		{
			String extName = name + "".bsh"";
			for(int i = importedCommands.size() - 1; i >= 0; i--)
			{
				CommandPathEntry entry = (CommandPathEntry)importedCommands
					.elementAt(i);
				InputStream in = entry.clas.getResourceAsStream(entry.path + extName);
				if(in != null)
					return in;
			}
		}
		if(parent == null)
			return null;
		else
			return parent.getCommand(name);
	}
	/**
		A command is a scripted method or compiled command class implementing a 
		specified method signature.  Commands are loaded from the classpath
		and may be imported using the importCommands() method.
		<p/>
		This method searches the imported commands packages for a script or
		command object corresponding to the name of the method.  If it is a
		script the script is sourced into this namespace and the BshMethod for
		the requested signature is returned.  If it is a compiled class the
		class is returned.  (Compiled command classes implement static invoke()
		methods).
		<p/>
		The imported packages are searched in reverse order, so that later
		imports take priority.
		Currently only the first object (script or class) with the appropriate
		name is checked.  If another, overloaded form, is located in another
		package it will not currently be found.  This could be fixed.
		<p/>
		@return a BshMethod, Class, or null if no such command is found.
		@param name is the name of the desired command method
		@param argTypes is the signature of the desired command method.
		@throws UtilEvalError if loadScriptedCommand throws UtilEvalError
			i.e. on errors loading a script that was found
	*/
	public Object getCommand( 	
		String name, Class [] argTypes, Interpreter interpreter ) 
		throws UtilEvalError
	{
		if (Interpreter.DEBUG) Interpreter.debug(""getCommand: ""+name);
		BshClassManager bcm = interpreter.getClassManager();
		InputStream in = getCommand( name );
		if ( in != null )
			return loadScriptedCommand( 
				in, name, argTypes, name, interpreter );
		/* // Chop leading ""/"" and change ""/"" to "".""
		String className;
		if ( path.equals(""/"") )
			className = name;
		else
			className = path.substring(1).replace('/','.') +"".""+name;
		Class clas = bcm.classForName( className );
		if ( clas != null )
			return clas; */
		if ( parent != null )
			return parent.getCommand( name, argTypes, interpreter );
		else
			return null;
	}
	protected BshMethod getImportedMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		// Try object imports
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.elementAt(i);
			Class clas = object.getClass();
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, false/*onlyStatic*/ );
			if ( method != null )
				return new BshMethod( method, object );
		}
		// Try static imports
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = (Class)importedStatic.elementAt(i);
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, true/*onlyStatic*/ );
			if ( method != null )
				return new BshMethod( method, null/*object*/ );
		}
		return null;
	}
	protected Variable getImportedVar( String name ) 
		throws UtilEvalError
	{
		// Try object imports
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.elementAt(i);
			Class clas = object.getClass();
			Field field = Reflect.resolveJavaField( 
				clas, name, false/*onlyStatic*/ );
			if ( field != null )
				return new Variable( 
					name, field.getType(), new LHS( object, field ) );
		}
		// Try static imports
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = (Class)importedStatic.elementAt(i);
			Field field = Reflect.resolveJavaField( 
				clas, name, true/*onlyStatic*/ );
			if ( field != null )
				return new Variable( name, field.getType(), new LHS( field ) );
		}
		return null;
	}
	/**
		Load a command script from the input stream and find the BshMethod in
		the target namespace.
		@throws UtilEvalError on error in parsing the script or if the the
			method is not found after parsing the script.
	*/
	/*
		If we want to support multiple commands in the command path we need to
		change this to not throw the exception.
	*/
	private BshMethod loadScriptedCommand( 
		InputStream in, String name, Class [] argTypes, String resourcePath, 
		Interpreter interpreter )
		throws UtilEvalError
	{
		try {
			interpreter.eval( 
				new InputStreamReader(in), this, resourcePath );
		} catch ( EvalError e ) {
		/* 
			Here we catch any EvalError from the interpreter because we are
			using it as a tool to load the command, not as part of the
			execution path.
		*/
			Interpreter.debug( e.toString() );
			throw new UtilEvalError( 
				""Error loading script: ""+ e.getMessage());
		}
		// Look for the loaded command 
		BshMethod meth = getMethod( name, argTypes );
		/*
		if ( meth == null )
			throw new UtilEvalError(""Loaded resource: "" + resourcePath +
				""had an error or did not contain the correct method"" );
		*/
		return meth;
	}
	/**
		Helper that caches class.
	*/
	void cacheClass( String name, Class c ) {
		if ( classCache == null ) {
			classCache = new Hashtable();
			//cacheCount++; // debug
		}
		classCache.put(name, c);
	}
	/**
		Load a class through this namespace taking into account imports.
		The class search will proceed through the parent namespaces if
		necessary.
		@return null if not found.
	*/
    public Class getClass( String name )
		throws UtilEvalError
    {
		Class c = getClassImpl(name);
		if ( c != null )
			return c;
		else
			// implement the recursion for getClassImpl()
			if ( parent != null )
				return parent.getClass( name );
			else
				return null;
	}
	/**
		Implementation of getClass() 
		Load a class through this namespace taking into account imports.
		<p>
		Check the cache first.  If an unqualified name look for imported 
		class or package.  Else try to load absolute name.
		<p>
		This method implements caching of unqualified names (normally imports).
		Qualified names are cached by the BshClassManager.
		Unqualified absolute class names (e.g. unpackaged Foo) are cached too
		so that we don't go searching through the imports for them each time.
		@return null if not found.
	*/
    private Class getClassImpl( String name )
		throws UtilEvalError
    {
		Class c = null;
		// Check the cache
		if (classCache != null) {
			c =	(Class)classCache.get(name);
			if ( c != null )
				return c;
		}
		// Unqualified (simple, non-compound) name
		boolean unqualifiedName = !Name.isCompound(name);
		// Unqualified name check imported
		if ( unqualifiedName ) 
		{
			// Try imported class
			if ( c == null )
				c = getImportedClassImpl( name );
			// if found as imported also cache it
			if ( c != null ) {
				cacheClass( name, c );
				return c;
			}
		}
		// Try absolute
		c = classForName( name );
		if ( c != null ) {
			// Cache unqualified names to prevent import check again
			if ( unqualifiedName )
				cacheClass( name, c );
			return c;
		}
		// Not found
		if ( Interpreter.DEBUG ) 
			Interpreter.debug(""getClass(): "" + name	+ "" not	found in ""+this);
		return null;
    }
	/**
		Try to make the name into an imported class.
		This method takes into account only imports (class or package)
		found directly in this NameSpace (no parent chain).
	*/
    private Class getImportedClassImpl( String name )
		throws UtilEvalError
    {
		// Try explicitly imported class, e.g. import foo.Bar;
		String fullname = null;
		if ( importedClasses != null )
			fullname = (String)importedClasses.get(name);
		// not sure if we should really recurse here for explicitly imported
		// class in parent...  
		if ( fullname != null ) 
		{
			/*
				Found the full name in imported classes.
			*/
			// Try to make the full imported name
			Class clas=classForName(fullname);
			// Handle imported inner class case
			if ( clas == null ) 
			{
				// Imported full name wasn't found as an absolute class
				// If it is compound, try to resolve to an inner class.  
				// (maybe this should happen in the BshClassManager?)
				if ( Name.isCompound( fullname ) )
					try {
						clas = getNameResolver( fullname ).toClass();
					} catch ( ClassNotFoundException e ) { /* not a class */ }
				else 
					if ( Interpreter.DEBUG ) Interpreter.debug(
						""imported unpackaged name not found:"" +fullname);
				// If found cache the full name in the BshClassManager
				if ( clas != null ) {
					// (should we cache info in not a class case too?)
					getClassManager().cacheClassInfo( fullname, clas );
					return clas;
				}
			} else
				return clas;
			// It was explicitly imported, but we don't know what it is.
			// should we throw an error here??
			return null;  
		}
		/*
			Try imported packages, e.g. ""import foo.bar.*;""
			in reverse order of import...
			(give later imports precedence...)
		*/
		if ( importedPackages != null )
			for(int i=importedPackages.size()-1; i>=0; i--)
			{
				String s = ((String)importedPackages.elementAt(i)) + ""."" + name;
				Class c=classForName(s);
				if ( c != null )
					return c;
			}
		BshClassManager bcm = getClassManager();
		/*
			Try super import if available
			Note: we do this last to allow explicitly imported classes
			and packages to take priority.  This method will also throw an
			error indicating ambiguity if it exists...
		*/
		if ( bcm.hasSuperImport() ) 
		{
			String s = bcm.getClassNameByUnqName( name );
			if ( s != null )
				return classForName( s );
		}
		return null;
    }
	private Class classForName( String name ) 
	{
		return getClassManager().classForName( name );
	}
	/**
		Implements NameSource
		@return all variable and method names in this and all parent
		namespaces
	*/
	public String [] getAllNames() 
	{
		Vector vec = new Vector();
		getAllNamesAux( vec );
		String [] names = new String [ vec.size() ];
		vec.copyInto( names );
		return names;
	}
	/**
		Helper for implementing NameSource
	*/
	protected void getAllNamesAux( Vector vec ) 
	{
		Enumeration varNames = variables.keys();
		while( varNames.hasMoreElements() )
			vec.addElement( varNames.nextElement() );
		Enumeration methodNames = methods.keys();
		while( methodNames.hasMoreElements() )
			vec.addElement( methodNames.nextElement() );
		if ( parent != null )
			parent.getAllNamesAux( vec );
	}
	Vector nameSourceListeners;
	/**
		Implements NameSource
		Add a listener who is notified upon changes to names in this space.
	*/
	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new Vector();
		nameSourceListeners.addElement( listener );
	}
	/**
		Perform ""import *;"" causing the entire classpath to be mapped.
		This can take a while.
	*/
	public void doSuperImport() 
		throws UtilEvalError
	{
		getClassManager().doSuperImport();
	}
	public String toString() {
		return ""NameSpace: "" 
			+ ( nsName==null
				? super.toString()
				: nsName + "" ("" + super.toString() +"")"" )
			+ ( isClass ? "" (isClass) "" : """" )
			+ ( isMethod ? "" (method) "" : """" )
			+ ( classStatic != null ? "" (class static) "" : """" )
			+ ( classInstance != null ? "" (class instance) "" : """" );
	}
	/*
		For serialization.
		Don't serialize non-serializable objects.
	*/
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException 
	{
		// clear name resolvers... don't know if this is necessary.
		names = null;
		s.defaultWriteObject();
	}
	/**
		Invoke a method in this namespace with the specified args and
		interpreter reference.  No caller information or call stack is
		required.  The method will appear as if called externally from Java.
		<p>
		@see bsh.This.invokeMethod( 
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo, boolean )
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter ) 
		throws EvalError
	{
		return invokeMethod( 
			methodName, args, interpreter, null, null );
	}
	/**
		This method simply delegates to This.invokeMethod();
		<p>
		@see bsh.This.invokeMethod( 
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo )
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter, 
		CallStack callstack, SimpleNode callerInfo ) 
		throws EvalError
	{
		return getThis( interpreter ).invokeMethod( 
			methodName, args, interpreter, callstack, callerInfo,
			false/*declaredOnly*/ );
	}
	/**
		Clear all cached classes and names
	*/
	public void classLoaderChanged() {
		nameSpaceChanged();
	}
	/**
		Clear all cached classes and names
	*/
	public void nameSpaceChanged() {
		classCache = null;
		names = null;
	}
	/**
		Import standard packages.  Currently:
		<pre>
			importClass(""bsh.EvalError"");
			importClass(""bsh.Interpreter"");
			importPackage(""javax.swing.event"");
			importPackage(""javax.swing"");
			importPackage(""java.awt.event"");
			importPackage(""java.awt"");
			importPackage(""java.net"");
			importPackage(""java.util"");
			importPackage(""java.io"");
			importPackage(""java.lang"");
			addCommandPath(""/bsh/commands"",getClass());
		</pre>
	*/
    public void loadDefaultImports()
    {
		/**
			Note: the resolver looks through these in reverse order, per
			precedence rules...  so for max efficiency put the most common
			ones later.
		*/
		importClass(""bsh.EvalError"");
		importClass(""bsh.Interpreter"");
		importPackage(""javax.swing.event"");
		importPackage(""javax.swing"");
		importPackage(""java.awt.event"");
		importPackage(""java.awt"");
		importPackage(""java.net"");
		importPackage(""java.util"");
		importPackage(""java.io"");
		importPackage(""java.lang"");
		addCommandPath(""/bsh/commands"",getClass());
    }
	/**
		This is the factory for Name objects which resolve names within
		this namespace (e.g. toObject(), toClass(), toLHS()).
		<p>
		This was intended to support name resolver caching, allowing 
		Name objects to cache info about the resolution of names for 
		performance reasons.  However this not proven useful yet.  
		<p>
		We'll leave the caching as it will at least minimize Name object
		creation.
		<p>
		(This method would be called getName() if it weren't already used for 
		the simple name of the NameSpace)
		<p>
		This method was public for a time, which was a mistake.  
		Use get() instead.
	*/
	Name getNameResolver( String ambigname ) 
	{
		if ( names == null )
			names = new Hashtable();
		Name name = (Name)names.get( ambigname );
		if ( name == null ) {
			name = new Name( this, ambigname );
			names.put( ambigname, name );
		} 
		return name;
	}
	public int getInvocationLine() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getLineNumber();
		else
			return -1;
	}
	public String getInvocationText() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getText();
		else
			return ""<invoked from Java code>"";
	}
	/**
		This is a helper method for working inside of bsh scripts and commands.
		In that context it is impossible to see a ClassIdentifier object
		for what it is.  Attempting to access a method on a ClassIdentifier
		will look like a static method invocation.  
		This method is in NameSpace for convenience (you don't have to import
		bsh.ClassIdentifier to use it );
	*/
	public static Class identifierToClass( ClassIdentifier ci ) 
	{
		return ci.getTargetClass();
	}
	/**
		Clear all variables, methods, and imports from this namespace.
		If this namespace is the root, it will be reset to the default 
		imports.
		@see #loadDefaultImports()
	*/
	public void clear() 
	{
		variables = null;
		methods = null;
		importedClasses = null;
		importedPackages = null;
		importedCommands = null;
		importedObjects = null;
		if ( parent == null )
			loadDefaultImports();	
    	classCache = null;
		names = null;
	}
	/**
		Import a compiled Java object's methods and variables into this 
		namespace.  When no scripted method / command or variable is found
		locally in this namespace method / fields of the object will be
		checked.  Objects are checked in the order of import with later imports
		taking precedence.
		<p/>
	*/
	/*
		Note: this impor pattern is becoming common... could factor it out into
		an importedObject Vector class.
	*/
	public void importObject( Object obj ) 
	{
		if ( importedObjects == null )
			importedObjects = new Vector();
		// If it exists, remove it and add it at the end (avoid memory leak)
		if ( importedObjects.contains( obj ) )
			importedObjects.remove( obj );
		importedObjects.addElement( obj );
		nameSpaceChanged();
	}
	/**
	*/
	public void importStatic( Class clas ) 
	{
		if ( importedStatic == null )
			importedStatic = new Vector();
		// If it exists, remove it and add it at the end (avoid memory leak)
		if ( importedStatic.contains( clas ) )
			importedStatic.remove( clas );
		importedStatic.addElement( clas );
		nameSpaceChanged();
	}
	/**
		Set the package name for classes defined in this namespace.
		Subsequent sets override the package.
	*/
	void setPackage( String packageName ) 
	{
		this.packageName = packageName;
	}
	String getPackage() 
	{
		if ( packageName != null )
			return packageName;
		if ( parent != null )
			return parent.getPackage();
		return null;
	}
}
"
bsh.Node,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
/* Generated By:JJTree: Do not edit this line. Node.java */
package bsh;
/*
	All BSH nodes must implement this interface.  It provides basic
	machinery for constructing the parent and child relationships
	between nodes.
*/
interface Node extends java.io.Serializable
{
/**
	This method is called after the node has been made the current
	node.  It indicates that child nodes can now be added to it.
*/
	public void jjtOpen();
/**
	This method is called after all the child nodes have been
	added.
*/
	public void jjtClose();
/**
	This pair of methods are used to inform the node of its
	parent.
*/
	public void jjtSetParent(Node n);
	public Node jjtGetParent();
/**
	This method tells the node to add its argument to the node's
	list of children.
*/
	public void jjtAddChild(Node n, int i);
/**
	This method returns a child node.  The children are numbered
	from zero, left to right.
*/
	public Node jjtGetChild(int i);
/**
	Return the number of children the node has.
*/
	public int jjtGetNumChildren();
}
"
bsh.ParseException,"/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
/* 	
	This file was auto generated, but has been modified since then.  If we
	need to regenerate it for some reason we should be careful to look at
	the notes below.  
	All BeanShell modifications are demarcated by ""Begin BeanShell 
	Modification - ... "" and ""End BeanShell Modification - ...""
	Note: Please leave the ^M carriage return in the above auto-generated line 
	or JavaCC will complain about version on Win systems.
	BeanShell Modification to generated file 
	----------------------------------------
	- Added sourceFile attribute
		setErrorSourceFile()
		getErrorSourceFile()
	- Modified getMessage() to print more tersely except on debug
	  (removed ""Was expecting one of...)
	- Added sourceFile info to getMessage()
	- Made ParseException extend EvalError
	- Modified constructors to use EvalError
	- Override 
		getErrorLineNumber()
		getErrorText()
	- Add
		toString()
*/
package bsh;
/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
// Begin BeanShell Modification - public, extend EvalError
public class ParseException extends EvalError {
// End BeanShell Modification - public, extend EvalError
	// Begin BeanShell Modification - sourceFile
	String sourceFile = ""<unknown>"";
	/**
		Used to add source file info to exception
	*/
	public void setErrorSourceFile( String file ) {
		this.sourceFile = file;
	}
	public String getErrorSourceFile() { 
		return sourceFile; 
	}
	// End BeanShell Modification - sourceFile
  /**
   * This constructor is used by the method ""generateParseException""
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields ""currentToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" set.  The boolean
   * flag ""specialConstructor"" is also set to true to indicate that
   * this constructor was used to create this object.
   * This constructor calls its super class with the empty string
   * to force the ""toString"" method of parent class ""Throwable"" to
   * print the error message in the form:
   *     ParseException: <result of getMessage>
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
	// Begin BeanShell Modification - constructor
	this();
	// End BeanShell Modification - constructor
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }
  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class ""Throwable"".  The fields ""errorToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */
  public ParseException() {
	// Begin BeanShell Modification - constructor
	this("""");
	// End BeanShell Modification - constructor
    specialConstructor = false;
  }
  public ParseException(String message) {
	// Begin BeanShell Modification - super constructor args
	// null node, null callstack, ParseException knows where the error is.
	super( message, null, null );
	// End BeanShell Modification - super constructor args
    specialConstructor = false;
  }
  /**
   * This variable determines which constructor was used to create
   * this object and thereby affects the semantics of the
   * ""getMessage"" method (see below).
   */
  protected boolean specialConstructor;
  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.
   */
  public Token currentToken;
  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;
  /**
   * This is a reference to the ""tokenImage"" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;
  // Begin BeanShell Modification - moved body to overloaded getMessage()
  public String	getMessage() {
	return getMessage( false );
  }
  // End BeanShell Modification - moved body to overloaded getMessage()
  /**
   * This method has the standard behavior when this object has been
   * created using the standard constructors.  Otherwise, it uses
   * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser), then this method is called during the printing
   * of the final stack trace, and hence the correct error message
   * gets displayed.
   */
  // Begin BeanShell Modification - added debug param
  public String getMessage( boolean debug ) {
  // End BeanShell Modification - added debug param
    if (!specialConstructor) {
      return super.getMessage();
    }
    String expected = """";
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected += ""..."";
      }
      expected += eol + ""    "";
    }
	// Begin BeanShell Modification - added sourceFile info
    String retval = ""In file: ""+ sourceFile +"" Encountered \"""";
	// End BeanShell Modification - added sourceFile info
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += "" "";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn + ""."" + eol;
	// Begin BeanShell Modification - made conditional on debug
	if ( debug )
	{
		if (expectedTokenSequences.length == 1) {
		  retval += ""Was expecting:"" + eol + ""    "";
		} else {
		  retval += ""Was expecting one of:"" + eol + ""    "";
		}
		retval += expected;
	}
	// End BeanShell Modification - made conditional on debug
    return retval;
  }
  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty(""line.separator"", ""\n"");
  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  protected String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
	// Begin BeanShell Modification - override error methods and toString
	public int getErrorLineNumber() 
	{
		return currentToken.next.beginLine;
	}
	public String getErrorText() { 
		// copied from generated getMessage()
		int	maxSize	= 0;
		for	(int i = 0; i <	expectedTokenSequences.length; i++) {
		  if (maxSize < expectedTokenSequences[i].length)
			maxSize	= expectedTokenSequences[i].length;
		}
		String retval = """";
		Token tok =	currentToken.next;
		for	(int i = 0; i <	maxSize; i++) 
		{
		  if (i != 0) retval += "" "";
		  if (tok.kind == 0) {
			retval += tokenImage[0];
			break;
		  }
		  retval +=	add_escapes(tok.image);
		  tok = tok.next;
		}
		return retval;
	}
	public String toString() {
		return getMessage();
	}
	// End BeanShell Modification - override error methods and toString
}
"
bsh.Parser,"/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package bsh;
import java.io.*;
import java.util.Vector;
/**
	This is the BeanShell parser.  It is used internally by the Interpreter
	class (which is probably what you are looking for).  The parser knows
	only how to parse the structure of the language, it does not understand
	names, commands, etc.
	<p>
	You can use the Parser from the command line to do basic structural 
	validation of BeanShell files without actually executing them. e.g.
	<code><pre>
		java bsh.Parser [ -p ] file [ file ] [ ... ]
	</pre></code>
	<p>
	The -p option causes the abstract syntax to be printed.
	<p>
	From code you'd use the Parser like this:
	<p
	<code><pre>
		Parser parser = new Parser(in);
		while( !(eof=parser.Line()) ) {
			SimpleNode node = parser.popNode();
			// use the node, etc. (See bsh.BSH* classes)
		}
	</pre></code>
*/
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();boolean retainComments = false;
        public void setRetainComments( boolean b ) {
                retainComments = b;
        }
        void jjtreeOpenNodeScope(Node n) {
                ((SimpleNode)n).firstToken = getToken(1);
        }
        void jjtreeCloseNodeScope(Node n) {
                ((SimpleNode)n).lastToken = getToken(0);
        }
        /**
		Re-initialize the input stream and token source.
	*/
        void reInitInput( Reader in ) {
                ReInit(in);
        }
        public SimpleNode popNode()
        {
                if ( jjtree.nodeArity() > 0)  // number of child nodes 
                        return (SimpleNode)jjtree.popNode();
                else
                        return null;
        }
        /**
		Explicitly re-initialize just the token reader.
		This seems to be necessary to avoid certain looping errors when
		reading bogus input.  See Interpreter.
	*/
        void reInitTokenInput( Reader in ) {
                jj_input_stream.ReInit( in,
                        jj_input_stream.getEndLine(),
                        jj_input_stream.getEndColumn() );
        }
        public static void main( String [] args )
                throws IOException, ParseException
        {
                boolean print = false;
                int i=0;
                if ( args[0].equals(""-p"") ) {
                        i++;
                        print=true;
                }
                for(; i< args.length; i++) {
                        Reader in = new FileReader(args[i]);
                        Parser parser = new Parser(in);
                        parser.setRetainComments(true);
                        while( !parser.Line()/*eof*/ )
                                if ( print )
                                        System.out.println( parser.popNode() );
                }
        }
        /**
		Lookahead for the enhanced for statement.  
		Expect ""for"" ""("" and then see whether we hit "":"" or a "";"" first.
	*/
        boolean isRegularForStatement()
        {
                int curTok = 1;
                Token tok;
                tok = getToken(curTok++);
                if ( tok.kind != FOR ) return false;
                tok = getToken(curTok++);
                if ( tok.kind != LPAREN ) return false;
                while (true)
                {
                        tok = getToken(curTok++);
                        switch (tok.kind) {
                                case COLON:
                                        return false;
                                case SEMICOLON:
                                        return true;
                                case EOF:
                                        return false;
                        }
                }
        }
        /**
		Generate a ParseException with the specified message, pointing to the
		current token.
		The auto-generated Parser.generateParseException() method does not
		provide line number info, therefore we do this.
	*/
        ParseException createParseException( String message )
        {
                Token errortok = token;
                int line = errortok.beginLine, column = errortok.beginColumn;
                String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
                return new ParseException( ""Parse error at line "" + line
                        + "", column "" + column + "" : "" + message );
        }
/*
	Thanks to Sreenivasa Viswanadha for suggesting how to get rid of expensive
	lookahead here.
*/
  final public boolean Line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
        Interpreter.debug(""End of File!"");
        {if (true) return true;}
      break;
    default:
      if (jj_2_1(1)) {
        BlockStatement();
        {if (true) return false;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error(""Missing return statement in function"");
  }
/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/
/*
	Gather modifiers for a class, method, or field.
	I lookahead is true then we are being called as part of a lookahead and we
	should not enforce any rules.  Otherwise we validate based on context
	(field, method, class)
*/
  final public Modifiers Modifiers(int context, boolean lookahead) throws ParseException {
        Modifiers mods = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                if ( !lookahead )
                        try {
                                if ( mods == null ) mods = new Modifiers();
                                mods.addModifier( context, getToken(0).image );
                        } catch ( IllegalStateException e ) {
                                {if (true) throw createParseException( e.getMessage() );}
                        }
    }
        {if (true) return mods;}
    throw new Error(""Missing return statement in function"");
  }
/**
*/
  final public void ClassDeclaration() throws ParseException {
 /*@bgen(jjtree) ClassDeclaration */
        BSHClassDeclaration jjtn000 = new BSHClassDeclaration(JJTCLASSDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Modifiers mods;
        Token name;
        int numInterfaces;
    try {
      mods = Modifiers(Modifiers.CLASS, false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        jj_consume_token(CLASS);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
                                  jjtn000.isInterface=true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      name = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        AmbiguousName();
                                      jjtn000.extend = true;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLEMENTS:
        jj_consume_token(IMPLEMENTS);
        numInterfaces = NameList();
                  jjtn000.numInterfaces=numInterfaces;
        break;
      default:
        ;
      }
      Block();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.modifiers = mods;
                jjtn000.name = name.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void MethodDeclaration() throws ParseException {
 /*@bgen(jjtree) MethodDeclaration */
        BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
        int count;
    try {
      mods = Modifiers(Modifiers.METHOD, false);
                                                      jjtn000.modifiers = mods;
      if (jj_2_2(2147483647)) {
        t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case VOID:
        case IDENTIFIER:
          ReturnType();
          t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        count = NameList();
                                      jjtn000.numThrows=count;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void PackageDeclaration() throws ParseException {
 /*@bgen(jjtree) PackageDeclaration */
  BSHPackageDeclaration jjtn000 = new BSHPackageDeclaration(JJTPACKAGEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(PACKAGE);
      AmbiguousName();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void ImportDeclaration() throws ParseException {
 /*@bgen(jjtree) ImportDeclaration */
    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token s = null;
        Token t = null;
    try {
      if (jj_2_3(3)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC:
          s = jj_consume_token(STATIC);
          break;
        default:
          ;
        }
        jj_consume_token(IMPORT);
        AmbiguousName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          t = jj_consume_token(DOT);
          jj_consume_token(STAR);
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
                if ( s != null ) jjtn000.staticImport = true;
                if ( t != null ) jjtn000.importPackage = true;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          jj_consume_token(IMPORT);
          jj_consume_token(STAR);
          jj_consume_token(SEMICOLON);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                jjtn000.superImport = true;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void VariableDeclarator() throws ParseException {
 /*@bgen(jjtree) VariableDeclarator */
        BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        VariableInitializer();
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.name = t.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
/*
this originally handled postfix array dimensions...
void VariableDeclaratorId() #VariableDeclaratorId :
{ Token t; }
{
  t=<IDENTIFIER> { jjtThis.name = t.image; }
  ( ""["" ""]"" { jjtThis.addUndefinedDimension(); } )*
}
*/
  final public void VariableInitializer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      Expression();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void ArrayInitializer() throws ParseException {
 /*@bgen(jjtree) ArrayInitializer */
  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        VariableInitializer();
        label_2:
        while (true) {
          if (jj_2_4(2)) {
            ;
          } else {
            break label_2;
          }
          jj_consume_token(COMMA);
          VariableInitializer();
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        ;
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameters() throws ParseException {
 /*@bgen(jjtree) FormalParameters */
  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        FormalParameter();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_3;
          }
          jj_consume_token(COMMA);
          FormalParameter();
        }
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameter() throws ParseException {
 /*@bgen(jjtree) FormalParameter */
  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      if (jj_2_5(2)) {
        Type();
        t = jj_consume_token(IDENTIFIER);
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                       jjtreeCloseNodeScope(jjtn000);
                                       jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                   jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Type, name and expression syntax follows.
*/
  final public void Type() throws ParseException {
 /*@bgen(jjtree) Type */
  BSHType jjtn000 = new BSHType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        PrimitiveType();
        break;
      case IDENTIFIER:
        AmbiguousName();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        if (jj_2_6(2)) {
          ;
        } else {
          break label_4;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                                 jjtn000.addArrayDimension();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Originally called ResultType in the grammar
*/
  final public void ReturnType() throws ParseException {
 /*@bgen(jjtree) ReturnType */
  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        jj_consume_token(VOID);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.isVoid = true;
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        Type();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimitiveType() throws ParseException {
 /*@bgen(jjtree) PrimitiveType */
  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtreeCloseNodeScope(jjtn000);
              jjtn000.type = Boolean.TYPE;
        break;
      case CHAR:
        jj_consume_token(CHAR);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Character.TYPE;
        break;
      case BYTE:
        jj_consume_token(BYTE);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Byte.TYPE;
        break;
      case SHORT:
        jj_consume_token(SHORT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Short.TYPE;
        break;
      case INT:
        jj_consume_token(INT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.type =  Integer.TYPE;
        break;
      case LONG:
        jj_consume_token(LONG);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Long.TYPE;
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Float.TYPE;
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.type =  Double.TYPE;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void AmbiguousName() throws ParseException {
 /*@bgen(jjtree) AmbiguousName */
    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t;
    StringBuffer s;
    try {
      t = jj_consume_token(IDENTIFIER);
        s = new StringBuffer(t.image);
      label_5:
      while (true) {
        if (jj_2_7(2)) {
          ;
        } else {
          break label_5;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
                                        s.append("".""+t.image);
      }
                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                      jjtc000 = false;
                                                                      jjtreeCloseNodeScope(jjtn000);
        jjtn000.text = s.toString();
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int NameList() throws ParseException {
  int count = 0;
    AmbiguousName();
                    ++count;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_6;
      }
      jj_consume_token(COMMA);
      AmbiguousName();
                                                       ++count;
    }
    {if (true) return count;}
    throw new Error(""Missing return statement in function"");
  }
/*
 * Expression syntax follows.
 */
  final public void Expression() throws ParseException {
    if (jj_2_8(2147483647)) {
      Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ConditionalExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void Assignment() throws ParseException {
 /*@bgen(jjtree) Assignment */
  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);int op ;
    try {
      PrimaryExpression();
      op = AssignmentOperator();
                                    jjtn000.operator = op;
      Expression();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int AssignmentOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
      break;
    case MODASSIGN:
      jj_consume_token(MODASSIGN);
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
      break;
    case LSHIFTASSIGNX:
      jj_consume_token(LSHIFTASSIGNX);
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGNX:
      jj_consume_token(RSIGNEDSHIFTASSIGNX);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGNX:
      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        t = getToken(0);
        {if (true) return t.kind;}
    throw new Error(""Missing return statement in function"");
  }
  final public void ConditionalExpression() throws ParseException {
    ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      Expression();
      jj_consume_token(COLON);
                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
        ConditionalExpression();
      } catch (Throwable jjte001) {
                                                     if (jjtc001) {
                                                       jjtree.clearNodeScope(jjtn001);
                                                       jjtc001 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte001 instanceof RuntimeException) {
                                                       {if (true) throw (RuntimeException)jjte001;}
                                                     }
                                                     if (jjte001 instanceof ParseException) {
                                                       {if (true) throw (ParseException)jjte001;}
                                                     }
                                                     {if (true) throw (Error)jjte001;}
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  3);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
      break;
    default:
      ;
    }
  }
  final public void ConditionalOrExpression() throws ParseException {
  Token t=null;
    ConditionalAndExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
      case BOOL_ORX:
        ;
        break;
      default:
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
        t = jj_consume_token(BOOL_OR);
        break;
      case BOOL_ORX:
        t = jj_consume_token(BOOL_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ConditionalAndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ConditionalAndExpression() throws ParseException {
  Token t=null;
    InclusiveOrExpression();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
      case BOOL_ANDX:
        ;
        break;
      default:
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
        t = jj_consume_token(BOOL_AND);
        break;
      case BOOL_ANDX:
        t = jj_consume_token(BOOL_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InclusiveOrExpression() throws ParseException {
  Token t=null;
    ExclusiveOrExpression();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
      case BIT_ORX:
        ;
        break;
      default:
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_ORX:
        t = jj_consume_token(BIT_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ExclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ExclusiveOrExpression() throws ParseException {
  Token t=null;
    AndExpression();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        break label_10;
      }
      t = jj_consume_token(XOR);
      AndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void AndExpression() throws ParseException {
  Token t=null;
    EqualityExpression();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
      case BIT_ANDX:
        ;
        break;
      default:
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        t = jj_consume_token(BIT_AND);
        break;
      case BIT_ANDX:
        t = jj_consume_token(BIT_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      EqualityExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void EqualityExpression() throws ParseException {
  Token t = null;
    InstanceOfExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InstanceOfExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InstanceOfExpression() throws ParseException {
  Token t = null;
    RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      t = jj_consume_token(INSTANCEOF);
      Type();
                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                              jjtreeCloseNodeScope(jjtn001);
                              jjtn001.kind = t.kind;
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtreeCloseNodeScope(jjtn001);
                              }
      }
      break;
    default:
      ;
    }
  }
  final public void RelationalExpression() throws ParseException {
  Token t = null;
    ShiftExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GTX:
      case LT:
      case LTX:
      case LE:
      case LEX:
      case GE:
      case GEX:
        ;
        break;
      default:
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        break;
      case LTX:
        t = jj_consume_token(LTX);
        break;
      case GT:
        t = jj_consume_token(GT);
        break;
      case GTX:
        t = jj_consume_token(GTX);
        break;
      case LE:
        t = jj_consume_token(LE);
        break;
      case LEX:
        t = jj_consume_token(LEX);
        break;
      case GE:
        t = jj_consume_token(GE);
        break;
      case GEX:
        t = jj_consume_token(GEX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ShiftExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void ShiftExpression() throws ParseException {
  Token t = null;
    AdditiveExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case LSHIFTX:
      case RSIGNEDSHIFT:
      case RSIGNEDSHIFTX:
      case RUNSIGNEDSHIFT:
      case RUNSIGNEDSHIFTX:
        ;
        break;
      default:
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        t = jj_consume_token(LSHIFT);
        break;
      case LSHIFTX:
        t = jj_consume_token(LSHIFTX);
        break;
      case RSIGNEDSHIFT:
        t = jj_consume_token(RSIGNEDSHIFT);
        break;
      case RSIGNEDSHIFTX:
        t = jj_consume_token(RSIGNEDSHIFTX);
        break;
      case RUNSIGNEDSHIFT:
        t = jj_consume_token(RUNSIGNEDSHIFT);
        break;
      case RUNSIGNEDSHIFTX:
        t = jj_consume_token(RUNSIGNEDSHIFTX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      AdditiveExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void AdditiveExpression() throws ParseException {
  Token t = null;
    MultiplicativeExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      MultiplicativeExpression();
                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                     jjtreeCloseNodeScope(jjtn001);
                                                     jjtn001.kind = t.kind;
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
    }
  }
  final public void MultiplicativeExpression() throws ParseException {
  Token t = null;
    UnaryExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case MOD:
        ;
        break;
      default:
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        t = jj_consume_token(STAR);
        break;
      case SLASH:
        t = jj_consume_token(SLASH);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtreeOpenNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  2);
                      jjtc001 = false;
                      jjtreeCloseNodeScope(jjtn001);
                      jjtn001.kind = t.kind;
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                        jjtreeCloseNodeScope(jjtn001);
                      }
      }
    }
  }
  final public void UnaryExpression() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case INCR:
      PreIncrementExpression();
      break;
    case DECR:
      PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
      UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void PreIncrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(INCR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void PreDecrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(DECR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void UnaryExpressionNotPlusMinus() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        t = jj_consume_token(TILDE);
        break;
      case BANG:
        t = jj_consume_token(BANG);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    default:
      if (jj_2_9(2147483647)) {
        CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          PostfixExpression();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
// This production is to determine lookahead only.
  final public void CastLookahead() throws ParseException {
    if (jj_2_10(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_11(2147483647)) {
      jj_consume_token(LPAREN);
      AmbiguousName();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        AmbiguousName();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
          Literal();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void PostfixExpression() throws ParseException {
  Token t = null;
    if (jj_2_12(2147483647)) {
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        t = jj_consume_token(INCR);
        break;
      case DECR:
        t = jj_consume_token(DECR);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                                jjtreeOpenNodeScope(jjtn001);
      try {
                                jjtree.closeNodeScope(jjtn001,  1);
                                jjtc001 = false;
                                jjtreeCloseNodeScope(jjtn001);
                jjtn001.kind = t.kind; jjtn001.postfix = true;
      } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  1);
                                  jjtreeCloseNodeScope(jjtn001);
                                }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        PrimaryExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void CastExpression() throws ParseException {
 /*@bgen(jjtree) CastExpression */
  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_13(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        UnaryExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          UnaryExpressionNotPlusMinus();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimaryExpression() throws ParseException {
                                               /*@bgen(jjtree) PrimaryExpression */
  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      PrimaryPrefix();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case LBRACKET:
        case DOT:
          ;
          break;
        default:
          break label_17;
        }
        PrimarySuffix();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void MethodInvocation() throws ParseException {
                                             /*@bgen(jjtree) MethodInvocation */
  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      AmbiguousName();
      Arguments();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }
  final public void PrimaryPrefix() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      Literal();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      break;
    case NEW:
      AllocationExpression();
      break;
    default:
      if (jj_2_14(2147483647)) {
        MethodInvocation();
      } else if (jj_2_15(2147483647)) {
        Type();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          AmbiguousName();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
  final public void PrimarySuffix() throws ParseException {
 /*@bgen(jjtree) PrimarySuffix */
    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_16(2)) {
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.CLASS;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.INDEX;
          break;
        case DOT:
          jj_consume_token(DOT);
          t = jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            Arguments();
            break;
          default:
            ;
          }
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.NAME;
        jjtn000.field = t.image;
          break;
        case LBRACE:
          jj_consume_token(LBRACE);
          Expression();
          jj_consume_token(RBRACE);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.PROPERTY;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token x;
    boolean b;
    String literal;
    char ch;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        x = jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'l' || ch == 'L')
    {
        literal = literal.substring(0,literal.length()-1);
        // This really should be Long.decode, but there isn't one. As a result,
        // hex and octal literals ending in 'l' or 'L' don't work.
        jjtn000.value = new Primitive( new Long( literal ).longValue() );
    }
    else
                try {
                jjtn000.value = new Primitive(
                                Integer.decode( literal ).intValue() );
                } catch ( NumberFormatException e ) {
                        {if (true) throw createParseException(
                                ""Error or number too big for integer type: ""+ literal );}
                }
        break;
      case FLOATING_POINT_LITERAL:
        x = jj_consume_token(FLOATING_POINT_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'f' || ch == 'F')
    {
        literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Float( literal ).floatValue() );
    }
    else
    {
        if(ch == 'd' || ch == 'D')
            literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Double( literal ).doubleValue() );
    }
        break;
      case CHARACTER_LITERAL:
        x = jj_consume_token(CHARACTER_LITERAL);
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtreeCloseNodeScope(jjtn000);
                try {
                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException(""Error parsing character: ""+x.image);}
                }
        break;
      case STRING_LITERAL:
        x = jj_consume_token(STRING_LITERAL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException(""Error parsing string: ""+x.image);}
                }
        break;
      case FALSE:
      case TRUE:
        b = BooleanLiteral();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = new Primitive( b );
        break;
      case NULL:
        NullLiteral();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.NULL;
        break;
      case VOID:
        VoidLiteral();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.VOID;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public boolean BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
           {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return false;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error(""Missing return statement in function"");
  }
  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }
  final public void VoidLiteral() throws ParseException {
    jj_consume_token(VOID);
  }
  final public void Arguments() throws ParseException {
 /*@bgen(jjtree) Arguments */
  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
// leave these on the stack for Arguments() to handle
  final public void ArgumentList() throws ParseException {
    Expression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_18;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }
  final public void AllocationExpression() throws ParseException {
 /*@bgen(jjtree) AllocationExpression */
  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_18(2)) {
        jj_consume_token(NEW);
        PrimitiveType();
        ArrayDimensions();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          jj_consume_token(NEW);
          AmbiguousName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ArrayDimensions();
            break;
          case LPAREN:
            Arguments();
            if (jj_2_17(2)) {
              Block();
            } else {
              ;
            }
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ArrayDimensions() throws ParseException {
 /*@bgen(jjtree) ArrayDimensions */
  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_21(2)) {
        label_19:
        while (true) {
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                                        jjtn000.addDefinedDimension();
          if (jj_2_19(2)) {
            ;
          } else {
            break label_19;
          }
        }
        label_20:
        while (true) {
          if (jj_2_20(2)) {
            ;
          } else {
            break label_20;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
                           jjtn000.addUndefinedDimension();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          label_21:
          while (true) {
            jj_consume_token(LBRACKET);
            jj_consume_token(RBRACKET);
              jjtn000.addUndefinedDimension();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACKET:
              ;
              break;
            default:
              break label_21;
            }
          }
          ArrayInitializer();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
 * Statement syntax follows.
 */
  final public void Statement() throws ParseException {
    if (jj_2_22(2)) {
      LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        EmptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpression();
        jj_consume_token(SEMICOLON);
        break;
      case SWITCH:
        SwitchStatement();
        break;
      case IF:
        IfStatement();
        break;
      case WHILE:
        WhileStatement();
        break;
      case DO:
        DoStatement();
        break;
      default:
        if (isRegularForStatement()) {
          ForStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FOR:
            EnhancedForStatement();
            break;
          case BREAK:
            BreakStatement();
            break;
          case CONTINUE:
            ContinueStatement();
            break;
          case RETURN:
            ReturnStatement();
            break;
          case SYNCHRONIZED:
            SynchronizedStatement();
            break;
          case THROW:
            ThrowStatement();
            break;
          case TRY:
            TryStatement();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }
  final public void LabeledStatement() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    Statement();
  }
  final public void Block() throws ParseException {
 /*@bgen(jjtree) Block */
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      label_22:
      while (true) {
        if (jj_2_23(1)) {
          ;
        } else {
          break label_22;
        }
        BlockStatement();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void BlockStatement() throws ParseException {
    if (jj_2_24(2147483647)) {
      ClassDeclaration();
    } else if (jj_2_25(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_26(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_27(2147483647)) {
      TypedVariableDeclaration();
      jj_consume_token(SEMICOLON);
    } else if (jj_2_28(1)) {
      Statement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
      case STATIC:
        ImportDeclaration();
        break;
      case PACKAGE:
        PackageDeclaration();
        break;
      case FORMAL_COMMENT:
        FormalComment();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void FormalComment() throws ParseException {
 /*@bgen(jjtree) #FormalComment( retainComments) */
        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FORMAL_COMMENT);
                              jjtree.closeNodeScope(jjtn000,  retainComments);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                jjtn000.text=t.image;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  retainComments);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void EmptyStatement() throws ParseException {
    jj_consume_token(SEMICOLON);
  }
  final public void StatementExpression() throws ParseException {
    Expression();
  }
  final public void SwitchStatement() throws ParseException {
 /*@bgen(jjtree) SwitchStatement */
  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(LBRACE);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
        case _DEFAULT:
          ;
          break;
        default:
          break label_23;
        }
        SwitchLabel();
        label_24:
        while (true) {
          if (jj_2_29(1)) {
            ;
          } else {
            break label_24;
          }
          BlockStatement();
        }
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SwitchLabel() throws ParseException {
 /*@bgen(jjtree) SwitchLabel */
  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        jj_consume_token(CASE);
        Expression();
        jj_consume_token(COLON);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        jj_consume_token(COLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.isDefault = true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void IfStatement() throws ParseException {
 /*@bgen(jjtree) IfStatement */
  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        Statement();
        break;
      default:
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void WhileStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Do statement is just a While statement with a special hook to execute
	at least once.
*/
  final public void DoStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DO);
      Statement();
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.isDoStatement=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForStatement() throws ParseException {
 /*@bgen(jjtree) ForStatement */
  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case TRUE:
      case VOID:
      case VOLATILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForInit();
                          jjtn000.hasForInit=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
                         jjtn000.hasExpression=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForUpdate();
                        jjtn000.hasForUpdate=true;
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	The new JDK1.5 enhanced for statement.
	e.g. for( int a : arrayOfInts ) { }
	We also support loose typing of the iterator var for BeanShell
	e.g. for( a : arrayOfInts ) { }
*/
  final public void EnhancedForStatement() throws ParseException {
 /*@bgen(jjtree) EnhancedForStatement */
  BSHEnhancedForStatement jjtn000 = new BSHEnhancedForStatement(JJTENHANCEDFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_30(4)) {
        jj_consume_token(FOR);
        jj_consume_token(LPAREN);
        t = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        Expression();
        jj_consume_token(RPAREN);
        Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
          jj_consume_token(FOR);
          jj_consume_token(LPAREN);
          Type();
          t = jj_consume_token(IDENTIFIER);
          jj_consume_token(COLON);
          Expression();
          jj_consume_token(RPAREN);
          Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForInit() throws ParseException {
  Token t = null;
    if (jj_2_31(2147483647)) {
      TypedVariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpressionList();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
/**
	Declared a typed variable.
	Untyped variables are not declared per-se but are handled by the part
	of the grammar that deals with assignments.
*/
  final public void TypedVariableDeclaration() throws ParseException {
 /*@bgen(jjtree) TypedVariableDeclaration */
        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
    try {
      mods = Modifiers(Modifiers.FIELD, false);
      Type();
      VariableDeclarator();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_25;
        }
        jj_consume_token(COMMA);
        VariableDeclarator();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        jjtn000.modifiers = mods;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void StatementExpressionList() throws ParseException {
 /*@bgen(jjtree) StatementExpressionList */
  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      StatementExpression();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_26;
        }
        jj_consume_token(COMMA);
        StatementExpression();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForUpdate() throws ParseException {
    StatementExpressionList();
  }
  final public void BreakStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BREAK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtreeCloseNodeScope(jjtn000);
                                 jjtn000.kind = BREAK;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ContinueStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CONTINUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtreeCloseNodeScope(jjtn000);
                                    jjtn000.kind = CONTINUE;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ReturnStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                  jjtn000.kind = RETURN;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SynchronizedStatement() throws ParseException {
 /*@bgen(jjtree) Block */
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SYNCHRONIZED);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Block();
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                                jjtreeCloseNodeScope(jjtn000);
                jjtn000.isSynchronized=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ThrowStatement() throws ParseException {
 /*@bgen(jjtree) ThrowStatement */
  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(THROW);
      Expression();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void TryStatement() throws ParseException {
 /*@bgen(jjtree) TryStatement */
  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);boolean closed = false;
    try {
      jj_consume_token(TRY);
      Block();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CATCH:
          ;
          break;
        default:
          break label_27;
        }
        jj_consume_token(CATCH);
        jj_consume_token(LPAREN);
        FormalParameter();
        jj_consume_token(RPAREN);
        Block();
                                                      closed = true;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINALLY:
        jj_consume_token(FINALLY);
        Block();
                              closed = true;
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if ( !closed ) {if (true) throw generateParseException();}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { } return true;
  }
  final private boolean jj_3R_46() {
    if (jj_3R_91()) return true;
    return false;
  }
  final private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3_23() {
    if (jj_3R_28()) return true;
    return false;
  }
  final private boolean jj_3R_161() {
    if (jj_3R_164()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_169()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_38() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  final private boolean jj_3R_158() {
    if (jj_3R_161()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_167()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_40() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_156() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_108()) return true;
    return false;
  }
  final private boolean jj_3R_165() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) return true;
    }
    if (jj_3R_158()) return true;
    return false;
  }
  final private boolean jj_3R_153() {
    if (jj_3R_158()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_165()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_90() {
    if (jj_3R_124()) return true;
    return false;
  }
  final private boolean jj_3R_89() {
    if (jj_3R_123()) return true;
    return false;
  }
  final private boolean jj_3R_88() {
    if (jj_3R_122()) return true;
    return false;
  }
  final private boolean jj_3R_162() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    }
    if (jj_3R_153()) return true;
    return false;
  }
  final private boolean jj_3R_87() {
    if (jj_3R_121()) return true;
    return false;
  }
  final private boolean jj_3R_148() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_162()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_86() {
    if (jj_3R_120()) return true;
    return false;
  }
  final private boolean jj_3R_85() {
    if (jj_3R_119()) return true;
    return false;
  }
  final private boolean jj_3R_84() {
    if (jj_3R_118()) return true;
    return false;
  }
  final private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) return true;
    }
    if (jj_3R_148()) return true;
    return false;
  }
  final private boolean jj_3R_83() {
    if (jj_3R_117()) return true;
    return false;
  }
  final private boolean jj_3R_135() {
    if (jj_3R_148()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_159()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_82() {
    if (jj_3R_116()) return true;
    return false;
  }
  final private boolean jj_3R_81() {
    if (jj_3R_115()) return true;
    return false;
  }
  final private boolean jj_3R_80() {
    if (jj_3R_114()) return true;
    return false;
  }
  final private boolean jj_3R_108() {
    if (jj_3R_135()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3R_79() {
    if (jj_3R_113()) return true;
    return false;
  }
  final private boolean jj_3R_78() {
    if (jj_3R_112()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3_17() {
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3R_77() {
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = isRegularForStatement();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3_22() {
    if (jj_3R_40()) return true;
    return false;
  }
  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_111() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  final private boolean jj_3R_160() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  final private boolean jj_3R_152() {
    if (jj_3R_69()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3R_157() {
    Token xsp;
    if (jj_3R_160()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_160()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_97()) return true;
    return false;
  }
  final private boolean jj_3_8() {
    if (jj_3R_33()) return true;
    if (jj_3R_34()) return true;
    return false;
  }
  final private boolean jj_3_20() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  final private boolean jj_3R_151() {
    if (jj_3R_150()) return true;
    return false;
  }
  final private boolean jj_3_19() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  final private boolean jj_3R_107() {
    if (jj_3R_33()) return true;
    if (jj_3R_34()) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  final private boolean jj_3_21() {
    Token xsp;
    if (jj_3_19()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_150() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) return true;
    }
    return false;
  }
  final private boolean jj_3R_71() {
    if (jj_3R_108()) return true;
    return false;
  }
  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }
  final private boolean jj_3R_70() {
    if (jj_3R_107()) return true;
    return false;
  }
  final private boolean jj_3R_145() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) return true;
    }
    return false;
  }
  final private boolean jj_3_18() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_36()) return true;
    if (jj_3R_150()) return true;
    return false;
  }
  final private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) return true;
    }
    return false;
  }
  final private boolean jj_3R_147() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  final private boolean jj_3R_76() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_111()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_134() {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_147()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_106() {
    if (jj_3R_134()) return true;
    return false;
  }
  final private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3R_69() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  final private boolean jj_3R_29() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_68() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }
  final private boolean jj_3R_67() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }
  final private boolean jj_3R_155() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }
  final private boolean jj_3R_66() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }
  final private boolean jj_3R_65() {
    if (jj_scan_token(INT)) return true;
    return false;
  }
  final private boolean jj_3R_154() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }
  final private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) return true;
    }
    return false;
  }
  final private boolean jj_3R_64() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }
  final private boolean jj_3R_56() {
    if (jj_3R_29()) return true;
    return false;
  }
  final private boolean jj_3R_63() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }
  final private boolean jj_3R_62() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }
  final private boolean jj_3R_61() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }
  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_144() {
    if (jj_scan_token(57)) return true;
    return false;
  }
  final private boolean jj_3R_74() {
    if (jj_3R_32()) return true;
    return false;
  }
  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }
  final private boolean jj_3R_73() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }
  final private boolean jj_3R_143() {
    if (jj_scan_token(41)) return true;
    return false;
  }
  final private boolean jj_3_6() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  final private boolean jj_3R_142() {
    if (jj_3R_149()) return true;
    return false;
  }
  final private boolean jj_3R_55() {
    if (jj_3R_36()) return true;
    return false;
  }
  final private boolean jj_3R_110() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_109()) return true;
    return false;
  }
  final private boolean jj_3R_141() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }
  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_140() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }
  final private boolean jj_3R_190() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3_4() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  final private boolean jj_3R_189() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_109()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3R_136() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3_5() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3R_75() {
    if (jj_3R_109()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_110()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) return true;
    }
    return false;
  }
  final private boolean jj_3R_124() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_38()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_189()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_190()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3R_43() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  final private boolean jj_3R_163() {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_139() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }
  final private boolean jj_3R_97() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  final private boolean jj_3R_30() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }
  final private boolean jj_3R_123() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3R_180() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  final private boolean jj_3R_54() {
    if (jj_3R_39()) return true;
    return false;
  }
  final private boolean jj_3R_188() {
    if (jj_3R_39()) return true;
    return false;
  }
  final private boolean jj_3R_53() {
    if (jj_3R_97()) return true;
    return false;
  }
  final private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }
  final private boolean jj_3R_122() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3R_177() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_176()) return true;
    return false;
  }
  final private boolean jj_3R_210() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_112()) return true;
    return false;
  }
  final private boolean jj_3R_121() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_188()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_138() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }
  final private boolean jj_3R_146() {
    if (jj_3R_69()) return true;
    return false;
  }
  final private boolean jj_3R_176() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3R_105() {
    if (jj_3R_129()) return true;
    return false;
  }
  final private boolean jj_3R_120() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3R_119() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3R_195() {
    if (jj_3R_205()) return true;
    return false;
  }
  final private boolean jj_3R_128() {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3R_133() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  final private boolean jj_3R_205() {
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_210()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_132() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_146()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) jj_scanpos = xsp;
    if (jj_scan_token(IMPORT)) return true;
    if (jj_3R_29()) return true;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) return true;
    }
    return false;
  }
  final private boolean jj_3R_93() {
    if (jj_3R_41()) return true;
    if (jj_3R_32()) return true;
    if (jj_3R_176()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_177()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_131() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  final private boolean jj_3R_95() {
    if (jj_scan_token(PACKAGE)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  final private boolean jj_3_2() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  final private boolean jj_3R_175() {
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3_16() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }
  final private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_174() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_76()) return true;
    return false;
  }
  final private boolean jj_3_15() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }
  final private boolean jj_3_31() {
    if (jj_3R_41()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3_14() {
    if (jj_3R_37()) return true;
    return false;
  }
  final private boolean jj_3R_126() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3R_127() {
    if (jj_3R_42()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3R_92() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) return true;
    }
    if (jj_3R_43()) return true;
    xsp = jj_scanpos;
    if (jj_3R_174()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) return true;
    }
    return false;
  }
  final private boolean jj_3R_204() {
    if (jj_3R_205()) return true;
    return false;
  }
  final private boolean jj_3R_103() {
    if (jj_3R_29()) return true;
    return false;
  }
  final private boolean jj_3R_203() {
    if (jj_3R_93()) return true;
    return false;
  }
  final private boolean jj_3R_194() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    }
    return false;
  }
  final private boolean jj_3R_102() {
    if (jj_3R_32()) return true;
    return false;
  }
  final private boolean jj_3R_58() {
    if (jj_3R_104()) return true;
    return false;
  }
  final private boolean jj_3R_125() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }
  final private boolean jj_3R_101() {
    if (jj_3R_37()) return true;
    return false;
  }
  final private boolean jj_3R_100() {
    if (jj_3R_130()) return true;
    return false;
  }
  final private boolean jj_3R_99() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  final private boolean jj_3R_137() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_184() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_173() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_76()) return true;
    return false;
  }
  final private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_98() {
    if (jj_3R_129()) return true;
    return false;
  }
  final private boolean jj_3R_172() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  final private boolean jj_3_30() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    }
    return false;
  }
  final private boolean jj_3R_37() {
    if (jj_3R_29()) return true;
    if (jj_3R_69()) return true;
    return false;
  }
  final private boolean jj_3R_185() {
    if (jj_3R_194()) return true;
    return false;
  }
  final private boolean jj_3R_91() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_172()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) jj_scanpos = xsp;
    if (jj_3R_38()) return true;
    return false;
  }
  final private boolean jj_3_13() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_36()) return true;
    return false;
  }
  final private boolean jj_3R_187() {
    if (jj_3R_195()) return true;
    return false;
  }
  final private boolean jj_3R_186() {
    if (jj_3R_39()) return true;
    return false;
  }
  final private boolean jj_3R_33() {
    if (jj_3R_57()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_58()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_217() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_208()) return true;
    return false;
  }
  final private boolean jj_3R_216() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_191()) return true;
    return false;
  }
  final private boolean jj_3R_117() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_214() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) return true;
    }
    return false;
  }
  final private boolean jj_3_12() {
    if (jj_3R_33()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) return true;
    }
    return false;
  }
  final private boolean jj_3R_219() {
    if (jj_3R_33()) return true;
    return false;
  }
  final private boolean jj_3R_116() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_45()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3_11() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }
  final private boolean jj_3R_218() {
    if (jj_3R_33()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) return true;
    }
    return false;
  }
  final private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) return true;
    }
    return false;
  }
  final private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_115() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_60() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    }
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_59() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  final private boolean jj_3_9() {
    if (jj_3R_35()) return true;
    return false;
  }
  final private boolean jj_3_29() {
    if (jj_3R_28()) return true;
    return false;
  }
  final private boolean jj_3R_114() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3R_41() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_72()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    }
    return false;
  }
  final private boolean jj_3_10() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_36()) return true;
    return false;
  }
  final private boolean jj_3R_213() {
    if (jj_3R_215()) return true;
    return false;
  }
  final private boolean jj_3R_212() {
    if (jj_3R_214()) return true;
    return false;
  }
  final private boolean jj_3R_202() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }
  final private boolean jj_3R_211() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    if (jj_3R_191()) return true;
    return false;
  }
  final private boolean jj_3R_208() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    }
    }
    return false;
  }
  final private boolean jj_3R_201() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }
  final private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }
  final private boolean jj_3R_183() {
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_207() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_33()) return true;
    return false;
  }
  final private boolean jj_3_1() {
    if (jj_3R_28()) return true;
    return false;
  }
  final private boolean jj_3R_113() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_39()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_183()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  final private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) return true;
    }
    }
    if (jj_3R_191()) return true;
    return false;
  }
  final private boolean jj_3R_206() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_33()) return true;
    return false;
  }
  final private boolean jj_3R_199() {
    if (jj_3R_208()) return true;
    return false;
  }
  final private boolean jj_3R_198() {
    if (jj_3R_207()) return true;
    return false;
  }
  final private boolean jj_3R_197() {
    if (jj_3R_206()) return true;
    return false;
  }
  final private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) return true;
    }
    if (jj_3R_191()) return true;
    return false;
  }
  final private boolean jj_3R_191() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) return true;
    }
    }
    }
    return false;
  }
  final private boolean jj_3R_44() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_76()) return true;
    return false;
  }
  final private boolean jj_3R_112() {
    if (jj_3R_39()) return true;
    return false;
  }
  final private boolean jj_3R_181() {
    if (jj_3R_191()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_209()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_200() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) return true;
    }
    if (jj_3R_181()) return true;
    return false;
  }
  final private boolean jj_3R_178() {
    if (jj_3R_181()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_200()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_96() {
    if (jj_scan_token(FORMAL_COMMENT)) return true;
    return false;
  }
  final private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) return true;
    }
    }
    }
    }
    }
    if (jj_3R_178()) return true;
    return false;
  }
  final private boolean jj_3R_171() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    if (jj_3R_166()) return true;
    return false;
  }
  final private boolean jj_3R_170() {
    if (jj_3R_178()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_192()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_52() {
    if (jj_3R_96()) return true;
    return false;
  }
  final private boolean jj_3R_182() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_170()) return true;
    return false;
  }
  final private boolean jj_3_27() {
    if (jj_3R_41()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  final private boolean jj_3R_51() {
    if (jj_3R_95()) return true;
    return false;
  }
  final private boolean jj_3R_168() {
    if (jj_3R_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_182()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_50() {
    if (jj_3R_94()) return true;
    return false;
  }
  final private boolean jj_3_26() {
    if (jj_3R_41()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }
  final private boolean jj_3R_179() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_32()) return true;
    return false;
  }
  final private boolean jj_3_28() {
    if (jj_3R_45()) return true;
    return false;
  }
  final private boolean jj_3R_166() {
    if (jj_3R_168()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    return false;
  }
  final private boolean jj_3_25() {
    if (jj_3R_41()) return true;
    if (jj_3R_42()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  final private boolean jj_3R_49() {
    if (jj_3R_93()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  final private boolean jj_3_24() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) return true;
    }
    return false;
  }
  final private boolean jj_3R_167() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_161()) return true;
    return false;
  }
  final private boolean jj_3R_48() {
    if (jj_3R_92()) return true;
    return false;
  }
  final private boolean jj_3R_164() {
    if (jj_3R_166()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_171()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  final private boolean jj_3R_47() {
    if (jj_3R_92()) return true;
    return false;
  }
  final private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) return true;
    }
    if (jj_3R_164()) return true;
    return false;
  }
  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  public Parser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }
  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }
  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException(""Parse error at line "" + line + "", column "" + column + "".  Encountered: "" + mess);
  }
  final public void enable_tracing() {
  }
  final public void disable_tracing() {
  }
}
"
bsh.ParserConstants,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserConstants.java */
package bsh;
public interface ParserConstants {
  int EOF = 0;
  int NONPRINTABLE = 6;
  int SINGLE_LINE_COMMENT = 7;
  int HASH_BANG_COMMENT = 8;
  int MULTI_LINE_COMMENT = 9;
  int ABSTRACT = 10;
  int BOOLEAN = 11;
  int BREAK = 12;
  int CLASS = 13;
  int BYTE = 14;
  int CASE = 15;
  int CATCH = 16;
  int CHAR = 17;
  int CONST = 18;
  int CONTINUE = 19;
  int _DEFAULT = 20;
  int DO = 21;
  int DOUBLE = 22;
  int ELSE = 23;
  int ENUM = 24;
  int EXTENDS = 25;
  int FALSE = 26;
  int FINAL = 27;
  int FINALLY = 28;
  int FLOAT = 29;
  int FOR = 30;
  int GOTO = 31;
  int IF = 32;
  int IMPLEMENTS = 33;
  int IMPORT = 34;
  int INSTANCEOF = 35;
  int INT = 36;
  int INTERFACE = 37;
  int LONG = 38;
  int NATIVE = 39;
  int NEW = 40;
  int NULL = 41;
  int PACKAGE = 42;
  int PRIVATE = 43;
  int PROTECTED = 44;
  int PUBLIC = 45;
  int RETURN = 46;
  int SHORT = 47;
  int STATIC = 48;
  int STRICTFP = 49;
  int SWITCH = 50;
  int SYNCHRONIZED = 51;
  int TRANSIENT = 52;
  int THROW = 53;
  int THROWS = 54;
  int TRUE = 55;
  int TRY = 56;
  int VOID = 57;
  int VOLATILE = 58;
  int WHILE = 59;
  int INTEGER_LITERAL = 60;
  int DECIMAL_LITERAL = 61;
  int HEX_LITERAL = 62;
  int OCTAL_LITERAL = 63;
  int FLOATING_POINT_LITERAL = 64;
  int EXPONENT = 65;
  int CHARACTER_LITERAL = 66;
  int STRING_LITERAL = 67;
  int FORMAL_COMMENT = 68;
  int IDENTIFIER = 69;
  int LETTER = 70;
  int DIGIT = 71;
  int LPAREN = 72;
  int RPAREN = 73;
  int LBRACE = 74;
  int RBRACE = 75;
  int LBRACKET = 76;
  int RBRACKET = 77;
  int SEMICOLON = 78;
  int COMMA = 79;
  int DOT = 80;
  int ASSIGN = 81;
  int GT = 82;
  int GTX = 83;
  int LT = 84;
  int LTX = 85;
  int BANG = 86;
  int TILDE = 87;
  int HOOK = 88;
  int COLON = 89;
  int EQ = 90;
  int LE = 91;
  int LEX = 92;
  int GE = 93;
  int GEX = 94;
  int NE = 95;
  int BOOL_OR = 96;
  int BOOL_ORX = 97;
  int BOOL_AND = 98;
  int BOOL_ANDX = 99;
  int INCR = 100;
  int DECR = 101;
  int PLUS = 102;
  int MINUS = 103;
  int STAR = 104;
  int SLASH = 105;
  int BIT_AND = 106;
  int BIT_ANDX = 107;
  int BIT_OR = 108;
  int BIT_ORX = 109;
  int XOR = 110;
  int MOD = 111;
  int LSHIFT = 112;
  int LSHIFTX = 113;
  int RSIGNEDSHIFT = 114;
  int RSIGNEDSHIFTX = 115;
  int RUNSIGNEDSHIFT = 116;
  int RUNSIGNEDSHIFTX = 117;
  int PLUSASSIGN = 118;
  int MINUSASSIGN = 119;
  int STARASSIGN = 120;
  int SLASHASSIGN = 121;
  int ANDASSIGN = 122;
  int ANDASSIGNX = 123;
  int ORASSIGN = 124;
  int ORASSIGNX = 125;
  int XORASSIGN = 126;
  int MODASSIGN = 127;
  int LSHIFTASSIGN = 128;
  int LSHIFTASSIGNX = 129;
  int RSIGNEDSHIFTASSIGN = 130;
  int RSIGNEDSHIFTASSIGNX = 131;
  int RUNSIGNEDSHIFTASSIGN = 132;
  int RUNSIGNEDSHIFTASSIGNX = 133;
  int DEFAULT = 0;
  String[] tokenImage = {
    ""<EOF>"",
    ""\"" \"""",
    ""\""\\t\"""",
    ""\""\\r\"""",
    ""\""\\f\"""",
    ""\""\\n\"""",
    ""<NONPRINTABLE>"",
    ""<SINGLE_LINE_COMMENT>"",
    ""<HASH_BANG_COMMENT>"",
    ""<MULTI_LINE_COMMENT>"",
    ""\""abstract\"""",
    ""\""boolean\"""",
    ""\""break\"""",
    ""\""class\"""",
    ""\""byte\"""",
    ""\""case\"""",
    ""\""catch\"""",
    ""\""char\"""",
    ""\""const\"""",
    ""\""continue\"""",
    ""\""default\"""",
    ""\""do\"""",
    ""\""double\"""",
    ""\""else\"""",
    ""\""enum\"""",
    ""\""extends\"""",
    ""\""false\"""",
    ""\""final\"""",
    ""\""finally\"""",
    ""\""float\"""",
    ""\""for\"""",
    ""\""goto\"""",
    ""\""if\"""",
    ""\""implements\"""",
    ""\""import\"""",
    ""\""instanceof\"""",
    ""\""int\"""",
    ""\""interface\"""",
    ""\""long\"""",
    ""\""native\"""",
    ""\""new\"""",
    ""\""null\"""",
    ""\""package\"""",
    ""\""private\"""",
    ""\""protected\"""",
    ""\""public\"""",
    ""\""return\"""",
    ""\""short\"""",
    ""\""static\"""",
    ""\""strictfp\"""",
    ""\""switch\"""",
    ""\""synchronized\"""",
    ""\""transient\"""",
    ""\""throw\"""",
    ""\""throws\"""",
    ""\""true\"""",
    ""\""try\"""",
    ""\""void\"""",
    ""\""volatile\"""",
    ""\""while\"""",
    ""<INTEGER_LITERAL>"",
    ""<DECIMAL_LITERAL>"",
    ""<HEX_LITERAL>"",
    ""<OCTAL_LITERAL>"",
    ""<FLOATING_POINT_LITERAL>"",
    ""<EXPONENT>"",
    ""<CHARACTER_LITERAL>"",
    ""<STRING_LITERAL>"",
    ""<FORMAL_COMMENT>"",
    ""<IDENTIFIER>"",
    ""<LETTER>"",
    ""<DIGIT>"",
    ""\""(\"""",
    ""\"")\"""",
    ""\""{\"""",
    ""\""}\"""",
    ""\""[\"""",
    ""\""]\"""",
    ""\"";\"""",
    ""\"",\"""",
    ""\"".\"""",
    ""\""=\"""",
    ""\"">\"""",
    ""\""@gt\"""",
    ""\""<\"""",
    ""\""@lt\"""",
    ""\""!\"""",
    ""\""~\"""",
    ""\""?\"""",
    ""\"":\"""",
    ""\""==\"""",
    ""\""<=\"""",
    ""\""@lteq\"""",
    ""\"">=\"""",
    ""\""@gteq\"""",
    ""\""!=\"""",
    ""\""||\"""",
    ""\""@or\"""",
    ""\""&&\"""",
    ""\""@and\"""",
    ""\""++\"""",
    ""\""--\"""",
    ""\""+\"""",
    ""\""-\"""",
    ""\""*\"""",
    ""\""/\"""",
    ""\""&\"""",
    ""\""@bitwise_and\"""",
    ""\""|\"""",
    ""\""@bitwise_or\"""",
    ""\""^\"""",
    ""\""%\"""",
    ""\""<<\"""",
    ""\""@left_shift\"""",
    ""\"">>\"""",
    ""\""@right_shift\"""",
    ""\"">>>\"""",
    ""\""@right_unsigned_shift\"""",
    ""\""+=\"""",
    ""\""-=\"""",
    ""\""*=\"""",
    ""\""/=\"""",
    ""\""&=\"""",
    ""\""@and_assign\"""",
    ""\""|=\"""",
    ""\""@or_assign\"""",
    ""\""^=\"""",
    ""\""%=\"""",
    ""\""<<=\"""",
    ""\""@left_shift_assign\"""",
    ""\"">>=\"""",
    ""\""@right_shift_assign\"""",
    ""\"">>>=\"""",
    ""\""@right_unsigned_shift_assign\"""",
  };
}
"
bsh.ParserTokenManager,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */
package bsh;
import java.io.*;
import java.util.Vector;
public class ParserTokenManager implements ParserConstants
{
  public  java.io.PrintStream debugStream = System.out;
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2)
{
   switch (pos)
   {
      case 0:
         if ((active1 & 0x200020000000000L) != 0L)
            return 56;
         if ((active0 & 0x3eL) != 0L)
            return 0;
         if ((active1 & 0x10000L) != 0L)
            return 11;
         if ((active0 & 0xffffffffffffc00L) != 0L)
         {
            jjmatchedKind = 69;
            return 35;
         }
         return -1;
      case 1:
         if ((active0 & 0x100600000L) != 0L)
            return 35;
         if ((active0 & 0xffffffeff9ffc00L) != 0L)
         {
            if (jjmatchedPos != 1)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 1;
            }
            return 35;
         }
         return -1;
      case 2:
         if ((active0 & 0xefffecebfdffc00L) != 0L)
         {
            if (jjmatchedPos != 2)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 2;
            }
            return 35;
         }
         if ((active0 & 0x100013040000000L) != 0L)
            return 35;
         return -1;
      case 3:
         if ((active0 & 0xc7ffcae3e5d3c00L) != 0L)
         {
            if (jjmatchedPos != 3)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 3;
            }
            return 35;
         }
         if ((active0 & 0x28002408182c000L) != 0L)
            return 35;
         return -1;
      case 4:
         if ((active0 & 0x86080003c053000L) != 0L)
            return 35;
         if ((active0 & 0x41f7cae02580c00L) != 0L)
         {
            if (jjmatchedPos != 4)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 4;
            }
            return 35;
         }
         return -1;
      case 5:
         if ((active0 & 0x41a1c2a12180c00L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 5;
            return 35;
         }
         if ((active0 & 0x45608400400000L) != 0L)
            return 35;
         return -1;
      case 6:
         if ((active0 & 0x41a102a00080400L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 6;
            return 35;
         }
         if ((active0 & 0xc0012100800L) != 0L)
            return 35;
         return -1;
      case 7:
         if ((active0 & 0x402000000080400L) != 0L)
            return 35;
         if ((active0 & 0x18102a00000000L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 7;
            return 35;
         }
         return -1;
      case 8:
         if ((active0 & 0x8000a00000000L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 8;
            return 35;
         }
         if ((active0 & 0x10102000000000L) != 0L)
            return 35;
         return -1;
      case 9:
         if ((active0 & 0x8000000000000L) != 0L)
         {
            jjmatchedKind = 69;
            jjmatchedPos = 9;
            return 35;
         }
         if ((active0 & 0xa00000000L) != 0L)
            return 35;
         return -1;
      case 10:
         if ((active0 & 0x8000000000000L) != 0L)
         {
            if (jjmatchedPos != 10)
            {
               jjmatchedKind = 69;
               jjmatchedPos = 10;
            }
            return 35;
         }
         return -1;
      case 11:
         if ((active0 & 0x8000000000000L) != 0L)
            return 35;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0, long active1, long active2)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
}
private final int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private final int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 9:
         return jjStartNfaWithStates_0(0, 2, 0);
      case 10:
         return jjStartNfaWithStates_0(0, 5, 0);
      case 12:
         return jjStartNfaWithStates_0(0, 4, 0);
      case 13:
         return jjStartNfaWithStates_0(0, 3, 0);
      case 32:
         return jjStartNfaWithStates_0(0, 1, 0);
      case 33:
         jjmatchedKind = 86;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x80000000L, 0x0L);
      case 37:
         jjmatchedKind = 111;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000000L, 0x0L);
      case 38:
         jjmatchedKind = 106;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x400000400000000L, 0x0L);
      case 40:
         return jjStopAtPos(0, 72);
      case 41:
         return jjStopAtPos(0, 73);
      case 42:
         jjmatchedKind = 104;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L, 0x0L);
      case 43:
         jjmatchedKind = 102;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x40001000000000L, 0x0L);
      case 44:
         return jjStopAtPos(0, 79);
      case 45:
         jjmatchedKind = 103;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x80002000000000L, 0x0L);
      case 46:
         return jjStartNfaWithStates_0(0, 80, 11);
      case 47:
         jjmatchedKind = 105;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000000L, 0x0L);
      case 58:
         return jjStopAtPos(0, 89);
      case 59:
         return jjStopAtPos(0, 78);
      case 60:
         jjmatchedKind = 84;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000008000000L, 0x1L);
      case 61:
         jjmatchedKind = 81;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000L, 0x0L);
      case 62:
         jjmatchedKind = 82;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x14000020000000L, 0x14L);
      case 63:
         return jjStopAtPos(0, 88);
      case 64:
         return jjMoveStringLiteralDfa1_0(0x0L, 0x282a280a50280000L, 0x2aL);
      case 91:
         return jjStopAtPos(0, 76);
      case 93:
         return jjStopAtPos(0, 77);
      case 94:
         jjmatchedKind = 110;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000000000L, 0x0L);
      case 97:
         return jjMoveStringLiteralDfa1_0(0x400L, 0x0L, 0x0L);
      case 98:
         return jjMoveStringLiteralDfa1_0(0x5800L, 0x0L, 0x0L);
      case 99:
         return jjMoveStringLiteralDfa1_0(0xfa000L, 0x0L, 0x0L);
      case 100:
         return jjMoveStringLiteralDfa1_0(0x700000L, 0x0L, 0x0L);
      case 101:
         return jjMoveStringLiteralDfa1_0(0x3800000L, 0x0L, 0x0L);
      case 102:
         return jjMoveStringLiteralDfa1_0(0x7c000000L, 0x0L, 0x0L);
      case 103:
         return jjMoveStringLiteralDfa1_0(0x80000000L, 0x0L, 0x0L);
      case 105:
         return jjMoveStringLiteralDfa1_0(0x3f00000000L, 0x0L, 0x0L);
      case 108:
         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
      case 110:
         return jjMoveStringLiteralDfa1_0(0x38000000000L, 0x0L, 0x0L);
      case 112:
         return jjMoveStringLiteralDfa1_0(0x3c0000000000L, 0x0L, 0x0L);
      case 114:
         return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L, 0x0L);
      case 115:
         return jjMoveStringLiteralDfa1_0(0xf800000000000L, 0x0L, 0x0L);
      case 116:
         return jjMoveStringLiteralDfa1_0(0x1f0000000000000L, 0x0L, 0x0L);
      case 118:
         return jjMoveStringLiteralDfa1_0(0x600000000000000L, 0x0L, 0x0L);
      case 119:
         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L, 0x0L);
      case 123:
         return jjStopAtPos(0, 74);
      case 124:
         jjmatchedKind = 108;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000100000000L, 0x0L);
      case 125:
         return jjStopAtPos(0, 75);
      case 126:
         return jjStopAtPos(0, 87);
      default :
         return jjMoveNfa_0(6, 0);
   }
}
private final int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0, active1, active2);
      return 1;
   }
   switch(curChar)
   {
      case 38:
         if ((active1 & 0x400000000L) != 0L)
            return jjStopAtPos(1, 98);
         break;
      case 43:
         if ((active1 & 0x1000000000L) != 0L)
            return jjStopAtPos(1, 100);
         break;
      case 45:
         if ((active1 & 0x2000000000L) != 0L)
            return jjStopAtPos(1, 101);
         break;
      case 60:
         if ((active1 & 0x1000000000000L) != 0L)
         {
            jjmatchedKind = 112;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x1L);
      case 61:
         if ((active1 & 0x4000000L) != 0L)
            return jjStopAtPos(1, 90);
         else if ((active1 & 0x8000000L) != 0L)
            return jjStopAtPos(1, 91);
         else if ((active1 & 0x20000000L) != 0L)
            return jjStopAtPos(1, 93);
         else if ((active1 & 0x80000000L) != 0L)
            return jjStopAtPos(1, 95);
         else if ((active1 & 0x40000000000000L) != 0L)
            return jjStopAtPos(1, 118);
         else if ((active1 & 0x80000000000000L) != 0L)
            return jjStopAtPos(1, 119);
         else if ((active1 & 0x100000000000000L) != 0L)
            return jjStopAtPos(1, 120);
         else if ((active1 & 0x200000000000000L) != 0L)
            return jjStopAtPos(1, 121);
         else if ((active1 & 0x400000000000000L) != 0L)
            return jjStopAtPos(1, 122);
         else if ((active1 & 0x1000000000000000L) != 0L)
            return jjStopAtPos(1, 124);
         else if ((active1 & 0x4000000000000000L) != 0L)
            return jjStopAtPos(1, 126);
         else if ((active1 & 0x8000000000000000L) != 0L)
            return jjStopAtPos(1, 127);
         break;
      case 62:
         if ((active1 & 0x4000000000000L) != 0L)
         {
            jjmatchedKind = 114;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000000000000L, active2, 0x14L);
      case 97:
         return jjMoveStringLiteralDfa2_0(active0, 0x48004018000L, active1, 0x800000800000000L, active2, 0L);
      case 98:
         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0x280000000000L, active2, 0L);
      case 101:
         return jjMoveStringLiteralDfa2_0(active0, 0x410000100000L, active1, 0L, active2, 0L);
      case 102:
         if ((active0 & 0x100000000L) != 0L)
            return jjStartNfaWithStates_0(1, 32, 35);
         break;
      case 103:
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x40080000L, active2, 0L);
      case 104:
         return jjMoveStringLiteralDfa2_0(active0, 0x860800000020000L, active1, 0L, active2, 0L);
      case 105:
         return jjMoveStringLiteralDfa2_0(active0, 0x18000000L, active1, 0L, active2, 0L);
      case 108:
         return jjMoveStringLiteralDfa2_0(active0, 0x20802000L, active1, 0x2000010200000L, active2, 0x2L);
      case 109:
         return jjMoveStringLiteralDfa2_0(active0, 0x600000000L, active1, 0L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa2_0(active0, 0x3801000000L, active1, 0L, active2, 0L);
      case 111:
         if ((active0 & 0x200000L) != 0L)
         {
            jjmatchedKind = 21;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0x6000040c04c0800L, active1, 0x2000000200000000L, active2, 0L);
      case 114:
         return jjMoveStringLiteralDfa2_0(active0, 0x190180000001000L, active1, 0x28000000000000L, active2, 0x28L);
      case 116:
         return jjMoveStringLiteralDfa2_0(active0, 0x3000000000000L, active1, 0L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa2_0(active0, 0x220000000000L, active1, 0L, active2, 0L);
      case 119:
         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
      case 120:
         return jjMoveStringLiteralDfa2_0(active0, 0x2000000L, active1, 0L, active2, 0L);
      case 121:
         return jjMoveStringLiteralDfa2_0(active0, 0x8000000004000L, active1, 0L, active2, 0L);
      case 124:
         if ((active1 & 0x100000000L) != 0L)
            return jjStopAtPos(1, 96);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(0, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0, active1, active2);
      return 2;
   }
   switch(curChar)
   {
      case 61:
         if ((active2 & 0x1L) != 0L)
            return jjStopAtPos(2, 128);
         else if ((active2 & 0x4L) != 0L)
            return jjStopAtPos(2, 130);
         break;
      case 62:
         if ((active1 & 0x10000000000000L) != 0L)
         {
            jjmatchedKind = 116;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x10L);
      case 97:
         return jjMoveStringLiteralDfa3_0(active0, 0x11000000022000L, active1, 0L, active2, 0L);
      case 98:
         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa3_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
      case 101:
         return jjMoveStringLiteralDfa3_0(active0, 0x1000L, active1, 0x2000000000000L, active2, 0x2L);
      case 102:
         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L, active2, 0L);
      case 105:
         return jjMoveStringLiteralDfa3_0(active0, 0xa04080000000000L, active1, 0x28280000000000L, active2, 0x28L);
      case 108:
         return jjMoveStringLiteralDfa3_0(active0, 0x400020004000000L, active1, 0L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa3_0(active0, 0x80040180c0000L, active1, 0x800000800000000L, active2, 0L);
      case 111:
         return jjMoveStringLiteralDfa3_0(active0, 0x900020000800L, active1, 0L, active2, 0L);
      case 112:
         return jjMoveStringLiteralDfa3_0(active0, 0x600000000L, active1, 0L, active2, 0L);
      case 114:
         if ((active0 & 0x40000000L) != 0L)
            return jjStartNfaWithStates_0(2, 30, 35);
         else if ((active1 & 0x200000000L) != 0L)
         {
            jjmatchedKind = 97;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x62000000000000L, active1, 0x2000000000000000L, active2, 0L);
      case 115:
         return jjMoveStringLiteralDfa3_0(active0, 0x800808400L, active1, 0L, active2, 0L);
      case 116:
         if ((active0 & 0x1000000000L) != 0L)
         {
            jjmatchedKind = 36;
            jjmatchedPos = 2;
         }
         else if ((active1 & 0x80000L) != 0L)
         {
            jjmatchedKind = 83;
            jjmatchedPos = 2;
         }
         else if ((active1 & 0x200000L) != 0L)
         {
            jjmatchedKind = 85;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x40a082014000L, active1, 0x50000000L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x80000001400000L, active1, 0L, active2, 0L);
      case 119:
         if ((active0 & 0x10000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 40, 35);
         break;
      case 121:
         if ((active0 & 0x100000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 56, 35);
         break;
      default :
         break;
   }
   return jjStartNfa_0(1, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(1, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0, active1, active2);
      return 3;
   }
   switch(curChar)
   {
      case 61:
         if ((active2 & 0x10L) != 0L)
            return jjStopAtPos(3, 132);
         break;
      case 95:
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 97:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000038101000L, active1, 0L, active2, 0L);
      case 98:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000L, active1, 0L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa4_0(active0, 0x8000000010000L, active1, 0L, active2, 0L);
      case 100:
         if ((active0 & 0x200000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 57, 35);
         else if ((active1 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 99;
            jjmatchedPos = 3;
         }
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
      case 101:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_0(3, 14, 35);
         else if ((active0 & 0x8000L) != 0L)
            return jjStartNfaWithStates_0(3, 15, 35);
         else if ((active0 & 0x800000L) != 0L)
            return jjStartNfaWithStates_0(3, 23, 35);
         else if ((active0 & 0x80000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 55, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x2002000000L, active1, 0x50000000L, active2, 0L);
      case 102:
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 103:
         if ((active0 & 0x4000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 38, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);
      case 105:
         return jjMoveStringLiteralDfa4_0(active0, 0x2008000000000L, active1, 0L, active2, 0L);
      case 107:
         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
      case 108:
         if ((active0 & 0x20000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 41, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x800200200000800L, active1, 0L, active2, 0L);
      case 109:
         if ((active0 & 0x1000000L) != 0L)
            return jjStartNfaWithStates_0(3, 24, 35);
         break;
      case 110:
         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
      case 111:
         if ((active0 & 0x80000000L) != 0L)
            return jjStartNfaWithStates_0(3, 31, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x60000400000000L, active1, 0L, active2, 0L);
      case 114:
         if ((active0 & 0x20000L) != 0L)
            return jjStartNfaWithStates_0(3, 17, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L, active1, 0L, active2, 0L);
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x4042000L, active1, 0L, active2, 0L);
      case 116:
         return jjMoveStringLiteralDfa4_0(active0, 0x5100800080400L, active1, 0x280000000000L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L, active1, 0L, active2, 0L);
      case 118:
         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(2, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0, active1, active2);
      return 4;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
      case 97:
         return jjMoveStringLiteralDfa5_0(active0, 0xc0800000000L, active1, 0x2000000000000000L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa5_0(active0, 0x6000000000000L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_0(4, 26, 35);
         else if ((active0 & 0x800000000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 59, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x100200000800L, active1, 0L, active2, 0L);
      case 104:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_0(4, 16, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000L, active1, 0x28000000000000L, active2, 0x28L);
      case 105:
         return jjMoveStringLiteralDfa5_0(active0, 0x1200000080000L, active1, 0L, active2, 0L);
      case 107:
         if ((active0 & 0x1000L) != 0L)
            return jjStartNfaWithStates_0(4, 12, 35);
         break;
      case 108:
         if ((active0 & 0x8000000L) != 0L)
         {
            jjmatchedKind = 27;
            jjmatchedPos = 4;
         }
         return jjMoveStringLiteralDfa5_0(active0, 0x10400000L, active1, 0L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa5_0(active0, 0x2000000L, active1, 0L, active2, 0L);
      case 113:
         if ((active1 & 0x10000000L) != 0L)
            return jjStopAtPos(4, 92);
         else if ((active1 & 0x40000000L) != 0L)
            return jjStopAtPos(4, 94);
         break;
      case 114:
         return jjMoveStringLiteralDfa5_0(active0, 0x402400000400L, active1, 0L, active2, 0L);
      case 115:
         if ((active0 & 0x2000L) != 0L)
            return jjStartNfaWithStates_0(4, 13, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);
      case 116:
         if ((active0 & 0x40000L) != 0L)
            return jjStartNfaWithStates_0(4, 18, 35);
         else if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_0(4, 29, 35);
         else if ((active0 & 0x800000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 47, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0x2000000000000L, active2, 0x2L);
      case 117:
         return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0L, active2, 0L);
      case 118:
         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0L, active2, 0L);
      case 119:
         if ((active0 & 0x20000000000000L) != 0L)
         {
            jjmatchedKind = 53;
            jjmatchedPos = 4;
         }
         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000000L, active1, 0x280000000000L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(3, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(3, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(4, active0, active1, active2);
      return 5;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 97:
         return jjMoveStringLiteralDfa6_0(active0, 0xc00L, active1, 0x800000000000000L, active2, 0L);
      case 99:
         if ((active0 & 0x200000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 45, 35);
         else if ((active0 & 0x1000000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 48, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
      case 100:
         return jjMoveStringLiteralDfa6_0(active0, 0x2000000L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x400000L) != 0L)
            return jjStartNfaWithStates_0(5, 22, 35);
         else if ((active0 & 0x8000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 39, 35);
         break;
      case 102:
         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
      case 103:
         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L, active1, 0L, active2, 0L);
      case 104:
         if ((active0 & 0x4000000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 50, 35);
         break;
      case 105:
         return jjMoveStringLiteralDfa6_0(active0, 0x410000000000000L, active1, 0x280000000000L, active2, 0L);
      case 108:
         return jjMoveStringLiteralDfa6_0(active0, 0x10100000L, active1, 0L, active2, 0L);
      case 109:
         return jjMoveStringLiteralDfa6_0(active0, 0x200000000L, active1, 0L, active2, 0L);
      case 110:
         if ((active0 & 0x400000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 46, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x800080000L, active1, 0L, active2, 0L);
      case 114:
         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      case 115:
         if ((active0 & 0x40000000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 54, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 116:
         if ((active0 & 0x400000000L) != 0L)
            return jjStartNfaWithStates_0(5, 34, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x2080000000000L, active1, 0x28000000000000L, active2, 0x28L);
      default :
         break;
   }
   return jjStartNfa_0(4, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(4, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(5, active0, active1, active2);
      return 6;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);
      case 97:
         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
      case 99:
         return jjMoveStringLiteralDfa7_0(active0, 0x800000400L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x40000000000L) != 0L)
            return jjStartNfaWithStates_0(6, 42, 35);
         else if ((active0 & 0x80000000000L) != 0L)
            return jjStartNfaWithStates_0(6, 43, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0x10000200000000L, active1, 0L, active2, 0L);
      case 102:
         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
      case 108:
         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L, active2, 0L);
      case 110:
         if ((active0 & 0x800L) != 0L)
            return jjStartNfaWithStates_0(6, 11, 35);
         break;
      case 111:
         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      case 115:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_0(6, 25, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x2802280000000000L, active2, 0x2L);
      case 116:
         if ((active0 & 0x100000L) != 0L)
            return jjStartNfaWithStates_0(6, 20, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000L, active1, 0L, active2, 0L);
      case 117:
         return jjMoveStringLiteralDfa7_0(active0, 0x80000L, active1, 0L, active2, 0L);
      case 121:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_0(6, 28, 35);
         break;
      default :
         break;
   }
   return jjStartNfa_0(5, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(5, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(6, active0, active1, active2);
      return 7;
   }
   switch(curChar)
   {
      case 99:
         return jjMoveStringLiteralDfa8_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
      case 101:
         if ((active0 & 0x80000L) != 0L)
            return jjStartNfaWithStates_0(7, 19, 35);
         else if ((active0 & 0x400000000000000L) != 0L)
            return jjStartNfaWithStates_0(7, 58, 35);
         return jjMoveStringLiteralDfa8_0(active0, 0x100800000000L, active1, 0x280000000000L, active2, 0L);
      case 104:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 105:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 110:
         return jjMoveStringLiteralDfa8_0(active0, 0x18000200000000L, active1, 0L, active2, 0L);
      case 112:
         if ((active0 & 0x2000000000000L) != 0L)
            return jjStartNfaWithStates_0(7, 49, 35);
         break;
      case 115:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x808000000000000L, active2, 0x8L);
      case 116:
         if ((active0 & 0x400L) != 0L)
            return jjStartNfaWithStates_0(7, 10, 35);
         break;
      case 117:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(6, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(6, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(7, active0, active1, active2);
      return 8;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x280000000000L, active2, 0L);
      case 100:
         if ((active0 & 0x100000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 44, 35);
         break;
      case 101:
         if ((active0 & 0x2000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 37, 35);
         break;
      case 103:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);
      case 104:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
      case 105:
         return jjMoveStringLiteralDfa9_0(active0, 0x8000000000000L, active1, 0x802000000000000L, active2, 0x2L);
      case 110:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 111:
         return jjMoveStringLiteralDfa9_0(active0, 0x800000000L, active1, 0L, active2, 0L);
      case 116:
         if ((active0 & 0x10000000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 52, 35);
         return jjMoveStringLiteralDfa9_0(active0, 0x200000000L, active1, 0L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(7, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(7, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(8, active0, active1, active2);
      return 9;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x80000000000L, active2, 0L);
      case 102:
         if ((active0 & 0x800000000L) != 0L)
            return jjStartNfaWithStates_0(9, 35, 35);
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);
      case 103:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);
      case 105:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
      case 110:
         if ((active1 & 0x2000000000000000L) != 0L)
            return jjStopAtPos(9, 125);
         break;
      case 111:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x200000000000L, active2, 0L);
      case 115:
         if ((active0 & 0x200000000L) != 0L)
            return jjStartNfaWithStates_0(9, 33, 35);
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 122:
         return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      default :
         break;
   }
   return jjStartNfa_0(8, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(8, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(9, active0, active1, active2);
      return 10;
   }
   switch(curChar)
   {
      case 101:
         return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);
      case 102:
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);
      case 105:
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 110:
         if ((active1 & 0x800000000000000L) != 0L)
            return jjStopAtPos(10, 123);
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x80000000000L, active2, 0L);
      case 114:
         if ((active1 & 0x200000000000L) != 0L)
            return jjStopAtPos(10, 109);
         break;
      case 116:
         if ((active1 & 0x2000000000000L) != 0L)
         {
            jjmatchedKind = 113;
            jjmatchedPos = 10;
         }
         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0L, active2, 0x2L);
      default :
         break;
   }
   return jjStartNfa_0(9, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(9, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(10, active0, active1, active2);
      return 11;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x2L);
      case 100:
         if ((active0 & 0x8000000000000L) != 0L)
            return jjStartNfaWithStates_0(11, 51, 35);
         else if ((active1 & 0x80000000000L) != 0L)
            return jjStopAtPos(11, 107);
         break;
      case 103:
         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);
      case 116:
         if ((active1 & 0x8000000000000L) != 0L)
         {
            jjmatchedKind = 115;
            jjmatchedPos = 11;
         }
         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x8L);
      default :
         break;
   }
   return jjStartNfa_0(10, active0, active1, active2);
}
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1, long old2, long active2)
{
   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(10, old0, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(11, 0L, active1, active2);
      return 12;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x8L);
      case 97:
         return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x2L);
      case 110:
         return jjMoveStringLiteralDfa13_0(active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(11, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa13_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(11, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(12, 0L, active1, active2);
      return 13;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x8L);
      case 101:
         return jjMoveStringLiteralDfa14_0(active1, 0x20000000000000L, active2, 0x20L);
      case 115:
         return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x2L);
      default :
         break;
   }
   return jjStartNfa_0(12, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa14_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(12, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(13, 0L, active1, active2);
      return 14;
   }
   switch(curChar)
   {
      case 100:
         return jjMoveStringLiteralDfa15_0(active1, 0x20000000000000L, active2, 0x20L);
      case 115:
         return jjMoveStringLiteralDfa15_0(active1, 0L, active2, 0xaL);
      default :
         break;
   }
   return jjStartNfa_0(13, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa15_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(13, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(14, 0L, active1, active2);
      return 15;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa16_0(active1, 0x20000000000000L, active2, 0x20L);
      case 105:
         return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x2L);
      case 115:
         return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x8L);
      default :
         break;
   }
   return jjStartNfa_0(14, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa16_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(14, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(15, 0L, active1, active2);
      return 16;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x2L);
      case 105:
         return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x8L);
      case 115:
         return jjMoveStringLiteralDfa17_0(active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(15, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa17_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(15, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(16, 0L, active1, active2);
      return 17;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa18_0(active1, 0L, active2, 0x8L);
      case 104:
         return jjMoveStringLiteralDfa18_0(active1, 0x20000000000000L, active2, 0x20L);
      case 110:
         if ((active2 & 0x2L) != 0L)
            return jjStopAtPos(17, 129);
         break;
      default :
         break;
   }
   return jjStartNfa_0(16, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa18_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(16, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(17, 0L, active1, active2);
      return 18;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa19_0(active1, 0x20000000000000L, active2, 0x20L);
      case 110:
         if ((active2 & 0x8L) != 0L)
            return jjStopAtPos(18, 131);
         break;
      default :
         break;
   }
   return jjStartNfa_0(17, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa19_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(17, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(18, 0L, active1, active2);
      return 19;
   }
   switch(curChar)
   {
      case 102:
         return jjMoveStringLiteralDfa20_0(active1, 0x20000000000000L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(18, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa20_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(18, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(19, 0L, active1, active2);
      return 20;
   }
   switch(curChar)
   {
      case 116:
         if ((active1 & 0x20000000000000L) != 0L)
         {
            jjmatchedKind = 117;
            jjmatchedPos = 20;
         }
         return jjMoveStringLiteralDfa21_0(active1, 0L, active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(19, 0L, active1, active2);
}
private final int jjMoveStringLiteralDfa21_0(long old1, long active1, long old2, long active2)
{
   if (((active1 &= old1) | (active2 &= old2)) == 0L)
      return jjStartNfa_0(19, 0L, old1, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(20, 0L, 0L, active2);
      return 21;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa22_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(20, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa22_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(20, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(21, 0L, 0L, active2);
      return 22;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa23_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(21, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa23_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(21, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(22, 0L, 0L, active2);
      return 23;
   }
   switch(curChar)
   {
      case 115:
         return jjMoveStringLiteralDfa24_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(22, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa24_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(22, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(23, 0L, 0L, active2);
      return 24;
   }
   switch(curChar)
   {
      case 115:
         return jjMoveStringLiteralDfa25_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(23, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa25_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(23, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(24, 0L, 0L, active2);
      return 25;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa26_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(24, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa26_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(24, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(25, 0L, 0L, active2);
      return 26;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa27_0(active2, 0x20L);
      default :
         break;
   }
   return jjStartNfa_0(25, 0L, 0L, active2);
}
private final int jjMoveStringLiteralDfa27_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(25, 0L, 0L, old2); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(26, 0L, 0L, active2);
      return 27;
   }
   switch(curChar)
   {
      case 110:
         if ((active2 & 0x20L) != 0L)
            return jjStopAtPos(27, 133);
         break;
      default :
         break;
   }
   return jjStartNfa_0(26, 0L, 0L, active2);
}
private final void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private final void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private final void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}
private final void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}
private final void jjCheckNAddStates(int start)
{
   jjCheckNAdd(jjnextStates[start]);
   jjCheckNAdd(jjnextStates[start + 1]);
}
static final long[] jjbitVec0 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec1 = {
   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec3 = {
   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
};
static final long[] jjbitVec4 = {
   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
};
static final long[] jjbitVec5 = {
   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec6 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
};
static final long[] jjbitVec7 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
};
static final long[] jjbitVec8 = {
   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
};
private final int jjMoveNfa_0(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 74;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if ((0x1ffffffffL & l) != 0L)
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAdd(0);
                  }
                  else if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(0, 6);
                  else if (curChar == 47)
                     jjAddStates(7, 9);
                  else if (curChar == 36)
                  {
                     if (kind > 69)
                        kind = 69;
                     jjCheckNAdd(35);
                  }
                  else if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  else if (curChar == 39)
                     jjAddStates(13, 14);
                  else if (curChar == 46)
                     jjCheckNAdd(11);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 1;
                  if ((0x3fe000000000000L & l) != 0L)
                  {
                     if (kind > 60)
                        kind = 60;
                     jjCheckNAddTwoStates(8, 9);
                  }
                  else if (curChar == 48)
                  {
                     if (kind > 60)
                        kind = 60;
                     jjCheckNAddStates(15, 17);
                  }
                  break;
               case 56:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 67;
                  else if (curChar == 47)
                  {
                     if (kind > 7)
                        kind = 7;
                     jjCheckNAddStates(18, 20);
                  }
                  if (curChar == 42)
                     jjCheckNAdd(62);
                  break;
               case 0:
                  if ((0x1ffffffffL & l) == 0L)
                     break;
                  if (kind > 6)
                     kind = 6;
                  jjCheckNAdd(0);
                  break;
               case 1:
                  if (curChar == 33)
                     jjCheckNAddStates(21, 23);
                  break;
               case 2:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     jjCheckNAddStates(21, 23);
                  break;
               case 3:
                  if ((0x2400L & l) != 0L && kind > 8)
                     kind = 8;
                  break;
               case 4:
                  if (curChar == 10 && kind > 8)
                     kind = 8;
                  break;
               case 5:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 7:
                  if ((0x3fe000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(8, 9);
                  break;
               case 8:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(8, 9);
                  break;
               case 10:
                  if (curChar == 46)
                     jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddStates(24, 26);
                  break;
               case 13:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(14);
                  break;
               case 14:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddTwoStates(14, 15);
                  break;
               case 16:
                  if (curChar == 39)
                     jjAddStates(13, 14);
                  break;
               case 17:
                  if ((0xffffff7fffffdbffL & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 18:
                  if (curChar == 39 && kind > 66)
                     kind = 66;
                  break;
               case 20:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 21:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(22, 18);
                  break;
               case 22:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 23:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 24;
                  break;
               case 24:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(22);
                  break;
               case 25:
                  if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  break;
               case 26:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 28:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 29:
                  if (curChar == 34 && kind > 67)
                     kind = 67;
                  break;
               case 30:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(27, 30);
                  break;
               case 31:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 32:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 33:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(31);
                  break;
               case 34:
                  if (curChar != 36)
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 35:
                  if ((0x3ff001000000000L & l) == 0L)
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 36:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(0, 6);
                  break;
               case 37:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(37, 38);
                  break;
               case 38:
                  if (curChar != 46)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddStates(31, 33);
                  break;
               case 39:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddStates(31, 33);
                  break;
               case 41:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(42);
                  break;
               case 42:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddTwoStates(42, 15);
                  break;
               case 43:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(43, 44);
                  break;
               case 45:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(46);
                  break;
               case 46:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 64)
                     kind = 64;
                  jjCheckNAddTwoStates(46, 15);
                  break;
               case 47:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(34, 36);
                  break;
               case 49:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(50);
                  break;
               case 50:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(50, 15);
                  break;
               case 51:
                  if (curChar != 48)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddStates(15, 17);
                  break;
               case 53:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(53, 9);
                  break;
               case 54:
                  if ((0xff000000000000L & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(54, 9);
                  break;
               case 55:
                  if (curChar == 47)
                     jjAddStates(7, 9);
                  break;
               case 57:
                  if ((0xffffffffffffdbffL & l) == 0L)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjCheckNAddStates(18, 20);
                  break;
               case 58:
                  if ((0x2400L & l) != 0L && kind > 7)
                     kind = 7;
                  break;
               case 59:
                  if (curChar == 10 && kind > 7)
                     kind = 7;
                  break;
               case 60:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 59;
                  break;
               case 61:
                  if (curChar == 42)
                     jjCheckNAdd(62);
                  break;
               case 62:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 63:
                  if (curChar == 42)
                     jjCheckNAddStates(37, 39);
                  break;
               case 64:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 65:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 66:
                  if (curChar == 47 && kind > 9)
                     kind = 9;
                  break;
               case 67:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(68, 69);
                  break;
               case 68:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(68, 69);
                  break;
               case 69:
                  if (curChar == 42)
                     jjCheckNAddStates(40, 42);
                  break;
               case 70:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(71, 69);
                  break;
               case 71:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(71, 69);
                  break;
               case 72:
                  if (curChar == 47 && kind > 68)
                     kind = 68;
                  break;
               case 73:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 67;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
               case 35:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 2:
                  jjAddStates(21, 23);
                  break;
               case 9:
                  if ((0x100000001000L & l) != 0L && kind > 60)
                     kind = 60;
                  break;
               case 12:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(43, 44);
                  break;
               case 15:
                  if ((0x5000000050L & l) != 0L && kind > 64)
                     kind = 64;
                  break;
               case 17:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 19:
                  if (curChar == 92)
                     jjAddStates(45, 47);
                  break;
               case 20:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 26:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 27:
                  if (curChar == 92)
                     jjAddStates(48, 50);
                  break;
               case 28:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 40:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(51, 52);
                  break;
               case 44:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(53, 54);
                  break;
               case 48:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(55, 56);
                  break;
               case 52:
                  if ((0x100000001000000L & l) != 0L)
                     jjCheckNAdd(53);
                  break;
               case 53:
                  if ((0x7e0000007eL & l) == 0L)
                     break;
                  if (kind > 60)
                     kind = 60;
                  jjCheckNAddTwoStates(53, 9);
                  break;
               case 57:
                  if (kind > 7)
                     kind = 7;
                  jjAddStates(18, 20);
                  break;
               case 62:
                  jjCheckNAddTwoStates(62, 63);
                  break;
               case 64:
               case 65:
                  jjCheckNAddTwoStates(65, 63);
                  break;
               case 68:
                  jjCheckNAddTwoStates(68, 69);
                  break;
               case 70:
               case 71:
                  jjCheckNAddTwoStates(71, 69);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAdd(0);
                  }
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                  {
                     if (kind > 69)
                        kind = 69;
                     jjCheckNAdd(35);
                  }
                  break;
               case 0:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 6)
                     kind = 6;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(21, 23);
                  break;
               case 17:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjstateSet[jjnewStateCnt++] = 18;
                  break;
               case 26:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(10, 12);
                  break;
               case 34:
               case 35:
                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 69)
                     kind = 69;
                  jjCheckNAdd(35);
                  break;
               case 57:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjAddStates(18, 20);
                  break;
               case 62:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 64:
               case 65:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 68:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(68, 69);
                  break;
               case 70:
               case 71:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(71, 69);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 74 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   37, 38, 43, 44, 47, 48, 15, 56, 61, 73, 26, 27, 29, 17, 19, 52, 
   54, 9, 57, 58, 60, 2, 3, 5, 11, 12, 15, 26, 27, 31, 29, 39, 
   40, 15, 47, 48, 15, 63, 64, 66, 69, 70, 72, 13, 14, 20, 21, 23, 
   28, 30, 32, 41, 42, 45, 46, 49, 50, 
};
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         return false;
   }
}
private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         if ((jjbitVec1[i1] & l1) != 0L)
            return true;
         return false;
   }
}
private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec4[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec5[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec6[i2] & l2) != 0L);
      case 51:
         return ((jjbitVec7[i2] & l2) != 0L);
      case 61:
         return ((jjbitVec8[i2] & l2) != 0L);
      default : 
         if ((jjbitVec3[i1] & l1) != 0L)
            return true;
         return false;
   }
}
public static final String[] jjstrLiteralImages = {
"""", null, null, null, null, null, null, null, null, null, 
""\141\142\163\164\162\141\143\164"", ""\142\157\157\154\145\141\156"", ""\142\162\145\141\153"", 
""\143\154\141\163\163"", ""\142\171\164\145"", ""\143\141\163\145"", ""\143\141\164\143\150"", 
""\143\150\141\162"", ""\143\157\156\163\164"", ""\143\157\156\164\151\156\165\145"", 
""\144\145\146\141\165\154\164"", ""\144\157"", ""\144\157\165\142\154\145"", ""\145\154\163\145"", 
""\145\156\165\155"", ""\145\170\164\145\156\144\163"", ""\146\141\154\163\145"", 
""\146\151\156\141\154"", ""\146\151\156\141\154\154\171"", ""\146\154\157\141\164"", ""\146\157\162"", 
""\147\157\164\157"", ""\151\146"", ""\151\155\160\154\145\155\145\156\164\163"", 
""\151\155\160\157\162\164"", ""\151\156\163\164\141\156\143\145\157\146"", ""\151\156\164"", 
""\151\156\164\145\162\146\141\143\145"", ""\154\157\156\147"", ""\156\141\164\151\166\145"", ""\156\145\167"", 
""\156\165\154\154"", ""\160\141\143\153\141\147\145"", ""\160\162\151\166\141\164\145"", 
""\160\162\157\164\145\143\164\145\144"", ""\160\165\142\154\151\143"", ""\162\145\164\165\162\156"", 
""\163\150\157\162\164"", ""\163\164\141\164\151\143"", ""\163\164\162\151\143\164\146\160"", 
""\163\167\151\164\143\150"", ""\163\171\156\143\150\162\157\156\151\172\145\144"", 
""\164\162\141\156\163\151\145\156\164"", ""\164\150\162\157\167"", ""\164\150\162\157\167\163"", ""\164\162\165\145"", 
""\164\162\171"", ""\166\157\151\144"", ""\166\157\154\141\164\151\154\145"", 
""\167\150\151\154\145"", null, null, null, null, null, null, null, null, null, null, null, null, ""\50"", 
""\51"", ""\173"", ""\175"", ""\133"", ""\135"", ""\73"", ""\54"", ""\56"", ""\75"", ""\76"", 
""\100\147\164"", ""\74"", ""\100\154\164"", ""\41"", ""\176"", ""\77"", ""\72"", ""\75\75"", ""\74\75"", 
""\100\154\164\145\161"", ""\76\75"", ""\100\147\164\145\161"", ""\41\75"", ""\174\174"", ""\100\157\162"", 
""\46\46"", ""\100\141\156\144"", ""\53\53"", ""\55\55"", ""\53"", ""\55"", ""\52"", ""\57"", ""\46"", 
""\100\142\151\164\167\151\163\145\137\141\156\144"", ""\174"", ""\100\142\151\164\167\151\163\145\137\157\162"", ""\136"", ""\45"", 
""\74\74"", ""\100\154\145\146\164\137\163\150\151\146\164"", ""\76\76"", 
""\100\162\151\147\150\164\137\163\150\151\146\164"", ""\76\76\76"", 
""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164"", ""\53\75"", ""\55\75"", ""\52\75"", ""\57\75"", ""\46\75"", 
""\100\141\156\144\137\141\163\163\151\147\156"", ""\174\75"", ""\100\157\162\137\141\163\163\151\147\156"", ""\136\75"", ""\45\75"", 
""\74\74\75"", ""\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", 
""\76\76\75"", 
""\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", ""\76\76\76\75"", 
""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156"", };
public static final String[] lexStateNames = {
   ""DEFAULT"", 
};
static final long[] jjtoToken = {
   0x1ffffffffffffc01L, 0xffffffffffffff3dL, 0x3fL, 
};
static final long[] jjtoSkip = {
   0x3feL, 0x0L, 0x0L, 
};
static final long[] jjtoSpecial = {
   0x380L, 0x0L, 0x0L, 
};
protected JavaCharStream input_stream;
private final int[] jjrounds = new int[74];
private final int[] jjstateSet = new int[148];
protected char curChar;
public ParserTokenManager(JavaCharStream stream)
{
   if (JavaCharStream.staticFlag)
      throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
   input_stream = stream;
}
public ParserTokenManager(JavaCharStream stream, int lexState)
{
   this(stream);
   SwitchTo(lexState);
}
public void ReInit(JavaCharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private final void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 74; i-- > 0;)
      jjrounds[i] = 0x80000000;
}
public void ReInit(JavaCharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}
public void SwitchTo(int lexState)
{
   if (lexState >= 1 || lexState < 0)
      throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}
protected Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}
int curLexState = 0;
int defaultLexState = 0;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;
public Token getNextToken() 
{
  int kind;
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;
  EOFLoop :
  for (;;)
  {   
   try   
   {     
      curChar = input_stream.BeginToken();
   }     
   catch(java.io.IOException e)
   {        
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }
   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjMoveStringLiteralDfa0_0();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         matchedToken.specialToken = specialToken;
         return matchedToken;
      }
      else
      {
         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
         {
            matchedToken = jjFillToken();
            if (specialToken == null)
               specialToken = matchedToken;
            else
            {
               matchedToken.specialToken = specialToken;
               specialToken = (specialToken.next = matchedToken);
            }
         }
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}
}
"
bsh.ParserTreeConstants,"/* Generated By:JJTree: Do not edit this line. src/bsh/ParserTreeConstants.java */
package bsh;
public interface ParserTreeConstants
{
  public int JJTVOID = 0;
  public int JJTCLASSDECLARATION = 1;
  public int JJTMETHODDECLARATION = 2;
  public int JJTPACKAGEDECLARATION = 3;
  public int JJTIMPORTDECLARATION = 4;
  public int JJTVARIABLEDECLARATOR = 5;
  public int JJTARRAYINITIALIZER = 6;
  public int JJTFORMALPARAMETERS = 7;
  public int JJTFORMALPARAMETER = 8;
  public int JJTTYPE = 9;
  public int JJTRETURNTYPE = 10;
  public int JJTPRIMITIVETYPE = 11;
  public int JJTAMBIGUOUSNAME = 12;
  public int JJTASSIGNMENT = 13;
  public int JJTTERNARYEXPRESSION = 14;
  public int JJTBINARYEXPRESSION = 15;
  public int JJTUNARYEXPRESSION = 16;
  public int JJTCASTEXPRESSION = 17;
  public int JJTPRIMARYEXPRESSION = 18;
  public int JJTMETHODINVOCATION = 19;
  public int JJTPRIMARYSUFFIX = 20;
  public int JJTLITERAL = 21;
  public int JJTARGUMENTS = 22;
  public int JJTALLOCATIONEXPRESSION = 23;
  public int JJTARRAYDIMENSIONS = 24;
  public int JJTBLOCK = 25;
  public int JJTFORMALCOMMENT = 26;
  public int JJTSWITCHSTATEMENT = 27;
  public int JJTSWITCHLABEL = 28;
  public int JJTIFSTATEMENT = 29;
  public int JJTWHILESTATEMENT = 30;
  public int JJTFORSTATEMENT = 31;
  public int JJTENHANCEDFORSTATEMENT = 32;
  public int JJTTYPEDVARIABLEDECLARATION = 33;
  public int JJTSTATEMENTEXPRESSIONLIST = 34;
  public int JJTRETURNSTATEMENT = 35;
  public int JJTTHROWSTATEMENT = 36;
  public int JJTTRYSTATEMENT = 37;
  public String[] jjtNodeName = {
    ""void"",
    ""ClassDeclaration"",
    ""MethodDeclaration"",
    ""PackageDeclaration"",
    ""ImportDeclaration"",
    ""VariableDeclarator"",
    ""ArrayInitializer"",
    ""FormalParameters"",
    ""FormalParameter"",
    ""Type"",
    ""ReturnType"",
    ""PrimitiveType"",
    ""AmbiguousName"",
    ""Assignment"",
    ""TernaryExpression"",
    ""BinaryExpression"",
    ""UnaryExpression"",
    ""CastExpression"",
    ""PrimaryExpression"",
    ""MethodInvocation"",
    ""PrimarySuffix"",
    ""Literal"",
    ""Arguments"",
    ""AllocationExpression"",
    ""ArrayDimensions"",
    ""Block"",
    ""FormalComment"",
    ""SwitchStatement"",
    ""SwitchLabel"",
    ""IfStatement"",
    ""WhileStatement"",
    ""ForStatement"",
    ""EnhancedForStatement"",
    ""TypedVariableDeclaration"",
    ""StatementExpressionList"",
    ""ReturnStatement"",
    ""ThrowStatement"",
    ""TryStatement"",
  };
}
"
bsh.Primitive,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Hashtable;
/**
    Wrapper for primitive types in Bsh.  This is package public because it 
	is used in the implementation of some bsh commands.
    See the note in LHS.java about wrapping objects.
*/
/*
	Note: this class is final because we may test == Primitive.class in places.
	If we need to change that search for those tests.
*/
public final class Primitive implements ParserConstants, java.io.Serializable
{
	static Hashtable primitiveToWrapper = new Hashtable();
	static Hashtable wrapperToPrimitive = new Hashtable();
	static {
		primitiveToWrapper.put( Boolean.TYPE, Boolean.class );
		primitiveToWrapper.put( Byte.TYPE, Byte.class );
		primitiveToWrapper.put( Short.TYPE, Short.class );
		primitiveToWrapper.put( Character.TYPE, Character.class );
		primitiveToWrapper.put( Integer.TYPE, Integer.class );
		primitiveToWrapper.put( Long.TYPE, Long.class );
		primitiveToWrapper.put( Float.TYPE, Float.class );
		primitiveToWrapper.put( Double.TYPE, Double.class );
		wrapperToPrimitive.put( Boolean.class, Boolean.TYPE );
		wrapperToPrimitive.put( Byte.class, Byte.TYPE );
		wrapperToPrimitive.put( Short.class, Short.TYPE );
		wrapperToPrimitive.put( Character.class, Character.TYPE );
		wrapperToPrimitive.put( Integer.class, Integer.TYPE );
		wrapperToPrimitive.put( Long.class, Long.TYPE );
		wrapperToPrimitive.put( Float.class, Float.TYPE );
		wrapperToPrimitive.put( Double.class, Double.TYPE );
	}
    /** The primitive value stored in its java.lang wrapper class */
    private Object value;
    private static class Special implements java.io.Serializable
    {
        private Special() { }
        public static final Special NULL_VALUE = new Special();
        public static final Special VOID_TYPE = new Special();
    }
    /*
        NULL means ""no value"".
        This ia a placeholder for primitive null value.
    */
    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);
    /**
        VOID means ""no type"".
        Strictly speaking, this makes no sense here.  But for practical
        reasons we'll consider the lack of a type to be a special value.
    */
    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);
    // private to prevent invocation with param that isn't a primitive-wrapper
    public Primitive( Object value )
    {
        if ( value == null )
            throw new InterpreterError(
				""Use Primitve.NULL instead of Primitive(null)"");
		if ( value != Special.NULL_VALUE 
			&& value != Special.VOID_TYPE &&
			!isWrapperType( value.getClass() ) 
		)
            throw new InterpreterError( ""Not a wrapper type: ""+value);
        this.value = value;
    }
    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }
	/**
    	Return the primitive value stored in its java.lang wrapper class 
	*/
    public Object getValue()
    {
        if ( value == Special.NULL_VALUE )
            return null;
        else 
		if ( value == Special.VOID_TYPE )
                throw new InterpreterError(""attempt to unwrap void type"");
        else
            return value;
    }
    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return ""null"";
        else if(value == Special.VOID_TYPE)
            return ""void"";
        else
            return value.toString();
    }
	/**
		Get the corresponding Java primitive TYPE class for this Primitive.
		@return the primitive TYPE class type of the value or Void.TYPE for
		Primitive.VOID or null value for type of Primitive.NULL
	*/
    public Class getType()
    {
		if ( this == Primitive.VOID )
			return Void.TYPE;
		// NULL return null as type... we currently use null type to indicate 
		// loose typing throughout bsh.
		if ( this == Primitive.NULL )
			return null;
		return unboxType( value.getClass() );
    }
	/**
		Perform a binary operation on two Primitives or wrapper types.
		If both original args were Primitives return a Primitive result
		else it was mixed (wrapper/primitive) return the wrapper type.
		The exception is for boolean operations where we will return the 
		primitive type eithe way.
	*/
    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws UtilEvalError
    {
		// special primitive types
        if ( obj1 == NULL || obj2 == NULL )
            throw new UtilEvalError(
				""Null value or 'null' literal in binary operation"");
        if ( obj1 == VOID || obj2 == VOID )
            throw new UtilEvalError(
			""Undefined variable, class, or 'void' literal in binary operation"");
		// keep track of the original types
		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();
		// Unwrap primitives
        if ( obj1 instanceof Primitive )
            obj1 = ((Primitive)obj1).getValue();
        if ( obj2 instanceof Primitive )
            obj2 = ((Primitive)obj2).getValue();
        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];
        if(lhs.getClass() != rhs.getClass())
            throw new UtilEvalError(""Type mismatch in operator.  "" 
			+ lhs.getClass() + "" cannot be used with "" + rhs.getClass() );
		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new UtilTargetError( ""Arithemetic Exception in binary op"", e);
		}
		// If both original args were Primitives return a Primitive result
		// else it was mixed (wrapper/primitive) return the wrapper type
		// Exception is for boolean result, return the primitive
		if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)
			|| result instanceof Boolean
		)
			return new Primitive( result );
		else
			return result;
    }
    static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws UtilEvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new UtilEvalError(""Invalid types in binary operator"" );
	}
    static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
        throws UtilEvalError
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();
        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case BOOL_OR:
            case BOOL_ORX:
                return new Boolean( lhs || rhs );
            case BOOL_AND:
            case BOOL_ANDX:
                return new Boolean( lhs && rhs );
            default:
                throw new InterpreterError(""unimplemented binary operator"");
        }
    }
    // returns Object covering both Long and Boolean return types
    static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Long(lhs + rhs);
            case MINUS:
                return new Long(lhs - rhs);
            case STAR:
                return new Long(lhs * rhs);
            case SLASH:
                return new Long(lhs / rhs);
            case MOD:
                return new Long(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);
            case XOR:
                return new Long(lhs ^ rhs);
            default:
                throw new InterpreterError(
					""Unimplemented binary long operator"");
        }
    }
    // returns Object covering both Integer and Boolean return types
    static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Integer(lhs + rhs);
            case MINUS:
                return new Integer(lhs - rhs);
            case STAR:
                return new Integer(lhs * rhs);
            case SLASH:
                return new Integer(lhs / rhs);
            case MOD:
                return new Integer(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);
            case XOR:
                return new Integer(lhs ^ rhs);
            default:
                throw new InterpreterError(
					""Unimplemented binary integer operator"");
        }
    }
    // returns Object covering both Double and Boolean return types
    static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws UtilEvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Double(lhs + rhs);
            case MINUS:
                return new Double(lhs - rhs);
            case STAR:
                return new Double(lhs * rhs);
            case SLASH:
                return new Double(lhs / rhs);
            case MOD:
                return new Double(lhs % rhs);
            // can't shift floating-point values
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError(""Can't shift doubles"");
            default:
                throw new InterpreterError(
					""Unimplemented binary double operator"");
        }
    }
    // returns Object covering both Long and Boolean return types
    static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws UtilEvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Float(lhs + rhs);
            case MINUS:
                return new Float(lhs - rhs);
            case STAR:
                return new Float(lhs * rhs);
            case SLASH:
                return new Float(lhs / rhs);
            case MOD:
                return new Float(lhs % rhs);
            // can't shift floats
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError(""Can't shift floats "");
            default:
                throw new InterpreterError(
					""Unimplemented binary float operator"");
        }
    }
	/**
		Promote primitive wrapper type to to Integer wrapper type
	*/
    static Object promoteToInteger(Object wrapper )
    {
        if(wrapper instanceof Character)
            return new Integer(((Character)wrapper).charValue());
        else if((wrapper instanceof Byte) || (wrapper instanceof Short))
            return new Integer(((Number)wrapper).intValue());
        return wrapper;
    }
	/**
		Promote the pair of primitives to the maximum type of the two.
		e.g. [int,long]->[long,long]
	*/
    static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);
        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;
            boolean b;
            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }
        return new Object[] { lhs, rhs };
    }
    public static Primitive unaryOperation(Primitive val, int kind)
        throws UtilEvalError
    {
        if (val == NULL)
            throw new UtilEvalError(
				""illegal use of null object or 'null' literal"");
        if (val == VOID)
            throw new UtilEvalError(
				""illegal use of undefined object or 'void' literal"");
        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());
        if ( operand instanceof Boolean )
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }
            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(
				""An error occurred.  Please call technical support."");
    }
    static boolean booleanUnaryOperation(Boolean B, int kind) 
		throws UtilEvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new UtilEvalError(""Operator inappropriate for boolean"");
        }
    }
    static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError(""bad integer unaryOperation"");
        }
    }
    static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError(""bad long unaryOperation"");
        }
    }
    static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError(""bad float unaryOperation"");
        }
    }
    static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError(""bad double unaryOperation"");
        }
    }
    public int intValue() throws UtilEvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new UtilEvalError(""Primitive not a number"");
    }
    public boolean booleanValue() throws UtilEvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new UtilEvalError(""Primitive not a boolean"");
    }
	/**
		Determine if this primitive is a numeric type.
		i.e. not boolean, null, or void (but including char)
	*/
	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}
    public Number numberValue() throws UtilEvalError
    {
		Object value = this.value;
		// Promote character to Number type for these purposes
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
        if (value instanceof Number)
            return (Number)value;
        else
            throw new UtilEvalError(""Primitive not a number"");
    }
	/**
		Primitives compare equal with other Primitives containing an equal
		wrapped value.
	*/
	public boolean equals( Object obj ) 
	{
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return false;
	}
	/**
		The hash of the Primitive is tied to the hash of the wrapped value but
		shifted so that they are not the same.
	*/
	public int hashCode() 
	{
		return this.value.hashCode() * 21; // arbitrary
	}
	/**
		Unwrap primitive values and map voids to nulls.
		Non Primitive types remain unchanged.
		@param obj object type which may be bsh.Primitive
		@return corresponding ""normal"" Java type, ""unwrapping"" 
			any bsh.Primitive types to their wrapper types.
	*/
	public static Object unwrap( Object obj ) 
	{
        // map voids to nulls for the outside world
        if (obj == Primitive.VOID)
            return null;
        // unwrap primitives
        if (obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}
    /*
        Unwrap Primitive wrappers to their java.lang wrapper values.
		e.g. Primitive(42) becomes Integer(42)
		@see #unwrap( Object )
    */
    public static Object [] unwrap( Object[] args )
    {
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = unwrap( args[i] );
		return oa;
    }
    /*
    */
    public static Object [] wrap( Object[] args, Class [] paramTypes )
    {
		if ( args == null )
			return null;
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = wrap( args[i], paramTypes[i] );
		return oa;
    }
	/**
		Wrap primitive values (as indicated by type param) and nulls in the 
		Primitive class.  Values not primitive or null are left unchanged.
		Primitive values are represented by their wrapped values in param value.
		<p/>
		The value null is mapped to Primitive.NULL.
		Any value specified with type Void.TYPE is mapped to Primitive.VOID.
	*/
    public static Object wrap(
		Object value, Class type )
    {
        if ( type == Void.TYPE )
            return Primitive.VOID;
        if ( value == null )
            return Primitive.NULL;
		if ( type.isPrimitive() )
			return new Primitive( value );
		return value;
    }
	/**
		Get the appropriate default value per JLS 4.5.4
	*/
	public static Primitive getDefaultValue( Class type )
	{
		if ( type == null || !type.isPrimitive() )
			return Primitive.NULL;
		if ( type == Boolean.TYPE )
			return new Primitive( false );
		// non boolean primitive, get appropriate flavor of zero
		try {
			return new Primitive((int)0).castToType( type, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError( ""bad cast"" );
		}
	}
	/**
		Get the corresponding java.lang wrapper class for the primitive TYPE
		class.
		e.g.  Integer.TYPE -> Integer.class
	*/
	public static Class boxType( Class primitiveType )
	{
		Class c = (Class)primitiveToWrapper.get( primitiveType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			""Not a primitive type: ""+ primitiveType );
	}
	/**
		Get the corresponding primitive TYPE class for the java.lang wrapper
		class type.
		e.g.  Integer.class -> Integer.TYPE
	*/
	public static Class unboxType( Class wrapperType )
	{
		Class c = (Class)wrapperToPrimitive.get( wrapperType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			""Not a primitive wrapper type: ""+wrapperType );
	}
	/**
		Cast this bsh.Primitive value to a new bsh.Primitive value
		This is usually a numeric type cast.  Other cases include:
			A boolean can be cast to boolen
			null can be cast to any object type and remains null
			Attempting to cast a void causes an exception
		@param toType is the java object or primitive TYPE class
	*/
	public Primitive castToType( Class toType, int operation ) 
		throws UtilEvalError
	{
		return castPrimitive( 
			toType, getType()/*fromType*/, this/*fromValue*/, 
			false/*checkOnly*/, operation );
	}
	/**
		@param toType is the java primitive TYPE type of the primitive to be
		cast to.
		@param fromType is the java primitive TYPE type of the primitive to be
		cast.  fromType should be null to indicate that the fromValue was null
		or void.
		@param fromValue is, optionally, the value to be converted.  If
		checkOnly is true fromValue must be null.  If checkOnly is false,
		fromValue must be non-null (Primitive.NULL is of course valid).
	*/
	static Primitive castPrimitive( 
		Class toType, Class fromType, Primitive fromValue, 
		boolean checkOnly, int operation ) 
		throws UtilEvalError
	{
		/*
			Lots of preconditions checked here...
			Once things are running smoothly we might comment these out
			(That's what assertions are for).
		*/
		if ( checkOnly && fromValue != null )
			throw new InterpreterError(""bad cast param 1"");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError(""bad cast param 2"");
		if ( fromType != null && !fromType.isPrimitive() )
			throw new InterpreterError(""bad fromType:"" +fromType);
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError(""inconsistent args 1"");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError(""inconsistent args 2"");
		// can't cast void to anything
		if ( fromType == Void.TYPE )
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( Reflect.normalizeClassName(toType), 
					""void value"", operation );
		// unwrap, etc.
		Object value = null; 
		if ( fromValue != null )
			value = fromValue.getValue();
		if ( toType.isPrimitive() )
		{
			// Trying to cast null to primitive type?
			if ( fromType == null )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError(
						""primitive type:"" + toType, ""Null value"", operation );
			// fall through
		} else
		{
			// Trying to cast primitive to an object type
			// Primitive.NULL can be cast to any object type
			if ( fromType == null )
				return checkOnly ? Types.VALID_CAST : 
					Primitive.NULL;
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError(
						""object type:"" + toType, ""primitive value"", operation);
		}
		// can only cast boolean to boolean
		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError( toType, fromType, operation );
			return checkOnly ? Types.VALID_CAST :
				fromValue;
		}
		// Do numeric cast
		// Only allow legal Java assignment unless we're a CAST operation
		if ( operation == Types.ASSIGNMENT 
			&& !Types.isJavaAssignable( toType, fromType ) 
		) {
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( toType, fromType, operation );
		}
		return checkOnly ? Types.VALID_CAST :
			new Primitive( castWrapper(toType, value) );
	}
	public static boolean isWrapperType( Class type )
	{
		return wrapperToPrimitive.get( type ) != null;
	}
	/**
		Cast a primitive value represented by its java.lang wrapper type to the
		specified java.lang wrapper type.  e.g.  Byte(5) to Integer(5) or
		Integer(5) to Byte(5) 
		@param toType is the java TYPE type
		@param value is the value in java.lang wrapper.
		value may not be null.
	*/
	static Object castWrapper( 
		Class toType, Object value ) 
	{
		if ( !toType.isPrimitive() )
			throw new InterpreterError(""invalid type in castWrapper: ""+toType);
		if ( value == null )
			throw new InterpreterError(""null value in castWrapper, guard"");
		if ( value instanceof Boolean && toType != Boolean.TYPE )
			throw new InterpreterError(""bad wrapper cast of boolean"");
		Class fromType = value.getClass();
		// first promote char to Number type to avoid duplicating code
		if ( value instanceof Character )
			value = new Integer(((Character)value).charValue());
		if ( !(value instanceof Number) )
			throw new InterpreterError(""bad type in cast"");
		Number number = (Number)value;
		if (toType == Byte.TYPE)
			return new Byte(number.byteValue());
		if (toType == Short.TYPE)
			return new Short(number.shortValue());
		if (toType == Character.TYPE)
			return new Character((char)number.intValue());
		if (toType == Integer.TYPE)
			return new Integer(number.intValue());
		if (toType == Long.TYPE)
			return new Long(number.longValue());
		if (toType == Float.TYPE)
			return new Float(number.floatValue());
		if (toType == Double.TYPE)
			return new Double(number.doubleValue());
		throw new InterpreterError(""error in wrapper cast"");
	}
}
"
bsh.Reflect,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.*;
import java.io.*;
import java.util.Vector;
/**
    All of the reflection API code lies here.  It is in the form
	of static utilities.  Maybe this belongs in LHS.java or a generic object 
	wrapper class.
*/
/*
	Note: This class is messy.  The method and field resolution need to be
	rewritten.  Various methods in here catch NoSuchMethod or NoSuchField
	exceptions during their searches.  These should be rewritten to avoid
	having to catch the exceptions.  Method lookups are now cached at a high 
	level so they are less important, however the logic is messy.
*/
class Reflect 
{
    /**
		Invoke method on arbitrary object.
		invocation may be static (through the object instance) or dynamic.
		Object may be a bsh scripted object (This type).
	*/
    public static Object invokeObjectMethod(
		Object object, String methodName, Object[] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo ) 
		throws ReflectError, EvalError, InvocationTargetException
	{
		// Bsh scripted object
		if ( object instanceof This && !This.isExposedThisMethod( methodName) ) 
			return ((This)object).invokeMethod( 
				methodName, args, interpreter, callstack, callerInfo,
				false/*delcaredOnly*/ );
		else 
		// Java object
		{ 
			// find the java method
			try {
				BshClassManager bcm = 
					interpreter == null ? null : interpreter.getClassManager();
				Class clas = object.getClass();
				Method method = resolveExpectedJavaMethod( 
					bcm, clas, object, methodName, args, false );
				return invokeOnMethod( method, object, args );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( callerInfo, callstack );
			}
		}
    }
    /** 
		Invoke a method known to be static.
		No object instance is needed and there is no possibility of the 
		method being a bsh scripted method.
	*/
    public static Object invokeStaticMethod(
		BshClassManager bcm, Class clas, String methodName, Object [] args )
        throws ReflectError, UtilEvalError, InvocationTargetException
    {
        Interpreter.debug(""invoke static Method"");
        Method method = resolveExpectedJavaMethod( 
			bcm, clas, null, methodName, args, true );
		return invokeOnMethod( method, null, args );
    }
	/**
		Invoke the Java method on the specified object.
		@param args may be null
	*/
	static Object invokeOnMethod( 
		Method method, Object object, Object[] args ) 
		throws ReflectError, InvocationTargetException
	{
		if ( args == null )
			args = new Object[0];
		if ( Interpreter.DEBUG ) 
		{
			Interpreter.debug(""Invoking method (entry): ""
				+method+"" with args:"" );
			for(int i=0; i<args.length; i++)
				Interpreter.debug(
					""args[""+i+""] = ""+args[i]
					+"" type = ""+args[i].getClass() );
		}
		// Map types to assignable forms, need to keep this fast...
		Object [] tmpArgs = new Object [ args.length ];
		Class [] types = method.getParameterTypes();
		try {
			for (int i=0; i<args.length; i++)
				tmpArgs[i] = Types.getAssignableForm( args[i], types[i] );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError(
				""illegal argument type in method invocation: ""+e );
		}
		// unwrap any primitives
		tmpArgs = Primitive.unwrap( tmpArgs );
		if ( Interpreter.DEBUG ) 
		{
			Interpreter.debug(""Invoking method (after massaging values): ""
				+method+"" with tmpArgs:"" );
			for(int i=0; i<tmpArgs.length; i++)
				Interpreter.debug(
					""tmpArgs[""+i+""] = ""+tmpArgs[i]
					+"" type = ""+tmpArgs[i].getClass() );
		}
		try {
			Object returnValue = method.invoke( object, tmpArgs );
			if ( returnValue == null )
				returnValue = Primitive.NULL;
			Class returnType = method.getReturnType();
			return Primitive.wrap( returnValue, returnType );
		} catch( IllegalAccessException e ) {
			throw new ReflectError( ""Cannot access method "" 
				+ StringUtil.methodString(
					method.getName(), method.getParameterTypes() ) 
				+ "" in '"" + method.getDeclaringClass() + ""' :"" + e );
		}
	}
    public static Object getIndex(Object array, int index)
        throws ReflectError, UtilTargetError
    {
		if ( Interpreter.DEBUG ) 
			Interpreter.debug(""getIndex: ""+array+"", index=""+index);
        try {
            Object val = Array.get(array, index);
            return Primitive.wrap( val, array.getClass().getComponentType() );
        }
        catch( ArrayIndexOutOfBoundsException  e1 ) {
			throw new UtilTargetError( e1 );
        } catch(Exception e) {
            throw new ReflectError(""Array access:"" + e);
        }
    }
    public static void setIndex(Object array, int index, Object val)
        throws ReflectError, UtilTargetError
    {
        try {
            val = Primitive.unwrap(val);
            Array.set(array, index, val);
        }
        catch( ArrayStoreException e2 ) {
			throw new UtilTargetError( e2 );
        } catch( IllegalArgumentException e1 ) {
			throw new UtilTargetError( 
				new ArrayStoreException( e1.toString() ) );
        } catch(Exception e) {
            throw new ReflectError(""Array access:"" + e);
        }
    }
    public static Object getStaticField(Class clas, String fieldName)
        throws UtilEvalError, ReflectError
    {
        return getFieldValue( clas, null, fieldName, true/*onlystatic*/);
    }
	/**
	*/
    public static Object getObjectField( Object object, String fieldName )
        throws UtilEvalError, ReflectError
    {
		if ( object instanceof This )
			return ((This)object).namespace.getVariable( fieldName );
		else {
			try {
				return getFieldValue(
					object.getClass(), object, fieldName, false/*onlystatic*/);
			} catch ( ReflectError e ) {
				// no field, try property acces
				if ( hasObjectPropertyGetter( object.getClass(), fieldName ) )
					return getObjectProperty( object, fieldName );
				else
					throw e;
			}
		}
    }
    static LHS getLHSStaticField(Class clas, String fieldName)
        throws UtilEvalError, ReflectError
    {
        Field f = resolveExpectedJavaField( 
			clas, fieldName, true/*onlystatic*/);
        return new LHS(f);
    }
	/**
		Get an LHS reference to an object field.
		This method also deals with the field style property access.
		In the field does not exist we check for a property setter.
	*/
    static LHS getLHSObjectField( Object object, String fieldName )
        throws UtilEvalError, ReflectError
    {
		if ( object instanceof This )
		{
			// I guess this is when we pass it as an argument?
			// Setting locally
			boolean recurse = false; 
			return new LHS( ((This)object).namespace, fieldName, recurse );
		}
		try {
			Field f = resolveExpectedJavaField( 
				object.getClass(), fieldName, false/*onlyStatic*/ );
			return new LHS(object, f);
		} catch ( ReflectError e ) 
		{
			// not a field, try property access
			if ( hasObjectPropertySetter( object.getClass(), fieldName ) )
				return new LHS( object, fieldName );
			else
				throw e;
		}
    }
    private static Object getFieldValue(
		Class clas, Object object, String fieldName, boolean onlyStatic ) 
		throws UtilEvalError, ReflectError
    {
        try {
            Field f = resolveExpectedJavaField( clas, fieldName, onlyStatic );
            Object value = f.get(object);
            Class returnType = f.getType();
            return Primitive.wrap( value, returnType );
        } catch( NullPointerException e ) { // shouldn't happen
            throw new ReflectError(
				""???"" + fieldName + "" is not a static field."");
        } catch(IllegalAccessException e) {
            throw new ReflectError(""Can't access field: "" + fieldName);
        }
    }
	/**
	*/
	/*
		Note: this method and resolveExpectedJavaField should be rewritten
		to invert this logic so that no exceptions need to be caught
		unecessarily.  This is just a temporary impl.
		@return the field or null if not found
	*/
    protected static Field resolveJavaField( 
		Class clas, String fieldName, boolean onlyStatic )
        throws UtilEvalError
    {
		try {
			return resolveExpectedJavaField( clas, fieldName, onlyStatic );
		} catch ( ReflectError e ) { 
			return null;
		}
	}
	/**
		@throws ReflectError if the field is not found.
	*/
	/*
		Note: this should really just throw NoSuchFieldException... need
		to change related signatures and code.
	*/
    protected static Field resolveExpectedJavaField( 
		Class clas, String fieldName, boolean onlyStatic
	)
        throws UtilEvalError, ReflectError
    {
		Field f;
        try {
			if ( Capabilities.haveAccessibility() )
				f = findAccessibleField( clas, fieldName );
			else
				// this one only finds public (and in interfaces, etc.)
				f = clas.getField(fieldName);
        }
        catch( NoSuchFieldException e)
        {
			// try declaredField
            throw new ReflectError(""No such field: "" + fieldName );
        }
		if ( onlyStatic && !Modifier.isStatic( f.getModifiers() ) )
			throw new UtilEvalError(
				""Can't reach instance field: ""+fieldName
				+"" from static context: ""+clas.getName() );
		return f;
    }
	/**
		Used when accessibility capability is available to locate an occurrance
		of the field in the most derived class or superclass and set its 
		accessibility flag.
		Note that this method is not needed in the simple non accessible
		case because we don't have to hunt for fields.
		Note that classes may declare overlapping private fields, so the 
		distinction about the most derived is important.  Java doesn't normally
		allow this kind of access (super won't show private variables) so 
		there is no real syntax for specifying which class scope to use...
		@return the Field or throws NoSuchFieldException
		@throws NoSuchFieldException if the field is not found
	*/
	/*
		This method should be rewritten to use getFields() and avoid catching
		exceptions during the search.
	*/
	private static Field findAccessibleField( Class clas, String fieldName ) 
		throws UtilEvalError, NoSuchFieldException
	{
		Field field;
		// Quick check catches public fields include those in interfaces
		try {
			field = clas.getField(fieldName);
			ReflectManager.RMSetAccessible( field );
			return field;
		} catch ( NoSuchFieldException e ) { }
		// Now, on with the hunt...
		while ( clas != null )
		{
			try {
				field = clas.getDeclaredField(fieldName);
				ReflectManager.RMSetAccessible( field );
				return field;
				// Not found, fall through to next class
			} catch(NoSuchFieldException e) { }
			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException( fieldName );
	}
	/**
		This method expects a non-null method from resolveJavaMethod().
		If the method is not found it throws a descriptive ReflectError.
	*/
    protected static Method resolveExpectedJavaMethod(
		BshClassManager bcm, Class clas, Object object, 
		String name, Object[] args, boolean onlyStatic )
        throws ReflectError, UtilEvalError
    {
		Method method = resolveJavaMethod( 
			bcm, clas, object, name, args, onlyStatic );
		if ( method != null )
			return method;
		Class [] types = Types.getTypes(args);
		throw new ReflectError(
			( onlyStatic ? ""Static method "" : ""Method "" )
			+ StringUtil.methodString(name, types) + 
			"" not found in class'"" + clas.getName() + ""'"");
	}
    /**
        The full blown resolver method.  All other method invocation methods
		delegate to this.  The method may be static or dynamic unless
		onlyStatic is set (in which case object may be null).
		If onlyStatic is set the only static methods will be located.
		<p/>
		This method performs Java method caching internally.
		@param onlyStatic 
			The method located must be static, the object param may be null.
		@return the method or null if no matching method was found.
		@deprecated
	*/
	/*
		Note: object is only used here for precondition... get rid of it?
	*/
    protected static Method resolveJavaMethod(
		BshClassManager bcm, Class clas, Object object, 
		String name, Object[] args, boolean onlyStatic )
        throws UtilEvalError
    {
		// Why is object in the args?
		if ( object == Primitive.NULL )
			throw new UtilTargetError( new NullPointerException(
				""Attempt to invoke method "" +name+"" on null value"" ) );
        Class [] types = Types.getTypes(args);
		return resolveJavaMethod( bcm, clas, name, types, onlyStatic );
	}
	/*
		Notes:
		This is broken.  It finds public but less specific methods over
		non-public but more specific ones.
		findMostSpecficMethod() needs to be rewritten to eliminate 
		findAccessibleMethod.  We should implement the findMostSpecificMethod 
		that uses the publicOnly flag.  FindMostSpecificMethod should also
		operate in two passes to give standard Java assignable matches priority
		over extended bsh type matches.
	*/
    protected static Method resolveJavaMethod(
		BshClassManager bcm, Class clas, String name, 
		Class [] types, boolean onlyStatic )
        throws UtilEvalError
    {
		if ( clas == null )
			throw new InterpreterError(""null class"");
		Method method = null;
		if ( bcm == null ) 
			Interpreter.debug(""resolveJavaMethod UNOPTIMIZED lookup"");
		else {
			method = bcm.getResolvedMethod( clas, name, types, onlyStatic );
			if ( method != null )
				return method;
		}
		if ( Interpreter.DEBUG )
			Interpreter.debug( ""Searching for method: ""+
				StringUtil.methodString(name, types)
					+ "" in '"" + clas.getName() + ""'"" );
		/*
			First try for an accessible version of the exact match.
			This first lookup seems redundant with below, but is apparently
			needed.  This whole thing is messy.
		*/
		try {
			method  = findAccessibleMethod( clas, name, types );
		} catch ( SecurityException e ) { }
		// If not found and there are arguments to match -
		// Look for an overloaded assignable match
		// (First find the method, then find accessible version of it)
		if ( method == null && types.length > 0 ) 
		{
			// Gather all of the methods of class and parents
			Vector mv = new Vector();
			Class c = clas;
			while( c != null )
			{
				Method [] m = c.getDeclaredMethods();
				for(int i=0; i<m.length; i++)
					mv.add( m[i] );
				c = c.getSuperclass();
			}
			Method [] methods = new Method [mv.size()];
			mv.copyInto( methods );
			boolean publicOnly = !Capabilities.haveAccessibility();
			method = findMostSpecificMethod( name, types, methods, publicOnly );
			if ( method != null && !Modifier.isPublic( method.getModifiers() ) )
			{
				try {
					ReflectManager.RMSetAccessible( method );
				} catch ( UtilEvalError e ) { /*ignore*/ }
			}
/*
			// If found a method, make sure we have accessible version of it
			if ( method != null ) 
			{
				try {
					method = findAccessibleMethod( 
						clas, method.getName(), method.getParameterTypes() );
				} catch ( SecurityException e ) { /leave null/ }
				if ( Interpreter.DEBUG && method == null )
					Interpreter.debug(
						""had a method, but it wasn't accessible"");
			}
	*/
		}
		if ( method != null 
			&& onlyStatic && !Modifier.isStatic( method.getModifiers() ) 
		)
			throw new UtilEvalError(
				""Cannot reach instance method: ""
				+ StringUtil.methodString(
					method.getName(), method.getParameterTypes() )
				+ "" from static context: ""+ clas.getName() );
		// Succeeded.  Cache the resolved method.
		if ( method != null && bcm != null )
			bcm.cacheResolvedMethod( clas, types, method );
		return method;
	}
	/**
		Locate a version of the method with the exact signature specified 
		that is accessible via a public interface or through a public 
		superclass or - if accessibility is on - through any interface or
		superclass.
		In the normal (non-accessible) case this still solves the problem that 
		arises when a package private class or private inner class implements a 
		public interface or derives from a public type.
		@param onlyStatic the method located must be static.
		@return null on not found
	*/
	/*
		Notes: See notes on findMostSpecificMethod.
		This method should be rolled into findMostSpecificMethod.
	*/
	static Method findAccessibleMethod( 
		Class clas, String name, Class [] types ) 
		throws UtilEvalError
	{
		Method meth = null;
		Method inaccessibleVersion = null;
		Vector classQ = new Vector();
		classQ.addElement( clas );
		Method found = null;
		while ( classQ.size() > 0 ) 
		{
			Class c = (Class)classQ.firstElement();
			classQ.removeElementAt(0);
			// Is this it?
			// Is the class public or can we use accessibility?
			if ( Modifier.isPublic( c.getModifiers() )
				|| ( Capabilities.haveAccessibility() ) )
			{
				try 
				{
					meth = c.getDeclaredMethod( name, types );
					// Is the method public or are we in accessibility mode?
					if ( ( Modifier.isPublic( meth.getModifiers() )
						&& Modifier.isPublic( c.getModifiers() ) )
						|| ( Capabilities.haveAccessibility() 
							&& ReflectManager.RMSetAccessible( meth ) ) )
					{
						found = meth; // Yes, it is.
						break;
					}
					else
					{
						// Found at least one matching method but couldn't use
						inaccessibleVersion = meth;
					}
				} catch ( NoSuchMethodException e ) { 
					// ignore and move on
				}
			}
			// No, it is not.
			// Is this a class?
			if ( !c.isInterface() ) {
				Class superclass = c.getSuperclass();
				if ( superclass != null )
					classQ.addElement((Object)superclass);
			}
			// search all of its interfaces breadth first
			Class [] intfs = c.getInterfaces();
			for( int i=0; i< intfs.length; i++ )
				classQ.addElement((Object)intfs[i]);
		}
		if ( found != null )
			return found;
		if ( inaccessibleVersion != null )
			throw new UtilEvalError(""Found non-public method: ""
				+inaccessibleVersion
				+"".  Use setAccessibility(true) to enable access to ""
				+"" private and protected members of classes."" );
		return null; 
	}
	/**
		Primary object constructor
		This method is simpler than those that must resolve general method
		invocation because constructors are not inherited.
	*/
    static Object constructObject( Class clas, Object[] args )
        throws ReflectError, InvocationTargetException
    {
		if ( clas.isInterface() )
			throw new ReflectError(
				""Can't create instance of an interface: ""+clas);
        Object obj = null;
        Class[] types = Types.getTypes(args);
        Constructor con = null;
		/* 
			Find an appropriate constructor.
			use declared here to see package and private as well
			(there are no inherited constructors to worry about) 
		*/
		Constructor[] constructors = clas.getDeclaredConstructors();
		if ( Interpreter.DEBUG ) 
			Interpreter.debug(""Looking for most specific constructor: ""+clas);
		con = findMostSpecificConstructor(types, constructors);
		if ( con == null )
		{
			if ( types.length == 0 )
				throw new ReflectError(
					""Can't find default constructor for: ""+clas);
			else
				throw new ReflectError(
					""Can't find constructor: "" 
					+ StringUtil.methodString( clas.getName(), types )
					+"" in class: ""+ clas.getName() );
		}
		if ( !Modifier.isPublic( con.getModifiers() )
			&& Capabilities.haveAccessibility() )
			try {
				ReflectManager.RMSetAccessible( con );
			} catch ( UtilEvalError e ) { /*ignore*/ }
        args=Primitive.unwrap( args );
        try {
            obj = con.newInstance( args );
        } catch(InstantiationException e) {
            throw new ReflectError(""the class is abstract "");
        } catch(IllegalAccessException e) {
            throw new ReflectError(
				""We don't have permission to create an instance.""
				+""Use setAccessibility(true) to enable access."" );
        } catch(IllegalArgumentException e) {
            throw new ReflectError(""the number of arguments was wrong"");
        } 
		if (obj == null)
            throw new ReflectError(""couldn't construct the object"");
        return obj;
    }
    /**
        Implement JLS 15.11.2 for method resolution
		@return null on no match
    */
	/*
		Notes:
		This is broken.  It finds public but less specific methods over
		non-public but more specific ones.
		This method needs to be rewritten to eliminate findAccessibleMethod.
		We should implement the findMostSpecificMethod that uses the publicOnly
		flag.  FindMostSpecificMethod should also operate in two passes to give
		standard Java assignable matches priority over extended bsh type
		matches.
	*/
    static Method findMostSpecificMethod(
		String name, Class[] idealMatch, Method[] methods,
		boolean publicOnly )
    {
		// Pull out the method signatures with matching names
		Vector sigs = new Vector();
		Vector meths = new Vector();
		for(int i=0; i<methods.length; i++)
		{
			if ( publicOnly && !Modifier.isPublic( methods[i].getModifiers() ) )
				continue;
			// method matches name 
			if ( methods[i].getName().equals( name ) ) 
			{
				meths.addElement( methods[i] );
				sigs.addElement( methods[i].getParameterTypes() );
			}
		}
		Class [][] candidates = new Class [ sigs.size() ][];
		sigs.copyInto( candidates );
		if ( Interpreter.DEBUG ) 
			Interpreter.debug(""Looking for most specific method: ""+name);
		int match = findMostSpecificSignature( idealMatch, candidates );
		if ( match == -1 )
			return null;
		else
			return (Method)meths.elementAt( match );
    }
    /*
        This method should parallel findMostSpecificMethod()
    */
    static Constructor findMostSpecificConstructor(
		Class[] idealMatch, Constructor[] constructors)
    {
		int match = 
			findMostSpecificConstructorIndex( idealMatch, constructors );
		if ( match == -1 )
			return null;
		else
			return constructors[ match ];
    }
    static int findMostSpecificConstructorIndex(
		Class[] idealMatch, Constructor[] constructors)
    {
		Class [][] candidates = new Class [ constructors.length ] [];
		for(int i=0; i< candidates.length; i++ )
			candidates[i] = constructors[i].getParameterTypes();
		return findMostSpecificSignature( idealMatch, candidates );
    }
	/**
        Implement JLS 15.11.2
		Return the index of the most specific arguments match or -1 if no	
		match is found.
	*/
	static int findMostSpecificSignature(
		Class [] idealMatch, Class [][] candidates )
	{
		Class [] bestMatch = null;
		int bestMatchIndex = -1;
		for (int i=0; i < candidates.length; i++) {
			Class[] targetMatch = candidates[i];
            /*
                If idealMatch fits targetMatch and this is the first match 
				or targetMatch is more specific than the best match, make it 
				the new best match.
            */
			if ( Types.isSignatureAssignable(idealMatch, targetMatch ) &&
				((bestMatch == null) ||
					Types.isSignatureAssignable( targetMatch, bestMatch )))
			{
				bestMatch = targetMatch;
				bestMatchIndex = i;
			}
		}
		if ( bestMatch != null )
			return bestMatchIndex;
		else
			return -1;
	}
	private static String accessorName( String getorset, String propName ) {
        return getorset 
			+ String.valueOf(Character.toUpperCase(propName.charAt(0))) 
			+ propName.substring(1);
	}
    public static boolean hasObjectPropertyGetter( 
		Class clas, String propName ) 
	{
		String getterName = accessorName(""get"", propName );
		try {
			clas.getMethod( getterName, new Class [0] );
			return true;
		} catch ( NoSuchMethodException e ) { /* fall through */ }
		getterName = accessorName(""is"", propName );
		try {
			Method m = clas.getMethod( getterName, new Class [0] );
			return ( m.getReturnType() == Boolean.TYPE );
		} catch ( NoSuchMethodException e ) {
			return false;
		}
	}
    public static boolean hasObjectPropertySetter( 
		Class clas, String propName ) 
	{
		String setterName = accessorName(""set"", propName );
		Class [] sig = new Class [] { clas };
		Method [] methods = clas.getMethods();
		// we don't know the right hand side of the assignment yet.
		// has at least one setter of the right name?
		for(int i=0; i<methods.length; i++)
			if ( methods[i].getName().equals( setterName ) )
				return true;
		return false;
	}
    public static Object getObjectProperty(
		Object obj, String propName )
        throws UtilEvalError, ReflectError
    {
        Object[] args = new Object[] { };
        Interpreter.debug(""property access: "");
		Method method = null;
		Exception e1=null, e2=null;
		try {
			String accessorName = accessorName( ""get"", propName );
			method = resolveExpectedJavaMethod( 
				null/*bcm*/, obj.getClass(), obj, accessorName, args, false );
		} catch ( Exception e ) { 
			e1 = e;
		}
		if ( method == null )
			try {
				String accessorName = accessorName( ""is"", propName );
				method = resolveExpectedJavaMethod( 
					null/*bcm*/, obj.getClass(), obj, 
					accessorName, args, false );
				if ( method.getReturnType() != Boolean.TYPE )
					method = null;
			} catch ( Exception e ) { 
				e2 = e;
			}
		if ( method == null )
			throw new ReflectError(""Error in property getter: ""
				+e1 + (e2!=null?"" : ""+e2:"""") );
        try {
			return invokeOnMethod( method, obj, args );
        }
        catch(InvocationTargetException e)
        {
            throw new UtilEvalError(""Property accessor threw exception: ""
				+e.getTargetException() );
        }
    }
    public static void setObjectProperty(
		Object obj, String propName, Object value)
        throws ReflectError, UtilEvalError
    {
        String accessorName = accessorName( ""set"", propName );
        Object[] args = new Object[] { value };
        Interpreter.debug(""property access: "");
        try {
			Method method = resolveExpectedJavaMethod( 
				null/*bcm*/, obj.getClass(), obj, accessorName, args, false );
			invokeOnMethod( method, obj, args );
        }
        catch ( InvocationTargetException e )
        {
            throw new UtilEvalError(""Property accessor threw exception: ""
				+e.getTargetException() );
        }
    }
    /** 
		Return a more human readable version of the type name.
		Specifically, array types are returned with postfix ""[]"" dimensions.
		e.g. return ""int []"" for integer array instead of ""class [I"" as
		would be returned by Class getName() in that case.
	*/
    public static String normalizeClassName(Class type)
    {
        if ( !type.isArray() )
            return type.getName();
        StringBuffer className = new StringBuffer();
        try {
            className.append( getArrayBaseType(type).getName() +"" "");
            for(int i = 0; i < getArrayDimensions(type); i++)
                className.append(""[]"");
        } catch( ReflectError e ) { /*shouldn't happen*/ }
        return className.toString();
    }
	/**
		returns the dimensionality of the Class
		returns 0 if the Class is not an array class
	*/
    public static int getArrayDimensions(Class arrayClass)
    {
        if ( !arrayClass.isArray() )
            return 0;
        return arrayClass.getName().lastIndexOf('[') + 1;  // why so cute?
    }
    /**
		Returns the base type of an array Class.
    	throws ReflectError if the Class is not an array class.
	*/
    public static Class getArrayBaseType(Class arrayClass) throws ReflectError
    {
        if ( !arrayClass.isArray() )
            throw new ReflectError(""The class is not an array."");
		return arrayClass.getComponentType();
    }
	/**
		A command may be implemented as a compiled Java class containing one or
		more static invoke() methods of the correct signature.  The invoke()
		methods must accept two additional leading arguments of the interpreter
		and callstack, respectively. e.g. invoke(interpreter, callstack, ... )
		This method adds the arguments and invokes the static method, returning
		the result.
	*/
	public static Object invokeCompiledCommand( 
		Class commandClass, Object [] args, Interpreter interpreter, 
		CallStack callstack )
		throws UtilEvalError
	{
        // add interpereter and namespace to args list
        Object[] invokeArgs = new Object[args.length + 2];
        invokeArgs[0] = interpreter;
        invokeArgs[1] = callstack;
        System.arraycopy( args, 0, invokeArgs, 2, args.length );
		BshClassManager bcm = interpreter.getClassManager();
		try {
        	return Reflect.invokeStaticMethod( 
				bcm, commandClass, ""invoke"", invokeArgs );
		} catch ( InvocationTargetException e ) {
			throw new UtilEvalError(
				""Error in compiled command: ""+e.getTargetException() );
		} catch ( ReflectError e ) {
			throw new UtilEvalError(""Error invoking compiled command: ""+e );
		}
	}
}
"
bsh.ReflectError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class ReflectError extends Exception
{
	public ReflectError() { super(); }
	public ReflectError(String s) { super(s); }
}
"
bsh.ReflectManager,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import bsh.Capabilities.Unavailable;
/**
	ReflectManager is a dynamically loaded extension that supports extended
	reflection features supported by JDK1.2 and greater.
	In particular it currently supports accessible method and field access 
	supported by JDK1.2 and greater.
*/
public abstract class ReflectManager
{
	private static ReflectManager rfm;
	/**
		Return the singleton bsh ReflectManager.
		@throws Unavailable
	*/
	public static ReflectManager getReflectManager() 
		throws Unavailable
	{
		if ( rfm == null ) 
		{
			Class clas;
			try {
				clas = Class.forName( ""bsh.reflect.ReflectManagerImpl"" );
				rfm = (ReflectManager)clas.newInstance();
			} catch ( Exception e ) {
				throw new Unavailable(""Reflect Manager unavailable: ""+e);
			}
		}
		return rfm;
	}
	/**
		Reflect Manager Set Accessible.
		Convenience method to invoke the reflect manager.
		@throws Unavailable
	*/
	public static boolean RMSetAccessible( Object obj ) 
		throws Unavailable
	{
		return getReflectManager().setAccessible( obj );
	}
	/**
		Set a java.lang.reflect Field, Method, Constructor, or Array of
		accessible objects to accessible mode.
		@return true if the object was accessible or false if it was not.
	*/
	public abstract boolean setAccessible( Object o );
}
"
bsh.Remote,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.*;
import java.net.*;
import java.text.*;
/**
	Remote executor class.
*/
public class Remote {
    public static void main( String args[] ) 
		throws Exception
	{
		if ( args.length < 2 ) {
			System.out.println(
				""usage: Remote URL(http|bsh) file [ file ] ... "");
			System.exit(1);
		}
		String url = args[0];
		String text = getFile(args[1]);
		int ret = eval( url, text, null );
		System.exit( ret );
		}
	/**
		Evaluate text in the interpreter at url, capturing output into
		output and returning a possible integer return value.
	*/
	public static int eval( String url, String text, StringBuffer output )
		throws IOException
	{
		String returnValue = null;
		if ( url.startsWith( ""http:"" ) ) {
			returnValue = doHttp( url, text );
		} else if ( url.startsWith( ""bsh:"" ) ) {
			returnValue = doBsh( url, text );
		} else
			throw new IOException( ""Unrecognized URL type.""
				+""Scheme must be http:// or bsh://"");
		try {
			return Integer.parseInt( returnValue );
		} catch ( Exception e ) {
			// this convention may change...
			return 0;
		}
	}
	static String doBsh( String url, String text ) 
	{ 
	    OutputStream out;
	    InputStream in;
	    String host = """";
	    String port = """";
	    String returnValue = ""-1"";
		String orgURL = url;
		// Need some format checking here
	    try {
			url = url.substring(6); // remove the bsh://
			// get the index of the : between the host and the port is located
			int index = url.indexOf("":"");
			host = url.substring(0,index);
			port = url.substring(index+1,url.length());
		} catch ( Exception ex ) {
			System.err.println(""Bad URL: ""+orgURL+"": ""+ex  );
			return returnValue;
	    }
	    try {
			System.out.println(""Connecting to host : "" 
				+ host + "" at port : "" + port);
			Socket s = new Socket(host, Integer.parseInt(port) + 1);
			out = s.getOutputStream();
			in = s.getInputStream();
			sendLine( text, out );
			BufferedReader bin = new BufferedReader( 
				new InputStreamReader(in));
			  String line;
			  while ( (line=bin.readLine()) != null )
				System.out.println( line );
			// Need to scrape a value from the last line?
			returnValue=""1"";
			return returnValue;
	    } catch(Exception ex) {
			System.err.println(""Error communicating with server: ""+ex);
			return returnValue;
	    }
	}
    private static void sendLine( String line, OutputStream outPipe )
		throws IOException
	{
		outPipe.write( line.getBytes() );
		outPipe.flush();
    }
	static String doHttp( String postURL, String text ) 
	{
		String returnValue = null;
		StringBuffer sb = new StringBuffer();
		sb.append( ""bsh.client=Remote"" );
		sb.append( ""&bsh.script="" );
		sb.append( URLEncoder.encode( text ) );
		String formData = sb.toString(  );
		try {
		  URL url = new URL( postURL );
		  HttpURLConnection urlcon =
			  (HttpURLConnection) url.openConnection(  );
		  urlcon.setRequestMethod(""POST"");
		  urlcon.setRequestProperty(""Content-type"",
			  ""application/x-www-form-urlencoded"");
		  urlcon.setDoOutput(true);
		  urlcon.setDoInput(true);
		  PrintWriter pout = new PrintWriter( new OutputStreamWriter(
			  urlcon.getOutputStream(), ""8859_1""), true );
		  pout.print( formData );
		  pout.flush();
		  // read results...
		  int rc = urlcon.getResponseCode();
		  if ( rc != HttpURLConnection.HTTP_OK )
			System.out.println(""Error, HTTP response: ""+rc );
		  returnValue = urlcon.getHeaderField(""Bsh-Return"");
		  BufferedReader bin = new BufferedReader( 
			new InputStreamReader( urlcon.getInputStream() ) );
		  String line;
		  while ( (line=bin.readLine()) != null )
			System.out.println( line );
		  System.out.println( ""Return Value: ""+returnValue );
		} catch (MalformedURLException e) {
		  System.out.println(e);     // bad postURL
		} catch (IOException e2) {
		  System.out.println(e2);    // I/O error
		}
		return returnValue;
	}
	static String getFile( String name ) 
		throws FileNotFoundException, IOException 
	{
		StringBuffer sb = new StringBuffer();
		BufferedReader bin = new BufferedReader( new FileReader( name ) );
		String line;
		while ( (line=bin.readLine()) != null )
			sb.append( line ).append( ""\n"" );
		return sb.toString();
	}
}
"
bsh.ReturnControl,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Represents a Return, Break, or Continue statement
*/
class ReturnControl implements ParserConstants {
	public int kind;
	public Object value;
	/** The node where we returned... for printing error messages correctly */
	public SimpleNode returnPoint;
	public ReturnControl( int kind, Object value, SimpleNode returnPoint ) {
		this.kind = kind;
		this.value = value;
		this.returnPoint = returnPoint;
	}
}
"
bsh.SimpleNode,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/*
	Note: great care (and lots of typing) were taken to insure that the
	namespace and interpreter references are passed on the stack and not 
	(as they were erroneously before) installed in instance variables...
	Each of these node objects must be re-entrable to allow for recursive 
	situations.
	The only data which should really be stored in instance vars here should 
	be parse tree data... features of the node which should never change (e.g.
	the number of arguments, etc.)
	Exceptions would be public fields of simple classes that just publish
	data produced by the last eval()... data that is used immediately. We'll
	try to remember to mark these as transient to highlight them.
*/
class SimpleNode implements Node 
{
	public static SimpleNode JAVACODE =
		new SimpleNode( -1 ) {
			public String getSourceFile() {
				return ""<Called from Java Code>"";
			}
			public int getLineNumber() {
				return -1;
			}
			public String getText()  {
				return ""<Compiled Java Code>"";
			}
		};
	protected Node parent;
	protected Node[] children;
	protected int id;
	Token firstToken, lastToken;
	/** the source of the text from which this was parsed */
	String sourceFile;
	public SimpleNode(int i) {
		id = i;
	}
	public void jjtOpen() { }
	public void jjtClose() { }
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	//public SimpleNode getParent() { return (SimpleNode)parent; }
	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}
		children[i] = n;
	}
	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	/*
		You can override these two methods in subclasses of SimpleNode to
		customize the way the node appears when the tree is dumped.  If
		your output uses more than one line you should override
		toString(String), otherwise overriding toString() is probably all
		you need to do.
	*/
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	/*
		Override this method if you want to customize how the node dumps
		out its children.
	*/
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + "" "");
				}
			}
		}
	}
	//  ---- BeanShell specific stuff hereafter ----  //
	/**
		Detach this node from its parent.
		This is primarily useful in node serialization.
		(see BSHMethodDeclaration)
	*/
	public void prune() {
		jjtSetParent( null );
	}
	/**
		This is the general signature for evaluation of a node.
	*/
	public Object eval( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		throw new InterpreterError(
			""Unimplemented or inappropriate for "" + getClass().getName() );
	}
	/**
		Set the name of the source file (or more generally source) of
		the text from which this node was parsed.
	*/
	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}
	/**
		Get the name of the source file (or more generally source) of
		the text from which this node was parsed.
		This will recursively search up the chain of parent nodes until
		a source is found or return a string indicating that the source
		is unknown.
	*/
	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return ""<unknown file>"";
		else
			return sourceFile;
	}
	/**
		Get the line number of the starting token
	*/
	public int getLineNumber() {
		return firstToken.beginLine;
	}
	/**
		Get the ending line number of the starting token
	public int getEndLineNumber() {
		return lastToken.endLine;
	}
	*/
	/**
		Get the text of the tokens comprising this node.
	*/
	public String getText() 
	{
		StringBuffer text = new StringBuffer();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(""."") )
				text.append("" "");
			if ( t==lastToken ||
				t.image.equals(""{"") || t.image.equals("";"") )
				break;
			t=t.next;
		}
		return text.toString();
	}
}
"
bsh.StringUtil,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.*;
public class StringUtil {
	public static String [] split( String s, String delim) {
		Vector v = new Vector();
		StringTokenizer st = new StringTokenizer(s, delim);
		while ( st.hasMoreTokens() )
			v.addElement( st.nextToken() );
		String [] sa = new String [ v.size() ];
		v.copyInto( sa );
		return sa;
	}
	public static String [] bubbleSort( String [] in ) {
		Vector v = new Vector();
		for(int i=0; i<in.length; i++)
			v.addElement(in[i]);
		int n = v.size();
		boolean swap = true;
		while ( swap ) {
			swap = false;
			for(int i=0; i<(n-1); i++)
				if ( ((String)v.elementAt(i)).compareTo(
						((String)v.elementAt(i+1)) ) > 0 ) {
					String tmp = (String)v.elementAt(i+1);
					v.removeElementAt( i+1 );
					v.insertElementAt( tmp, i );
					swap = true;
				}
		}
		String [] out = new String [ n ];
		v.copyInto(out);
		return out;
	}
	public static String maxCommonPrefix( String one, String two ) {
		int i=0;
		while( one.regionMatches( 0, two, 0, i ) )
			i++;
		return one.substring(0, i-1);
	}
    public static String methodString(String name, Class[] types)
    {
        StringBuffer sb = new StringBuffer(name + ""("");
        if ( types.length > 0 )
			sb.append("" "");
        for( int i=0; i<types.length; i++ )
        {
            Class c = types[i];
            sb.append( ( (c == null) ? ""null"" : c.getName() ) 
				+ ( i < (types.length-1) ? "", "" : "" "" ) );
        }
        sb.append("")"");
        return sb.toString();
    }
	/**
		Split a filename into dirName, baseName
		@return String [] { dirName, baseName }
    public String [] splitFileName( String fileName ) 
	{ 
		String dirName, baseName;
		int i = fileName.lastIndexOf( File.separator );
		if ( i != -1 ) {
			dirName = fileName.substring(0, i);
			baseName = fileName.substring(i+1);
		} else
			baseName = fileName;
		return new String[] { dirName, baseName };
	}
	*/
	/**
		Hack - The real method is in Reflect.java which is not public.
	*/
    public static String normalizeClassName( Class type )
	{
		return Reflect.normalizeClassName( type );
	}
}
"
bsh.TargetError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.InvocationTargetException;
import java.io.PrintStream;
/**
	TargetError is an EvalError that wraps an exception thrown by the script	
	(or by code called from the script).  TargetErrors indicate exceptions 
	which can be caught within the script itself, whereas a general EvalError 
	indicates that the script cannot be evaluated further for some reason.
	If the exception is caught within the script it is automatically unwrapped,
	so the code looks like normal Java code.  If the TargetError is thrown
	from the eval() or interpreter.eval() method it may be caught and unwrapped
	to determine what exception was thrown.
*/
public class TargetError extends EvalError 
{
	Throwable target;
	boolean inNativeCode;
	public TargetError(
		String msg, Throwable t, SimpleNode node, CallStack callstack, 
		boolean inNativeCode )
	{
		super( msg, node, callstack );
		target = t;
		this.inNativeCode = inNativeCode;
	}
	public TargetError( Throwable t, SimpleNode node, CallStack callstack )
	{
		this(""TargetError"", t, node, callstack, false);
	}
	public Throwable getTarget()
	{
		// check for easy mistake
		if(target instanceof InvocationTargetException)
			return((InvocationTargetException)target).getTargetException();
		else
			return target;
	}
	public String toString() 
	{
		return super.toString() 
			+ ""\nTarget exception: "" + 
			printTargetError( target );
	}
    public void printStackTrace() { 
		printStackTrace( false, System.err );
	}
    public void printStackTrace( PrintStream out ) { 
		printStackTrace( false, out );
	}
    public void printStackTrace( boolean debug, PrintStream out ) {
		if ( debug ) {
			super.printStackTrace( out );
			out.println(""--- Target Stack Trace ---"");
		}
		target.printStackTrace( out );
	}
	/**
		Generate a printable string showing the wrapped target exception.
		If the proxy mechanism is available, allow the extended print to
		check for UndeclaredThrowableException and print that embedded error.
	*/
	public String printTargetError( Throwable t ) 
	{
		String s = target.toString();
		if ( Capabilities.canGenerateInterfaces() )
			s += ""\n"" + xPrintTargetError( t );
		return s;
	}
	/**
		Extended form of print target error.
		This indirection is used to print UndeclaredThrowableExceptions 
		which are possible when the proxy mechanism is available.
		We are shielded from compile problems by using a bsh script.
		This is acceptable here because we're not in a critical path...
		Otherwise we'd need yet another dynamically loaded module just for this.
	*/
	public String xPrintTargetError( Throwable t ) 
	{
		String getTarget =
			""import java.lang.reflect.UndeclaredThrowableException;""+
			""String result=\""\"";""+
			""while ( target instanceof UndeclaredThrowableException ) {""+
			""	target=target.getUndeclaredThrowable(); "" +
			""	result+=\""Nested: \""+target.toString();"" +
			""}""+
			""return result;"";
		Interpreter i = new Interpreter();
		try {
			i.set(""target"", t);
			return (String)i.eval( getTarget );
		} catch ( EvalError e ) {
			throw new InterpreterError(""xprintarget: ""+e.toString() );
		}
	}
	/**
		Return true if the TargetError was generated from native code.
		e.g. if the script called into a compiled java class which threw
		the excpetion.  We distinguish so that we can print the stack trace
		for the native code case... the stack trace would not be useful if
		the exception was generated by the script.  e.g. if the script
		explicitly threw an exception... (the stack trace would simply point
		to the bsh internals which generated the exception).
	*/
	public boolean inNativeCode() { 
		return inNativeCode; 
	}
}
"
bsh.This,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.IOException;
/**
	'This' is the type of bsh scripted objects.
	A 'This' object is a bsh scripted object context.  It holds a namespace 
	reference and implements event listeners and various other interfaces.
	This holds a reference to the declaring interpreter for callbacks from
	outside of bsh.
*/
public class This implements java.io.Serializable, Runnable 
{
	/**
		The namespace that this This reference wraps.
	*/
	NameSpace namespace;
	/**
		This is the interpreter running when the This ref was created.
		It's used as a default interpreter for callback through the This
		where there is no current interpreter instance 
		e.g. interface proxy or event call backs from outside of bsh.
	*/
	transient Interpreter declaringInterpreter;
	/**
		getThis() is a factory for bsh.This type references.  The capabilities
		of "".this"" references in bsh are version dependent up until jdk1.3.
		The version dependence was to support different default interface
		implementations.  i.e. different sets of listener interfaces which
		scripted objects were capable of implementing.  In jdk1.3 the 
		reflection proxy mechanism was introduced which allowed us to 
		implement arbitrary interfaces.  This is fantastic.
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  We create it here only if needed for the namespace.
		Note: this method could be considered slow because of the way it 
		dynamically factories objects.  However I've also done tests where 
		I hard-code the factory to return JThis and see no change in the 
		rough test suite time.  This references are also cached in NameSpace.  
	*/
    static This getThis( 
		NameSpace namespace, Interpreter declaringInterpreter ) 
	{
		try {
			Class c;
			if ( Capabilities.canGenerateInterfaces() )
				c = Class.forName( ""bsh.XThis"" );
			else if ( Capabilities.haveSwing() )
				c = Class.forName( ""bsh.JThis"" );
			else
				return new This( namespace, declaringInterpreter );
			return (This)Reflect.constructObject( c,
				new Object [] { namespace, declaringInterpreter } );
		} catch ( Exception e ) {
			throw new InterpreterError(""internal error 1 in This: ""+e);
		}
    }
	/**
		Get a version of this scripted object implementing the specified 
		interface.
	*/
	/*
		If this type of This implements it directly return this,
		else try complain that we don't have the proxy mechanism.
	*/
	public Object getInterface( Class clas ) 
		throws UtilEvalError
	{
		if ( clas.isInstance( this ) )
			return this;
		else
			throw new UtilEvalError( ""Dynamic proxy mechanism not available. ""
			+ ""Cannot construct interface type: ""+clas );
	}
	/**
		Get a version of this scripted object implementing the specified
		interfaces.
	*/
	public Object getInterface( Class [] ca ) 
		throws UtilEvalError
	{
		for(int i=0; i<ca.length; i++)
			if ( !(ca[i].isInstance( this )) )
				throw new UtilEvalError( 
					""Dynamic proxy mechanism not available. "" 
					+ ""Cannot construct interface type: ""+ca[i] );
		return this;
	}
	/*
		I wish protected access were limited to children and not also 
		package scope... I want this to be a singleton implemented by various
		children.  
	*/
	protected This( NameSpace namespace, Interpreter declaringInterpreter ) { 
		this.namespace = namespace; 
		this.declaringInterpreter = declaringInterpreter;
		//initCallStack( namespace );
	}
	public NameSpace getNameSpace() {
		return namespace;
	}
	public String toString() {
		return ""'this' reference to Bsh object: "" + namespace;
	}
	public void run() {
		try {
			invokeMethod( ""run"", new Object[0] );
		} catch( EvalError e ) {
			declaringInterpreter.error(
				""Exception in runnable:"" + e );
		}
	}
	/**
		Invoke specified method as from outside java code, using the 
		declaring interpreter and current namespace.
		The call stack will indicate that the method is being invoked from
		outside of bsh in native java code.
		Note: you must still wrap/unwrap args/return values using 
		Primitive/Primitive.unwrap() for use outside of BeanShell.
		@see bsh.Primitive
	*/
	public Object invokeMethod( String name, Object [] args ) 
		throws EvalError
	{
		// null callstack, one will be created for us 
		return invokeMethod( 
			name, args, null/*declaringInterpreter*/, null, null, 
			false/*declaredOnly*/ );
	}
	/**
		Invoke a method in this namespace with the specified args,
		interpreter reference, callstack, and caller info.
		<p>
		Note: If you use this method outside of the bsh package and wish to 
		use variables with primitive values you will have to wrap them using 
		bsh.Primitive.  Consider using This getInterface() to make a true Java
		interface for invoking your scripted methods.
		<p>
		This method also implements the default object protocol of toString(), 
		hashCode() and equals() and the invoke() meta-method handling as a 
		last resort.
		<p>
		Note: The invoke() meta-method will not catch the Object protocol
		methods (toString(), hashCode()...).  If you want to override them you 
		have to script them directly.
		<p>
		@see bsh.This.invokeMethod( 
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo )
		@param if callStack is null a new CallStack will be created and
			initialized with this namespace.
		@param declaredOnly if true then only methods declared directly in the
			namespace will be visible - no inherited or imported methods will
			be visible.
		@see bsh.Primitive
	*/
	/*
		invokeMethod() here is generally used by outside code to callback
		into the bsh interpreter. e.g. when we are acting as an interface
		for a scripted listener, etc.  In this case there is no real call stack
		so we make a default one starting with the special JAVACODE namespace
		and our namespace as the next.
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo, 
		boolean declaredOnly  ) 
		throws EvalError
	{
		/*
			Wrap nulls.
			This is a bit of a cludge to address a deficiency in the class
			generator whereby it does not wrap nulls on method delegate.  See
			Class Generator.java.  If we fix that then we can remove this.
			(just have to generate the code there.)
		*/
		if ( args != null )
		{
			Object [] oa = new Object [args.length];
			for(int i=0; i<args.length; i++)
				oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );
			args = oa;
		}
		if ( interpreter == null )
			interpreter = declaringInterpreter;
		if ( callstack == null )
			callstack = new CallStack( namespace );
		if ( callerInfo == null )
			callerInfo = SimpleNode.JAVACODE;
		// Find the bsh method
		Class [] types = Types.getTypes( args );
		BshMethod bshMethod = null;
		try {
			bshMethod = namespace.getMethod( methodName, types, declaredOnly );
		} catch ( UtilEvalError e ) {
			// leave null
		}
		if ( bshMethod != null )
			return bshMethod.invoke( args, interpreter, callstack, callerInfo );
		/*
			No scripted method of that name.
			Implement the required part of the Object protocol:
				public int hashCode();
				public boolean equals(java.lang.Object);
				public java.lang.String toString();
			if these were not handled by scripted methods we must provide
			a default impl.
		*/
		// a default toString() that shows the interfaces we implement
		if ( methodName.equals(""toString"" ) )
			return toString();
		// a default hashCode()
		if ( methodName.equals(""hashCode"" ) )
			return new Integer(this.hashCode());
		// a default equals() testing for equality with the This reference
		if ( methodName.equals(""equals"" ) ) {
			Object obj = args[0];
			return new Boolean( this == obj );
		}
		// Look for a default invoke() handler method in the namespace
		// Note: this code duplicates that in NameSpace getCommand()
		// is that ok?
		try {
			bshMethod = namespace.getMethod( 
				""invoke"", new Class [] { null, null } );
		} catch ( UtilEvalError e ) { /*leave null*/ }
		// Call script ""invoke( String methodName, Object [] args );
		if ( bshMethod != null )
			return bshMethod.invoke( new Object [] { methodName, args }, 
				interpreter, callstack, callerInfo );
		throw new EvalError(""Method "" + 
			StringUtil.methodString( methodName, types ) +
			"" not found in bsh scripted object: ""+ namespace.getName(), 
			callerInfo, callstack );
	}
	/**
		Bind a This reference to a parent's namespace with the specified
		declaring interpreter.  Also re-init the callstack.  It's necessary 
		to bind a This reference before it can be used after deserialization.
		This is used by the bsh load() command.
		<p>
		This is a static utility method because it's used by a bsh command
		bind() and the interpreter doesn't currently allow access to direct 
		methods of This objects (small hack)
	*/
	public static void bind( 
		This ths, NameSpace namespace, Interpreter declaringInterpreter ) 
	{ 
		ths.namespace.setParent( namespace ); 
		ths.declaringInterpreter = declaringInterpreter;
	}
	/**
		Allow invocations of these method names on This type objects.
		Don't give bsh.This a chance to override their behavior.
		<p>
		If the method is passed here the invocation will actually happen on
		the bsh.This object via the regular reflective method invocation 
		mechanism.  If not, then the method is evaluated by bsh.This itself
		as a scripted method call.
	*/
	static boolean isExposedThisMethod( String name ) 
	{
		return 
			name.equals(""getClass"") 
			|| name.equals(""invokeMethod"")
			|| name.equals(""getInterface"")
			// These are necessary to let us test synchronization from scripts
			|| name.equals(""wait"") 
			|| name.equals(""notify"")
			|| name.equals(""notifyAll"");
	}
}
"
bsh.Token,"/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
package bsh;
/*
	This file has been modified for BeanShell to make Token serializable.
	If this file is regenerated please make this change.
	All BeanShell modifications are demarcated by ""Begin BeanShell 
	Modification - ... "" and ""End BeanShell Modification - ...""
*/
/**
 * Describes the input token stream.
 */
	// Begin BeanShell Modification - serializable
public class Token implements java.io.Serializable {
	// End BeanShell Modification - serializable
  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;
  /**
   * beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.
   */
  public int beginLine, beginColumn, endLine, endColumn;
  /**
   * The string image of the token.
   */
  public String image;
  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;
  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;
  /**
   * Returns the image.
   */
  public String toString()
  {
     return image;
  }
  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simlpy add something like :
   *
   *    case MyParserConstants.ID : return new IDToken();
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use it in your lexical actions.
   */
  public static final Token newToken(int ofKind)
  {
     switch(ofKind)
     {
       default : return new Token();
     }
  }
}
"
bsh.TokenMgrError,"/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
package bsh;
public class TokenMgrError extends Error
{
   /*
    * Ordinals for various reasons why an Error of this type can be thrown.
    */
   /**
    * Lexical error occured.
    */
   static final int LEXICAL_ERROR = 0;
   /**
    * An attempt wass made to create a second instance of a static token manager.
    */
   static final int STATIC_LEXER_ERROR = 1;
   /**
    * Tried to change to an invalid lexical state.
    */
   static final int INVALID_LEXICAL_STATE = 2;
   /**
    * Detected (and bailed out of) an infinite loop in the token manager.
    */
   static final int LOOP_DETECTED = 3;
   /**
    * Indicates the reason why the exception is thrown. It will have
    * one of the above 4 values.
    */
   int errorCode;
   /**
    * Replaces unprintable characters by their espaced (or unicode escaped)
    * equivalents in the given string
    */
   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
   /**
    * Returns a detailed message for the Error when it is thrown by the
    * token manager to indicate a lexical error.
    * Parameters : 
    *    EOFSeen     : indicates if EOF caused the lexicl error
    *    curLexState : lexical state in which this error occured
    *    errorLine   : line number when the error occured
    *    errorColumn : column number when the error occured
    *    errorAfter  : prefix that was seen before this error occured
    *    curchar     : the offending character
    * Note: You can customize the lexical error message by modifying this method.
    */
   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
      return(""Lexical error at line "" +
           errorLine + "", column "" +
           errorColumn + "".  Encountered: "" +
           (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
           ""after : \"""" + addEscapes(errorAfter) + ""\"""");
   }
   /**
    * You can also modify the body of this method to customize your error messages.
    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
    * of end-users concern, so you can return something like : 
    *
    *     ""Internal Error : Please file a bug report .... ""
    *
    * from this method for such cases in the release version of your parser.
    */
   public String getMessage() {
      return super.getMessage();
   }
   /*
    * Constructors of various flavors follow.
    */
   public TokenMgrError() {
   }
   public TokenMgrError(String message, int reason) {
      super(message);
      errorCode = reason;
   }
   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
}
"
bsh.Types,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Static routines supporing type comparison and conversion in BeanShell.
*/
class Types 
{
	static final int CAST=0, ASSIGNMENT=1;
	/**
		Special value that indicates by identity that the result of a cast
		operation was a valid cast.  This is used by castObject() and
		castPrimitive() in the checkOnly mode of operation.  This value is a 
		Primitive type so that it can be returned by castPrimitive.
	*/
	static Primitive VALID_CAST = new Primitive(1);
	static Primitive INVALID_CAST = new Primitive(-1);
	/**
		Get the Java types of the arguments.
	*/
    public static Class[] getTypes( Object[] args )
    {
        if ( args == null )
            return new Class[0];
        Class[] types = new Class[ args.length ];
        for( int i=0; i<args.length; i++ )
        {
			if ( args[i] == null )
				types[i] = null;
            else 
			if ( args[i] instanceof Primitive )
                types[i] = ((Primitive)args[i]).getType();
            else
                types[i] = args[i].getClass();
        }
        return types;
    }
	/**
		Arguments are assignable as defined by Types.getAssignableForm()
		which takes into account special bsh conversions such as XThis and
		primitive wrapper promotion.
		@deprecated fix this! need to stop catching exception
	*/
	static boolean argsAssignable( Class [] parameters, Object [] args )
	{
		Class [] argTypes = getTypes( args );
		return isSignatureAssignable( argTypes, parameters );
	}
	/**
		Is the 'from' signature (argument types) assignable to the 'to' 
		signature (candidate method types) using isJavaAssignable()?
		This method handles the special case of null values in 'to' types 
		indicating a loose type and matching anything.
	*/
	/*
		Should check for strict java here and use isJavaAssignable() instead
	*/
    static boolean isSignatureAssignable( Class[] from, Class[] to )
    {
        if ( from.length != to.length )
            return false;
        for(int i=0; i<from.length; i++)
            if ( !isBshAssignable( to[i], from[i] ) )
                return false;
        return true;
    }
    /**
		Is a standard Java assignment legal from the rhs type to the lhs type
		in a normal assignment (i.e. without any cast)?
		<p/>
		For Java primitive TYPE classes this method takes primitive promotion
		into account.  The ordinary Class.isAssignableFrom() does not take 
		primitive promotion conversions into account.  Note that Java allows
		additional assignments without a cast in combination with variable
		declarations.  Those are handled elsewhere (maybe should be here with a
		flag?)
		<p/>
		This class accepts a null rhs type indicating that the rhs was the
		value Primitive.NULL and allows it to be assigned to any object lhs
		type (non primitive)
		<p/>
		Note that the getAssignableForm() method is the primary bsh method for 
		checking assignability.  It adds additional bsh conversions, etc. 
		@see #isBshAssignable( Class, Class )
		@param lhs assigning from rhs to lhs
		@param rhs assigning from rhs to lhs
	*/
    static boolean isJavaAssignable( Class lhs, Class rhs )
    {
		// null 'from' type corresponds to type of Primitive.NULL
		// assign to any object type
		if ( rhs == null ) 
			return !lhs.isPrimitive();
		if ( lhs.isPrimitive() && rhs.isPrimitive() )
		{
			if ( lhs == rhs )
				return true;
			// handle primitive widening conversions - JLS 5.1.2
			if ( (rhs == Byte.TYPE) && 
				(lhs == Short.TYPE || lhs == Integer.TYPE ||
                lhs == Long.TYPE || lhs == Float.TYPE || lhs == Double.TYPE))
                    return true;
            if ( (rhs == Short.TYPE) && 
				(lhs == Integer.TYPE || lhs == Long.TYPE ||
                lhs == Float.TYPE || lhs == Double.TYPE))
                    return true;
            if ((rhs == Character.TYPE) && 
				(lhs == Integer.TYPE || lhs == Long.TYPE ||
                lhs == Float.TYPE || lhs == Double.TYPE))
                    return true;
            if ((rhs == Integer.TYPE) && 
				(lhs == Long.TYPE || lhs == Float.TYPE ||
                lhs == Double.TYPE))
                    return true;
            if ((rhs == Long.TYPE) && 
				(lhs == Float.TYPE || lhs == Double.TYPE))
                return true;
            if ((rhs == Float.TYPE) && (lhs == Double.TYPE))
                return true;
        }
        else
            if ( lhs.isAssignableFrom(rhs) )
                return true;
        return false;
    }
	/**
		@param rhs may be Primitive
		@param lhsType is java type or TYPE
		@deprecated Getting rid of this...
		Use isBshAssignable(...) and castObject(...)
	*/
    public static Object getAssignableForm( Object rhs, Class lhsType )
		throws UtilEvalError
    {
		return castObject( rhs, lhsType, ASSIGNMENT );
    }
	/**
		Attempt to cast an object instance to a new type.
		This method can handle fromValue Primitive types (representing 
		primitive casts) as well as fromValue object casts requiring interface 
		generation, etc.
		@param toType the class type of the cast result, which may include
		primitive types, e.g. Byte.TYPE
		@param fromValue an Object or bsh.Primitive primitive value (including
			Primitive.NULL or Primitive.VOID )
		@see #isBshAssignable( Class, Class )
	*/
	public static Object castObject( 
		Object fromValue, Class toType, int operation ) 
		throws UtilEvalError
	{
		if ( fromValue == null )
			throw new InterpreterError(""null fromValue"");
		Class fromType = 
			fromValue instanceof Primitive ? 
				((Primitive)fromValue).getType() 
				: fromValue.getClass();
		return castObject( 
			toType, fromType, fromValue, operation, false/*checkonly*/ );
	}
	static boolean isBshAssignable( Class toType, Class fromType )
	{
		try {
			return castObject( 
				toType, fromType, null/*fromValue*/, 
				ASSIGNMENT, true/*checkOnly*/ 
			) == VALID_CAST;
		} catch ( UtilEvalError e ) {
			// This should not happen with checkOnly true
			throw new InterpreterError(""err in cast check: ""+e);
		}
	}
	/*
		Perform a cast, cast check, or assignability check.
		@param toType the class type of the cast result, which may include
			primitive types, e.g. Byte.TYPE.  toType may be null to indicate a
			loose type assignment (which matches any fromType).
		@param fromType is the class type of the value to be cast including
			java primitive TYPE classes for primitives.
			fromType should be null to indicate that the fromValue is or would
			be Primitive.NULL
		@param fromValue an Object or bsh.Primitive primitive value (including
			Primitive.NULL or Primitive.VOID )
		@param checkOnly If checkOnly is true then fromValue must be null.
			FromType is checked for the cast to toType...
			If checkOnly is false then fromValue must be non-null
			(Primitive.NULL is ok) and the actual cast is performed.
		@throws UtilEvalError on invalid assignment (when operation is
			assignment ).
		@throws UtilTargetError wrapping ClassCastException on cast error 
			(when operation is cast)
		@param operation is Types.CAST or Types.ASSIGNMENT
		@see Primitive.getType()
	*/
	static Object castObject( 
		Class toType, Class fromType, Object fromValue, 
		int operation, boolean checkOnly )
		throws UtilEvalError
	{
		/*
			Lots of preconditions checked here...
			Once things are running smoothly we might comment these out
			(That's what assertions are for).
		*/
		if ( checkOnly && fromValue != null )
			throw new InterpreterError(""bad cast params 1"");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError(""bad cast params 2"");
		if ( fromType == Primitive.class )
			throw new InterpreterError(""bad from Type, need to unwrap"");
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError(""inconsistent args 1"");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError(""inconsistent args 2"");
		if ( toType == Void.TYPE )
			throw new InterpreterError(""loose toType should be null"");
		// assignment to loose type, void type, or exactly same type
		if ( toType == null || toType == fromType )
			return checkOnly ? VALID_CAST :
				fromValue;
        if ( toType.isPrimitive() ) 
		{
			if ( fromType == Void.TYPE || fromType == null 
				|| fromType.isPrimitive() )
			{
				// Both primitives, do primitive cast
				return Primitive.castPrimitive( 
					toType, fromType, (Primitive)fromValue, 
					checkOnly, operation );
			} else
			{
				if ( Primitive.isWrapperType( fromType ) )
				{
					// wrapper to primitive
					// Convert value to Primitive and check/cast it.
					//Object r = checkOnly ? VALID_CAST :
					Class unboxedFromType = Primitive.unboxType( fromType );
					Primitive primFromValue;
					if ( checkOnly ) 
						primFromValue = null; // must be null in checkOnly
					else
						primFromValue = (Primitive)Primitive.wrap( 
							fromValue, unboxedFromType );
					return Primitive.castPrimitive( 
						toType, unboxedFromType, primFromValue, 
						checkOnly, operation );
				} else
				{
					// Cannot cast from arbitrary object to primitive
					if ( checkOnly )
						return INVALID_CAST;
					else
						throw castError( toType, fromType, operation );
				}
			}
        }
		// Casting to reference type
		if ( fromType == Void.TYPE || fromType == null
			|| fromType.isPrimitive() )
		{
			if ( Primitive.isWrapperType( toType ) 
				&& fromType != Void.TYPE && fromType != null )
			{
				// primitive to wrapper type
				return checkOnly ? VALID_CAST :
					Primitive.castWrapper( 
						Primitive.unboxType(toType), 
						((Primitive)fromValue).getValue() );
			}
			// Primitive (not null or void) to Object.class type
			if ( toType == Object.class 
				&& fromType != Void.TYPE && fromType != null )
			{
				// box it
				return checkOnly ? VALID_CAST :
					((Primitive)fromValue).getValue();
			}
			// Primitive to arbitrary object type. 
			// Allow Primitive.castToType() to handle it as well as cases of 
			// Primitive.NULL and Primitive.VOID
			return Primitive.castPrimitive( 
				toType, fromType, (Primitive)fromValue, checkOnly, operation );
		}
		// If type already assignable no cast necessary
		// We do this last to allow various errors above to be caught.
		// e.g cast Primitive.Void to Object would pass this
		if ( toType.isAssignableFrom( fromType ) )
			return checkOnly ? VALID_CAST : 
				fromValue;
		// Can we use the proxy mechanism to cast a bsh.This to 
		// the correct interface?
		if ( toType.isInterface() 
			&& bsh.This.class.isAssignableFrom( fromType ) 
			&& Capabilities.canGenerateInterfaces() 
		)
			return checkOnly ? VALID_CAST : 
				((bsh.This)fromValue).getInterface( toType );
		// Both numeric wrapper types? 
		// Try numeric style promotion wrapper cast
		if ( Primitive.isWrapperType( toType ) 
			&& Primitive.isWrapperType( fromType ) 
		)
			return checkOnly ? VALID_CAST :
				Primitive.castWrapper( toType, fromValue );
		if ( checkOnly )
			return INVALID_CAST;
		else
			throw castError( toType, fromType , operation  );
	}
	/**
		Return a UtilEvalError or UtilTargetError wrapping a ClassCastException
		describing an illegal assignment or illegal cast, respectively.	
	*/
    static UtilEvalError castError( 
		Class lhsType, Class rhsType, int operation   ) 
    {
		return castError( 
			Reflect.normalizeClassName(lhsType),
			Reflect.normalizeClassName(rhsType), operation  );
    }
    static UtilEvalError castError( 
		String lhs, String rhs, int operation   ) 
    {
		if ( operation == ASSIGNMENT )
			return new UtilEvalError (
				""Can't assign "" + rhs + "" to ""+ lhs );
		Exception cce = new ClassCastException(
			""Cannot cast "" + rhs + "" to "" + lhs );
		return new UtilTargetError( cce );
    }
	// Currently unused, but we'll probably need it later.
	/**
		Determine if a cast would be legitimate in order to handle the 
		special cases where a numeric declared var is assigned a type larger 
		than it can handle. (JLS cite??)
			byte b = 5;
			byte b1 = 5*10;
		Normally the above would be int types.
	boolean canCastToDeclaredType( Object value, Class toType ) {
		if ( !(value instanceof Primitive) )
			return false;
		Class fromType = ((Primitive)value).getType();
		if ( (toType==Byte.TYPE || toType==Short.TYPE || toType==Character.TYPE)
			&& fromType == Integer.TYPE 
		)
			return true;
		else
			return false;
	}
	*/
	/**
	// Need to confirm that this works under 1.1
	static Class typeDescriptorToType( String desc ) 
	{
		if ( desc.startsWith(""["") )
			// wouldn't normally use Class.forName, but for primitive ok...
			return Class.forName(
	}
	*/
}
"
bsh.UtilEvalError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	UtilEvalError is an error corresponding to an EvalError but thrown by a 
	utility or other class that does not have the caller context (Node) 
	available to it.  A normal EvalError must supply the caller Node in order 
	for error messages to be pinned to the correct line and location in the 
	script.  UtilEvalError is a checked exception that is *not* a subtype of 
	EvalError, but instead must be caught and rethrown as an EvalError by 
	the a nearest location with context.  The method toEvalError( Node ) 
	should be used to throw the EvalError, supplying the node.
	<p>
	To summarize: Utilities throw UtilEvalError.  ASTs throw EvalError.
	ASTs catch UtilEvalError and rethrow it as EvalError using 
	toEvalError( Node ).  
	<p>
	Philosophically, EvalError and UtilEvalError corrospond to 
	RuntimeException.  However they are constrained in this way in order to 
	add the context for error reporting.
	@see UtilTargetError
*/
public class UtilEvalError extends Exception 
{
	protected UtilEvalError() {
	}
	public UtilEvalError( String s ) {
		super(s);
	}
	/**
		Re-throw as an eval error, prefixing msg to the message and specifying
		the node.  If a node already exists the addNode is ignored.
		@see #setNode( bsh.SimpleNode )
		<p>
		@param msg may be null for no additional message.
	*/
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  ) 
	{
		if ( Interpreter.DEBUG )
			printStackTrace();
		if ( msg == null )
			msg = """";
		else
			msg = msg + "": "";
		return new EvalError( msg+getMessage(), node, callstack );
	}
	public EvalError toEvalError ( SimpleNode node, CallStack callstack ) 
	{
		return toEvalError( null, node, callstack );
	}
}
"
bsh.UtilTargetError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	UtilTargetError is an error corresponding to a TargetError but thrown by a 
	utility or other class that does not have the caller context (Node) 
	available to it.  See UtilEvalError for an explanation of the difference
	between UtilEvalError and EvalError.
	<p>
	@see UtilEvalError
*/
public class UtilTargetError extends UtilEvalError
{
	public Throwable t;
	public UtilTargetError( String message, Throwable t ) {
		super( message );
		this.t = t;
	}
	public UtilTargetError( Throwable t ) {
		this( null, t );
	}
	/**
		Override toEvalError to throw TargetError type.
	*/
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  ) 
	{
		if ( msg == null )
			msg = getMessage();
		else
			msg = msg + "": "" + getMessage();
		return new TargetError( msg, t, node, callstack, false );
	}
}
"
bsh.Variable,"package bsh;
public class Variable implements java.io.Serializable 
{
	static final int DECLARATION=0, ASSIGNMENT=1;
	/** A null type means an untyped variable */
	String name;
	Class type = null;
	String typeDescriptor;
	Object value;
	Modifiers modifiers;
	LHS lhs;
	Variable( String name, Class type, LHS lhs ) 
	{
		this.name = name;
		this.lhs = lhs;
		this.type = type;
	}
	Variable( String name, Object value, Modifiers modifiers )
		throws UtilEvalError
	{
		this( name, (Class)null/*type*/, value, modifiers );
	}
	/**
		This constructor is used in class generation.
	*/
	Variable( 
		String name, String typeDescriptor, Object value, Modifiers modifiers 
	)
		throws UtilEvalError
	{
		this( name, (Class)null/*type*/, value, modifiers );
		this.typeDescriptor = typeDescriptor;
	}
	/**
		@param value may be null if this 
	*/
	Variable( String name, Class type, Object value, Modifiers modifiers )
		throws UtilEvalError
	{
		this.name=name;
		this.type =	type;
		this.modifiers = modifiers;
		setValue( value, DECLARATION );
	}
	/**
		Set the value of the typed variable.
		@param value should be an object or wrapped bsh Primitive type.
		if value is null the appropriate default value will be set for the
		type: e.g. false for boolean, zero for integer types.
	*/
	public void setValue( Object value, int context ) 
		throws UtilEvalError
	{
		// check this.value
		if ( hasModifier(""final"") && this.value != null )
			throw new UtilEvalError (""Final variable, can't re-assign."");
		if ( value == null )
			value = Primitive.getDefaultValue( type );
		if ( lhs != null )
		{
			lhs.assign( value, false/*strictjava*/ );
			return;
		}
		if ( type != null )
			value = Types.castObject( value, type, 
				context == DECLARATION ? Types.CAST : Types.ASSIGNMENT
			);
		this.value= value;
	}
	Object getValue() 
		throws UtilEvalError
	{ 
		if ( lhs != null )
			return lhs.getValue();
		return value; 
	}
	/** A type of null means loosely typed variable */
	public Class getType() { return type;	}
	public String getTypeDescriptor() { return typeDescriptor; }
	public Modifiers getModifiers() { return modifiers; }
	public String getName() { return name; }
	public boolean hasModifier( String name ) {
		return modifiers != null && modifiers.hasModifier(name);
	}
	public String toString() { 
		return ""Variable: ""+super.toString()+"" ""+name+"", type:""+type
			+"", value:""+value +"", lhs = ""+lhs;
	}
}
"
bsh.XThis,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.*;
import java.lang.reflect.InvocationHandler;
import java.io.*;
import java.util.Hashtable;
/**
	XThis is a dynamically loaded extension which extends This.java and adds 
	support for the generalized interface proxy mechanism introduced in 
	JDK1.3.  XThis allows bsh scripted objects to implement arbitrary 
	interfaces (be arbitrary event listener types).
	Note: This module relies on new features of JDK1.3 and will not compile
	with JDK1.2 or lower.  For those environments simply do not compile this
	class.
	Eventually XThis should become simply This, but for backward compatability
	we will maintain This without requiring support for the proxy mechanism.
	XThis stands for ""eXtended This"" (I had to call it something).
	@see JThis	 See also JThis with explicit JFC support for compatability.
	@see This	
*/
class XThis extends This 
	{
	/**
		A cache of proxy interface handlers.
		Currently just one per interface.
	*/
	Hashtable interfaces;
	InvocationHandler invocationHandler = new Handler();
	XThis( NameSpace namespace, Interpreter declaringInterp ) { 
		super( namespace, declaringInterp ); 
	}
	public String toString() {
		return ""'this' reference (XThis) to Bsh object: "" + namespace;
	}
	/**
		Get dynamic proxy for interface, caching those it creates.
	*/
	public Object getInterface( Class clas ) 
	{
		return getInterface( new Class[] { clas } );
	}
	/**
		Get dynamic proxy for interface, caching those it creates.
	*/
	public Object getInterface( Class [] ca ) 
	{
		if ( interfaces == null )
			interfaces = new Hashtable();
		// Make a hash of the interface hashcodes in order to cache them
		int hash = 21;
		for(int i=0; i<ca.length; i++)
			hash *= ca[i].hashCode() + 3;
		Object hashKey = new Integer(hash);
		Object interf = interfaces.get( hashKey );
		if ( interf == null ) 
		{
			ClassLoader classLoader = ca[0].getClassLoader(); // ?
			interf = Proxy.newProxyInstance( 
				classLoader, ca, invocationHandler );
			interfaces.put( hashKey, interf );
		}
		return interf;
	}
	/**
		This is the invocation handler for the dynamic proxy.
		<p>
		Notes:
		Inner class for the invocation handler seems to shield this unavailable
		interface from JDK1.2 VM...  
		I don't understand this.  JThis works just fine even if those
		classes aren't there (doesn't it?)  This class shouldn't be loaded
		if an XThis isn't instantiated in NameSpace.java, should it?
	*/
	class Handler implements InvocationHandler, java.io.Serializable 
	{
		public Object invoke( Object proxy, Method method, Object[] args ) 
			throws Throwable
		{
			try { 
				return invokeImpl( proxy, method, args );
			} catch ( TargetError te ) {
				// Unwrap target exception.  If the interface declares that 
				// it throws the ex it will be delivered.  If not it will be 
				// wrapped in an UndeclaredThrowable
				throw te.getTarget();
			} catch ( EvalError ee ) {
				// Ease debugging...
				// XThis.this refers to the enclosing class instance
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( ""EvalError in scripted interface: ""
					+ XThis.this.toString() + "": ""+ ee );
				throw ee;
			}
		}
		public Object invokeImpl( Object proxy, Method method, Object[] args ) 
			throws EvalError 
		{
			String methodName = method.getName();
			CallStack callstack = new CallStack( namespace );
			/*
				If equals() is not explicitly defined we must override the 
				default implemented by the This object protocol for scripted
				object.  To support XThis equals() must test for equality with 
				the generated proxy object, not the scripted bsh This object;
				otherwise callers from outside in Java will not see a the 
				proxy object as equal to itself.
			*/
			BshMethod equalsMethod = null;
			try {
				equalsMethod = namespace.getMethod( 
					""equals"", new Class [] { Object.class } );
			} catch ( UtilEvalError e ) {/*leave null*/ }
			if ( methodName.equals(""equals"" ) && equalsMethod == null ) {
				Object obj = args[0];
				return new Boolean( proxy == obj );
			}
			/*
				If toString() is not explicitly defined override the default 
				to show the proxy interfaces.
			*/
			BshMethod toStringMethod = null;
			try {
				toStringMethod = 
					namespace.getMethod( ""toString"", new Class [] { } );
			} catch ( UtilEvalError e ) {/*leave null*/ }
			if ( methodName.equals(""toString"" ) && toStringMethod == null)
			{
				Class [] ints = proxy.getClass().getInterfaces();
				// XThis.this refers to the enclosing class instance
				StringBuffer sb = new StringBuffer( 
					XThis.this.toString() + ""\nimplements:"" );
				for(int i=0; i<ints.length; i++)
					sb.append( "" ""+ ints[i].getName() 
						+ ((ints.length > 1)?"","":"""") );
				return sb.toString();
			}
			Class [] paramTypes = method.getParameterTypes();
			return Primitive.unwrap( 
				invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );
		}
	};
}
"
bsh.collection.CollectionIterator,"package bsh.collection;
import java.util.Iterator;
import java.util.Collection;
import java.util.Enumeration;
//import java.util.Map;
import java.lang.reflect.Array;
/**
 *	This is the implementation of:
 *	BshIterator - a dynamically loaded extension that supports the collections
 *	API supported by JDK1.2 and greater.
 *
 *	@author Daniel Leuck
 *	@author Pat Niemeyer
 */
public class CollectionIterator implements bsh.BshIterator
{
	private Iterator iterator;
	/**
	 * Construct a basic CollectionIterator
	 *
	 * @param The object over which we are iterating
	 *
	 * @throws java.lang.IllegalArgumentException If the argument is not a
	 * supported (i.e. iterable) type.
	 *
	 * @throws java.lang.NullPointerException If the argument is null
	 */	
	public CollectionIterator(Object iterateOverMe) {
		iterator = createIterator(iterateOverMe);	
	}
	/**
	 * Create an iterator over the given object
	 *
	 * @param iterateOverMe Object of type Iterator, Collection, or types
	 * supported by CollectionManager.BasicBshIterator
	 *
	 * @return an Iterator
	 *
	 * @throws java.lang.IllegalArgumentException If the argument is not a
	 * supported (i.e. iterable) type.
	 *
	 * @throws java.lang.NullPointerException If the argument is null
	 */
	protected Iterator createIterator(Object iterateOverMe) 
	{
		if (iterateOverMe==null)
			throw new NullPointerException(""Object arguments passed to "" +
				""the CollectionIterator constructor cannot be null."");
		if (iterateOverMe instanceof Iterator)
			return (Iterator)iterateOverMe;
		if (iterateOverMe instanceof Collection) 
			return ((Collection)iterateOverMe).iterator();
		/*
		Should we be able to iterate over maps?
		if (iterateOverMe instanceof Map)
			return ((Map)iterateOverMe).entrySet().iterator();
		*/
		throw new IllegalArgumentException(
			""Cannot enumerate object of type ""+iterateOverMe.getClass());
	}
	/**
	 * Fetch the next object in the iteration
	 *
	 * @return The next object
	 */	
	public Object next() {
		return iterator.next();
	}
	/**
	 * Returns true if and only if there are more objects available
	 * via the <code>next()</code> method
	 *
	 * @return The next object
	 */	
	public boolean hasNext() {
		return iterator.hasNext();	
	}
}
"
bsh.collection.CollectionManagerImpl,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh.collection;
import java.util.Iterator;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Map;
import java.lang.reflect.Array;
import bsh.BshIterator;
/**
	Dynamically loaded extension supporting post 1.1 collections iterator.
 	@author Pat Niemeyer
 */
public class CollectionManagerImpl extends bsh.CollectionManager
{
	public BshIterator getBshIterator( Object obj ) 
		throws IllegalArgumentException
	{
		if ( obj instanceof Collection || obj instanceof Iterator )
			return new CollectionIterator( obj ); 
		else
			return new bsh.CollectionManager.BasicBshIterator( obj ); 
	}
	public boolean isMap( Object obj ) 
	{
		if ( obj instanceof Map )
			return true;
		else
			return super.isMap( obj );
	}
	public Object getFromMap( Object map, Object key ) 
	{
		// Hashtable implements Map
		return ((Map)map).get(key);
	}
	public Object putInMap( Object map, Object key, Object value ) 
	{
		// Hashtable implements Map
		return ((Map)map).put(key, value);
	}
}
"
bsh.commands.dir,"/**
	Display the contents of the current working directory.  
	The format is similar to the Unix ls -l
	<em>This is an example of a bsh command written in Java for speed.</em>
	@method void dir( [ String dirname ] )
*/
package bsh.commands;
import java.io.*;
import bsh.*;
import java.util.Date;
import java.util.Vector;
import java.util.GregorianCalendar;
import java.util.Calendar;
public class dir 
{
	static final String [] months = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", 
		""May"", ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };
	public static String usage() {
		return ""usage: dir( String dir )\n       dir()"";
	}
	/**
		Implement dir() command.
	*/
	public static void invoke( Interpreter env, CallStack callstack ) 
	{
		String dir = ""."";
		invoke( env, callstack, dir );
	}
	/**
		Implement dir( String directory ) command.
	*/
	public static void invoke( 
		Interpreter env, CallStack callstack, String dir ) 
	{
		File file;
		try {
			file =  env.pathToFile( dir );
		} catch (IOException e ) {
			env.println(""error reading path: ""+e);
			return;
		}
		if ( !file.exists() || !file.canRead() ) {
			env.println( ""Can't read "" + file );
			return;
		}
		if ( !file.isDirectory() )  {
			env.println(""'""+dir+""' is not a directory"");
		}
		String [] files = file.list();
		files = StringUtil.bubbleSort(files);
		for( int i=0; i< files.length; i++ ) {
			File f = new File( dir + File.separator + files[i] );
			StringBuffer sb = new StringBuffer();
			sb.append( f.canRead() ? ""r"": ""-"" );
			sb.append( f.canWrite() ? ""w"": ""-"" );
			sb.append( ""_"" );
			sb.append( "" "");
			Date d = new Date(f.lastModified());
			GregorianCalendar c = new GregorianCalendar();
			c.setTime(d);
			int day	= c.get(Calendar.DAY_OF_MONTH);
			sb.append( months[ c.get(Calendar.MONTH) ] + "" "" + day );
			if ( day < 10 ) 
				sb.append("" "");
			sb.append("" "");
			// hack to get fixed length 'length' field
			int fieldlen = 8;
			StringBuffer len = new StringBuffer();
			for(int j=0; j<fieldlen; j++)
				len.append("" "");
			len.insert(0, f.length());
			len.setLength(fieldlen);
			// hack to move the spaces to the front
			int si = len.toString().indexOf("" "");
			if ( si != -1 ) {
				String pad = len.toString().substring(si);
				len.setLength(si);
				len.insert(0, pad);
			}
			sb.append( len.toString() );
			sb.append( "" "" + f.getName() );
			if ( f.isDirectory() ) 
				sb.append(""/"");
			env.println( sb.toString() );
		}
	}
}
"
bsh.reflect.ReflectManagerImpl,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh.reflect;
import bsh.ReflectManager;
import java.lang.reflect.AccessibleObject;
/**
	This is the implementation of:
	ReflectManager - a dynamically loaded extension that supports extended
	reflection features supported by JDK1.2 and greater.
	In particular it currently supports accessible method and field access 
	supported by JDK1.2 and greater.
*/
public class ReflectManagerImpl extends ReflectManager
{
	/**
		Set a java.lang.reflect Field, Method, Constructor, or Array of
		accessible objects to accessible mode.
		If the object is not an AccessibleObject then do nothing.
		@return true if the object was accessible or false if it was not.
	*/
// Arrays incomplete... need to use the array setter
	public boolean setAccessible( Object obj ) 
	{
		if ( obj instanceof AccessibleObject ) {
			((AccessibleObject)obj).setAccessible(true);
			return true;
		} else
			return false;
	}
}
"
com.microstar.xml.HandlerBase,"// HandlerBase.java: Simple base class for AElfred processors.
// NO WARRANTY! See README, and copyright below.
// $Id: HandlerBase.java,v 1.1.1.1 2001/09/02 05:39:36 spestov Exp $
package com.microstar.xml;
import com.microstar.xml.XmlHandler;
import com.microstar.xml.XmlException;
import java.io.Reader;
/**
  * Convenience base class for AElfred handlers.
  * <p>This base class implements the XmlHandler interface with
  * (mostly empty) default handlers.  You are not required to use this,
  * but if you need to handle only a few events, you might find
  * it convenient to extend this class rather than implementing
  * the entire interface.  This example overrides only the
  * <code>charData</code> method, using the defaults for the others:
  * <pre>
  * import com.microstar.xml.HandlerBase;
  *
  * public class MyHandler extends HandlerBase {
  *   public void charData (char ch[], int start, int length)
  *   {
  *     System.out.println(""Data: "" + new String (ch, start, length));
  *   }
  * }
  * </pre>
  * <p>This class is optional, but if you use it, you must also
  * include the <code>XmlException</code> class.
  * <p>Do not extend this if you are using SAX; extend
  * <code>org.xml.sax.HandlerBase</code> instead.
  * @author Copyright (c) 1998 by Microstar Software Ltd.
  * @author written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlHandler
  * @see XmlException
  * @see org.xml.sax.HandlerBase
  */
public class HandlerBase implements XmlHandler {
  /**
    * Handle the start of the document.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#startDocument
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void startDocument () 
    throws java.lang.Exception
  {
  }
  /**
    * Handle the end of the document.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#endDocument
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void endDocument ()
    throws java.lang.Exception
  {
  }
  /**
    * Resolve an external entity.
    * <p>The default implementation simply returns the supplied
    * system identifier.
    * @see com.microstar.xml.XmlHandler#resolveEntity
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public Object resolveEntity (String publicId, String systemId) 
    throws java.lang.Exception
  {
    return null;
  }
  /**
    * Handle the start of an external entity.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#startExternalEntity
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void startExternalEntity (String systemId)
    throws java.lang.Exception
  {
  }
  /**
    * Handle the end of an external entity.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#endExternalEntity
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void endExternalEntity (String systemId)
    throws java.lang.Exception
  {
  }
  /**
    * Handle a document type declaration.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#doctypeDecl
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void doctypeDecl (String name, String publicId, String systemId)
    throws java.lang.Exception
  {
  }
  /**
    * Handle an attribute assignment.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#attribute
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void attribute (String aname, String value, boolean isSpecified)
    throws java.lang.Exception
  {
  }
  /**
    * Handle the start of an element.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#startElement
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void startElement (String elname)
    throws java.lang.Exception
  {
  }
  /**
    * Handle the end of an element.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#endElement
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void endElement (String elname)
    throws java.lang.Exception
  {
  }
  /**
    * Handle character data.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#charData
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void charData (char ch[], int start, int length)
    throws java.lang.Exception
  {
  }
  /**
    * Handle ignorable whitespace.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#ignorableWhitespace
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void ignorableWhitespace (char ch[], int start, int length)
    throws java.lang.Exception
  {
  }
  /**
    * Handle a processing instruction.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#processingInstruction
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void processingInstruction (String target, String data)
    throws java.lang.Exception
  {
  }
  /**
    * Throw an exception for a fatal error.
    * <p>The default implementation throws <code>XmlException</code>.
    * @see com.microstar.xml.XmlHandler#error
    * @exception com.microstar.xml.XmlException A specific parsing error.
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void error (String message, String systemId, int line, int column)
    throws XmlException, java.lang.Exception
  {
    throw new XmlException(message, systemId, line, column);
  }
}
"
com.microstar.xml.XmlException,"// XmlException.java: Simple base class for AElfred processors.
// NO WARRANTY! See README, and copyright below.
// $Id: XmlException.java,v 1.1.1.1 2001/09/02 05:39:36 spestov Exp $
package com.microstar.xml;
/**
  * Convenience exception class for reporting XML parsing errors.
  * <p>This is an exception class that you can use to encapsulate all
  * of the information from &AElig;lfred's <code>error</code> callback.
  * This is not necessary for routine use of &AElig;lfred, but it
  * is used by the optional <code>HandlerBase</code> class.
  * <p>Note that the core &AElig;lfred classes do <em>not</em>
  * use this exception.
  * @author Copyright (c) 1998 by Microstar Software Ltd.
  * @author written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlHandler#error
  * @see HandlerBase
  */
public class XmlException extends Exception
{
  private String message;
  private String systemId;
  private int line;
  private int column;
  /**
    * Construct a new XML parsing exception.
    * @param message The error message from the parser.
    * @param systemId The URI of the entity containing the error.
    * @param line The line number where the error appeared.
    * @param column The column number where the error appeared.
    */
  public XmlException (String message, String systemId, int line, int column)
  {
    this.message = message;
    this.systemId = systemId;
    this.line = line;
    this.column = column;
  }
  /**
    * Get the error message from the parser.
    * @return A string describing the error.
    */
  public String getMessage ()
  {
    return message;
  }
  /**
    * Get the URI of the entity containing the error.
    * @return The URI as a string.
    */
  public String getSystemId ()
  {
    return systemId;
  }
  /**
    * Get the line number containing the error.
    * @return The line number as an integer.
    */
  public int getLine ()
  {
    return line;
  }
  /**
    * Get the column number containing the error.
    * @return The column number as an integer.
    */
  public int getColumn ()
  {
    return column;
  }
}
"
com.microstar.xml.XmlHandler,"// XmlHandler.java: the callback interface.
// NO WARRANTY! See README, and copyright below.
// $Id: XmlHandler.java,v 1.1.1.1 2001/09/02 05:39:38 spestov Exp $
package com.microstar.xml;
/**
  * XML Processing Interface.
  * <p>Whenever you parse an XML document, you must provide an object
  * from a class that implements this interface to receive the parsing 
  * events.
  * <p>If you do not want to implement this entire interface, you
  * can extend the <code>HandlerBase</code> convenience class and
  * then implement only what you need.
  * <p>If you are using SAX, you should implement the SAX handler
  * interfaces rather than this one.
  * @author Copyright (c) 1997, 1998 by Microstar Software Ltd.
  * @author written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlParser
  * @see HandlerBase
  * @see org.xml.sax.EntityHandler
  * @see org.xml.sax.DocumentHandler
  * @see org.xml.sax.ErrorHandler
  */
public interface XmlHandler {
  /**
    * Start the document.
    * <p>&AElig;lfred will call this method just before it
    * attempts to read the first entity (the root of the document).
    * It is guaranteed that this will be the first method called.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #endDocument
    */
  public void startDocument ()
    throws java.lang.Exception;
  /**
    * End the document.
    * <p>&AElig;lfred will call this method once, when it has
    * finished parsing the XML document.
    * It is guaranteed that this will be the last method called.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startDocument
    */
  public void endDocument ()
    throws java.lang.Exception;
  /**
    * Resolve an External Entity.
    * <p>Give the handler a chance to redirect external entities
    * to different URIs.  &AElig;lfred will call this method for the
    * top-level document entity, for external text (XML) entities, 
    * and the external DTD subset (if any).
    * @param publicId The public identifier, or null if none was supplied.
    * @param systemId The system identifier.
    * @return The replacement system identifier, or null to use
    *         the default.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startExternalEntity
    * @see #endExternalEntity
    */
  public Object resolveEntity (String publicId, String systemId)
    throws java.lang.Exception;
  /**
    * Begin an external entity.
    * <p>&AElig;lfred will call this method at the beginning of
    * each external entity, including the top-level document entity
    * and the external DTD subset (if any).
    * <p>If necessary, you can use this method to track the location
    * of the current entity so that you can resolve relative URIs
    * correctly.
    * @param systemId The URI of the external entity that is starting.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #endExternalEntity
    * @see #resolveEntity
    */
  public void startExternalEntity (String systemId)
    throws java.lang.Exception;
  /**
    * End an external entity.
    * <p>&AElig;lfred will call this method at the end of
    * each external entity, including the top-level document entity
    * and the external DTD subset.
    * <p>If necessary, you can use this method to track the location
    * of the current entity so that you can resolve relative URIs
    * correctly.
    * @param systemId The URI of the external entity that is ending.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startExternalEntity
    * @see #resolveEntity
    */
  public void endExternalEntity (String systemId)
    throws java.lang.Exception;
  /**
    * Document type declaration.
    * <p>&AElig;lfred will call this method when or if it encounters
    * the document type (DOCTYPE) declaration.
    * <p>Please note that the public and system identifiers will
    * not always be a reliable indication of the DTD in use.
    * @param name The document type name.
    * @param publicId The public identifier, or null if unspecified.
    * @param systemId The system identifier, or null if unspecified.
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void doctypeDecl (String name, String publicId, String systemId)
    throws java.lang.Exception;
  /**
    * Attribute.
    * <p>&AElig;lfred will call this method once for each attribute 
    * (specified or defaulted) before reporting a startElement event.
    * It is up to your handler to collect the attributes, if
    * necessary.
    * <p>You may use XmlParser.getAttributeType() to find the attribute's
    * declared type.
    * @param name The name of the attribute.
    * @param type The type of the attribute (see below).
    * @param value The value of the attribute, or null if the attribute
    *        is <code>#IMPLIED</code>.
    * @param isSpecified True if the value was specified, false if it
    *       was defaulted from the DTD.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startElement
    * @see XmlParser#declaredAttributes
    * @see XmlParser#getAttributeType
    * @see XmlParser#getAttributeDefaultValue
    */
  public void attribute (String aname, String value, boolean isSpecified)
    throws java.lang.Exception;
  /**
    * Start an element.
    * <p>&AElig;lfred will call this method at the beginning of each
    * element.  By the time this is called, all of the attributes
    * for the element will already have been reported using the
    * <code>attribute</code> method.
    * @param elname The element type name.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #attribute
    * @see #endElement
    * @see XmlParser#declaredElements
    * @see XmlParser#getElementContentType
    */
  public void startElement (String elname)
    throws java.lang.Exception;
  /**
    * End an element.
    * <p>&AElig;lfred will call this method at the end of each element
    * (including EMPTY elements).
    * @param elname The element type name.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startElement
    * @see XmlParser#declaredElements
    * @see XmlParser#getElementContentType
    */
  public void endElement (String elname)
    throws java.lang.Exception;
  /**
    * Character data.
    * <p>&AElig;lfred will call this method once for each chunk of
    * character data found in the contents of elements.  Note that
    * the parser may break up a long sequence of characters into
    * smaller chunks and call this method once for each chunk.
    * <p>Do <em>not</em> attempt to read more than <var>length</var>
    * characters from the array, or to read before the 
    * <var>start</var> position.
    * @param ch The character data.
    * @param start The starting position in the array.
    * @param length The number of characters available.
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void charData (char ch[], int start, int length)
    throws java.lang.Exception;
  /**
    * Ignorable whitespace.
    * <p>&AElig;lfred will call this method once for each sequence
    * of ignorable whitespace in element content (never in mixed content).
    * <p>For details, see section 2.10 of the XML 1.0 recommendation.
    * <p>Do <em>not</em> attempt to read more than <var>length</var>
    * characters from the array or to read before the <var>start</var>
    * position.
    * @param ch The literal whitespace characters.
    * @param start The starting position in the array.
    * @param length The number of whitespace characters available.
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void ignorableWhitespace (char ch[], int start, int length)
    throws java.lang.Exception;
  /**
    * Processing instruction.
    * <p>&AElig;lfred will call this method once for each
    * processing instruction.  Note that processing instructions may
    * appear outside of the top-level element.  The
    * @param target The target (the name at the start of the PI).
    * @param data The data, if any (the rest of the PI).
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void processingInstruction (String target, String data)
    throws java.lang.Exception;
  /**
    * Fatal XML parsing error.
    * <p>&AElig;lfred will call this method whenever it encounters
    * a serious error.  The parser will attempt to continue past this 
    * point so that you can find more possible error points, but if
    * this method is called you should assume that the document is
    * corrupt and you should not try to use its contents.
    * <p>Note that you can use the <code>XmlException</code> class
    * to encapsulate all of the information provided, though the
    * use of the class is not mandatory.
    * @param message The error message.
    * @param systemId The system identifier of the entity that 
    *        contains the error.
    * @param line The approximate line number of the error.
    * @param column The approximate column number of the error.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see XmlException
    */
  public void error (String message, String systemId, int line, int column)
    throws java.lang.Exception;
}
"
com.microstar.xml.XmlParser,"// XmlParser.java: the main parser class.
// NO WARRANTY! See README, and copyright below.
// $Id: XmlParser.java,v 1.3 2004/02/22 20:00:47 spestov Exp $
package com.microstar.xml;
import java.io.BufferedInputStream;
import java.io.EOFException;
import java.io.InputStream;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
/**
  * Parse XML documents and return parse events through call-backs.
  * <p>You need to define a class implementing the <code>XmlHandler</code>
  * interface: an object belonging to this class will receive the
  * callbacks for the events.  (As an alternative to implementing
  * the full XmlHandler interface, you can simply extend the 
  * <code>HandlerBase</code> convenience class.)
  * <p>Usage (assuming that <code>MyHandler</code> is your implementation
  * of the <code>XmlHandler</code> interface):
  * <pre>
  * XmlHandler handler = new MyHandler();
  * XmlParser parser = new XmlParser();
  * parser.setHandler(handler);
  * try {
  *   parser.parse(""http://www.host.com/doc.xml"", null);
  * } catch (Exception e) {
  *   [do something interesting]
  * }
  * </pre>
  * <p>Alternatively, you can use the standard SAX interfaces
  * with the <code>SAXDriver</code> class as your entry point.
  * @author Copyright (c) 1997, 1998 by Microstar Software Ltd.
  * @author Written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlHandler
  * @see HandlerBase
  * @see SAXDriver
  */
public class XmlParser {
  //
  // Use special cheats that speed up the code (currently about 50%),
  // but may cause problems with future maintenance and add to the
  // class file size (about 500 bytes).
  //
  private final static boolean USE_CHEATS = true;
  //////////////////////////////////////////////////////////////////////
  // Constructors.
  ////////////////////////////////////////////////////////////////////////
  /**
    * Construct a new parser with no associated handler.
    * @see #setHandler
    * @see #parse
    */
  public XmlParser ()
  {
  }
  /**
    * Set the handler that will receive parsing events.
    * @param handler The handler to receive callback events.
    * @see #parse
    * @see XmlHandler
    */
  public void setHandler (XmlHandler handler)
  {
    this.handler = handler;
  }
  /**
    * Parse an XML document from a URI.
    * <p>You may parse a document more than once, but only one thread
    * may call this method for an object at one time.
    * @param systemId The URI of the document.
    * @param publicId The public identifier of the document, or null.
    * @param encoding The suggested encoding, or null if unknown.
    * @exception java.lang.Exception Any exception thrown by your
    *            own handlers, or any derivation of java.io.IOException
    *            thrown by the parser itself.
    */
  public void parse (String systemId, String publicId, String encoding)
    throws java.lang.Exception
  {
    doParse(systemId, publicId, null, null, encoding);
  }
  /**
    * Parse an XML document from a byte stream.
    * <p>The URI that you supply will become the base URI for
    * resolving relative links, but &AElig;lfred will actually read
    * the document from the supplied input stream.
    * <p>You may parse a document more than once, but only one thread
    * may call this method for an object at one time.
    * @param systemId The base URI of the document, or null if not
    *                 known.
    * @param publicId The public identifier of the document, or null
    *                 if not known.
    * @param stream A byte input stream.
    * @param encoding The suggested encoding, or null if unknown.
    * @exception java.lang.Exception Any exception thrown by your
    *            own handlers, or any derivation of java.io.IOException
    *            thrown by the parser itself.
    */
  public void parse (String systemId, String publicId,
		     InputStream stream, String encoding)
    throws java.lang.Exception
  {
    doParse(systemId, publicId, null, stream, encoding);
  }
  /**
    * Parse an XML document from a character stream.
    * <p>The URI that you supply will become the base URI for
    * resolving relative links, but &AElig;lfred will actually read
    * the document from the supplied input stream.
    * <p>You may parse a document more than once, but only one thread
    * may call this method for an object at one time.
    * @param systemId The base URI of the document, or null if not
    *                 known.
    * @param publicId The public identifier of the document, or null
    *                 if not known.
    * @param reader A character stream.
    * @exception java.lang.Exception Any exception thrown by your
    *            own handlers, or any derivation of java.io.IOException
    *            thrown by the parser itself.
    */
  public void parse (String systemId, String publicId, Reader reader)
    throws java.lang.Exception
  {
    doParse(systemId, publicId, reader, null, null);
  }
  private synchronized void doParse (String systemId, String publicId,
				     Reader reader, InputStream stream,
				     String encoding)
    throws java.lang.Exception
  {
    basePublicId = publicId;
    baseURI = systemId;
    baseReader = reader;
    baseInputStream = stream;
    initializeVariables();
				// Set the default entities here.
    setInternalEntity(intern(""amp""), ""&#38;"");
    setInternalEntity(intern(""lt""), ""&#60;"");
    setInternalEntity(intern(""gt""), ""&#62;"");
    setInternalEntity(intern(""apos""), ""&#39;"");
    setInternalEntity(intern(""quot""), ""&#34;"");
    if (handler != null) {
      handler.startDocument();
    }
    pushURL(""[document]"", basePublicId, baseURI, baseReader, baseInputStream,
	    encoding);
    parseDocument();
    if (handler != null) {
      handler.endDocument();
    }
    cleanupVariables();
  }
  ////////////////////////////////////////////////////////////////////////
  // Constants.
  ////////////////////////////////////////////////////////////////////////
  //
  // Constants for element content type.
  //
  /**
    * Constant: an element has not been declared.
    * @see #getElementContentType
    */
  public final static int CONTENT_UNDECLARED = 0;
  /**
    * Constant: the element has a content model of ANY.
    * @see #getElementContentType
    */
  public final static int CONTENT_ANY = 1;
  /**
    * Constant: the element has declared content of EMPTY.
    * @see #getElementContentType
    */
  public final static int CONTENT_EMPTY = 2;
  /**
    * Constant: the element has mixed content.
    * @see #getElementContentType
    */
  public final static int CONTENT_MIXED = 3;
  /**
    * Constant: the element has element content.
    * @see #getElementContentType
    */
  public final static int CONTENT_ELEMENTS = 4;
  //
  // Constants for the entity type.
  //
  /**
    * Constant: the entity has not been declared.
    * @see #getEntityType
    */
  public final static int ENTITY_UNDECLARED = 0;
  /**
    * Constant: the entity is internal.
    * @see #getEntityType
    */
  public final static int ENTITY_INTERNAL = 1;
  /**
    * Constant: the entity is external, non-XML data.
    * @see #getEntityType
    */
  public final static int ENTITY_NDATA = 2;
  /**
    * Constant: the entity is external XML data.
    * @see #getEntityType
    */
  public final static int ENTITY_TEXT = 3;
  //
  // Constants for attribute type.
  //
  /**
    * Constant: the attribute has not been declared for this element type.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_UNDECLARED = 0;
  /**
    * Constant: the attribute value is a string value.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_CDATA = 1;
  /**
    * Constant: the attribute value is a unique identifier.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ID = 2;
  /**
    * Constant: the attribute value is a reference to a unique identifier.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_IDREF = 3;
  /**
    * Constant: the attribute value is a list of ID references.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_IDREFS = 4;
  /**
    * Constant: the attribute value is the name of an entity.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ENTITY = 5;
  /**
    * Constant: the attribute value is a list of entity names.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ENTITIES = 6;
  /**
    * Constant: the attribute value is a name token.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_NMTOKEN = 7;
  /**
    * Constant: the attribute value is a list of name tokens.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_NMTOKENS = 8;
  /**
    * Constant: the attribute value is a token from an enumeration.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ENUMERATED = 9;
  /**
    * Constant: the attribute is the name of a notation.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_NOTATION = 10;
  //
  // When the class is loaded, populate the hash table of
  // attribute types.
  //
  /**
    * Hash table of attribute types.
    */
  private static Hashtable attributeTypeHash;
  static {
    attributeTypeHash = new Hashtable();
    attributeTypeHash.put(""CDATA"", new Integer(ATTRIBUTE_CDATA));
    attributeTypeHash.put(""ID"", new Integer(ATTRIBUTE_ID));
    attributeTypeHash.put(""IDREF"", new Integer(ATTRIBUTE_IDREF));
    attributeTypeHash.put(""IDREFS"", new Integer(ATTRIBUTE_IDREFS));
    attributeTypeHash.put(""ENTITY"", new Integer(ATTRIBUTE_ENTITY));
    attributeTypeHash.put(""ENTITIES"", new Integer(ATTRIBUTE_ENTITIES));
    attributeTypeHash.put(""NMTOKEN"", new Integer(ATTRIBUTE_NMTOKEN));
    attributeTypeHash.put(""NMTOKENS"", new Integer(ATTRIBUTE_NMTOKENS));
    attributeTypeHash.put(""NOTATION"", new Integer(ATTRIBUTE_NOTATION));
  }
  //
  // Constants for supported encodings.
  //
  private final static int ENCODING_UTF_8 = 1;
  private final static int ENCODING_ISO_8859_1 = 2;
  private final static int ENCODING_UCS_2_12 = 3;
  private final static int ENCODING_UCS_2_21 = 4;
  private final static int ENCODING_UCS_4_1234 = 5;
  private final static int ENCODING_UCS_4_4321 = 6;
  private final static int ENCODING_UCS_4_2143 = 7;
  private final static int ENCODING_UCS_4_3412 = 8;
  //
  // Constants for attribute default value.
  //
  /**
    * Constant: the attribute is not declared.
    * @see #getAttributeDefaultValueType
    */
  public final static int ATTRIBUTE_DEFAULT_UNDECLARED = 0;
  /**
    * Constant: the attribute has a literal default value specified.
    * @see #getAttributeDefaultValueType
    * @see #getAttributeDefaultValue
    */
  public final static int ATTRIBUTE_DEFAULT_SPECIFIED = 1;
  /**
    * Constant: the attribute was declared #IMPLIED.
    * @see #getAttributeDefaultValueType
    */
  public final static int ATTRIBUTE_DEFAULT_IMPLIED = 2;
  /**
    * Constant: the attribute was declared #REQUIRED.
    * @see #getAttributeDefaultValueType
    */
  public final static int ATTRIBUTE_DEFAULT_REQUIRED = 3;
  /**
    * Constant: the attribute was declared #FIXED.
    * @see #getAttributeDefaultValueType
    * @see #getAttributeDefaultValue
    */
  public final static int ATTRIBUTE_DEFAULT_FIXED = 4;
  //
  // Constants for input.
  //
  private final static int INPUT_NONE = 0;
  private final static int INPUT_INTERNAL = 1;
  private final static int INPUT_EXTERNAL = 2;
  private final static int INPUT_STREAM = 3;
  private final static int INPUT_BUFFER = 4;
  private final static int INPUT_READER = 5;
  //
  // Flags for reading literals.
  //
  private final static int LIT_CHAR_REF = 1;
  private final static int LIT_ENTITY_REF = 2;
  private final static int LIT_PE_REF = 4;
  private final static int LIT_NORMALIZE = 8;
  //
  // Flags for parsing context.
  //
  private final static int CONTEXT_NONE = 0;
  private final static int CONTEXT_DTD = 1;
  private final static int CONTEXT_ENTITYVALUE = 2;
  private final static int CONTEXT_ATTRIBUTEVALUE = 3;
  //////////////////////////////////////////////////////////////////////
  // Error reporting.
  //////////////////////////////////////////////////////////////////////
  /**
    * Report an error.
    * @param message The error message.
    * @param textFound The text that caused the error (or null).
    * @see XmlHandler#error
    * @see #line
    */
  void error (String message, String textFound, String textExpected)
    throws java.lang.Exception
  {
    errorCount++;
    if (textFound != null) {
      message = message + "" (found \"""" + textFound + ""\"")"";
    }
    if (textExpected != null) {
      message = message + "" (expected \"""" + textExpected + ""\"")"";
    }
    if (handler != null) {
      String uri = null;
      if (externalEntity != null) {
	uri = externalEntity.getURL().toString();
      }
      handler.error(message, uri, line, column);
    }
  }
  /**
    * Report a serious error.
    * @param message The error message.
    * @param textFound The text that caused the error (or null).
    */
  void error (String message, char textFound, String textExpected)
    throws java.lang.Exception
  {
    error(message, new Character(textFound).toString(), textExpected);
  }
  //////////////////////////////////////////////////////////////////////
  // Major syntactic productions.
  //////////////////////////////////////////////////////////////////////
  /**
    * Parse an XML document.
    * <pre>
    * [1] document ::= prolog element Misc*
    * </pre>
    * <p>This is the top-level parsing function for a single XML
    * document.  As a minimum, a well-formed document must have
    * a document element, and a valid document must have a prolog
    * as well.
    */
  void parseDocument ()
    throws java.lang.Exception
    {
    char c;
    parseProlog();
    require('<');
    parseElement();
    try
      {
      parseMisc();  //skip all white, PIs, and comments
      c=readCh();   //if this doesn't throw an exception...
      error(""unexpected characters after document end"",c,null);
      }
    catch (EOFException e)
      {return;}
    }
  /**
    * Skip a comment.
    * <pre>
    * [18] Comment ::= '&lt;!--' ((Char - '-') | ('-' (Char - '-')))* ""-->""
    * </pre>
    * <p>(The <code>&lt;!--</code> has already been read.)
    */
  void parseComment ()
    throws java.lang.Exception
  {
    skipUntil(""-->"");
  }
  /**
    * Parse a processing instruction and do a call-back.
    * <pre>
    * [19] PI ::= '&lt;?' Name (S (Char* - (Char* '?&gt;' Char*)))? '?&gt;'
    * </pre>
    * <p>(The <code>&lt;?</code> has already been read.)
    * <p>An XML processing instruction <em>must</em> begin with
    * a Name, which is the instruction's target.
    */
  void parsePI ()
    throws java.lang.Exception
  {
    String name;
    name = readNmtoken(true);
    if (!tryRead(""?>"")) {
      requireWhitespace();
      parseUntil(""?>"");
    }
    if (handler != null) {
      handler.processingInstruction(name, dataBufferToString());
    }
  }
  /**
    * Parse a CDATA marked section.
    * <pre>
    * [20] CDSect ::= CDStart CData CDEnd
    * [21] CDStart ::= '&lt;![CDATA['
    * [22] CData ::= (Char* - (Char* ']]&gt;' Char*))
    * [23] CDEnd ::= ']]&gt;'
    * </pre>
    * <p>(The '&lt;![CDATA[' has already been read.)
    * <p>Note that this just appends characters to the dataBuffer,
    * without actually generating an event.
    */
  void parseCDSect ()
    throws java.lang.Exception
  {
    parseUntil(""]]>"");
  }
  /**
    * Parse the prolog of an XML document.
    * <pre>
    * [24] prolog ::= XMLDecl? Misc* (Doctypedecl Misc*)?
    * </pre>
    * <p>There are a couple of tricks here.  First, it is necessary to
    * declare the XML default attributes after the DTD (if present)
    * has been read.  Second, it is not possible to expand general
    * references in attribute value literals until after the entire
    * DTD (if present) has been parsed.
    * <p>We do not look for the XML declaration here, because it is
    * handled by pushURL().
    * @see pushURL
    */
  void parseProlog ()
    throws java.lang.Exception
  {
    parseMisc();
    if (tryRead(""<!DOCTYPE"")) {
      parseDoctypedecl();
      parseMisc();
    }
  }
  /**
    * Parse the XML declaration.
    * <pre>
    * [25] XMLDecl ::= '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?&gt;'
    * [26] VersionInfo ::= S 'version' Eq ('""1.0""' | ""'1.0'"")
    * [33] SDDecl ::= S 'standalone' Eq ""'"" ('yes' | 'no') ""'""
    *               | S 'standalone' Eq '""' (""yes"" | ""no"") '""'
    * [78] EncodingDecl ::= S 'encoding' Eq QEncoding
    * </pre>
    * <p>([80] to [82] are also significant.)
    * <p>(The <code>&lt;?xml</code> and whitespace have already been read.)
    * <p>TODO: validate value of standalone.
    * @see #parseTextDecl
    * @see #checkEncoding
    */
  void parseXMLDecl (boolean ignoreEncoding)
    throws java.lang.Exception
  {
    String version;
    String encodingName = null;
    String standalone = null;
				// Read the version.
    require(""version"");
    parseEq();
    version = readLiteral(0);
    if (!version.equals(""1.0"")) {
      error(""unsupported XML version"", version, ""1.0"");
    }
				// Try reading an encoding declaration.
    skipWhitespace();
    if (tryRead(""encoding"")) {
      parseEq();
      encodingName = readLiteral(0);
      checkEncoding(encodingName, ignoreEncoding);
    }
				// Try reading a standalone declaration
    skipWhitespace();
    if (tryRead(""standalone"")) {
      parseEq();
      standalone = readLiteral(0);
    }
    skipWhitespace();
    require(""?>"");
  }
  /**
    * Parse the Encoding PI.
    * <pre>
    * [78] EncodingDecl ::= S 'encoding' Eq QEncoding
    * [79] EncodingPI ::= '&lt;?xml' S 'encoding' Eq QEncoding S? '?&gt;'
    * [80] QEncoding ::= '""' Encoding '""' | ""'"" Encoding ""'""
    * [81] Encoding ::= LatinName
    * [82] LatinName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
    * </pre>
    * <p>(The <code>&lt;?xml</code>' and whitespace have already been read.)
    * @see #parseXMLDecl
    * @see #checkEncoding
    */
  void parseTextDecl (boolean ignoreEncoding)
    throws java.lang.Exception
  {
    String encodingName = null;
				// Read an optional version.
    if (tryRead(""version"")) {
      String version;
      parseEq();
      version = readLiteral(0);
      if (!version.equals(""1.0"")) {
	error(""unsupported XML version"", version, ""1.0"");
      }
      requireWhitespace();
    }
				// Read the encoding.
    require(""encoding"");
    parseEq();
    encodingName = readLiteral(0);
    checkEncoding(encodingName, ignoreEncoding);
    skipWhitespace();
    require(""?>"");
  }
  /**
    * Check that the encoding specified makes sense.
    * <p>Compare what the author has specified in the XML declaration
    * or encoding PI with what we have detected.
    * <p>This is also important for distinguishing among the various
    * 7- and 8-bit encodings, such as ISO-LATIN-1 (I cannot autodetect
    * those).
    * @param encodingName The name of the encoding specified by the user.
    * @see #parseXMLDecl
    * @see #parseTextDecl
    */
  void checkEncoding (String encodingName, boolean ignoreEncoding)
    throws java.lang.Exception
  {
    encodingName = encodingName.toUpperCase();
    if (ignoreEncoding) {
      return;
    }
    switch (encoding) {
				// 8-bit encodings
    case ENCODING_UTF_8:
      if (encodingName.equals(""ISO-8859-1"")) {
	encoding = ENCODING_ISO_8859_1;
      } else if (!encodingName.equals(""UTF-8"")) {
	error(""unsupported 8-bit encoding"",
	      encodingName,
	      ""UTF-8 or ISO-8859-1"");
      }
      break;
				// 16-bit encodings
    case ENCODING_UCS_2_12:
    case ENCODING_UCS_2_21:
      if (!encodingName.equals(""ISO-10646-UCS-2"") &&
	  !encodingName.equals(""UTF-16"")) {
	error(""unsupported 16-bit encoding"",
	      encodingName,
	      ""ISO-10646-UCS-2"");
      }
      break;
				// 32-bit encodings
    case ENCODING_UCS_4_1234:
    case ENCODING_UCS_4_4321:
    case ENCODING_UCS_4_2143:
    case ENCODING_UCS_4_3412:
      if (!encodingName.equals(""ISO-10646-UCS-4"")) {
	error(""unsupported 32-bit encoding"",
	      encodingName,
	      ""ISO-10646-UCS-4"");
      }
    }
  }
  /**
    * Parse miscellaneous markup outside the document element and DOCTYPE
    * declaration.
    * <pre>
    * [27] Misc ::= Comment | PI | S
    * </pre>
    */
  void parseMisc ()
    throws java.lang.Exception
    {
    while (true)
      {
      skipWhitespace();
      if (tryRead(""<?""))
        {parsePI();}
      else if (tryRead(""<!--""))
        {parseComment();}
      else
        {return;}
      }
    }
  /**
    * Parse a document type declaration.
    * <pre>
    * [28] doctypedecl ::= '&lt;!DOCTYPE' S Name (S ExternalID)? S?
    *                      ('[' %markupdecl* ']' S?)? '&gt;'
    * </pre>
    * <p>(The <code>&lt;!DOCTYPE</code> has already been read.)
    */
  void parseDoctypedecl ()
    throws java.lang.Exception
  {
    char c;
    String doctypeName, ids[];
				// Read the document type name.
    requireWhitespace();
    doctypeName = readNmtoken(true);
				// Read the ExternalIDs.
    skipWhitespace();
    ids = readExternalIds(false);
				// Look for a declaration subset.
    skipWhitespace();
    if (tryRead('[')) {
				// loop until the subset ends
      while (true) {
	context = CONTEXT_DTD;
	skipWhitespace();
	context = CONTEXT_NONE;
	if (tryRead(']')) {
	  break;		// end of subset
	} else {
	  context = CONTEXT_DTD;
	  parseMarkupdecl();
	  context = CONTEXT_NONE;
	}
      }
    }
				// Read the external subset, if any
    if (ids[1] != null) {
      pushURL(""[external subset]"", ids[0], ids[1], null, null, null);
				// Loop until we end up back at '>'
      while (true) {
	context = CONTEXT_DTD;
	skipWhitespace();
	context = CONTEXT_NONE;
	if (tryRead('>')) {
	  break;
	} else {
	  context = CONTEXT_DTD;
	  parseMarkupdecl();
	  context = CONTEXT_NONE;
	}
      }
    } else {
				// No external subset.
      skipWhitespace();
      require('>');
    }
    if (handler != null) {
      handler.doctypeDecl(doctypeName, ids[0], ids[1]);
    }
				// Expand general entities in
				// default values of attributes.
				// (Do this after the doctypeDecl
				// event!).
    // expandAttributeDefaultValues();
  }
  /**
    * Parse a markup declaration in the internal or external DTD subset.
    * <pre>
    * [29] markupdecl ::= ( %elementdecl | %AttlistDecl | %EntityDecl |
    *                       %NotationDecl | %PI | %S | %Comment |
    *                       InternalPERef )
    * [30] InternalPERef ::= PEReference
    * [31] extSubset ::= (%markupdecl | %conditionalSect)*
    * </pre>
    */
  void parseMarkupdecl ()
    throws java.lang.Exception
  {
    if (tryRead(""<!ELEMENT"")) {
      parseElementdecl();
    } else if (tryRead(""<!ATTLIST"")) {
      parseAttlistDecl();
    } else if (tryRead(""<!ENTITY"")) {
      parseEntityDecl();
    } else if (tryRead(""<!NOTATION"")) {
      parseNotationDecl();
    } else if (tryRead(""<?"")) {
      parsePI();
    } else if (tryRead(""<!--"")) {
      parseComment();
    } else if (tryRead(""<!["")) {
      parseConditionalSect();
    } else {
      error(""expected markup declaration"", null, null);
    }
  }
  /**
    * Parse an element, with its tags.
    * <pre>
    * [33] STag ::= '&lt;' Name (S Attribute)* S? '&gt;' [WFC: unique Att spec]
    * [38] element ::= EmptyElement | STag content ETag
    * [39] EmptyElement ::= '&lt;' Name (S Attribute)* S? '/&gt;'
    *                       [WFC: unique Att spec]
    * </pre>
    * <p>(The '&lt;' has already been read.)
    * <p>NOTE: this method actually chains onto parseContent(), if necessary,
    * and parseContent() will take care of calling parseETag().
    */
  void parseElement ()
    throws java.lang.Exception
  {
    String gi;
    char c;
    int oldElementContent = currentElementContent;
    String oldElement = currentElement;
				// This is the (global) counter for the
				// array of specified attributes.
    tagAttributePos = 0;
				// Read the element type name.
    gi = readNmtoken(true);
				// Determine the current content type.
    currentElement = gi;
    currentElementContent = getElementContentType(gi);
    if (currentElementContent == CONTENT_UNDECLARED) {
      currentElementContent = CONTENT_ANY;
    }
				// Read the attributes, if any.
				// After this loop, we should be just
				// in front of the closing delimiter.
    skipWhitespace();
    c = readCh();
    while (c != '/' && c != '>') {
      unread(c);
      parseAttribute(gi);
      skipWhitespace();
      c = readCh();
    }
    unread(c);
				// Supply any defaulted attributes.
    Enumeration atts = declaredAttributes(gi);
    if (atts != null) {
      String aname;
    loop: while (atts.hasMoreElements()) {
      aname = (String)atts.nextElement();
				// See if it was specified.
      for (int i = 0; i < tagAttributePos; i++) {
	if (tagAttributes[i] == aname) {
	  continue loop;
	}
      }
				// I guess not...
      if (handler != null) {
	handler.attribute(aname,
			  getAttributeExpandedValue(gi, aname),
			  false);
      }
    }
    }
				// Figure out if this is a start tag
				// or an empty element, and dispatch an
				// event accordingly.
    c = readCh();
    switch (c) {
    case '>':
      if (handler != null) {
	handler.startElement(gi);
      }
      parseContent();
      break;
    case '/':
      require('>');
      if (handler != null) {
	handler.startElement(gi);
	handler.endElement(gi);
      }
      break;
    }
				// Restore the previous state.
    currentElement = oldElement;
    currentElementContent = oldElementContent;
  }
  /**
    * Parse an attribute assignment.
    * <pre>
    * [34] Attribute ::= Name Eq AttValue
    * </pre>
    * @param name The name of the attribute's element.
    * @see XmlHandler#attribute
    */
  void parseAttribute (String name)
    throws java.lang.Exception
  {
    String aname;
    int type;
    String value;
				// Read the attribute name.
    aname = readNmtoken(true).intern();
    type = getAttributeDefaultValueType(name, aname);
				// Parse '='
    parseEq();
				// Read the value, normalizing whitespace
				// if it is not CDATA.
    if (type == ATTRIBUTE_CDATA || type == ATTRIBUTE_UNDECLARED) {
      value = readLiteral(LIT_CHAR_REF | LIT_ENTITY_REF);
    } else {
      value = readLiteral(LIT_CHAR_REF | LIT_ENTITY_REF | LIT_NORMALIZE);
    }
				// Inform the handler about the
				// attribute.
    if (handler != null) {
      handler.attribute(aname, value, true);
    }
    dataBufferPos = 0;
				// Note that the attribute has been
				// specified.
    if (tagAttributePos == tagAttributes.length) {
      String newAttrib[] = new String[tagAttributes.length * 2];
      System.arraycopy(tagAttributes, 0, newAttrib, 0, tagAttributePos);
      tagAttributes = newAttrib;
    }
    tagAttributes[tagAttributePos++] = aname;
  }
  /**
    * Parse an equals sign surrounded by optional whitespace.
    * [35] Eq ::= S? '=' S?
    */
  void parseEq ()
    throws java.lang.Exception
  {
    skipWhitespace();
    require('=');
    skipWhitespace();
  }
  /**
    * Parse an end tag.
    * [36] ETag ::= '</' Name S? '>'
    * *NOTE: parseContent() chains to here.
    */
  void parseETag ()
    throws java.lang.Exception
  {
    String name;
    name = readNmtoken(true);
    if (name != currentElement) {
      error(""mismatched end tag"", name, currentElement);
    }
    skipWhitespace();
    require('>');
    if (handler != null) {
      handler.endElement(name);
    }
  }
  /**
    * Parse the content of an element.
    * [37] content ::= (element | PCData | Reference | CDSect | PI | Comment)*
    * [68] Reference ::= EntityRef | CharRef
    */
  void parseContent ()
    throws java.lang.Exception
  {
    String data;
    char c;
    while (true) {
      switch (currentElementContent) {
      case CONTENT_ANY:
      case CONTENT_MIXED:
	parsePCData();
	break;
      case CONTENT_ELEMENTS:
	parseWhitespace();
	break;
      }
				// Handle delimiters
      c = readCh();
      switch (c) {
      case '&':			// Found ""&""
	c = readCh();
	if (c == '#') {
	  parseCharRef();
	} else {
	  unread(c);
	  parseEntityRef(true);
	}
	break;
      case '<':			// Found ""<""
	c = readCh();
	switch (c) {
	case '!':		// Found ""<!""
	  c = readCh();
	  switch (c) {
	  case '-':		// Found ""<!-""
	    require('-');
	    parseComment();
	    break;
	  case '[':		// Found ""<![""
	    require(""CDATA["");
	    parseCDSect();
	    break;
	  default:
	    error(""expected comment or CDATA section"", c, null);
	    break;
	  }
	  break;
	case '?':		// Found ""<?""
	  dataBufferFlush();
	  parsePI();
	  break;
	case '/':		// Found ""</""
	  dataBufferFlush();
	  parseETag();
	  return;
	default:		// Found ""<"" followed by something else
	  dataBufferFlush();
	  unread(c);
	  parseElement();
	  break;
	}
      }
    }
  }
  /**
    * Parse an element type declaration.
    * [40] elementdecl ::= '<!ELEMENT' S %Name S (%S S)? %contentspec S? '>'
    *                      [VC: Unique Element Declaration]
    * *NOTE: the '<!ELEMENT' has already been read.
    */
  void parseElementdecl ()
    throws java.lang.Exception
  {
    String name;
    requireWhitespace();
				// Read the element type name.
    name = readNmtoken(true);
    requireWhitespace();
				// Read the content model.
    parseContentspec(name);
    skipWhitespace();
    require('>');
  }
  /**
    * Content specification.
    * [41] contentspec ::= 'EMPTY' | 'ANY' | Mixed | elements
    */
  void parseContentspec (String name)
    throws java.lang.Exception
  {
    if (tryRead(""EMPTY"")) {
      setElement(name, CONTENT_EMPTY, null, null);
      return;
    } else if (tryRead(""ANY"")) {
      setElement(name, CONTENT_ANY, null, null);
      return;
    } else {
      require('(');
      dataBufferAppend('(');
      skipWhitespace();
      if (tryRead(""#PCDATA"")) {
	dataBufferAppend(""#PCDATA"");
	parseMixed();
	setElement(name, CONTENT_MIXED, dataBufferToString(), null);
      } else {
	parseElements();
	setElement(name, CONTENT_ELEMENTS, dataBufferToString(), null);
      }
    }
  }
  /**
    * Parse an element-content model.
    * [42] elements ::= (choice | seq) ('?' | '*' | '+')?
    * [44] cps ::= S? %cp S?
    * [45] choice ::= '(' S? %ctokplus (S? '|' S? %ctoks)* S? ')'
    * [46] ctokplus ::= cps ('|' cps)+
    * [47] ctoks ::= cps ('|' cps)*
    * [48] seq ::= '(' S? %stoks (S? ',' S? %stoks)* S? ')'
    * [49] stoks ::= cps (',' cps)*
    * *NOTE: the opening '(' and S have already been read.
    * *TODO: go over parameter entity boundaries more carefully.
    */
  void parseElements ()
    throws java.lang.Exception
  {
    char c;
    char sep;
				// Parse the first content particle
    skipWhitespace();
    parseCp();
				// Check for end or for a separator.
    skipWhitespace();
    c = readCh();
    switch (c) {
    case ')':
      dataBufferAppend(')');
      c = readCh();
      switch (c) {
      case '*':
      case '+':
      case '?':
	dataBufferAppend(c);
	break;
      default:
	unread(c);
      }
      return;
    case ',':			// Register the separator.
    case '|':
      sep = c;
      dataBufferAppend(c);
      break;
    default:
      error(""bad separator in content model"", c, null);
      return;
    }
				// Parse the rest of the content model.
    while (true) {
      skipWhitespace();
      parseCp();
      skipWhitespace();
      c = readCh();
      if (c == ')') {
	dataBufferAppend(')');
	break;
      } else if (c != sep) {
	error(""bad separator in content model"", c, null);
	return;
      } else {
	dataBufferAppend(c);
      }
    }
				// Check for the occurrence indicator.
    c = readCh();
    switch (c) {
    case '?':
    case '*':
    case '+':
      dataBufferAppend(c);
      return;
    default:
      unread(c);
      return;
    }
  }
  /**
    * Parse a content particle.
    * [43] cp ::= (Name | choice | seq) ('?' | '*' | '+')
    * *NOTE: I actually use a slightly different production here:
    *        cp ::= (elements | (Name ('?' | '*' | '+')?))
    */
  void parseCp ()
    throws java.lang.Exception
  {
    char c;
    if (tryRead('(')) {
      dataBufferAppend('(');
      parseElements();
    } else {
      dataBufferAppend(readNmtoken(true));
      c = readCh();
      switch (c) {
      case '?':
      case '*':
      case '+':
	dataBufferAppend(c);
	break;
      default:
	unread(c);
	break;
      }
    }
  }
  /**
    * Parse mixed content.
    * [50] Mixed ::= '(' S? %( %'#PCDATA' (S? '|' S? %Mtoks)* ) S? ')*'
    *              | '(' S? %('#PCDATA') S? ')'
    * [51] Mtoks ::= %Name (S? '|' S? %Name)*
    * *NOTE: the S and '#PCDATA' have already been read.
    */
  void parseMixed ()
    throws java.lang.Exception
  {
    char c;
				// Check for PCDATA alone.
    skipWhitespace();
    if (tryRead(')')) {
      dataBufferAppend("")*"");
      tryRead('*');
      return;
    }
				// Parse mixed content.
    skipWhitespace();
    while (!tryRead("")*"")) {
      require('|');
      dataBufferAppend('|');
      skipWhitespace();
      dataBufferAppend(readNmtoken(true));
      skipWhitespace();
    }
    dataBufferAppend("")*"");
  }
  /**
    * Parse an attribute list declaration.
    * [52] AttlistDecl ::= '<!ATTLIST' S %Name S? %AttDef+ S? '>'
    * *NOTE: the '<!ATTLIST' has already been read.
    */
  void parseAttlistDecl ()
    throws java.lang.Exception
  {
    String elementName;
    requireWhitespace();
    elementName = readNmtoken(true);
    requireWhitespace();
    while (!tryRead('>')) {
      parseAttDef(elementName);
      skipWhitespace();
    }
  }
  /**
    * Parse a single attribute definition.
    * [53] AttDef ::= S %Name S %AttType S %Default
    */
  void parseAttDef (String elementName)
    throws java.lang.Exception
  {
    String name;
    int type;
    String enumeration = null;
				// Read the attribute name.
    name = readNmtoken(true);
				// Read the attribute type.
    requireWhitespace();
    type = readAttType();
				// Get the string of enumerated values
				// if necessary.
    if (type == ATTRIBUTE_ENUMERATED || type == ATTRIBUTE_NOTATION) {
      enumeration = dataBufferToString();
    }
				// Read the default value.
    requireWhitespace();
    parseDefault(elementName, name, type, enumeration);
  }
  /**
    * Parse the attribute type.
    * [54] AttType ::= StringType | TokenizedType | EnumeratedType
    * [55] StringType ::= 'CDATA'
    * [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' |
    *                        'NMTOKEN' | 'NMTOKENS'
    * [57] EnumeratedType ::= NotationType | Enumeration
    * *TODO: validate the type!!
    */
  int readAttType ()
    throws java.lang.Exception
  {
    String typeString;
    Integer type;
    if (tryRead('(')) {
      parseEnumeration();
      return ATTRIBUTE_ENUMERATED;
    } else {
      typeString = readNmtoken(true);
      if (typeString.equals(""NOTATION"")) {
	parseNotationType();
      }
      type = (Integer)attributeTypeHash.get(typeString);
      if (type == null) {
	error(""illegal attribute type"", typeString, null);
	return ATTRIBUTE_UNDECLARED;
      } else {
	return type.intValue();
      }
    }
  }
  /**
    * Parse an enumeration.
    * [60] Enumeration ::= '(' S? %Etoks (S? '|' S? %Etoks)* S? ')'
    * [61] Etoks ::= %Nmtoken (S? '|' S? %Nmtoken)*
    * *NOTE: the '(' has already been read.
    */
  void parseEnumeration ()
    throws java.lang.Exception
  {
    char c;
    dataBufferAppend('(');
				// Read the first token.
    skipWhitespace();
    dataBufferAppend(readNmtoken(true));
				// Read the remaining tokens.
    skipWhitespace();
    while (!tryRead(')')) {
      require('|');
      dataBufferAppend('|');
      skipWhitespace();
      dataBufferAppend(readNmtoken(true));
      skipWhitespace();
    }
    dataBufferAppend(')');
  }
  /**
    * Parse a notation type for an attribute.
    * [58] NotationType ::= %'NOTATION' S '(' S? %Ntoks (S? '|' S? %Ntoks)*
    *                       S? ')'
    * [59] Ntoks ::= %Name (S? '|' S? %Name)
    * *NOTE: the 'NOTATION' has already been read
    */
  void parseNotationType ()
    throws java.lang.Exception
  {
    requireWhitespace();
    require('(');
    parseEnumeration();
  }
  /**
    * Parse the default value for an attribute.
    * [62] Default ::= '#REQUIRED' | '#IMPLIED' | ((%'#FIXED' S)? %AttValue
    */
  void parseDefault (String elementName, String name, int type, String enumeration)
    throws java.lang.Exception
  {
    int valueType = ATTRIBUTE_DEFAULT_SPECIFIED;
    String value = null;
    boolean normalizeWSFlag;
    if (tryRead('#')) {
      if (tryRead(""FIXED"")) {
	valueType = ATTRIBUTE_DEFAULT_FIXED;
	requireWhitespace();
	context = CONTEXT_ATTRIBUTEVALUE;
	value = readLiteral(LIT_CHAR_REF);
	context = CONTEXT_DTD;
      } else if (tryRead(""REQUIRED"")) {
	valueType = ATTRIBUTE_DEFAULT_REQUIRED;
      } else if (tryRead(""IMPLIED"")) {
	valueType = ATTRIBUTE_DEFAULT_IMPLIED;
      } else {
	error(""illegal keyword for attribute default value"", null, null);
      }
    } else {
      context = CONTEXT_ATTRIBUTEVALUE;
      value = readLiteral(LIT_CHAR_REF);
      context = CONTEXT_DTD;
    }
    setAttribute(elementName, name, type, enumeration, value, valueType);
  }
  /**
    * Parse a conditional section.
    * [63] conditionalSect ::= includeSect || ignoreSect
    * [64] includeSect ::= '<![' %'INCLUDE' '[' (%markupdecl*)* ']]>'
    * [65] ignoreSect ::= '<![' %'IGNORE' '[' ignoreSectContents* ']]>'
    * [66] ignoreSectContents ::= ((SkipLit | Comment | PI) -(Char* ']]>'))
    *                           | ('<![' ignoreSectContents* ']]>')
    *                           | (Char - (']' | [<'""]))
    *                           | ('<!' (Char - ('-' | '[')))
    * *NOTE: the '<![' has already been read.
    * *TODO: verify that I am handling ignoreSectContents right.
    */
  void parseConditionalSect ()
    throws java.lang.Exception
  {
    skipWhitespace();
    if (tryRead(""INCLUDE"")) {
      skipWhitespace();
      require('[');
      skipWhitespace();
      while (!tryRead(""]]>"")) {
	parseMarkupdecl();
	skipWhitespace();
      }
    } else if (tryRead(""IGNORE"")) {
      skipWhitespace();
      require('[');
      int nesting = 1;
      char c;
      for (int nest = 1; nest > 0; ) {
	c = readCh();
	switch (c) {
	case '<':
	  if (tryRead(""!["")) {
	    nest++;
	  }
	case ']':
	  if (tryRead(""]>"")) {
	    nest--;
	  }
	}
      }
    } else {
      error(""conditional section must begin with INCLUDE or IGNORE"",
	    null, null);
    }
  }
  /**
    * Read a character reference.
    * [67] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
    * *NOTE: the '&#' has already been read.
    */
  void parseCharRef ()
    throws java.lang.Exception
  {
    int value = 0;
    char c;
    if (tryRead('x')) {
      loop1: while (true) {
	c = readCh();
	switch (c) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'a':
	case 'A':
	case 'b':
	case 'B':
	case 'c':
	case 'C':
	case 'd':
	case 'D':
	case 'e':
	case 'E':
	case 'f':
	case 'F':
	  value *= 16;
	  value += Integer.parseInt(new Character(c).toString(), 16);
	  break;
	case ';':
	  break loop1;
	default:
	  error(""illegal character in character reference"", c, null);
	  break loop1;
	}
      }
    } else {
      loop2: while (true) {
	c = readCh();
	switch (c) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  value *= 10;
	  value += Integer.parseInt(new Character(c).toString(), 10);
	  break;
	case ';':
	  break loop2;
	default:
	  error(""illegal character in character reference"", c, null);
	  break loop2;
	}
      }
    }
    // Check for surrogates: 00000000 0000xxxx yyyyyyyy zzzzzzzz
    //  (1101|10xx|xxyy|yyyy + 1101|11yy|zzzz|zzzz: 
    if (value <= 0x0000ffff) {
				// no surrogates needed
      dataBufferAppend((char)value);
    } else if (value <= 0x000fffff) {
				// > 16 bits, surrogate needed
      dataBufferAppend((char)(0xd8 | ((value & 0x000ffc00) >> 10)));
      dataBufferAppend((char)(0xdc | (value & 0x0003ff)));
    } else {
				// too big for surrogate
      error(""character reference "" + value + "" is too large for UTF-16"",
	    new Integer(value).toString(), null);
    }
  }
  /**
    * Parse a reference.
    * [69] EntityRef ::= '&' Name ';'
    * *NOTE: the '&' has already been read.
    * @param externalAllowed External entities are allowed here.
    */
  void parseEntityRef (boolean externalAllowed)
    throws java.lang.Exception
  {
    String name;
    name = readNmtoken(true);
    require(';');
    switch (getEntityType(name)) {
    case ENTITY_UNDECLARED:
      error(""reference to undeclared entity"", name, null);
      break;
    case ENTITY_INTERNAL:
      pushString(name, getEntityValue(name));
      break;
    case ENTITY_TEXT:
      if (externalAllowed) {
	pushURL(name, getEntityPublicId(name),
		getEntitySystemId(name),
		null, null, null);
      } else {
	error(""reference to external entity in attribute value."", name, null);
      }
      break;
    case ENTITY_NDATA:
      if (externalAllowed) {
	error(""data entity reference in content"", name, null);
      } else {
	error(""reference to external entity in attribute value."", name, null);
      }
      break;
    }
  }
  /**
    * Parse a parameter entity reference.
    * [70] PEReference ::= '%' Name ';'
    * *NOTE: the '%' has already been read.
    */
  void parsePEReference (boolean isEntityValue)
    throws java.lang.Exception
  {
    String name;
    name = ""%"" + readNmtoken(true);
    require(';');
    switch (getEntityType(name)) {
    case ENTITY_UNDECLARED:
      error(""reference to undeclared parameter entity"", name, null);
      break;
    case ENTITY_INTERNAL:
      if (isEntityValue) {
	pushString(name, getEntityValue(name));
      } else {
	pushString(name, "" "" + getEntityValue(name) + ' ');
      }
      break;
    case ENTITY_TEXT:
      if (isEntityValue) {
	pushString(null, "" "");
      }
      pushURL(name, getEntityPublicId(name),
	      getEntitySystemId(name),
	      null, null, null);
      if (isEntityValue) {
	pushString(null, "" "");
      }
      break;
    }
  }
  /**
    * Parse an entity declaration.
    * [71] EntityDecl ::= '<!ENTITY' S %Name S %EntityDef S? '>'
    *                   | '<!ENTITY' S '%' S %Name S %EntityDef S? '>'
    * [72] EntityDef ::= EntityValue | ExternalDef
    * [73] ExternalDef ::= ExternalID %NDataDecl?
    * [74] ExternalID ::= 'SYSTEM' S SystemLiteral
    *                   | 'PUBLIC' S PubidLiteral S SystemLiteral
    * [75] NDataDecl ::= S %'NDATA' S %Name
    * *NOTE: the '<!ENTITY' has already been read.
    */
  void parseEntityDecl ()
    throws java.lang.Exception
  {
    char c;
    boolean peFlag = false;
    String name, value, notationName, ids[];
				// Check for a parameter entity.
    requireWhitespace();
    if (tryRead('%')) {
      peFlag = true;
      requireWhitespace();
    }
				// Read the entity name, and prepend
				// '%' if necessary.
    name = readNmtoken(true);
    if (peFlag) {
      name = ""%"" + name;
    }
				// Read the entity value.
    requireWhitespace();
    c = readCh();
    unread(c);
    if (c == '""' || c == '\'') {
				// Internal entity.
      context = CONTEXT_ENTITYVALUE;
      value = readLiteral(LIT_CHAR_REF|LIT_PE_REF);
      context = CONTEXT_DTD;
      setInternalEntity(name,value);
    } else {
				// Read the external IDs
      ids = readExternalIds(false);
      if (ids[1] == null) {
	error(""system identifer missing"", name, null);
      }
				// Check for NDATA declaration.
      skipWhitespace();
      if (tryRead(""NDATA"")) {
	requireWhitespace();
	notationName = readNmtoken(true);
	setExternalDataEntity(name, ids[0], ids[1], notationName);
      } else {
	setExternalTextEntity(name, ids[0], ids[1]);
      }
    }
				// Finish the declaration.
    skipWhitespace();
    require('>');
  }
  /**
    * Parse a notation declaration.
    * [81] NotationDecl ::= '<!NOTATION' S %Name S %ExternalID S? '>'
    * *NOTE: the '<!NOTATION' has already been read.
    */
  void parseNotationDecl ()
    throws java.lang.Exception
  {
    String nname, ids[];
    requireWhitespace();
    nname = readNmtoken(true);
    requireWhitespace();
				// Read the external identifiers.
    ids = readExternalIds(true);
    if (ids[0] == null && ids[1] == null) {
      error(""external identifer missing"", nname, null);
    }
				// Register the notation.
    setNotation(nname, ids[0], ids[1]);
    skipWhitespace();
    require('>');
  }
  /**
    * Parse PCDATA.
    * <pre>
    * [16] PCData ::= [^&lt;&amp;]*
    * </pre>
    * <p>The trick here is that the data stays in the dataBuffer without
    * necessarily being converted to a string right away.
    */
  void parsePCData ()
    throws java.lang.Exception
  {
    char c;
				// Start with a little cheat -- in most
				// cases, the entire sequence of
				// character data will already be in
				// the readBuffer; if not, fall through to
				// the normal approach.
    if (USE_CHEATS) {
      int lineAugment = 0;
      int columnAugment = 0;
      loop: for (int i = readBufferPos; i < readBufferLength; i++) {
	switch (readBuffer[i]) {
	case '\n':
	  lineAugment++;
	  columnAugment = 0;
	  break;
	case '&':
	case '<':
	  int start = readBufferPos;
	  columnAugment++;
	  readBufferPos = i;
	  if (lineAugment > 0) {
	    line += lineAugment;
	    column = columnAugment;
	  } else {
	    column += columnAugment;
	  }
	  dataBufferAppend(readBuffer, start, i-start);
	  return;
	default:
	  columnAugment++;
	}
      }
    }
				// OK, the cheat didn't work; start over
				// and do it by the book.
    while (true) {
      c = readCh();
      switch (c) {
      case '<':
      case '&':
	unread(c);
	return;
      default:
	dataBufferAppend(c);
	break;
      }
    }
  }
  //////////////////////////////////////////////////////////////////////
  // High-level reading and scanning methods.
  //////////////////////////////////////////////////////////////////////
  /**
    * Require whitespace characters.
    * [1] S ::= (#x20 | #x9 | #xd | #xa)+
    */
  void requireWhitespace ()
    throws java.lang.Exception
  {
    char c = readCh();
    if (isWhitespace(c)) {
      skipWhitespace();
    } else {
      error(""whitespace expected"", c, null);
    }
  }
  /**
    * Parse whitespace characters, and leave them in the data buffer.
    */
  void parseWhitespace ()
    throws java.lang.Exception
  {
    char c = readCh();
    while (isWhitespace(c)) {
      dataBufferAppend(c);
      c = readCh();
    }
    unread(c);
  }
  /**
    * Skip whitespace characters.
    * [1] S ::= (#x20 | #x9 | #xd | #xa)+
    */
  void skipWhitespace ()
    throws java.lang.Exception
  {
				// Start with a little cheat.  Most of
				// the time, the white space will fall
				// within the current read buffer; if
				// not, then fall through.
    if (USE_CHEATS) {
      int lineAugment = 0;
      int columnAugment = 0;
      loop: for (int i = readBufferPos; i < readBufferLength; i++) {
	switch (readBuffer[i]) {
	case ' ':
	case '\t':
	case '\r':
	  columnAugment++;
	  break;
	case '\n':
	  lineAugment++;
	  columnAugment = 0;
	  break;
	case '%':
	  if (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) {
	    break loop;
	  } // else fall through...
	default:
	  readBufferPos = i;
	  if (lineAugment > 0) {
	    line += lineAugment;
	    column = columnAugment;
	  } else {
	    column += columnAugment;
	  }
	  return;
	}
      }
    }
				// OK, do it by the book.
    char c = readCh();
    while (isWhitespace(c)) {
      c = readCh();
    }
    unread(c);
  }
  /**
    * Read a name or name token.
    * [5] Name ::= (Letter | '_' | ':') (NameChar)*
    * [7] Nmtoken ::= (NameChar)+
    * *NOTE: [6] is implemented implicitly where required.
    */
  String readNmtoken (boolean isName)
    throws java.lang.Exception
  {
    char c;
    if (USE_CHEATS) {
      loop: for (int i = readBufferPos; i < readBufferLength; i++) {
	switch (readBuffer[i]) {
	case '%':
	  if (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) {
	    break loop;
	  } // else fall through...
	case '<':
	case '>':
	case '&':
	case ',':
	case '|':
	case '*':
	case '+':
	case '?':
	case ')':
	case '=':
	case '\'':
	case '""':
	case '[':
	case ' ':
	case '\t':
	case '\r':
	case '\n':
	case ';':
	case '/':
	case '#':
	  int start = readBufferPos;
	  if (i == start) {
	    error(""name expected"", readBuffer[i], null);
	  }
	  readBufferPos = i;
	  return intern(readBuffer, start, i - start);
	}
      }
    }
    nameBufferPos = 0;
				// Read the first character.
    loop: while (true) {
      c = readCh();
      switch (c) {
      case '%':
      case '<':
      case '>':
      case '&':
      case ',':
      case '|':
      case '*':
      case '+':
      case '?':
      case ')':
      case '=':
      case '\'':
      case '""':
      case '[':
      case ' ':
      case '\t':
      case '\n':
      case '\r':
      case ';':
      case '/':
	unread(c);
	if (nameBufferPos == 0) {
	  error(""name expected"", null, null);
	}
	String s = intern(nameBuffer,0,nameBufferPos);
	nameBufferPos = 0;
	return s;
      default:
	nameBuffer =
	  (char[])extendArray(nameBuffer, nameBuffer.length, nameBufferPos);
	nameBuffer[nameBufferPos++] = c;
      }
    }
  }
  /**
    * Read a literal.
    * [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    *                 | ""'"" ([^<&'] | Reference)* ""'""
    * [11] SystemLiteral ::= '""' URLchar* '""' | ""'"" (URLchar - ""'"")* ""'""
    * [13] PubidLiteral ::= '""' PubidChar* '""' | ""'"" (PubidChar - ""'"")* ""'""
    * [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    *                   | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    */
  String readLiteral (int flags)
    throws java.lang.Exception
  {
    char delim, c;
    int startLine = line;
				// Find the delimiter.
    delim = readCh();
    if (delim != '""' && delim != '\'' && delim != (char)0) {
      error(""expected '\""' or \""'\"""", delim, null);
      return null;
    }
				// Read the literal.
    try {
      c = readCh();
    loop: while (c != delim) {
      switch (c) {
				// Literals never have line ends
      case '\n':
      case '\r':
	c = ' ';
	break;
				// References may be allowed
      case '&':
	if ((flags & LIT_CHAR_REF) > 0) {
	  c = readCh();
	  if (c == '#') {
	    parseCharRef();
	    c = readCh();
	    continue loop;		// check the next character
	  } else if ((flags & LIT_ENTITY_REF) > 0) {
	    unread(c);
	    parseEntityRef(false);
	    c = readCh();
	    continue loop;
	  } else {
	    dataBufferAppend('&');
	  }
	}
	break;
      default:
	break;
      }
      dataBufferAppend(c);
      c = readCh();
    }
    } catch (EOFException e) {
      error(""end of input while looking for delimiter (started on line ""
	    + startLine + ')', null, new Character(delim).toString());
    }
				// Normalise whitespace if necessary.
    if ((flags & LIT_NORMALIZE) > 0) {
      dataBufferNormalize();
    }
				// Return the value.
    return dataBufferToString();
  }
  /**
    * Try reading external identifiers.
    * <p>The system identifier is not required for notations.
    * @param inNotation Are we in a notation?
    * @return A two-member String array containing the identifiers.
    */
  String[] readExternalIds (boolean inNotation)
    throws java.lang.Exception
  {
    char c;
    String ids[] = new String[2];
    if (tryRead(""PUBLIC"")) {
      requireWhitespace();
      ids[0] = readLiteral(LIT_NORMALIZE); // public id
      if (inNotation) {
	skipWhitespace();
	if (tryRead('""') || tryRead('\'')) {
	  ids[1] = readLiteral(0);
	}
      } else {
	requireWhitespace();
	ids[1] = readLiteral(0); // system id
      }
    } else if (tryRead(""SYSTEM"")) {
      requireWhitespace();
      ids[1] = readLiteral(0);	// system id
    }
    return ids;
  }
  /**
    * Test if a character is whitespace.
    * <pre>
    * [1] S ::= (#x20 | #x9 | #xd | #xa)+
    * </pre>
    * @param c The character to test.
    * @return true if the character is whitespace.
    */
  final boolean isWhitespace (char c)
  {
    switch ((int)c) {
    case 0x20:
    case 0x09:
    case 0x0d:
    case 0x0a:
      return true;
    default:
      return false;
    }
  }
  //////////////////////////////////////////////////////////////////////
  // Utility routines.
  //////////////////////////////////////////////////////////////////////
  /**
    * Add a character to the data buffer.
    */
  void dataBufferAppend (char c)
  {
				// Expand buffer if necessary.
    dataBuffer =
      (char[])extendArray(dataBuffer, dataBuffer.length, dataBufferPos);
    dataBuffer[dataBufferPos++] = c;
  }
  /** 
    * Add a string to the data buffer.
    */
  void dataBufferAppend (String s)
  {
    dataBufferAppend(s.toCharArray(), 0, s.length());
  }
  /**
    * Append (part of) a character array to the data buffer.
    */
  void dataBufferAppend (char ch[], int start, int length)
  {
    dataBuffer =
      (char[])extendArray(dataBuffer, dataBuffer.length,
			  dataBufferPos + length);
    System.arraycopy((Object)ch, start,
		     (Object)dataBuffer, dataBufferPos,
		     length);
    dataBufferPos += length;
  }
  /**
    * Normalise whitespace in the data buffer.
    */
  void dataBufferNormalize ()
  {
    int i = 0;
    int j = 0;
    int end = dataBufferPos;
				// Skip whitespace at the start.
    while (j < end && isWhitespace(dataBuffer[j])) {
      j++;
    }
				// Skip whitespace at the end.
    while (end > j && isWhitespace(dataBuffer[end - 1])) {
      end --;
    }
				// Start copying to the left.
    while (j < end) {
      char c = dataBuffer[j++];
				// Normalise all other whitespace to
				// a single space.
      if (isWhitespace(c)) {
	while (j < end && isWhitespace(dataBuffer[j++])) {
	}
	dataBuffer[i++] = ' ';
	dataBuffer[i++] = dataBuffer[j-1];
      } else {
	dataBuffer[i++] = c;
      }
    }
				// The new length is <= the old one.
    dataBufferPos = i;
  }
  /**
    * Convert the data buffer to a string.
    * @param internFlag true if the contents should be interned.
    * @see #intern(char[],int,int)
    */
  String dataBufferToString ()
  {
    String s = new String(dataBuffer, 0, dataBufferPos);
    dataBufferPos = 0;
    return s;
  }
  /**
    * Flush the contents of the data buffer to the handler, if
    * appropriate, and reset the buffer for new input.
    */
  void dataBufferFlush ()
    throws java.lang.Exception
  {
    if (dataBufferPos > 0) {
      switch (currentElementContent) {
      case CONTENT_UNDECLARED:
      case CONTENT_EMPTY:
	// do nothing
	break;
      case CONTENT_MIXED:
      case CONTENT_ANY:
	if (handler != null) {
	  handler.charData(dataBuffer, 0, dataBufferPos);
	}
	break;
      case CONTENT_ELEMENTS:
	if (handler != null) {
	  handler.ignorableWhitespace(dataBuffer, 0, dataBufferPos);
	}
	break;
      }
      dataBufferPos = 0;
    }
  }
  /**
    * Require a string to appear, or throw an exception.
    */
  void require (String delim)
    throws java.lang.Exception
  {
    char ch[] = delim.toCharArray();
    for (int i = 0; i < ch.length; i++) {
      require(ch[i]);
    }
  }
  /**
    * Require a character to appear, or throw an exception.
    */
  void require (char delim)
       throws java.lang.Exception
  {
    char c = readCh();
    if (c != delim) {
      error(""expected character"", c, new Character(delim).toString());
    }
  }
  /**
    * Return an internalised version of a string.
    * <p>&AElig;lfred uses this method to create an internalised version
    * of all names and attribute values, so that it can test equality
    * with <code>==</code> instead of <code>String.equals()</code>.
    * <p>If you want to be able to test for equality in the same way,
    * you can use this method to internalise your own strings first:
    * <pre>
    * String PARA = handler.intern(""PARA"");
    * </pre>
    * <p>Note that this will not return the same results as String.intern().
    * @param s The string to internalise.
    * @return An internalised version of the string.
    * @see #intern(char[],int,int)
    * @see java.lang.String#intern
    */
  public String intern (String s)
  {
    char ch[] = s.toCharArray();
    return intern(ch, 0, ch.length);
  }
  /**
    * Create an internalised string from a character array.
    * <p>This is much more efficient than constructing a non-internalised
    * string first, and then internalising it.
    * <p>Note that this will not return the same results as String.intern().
    * @param ch an array of characters for building the string.
    * @param start the starting position in the array.
    * @param length the number of characters to place in the string.
    * @return an internalised string.
    * @see #intern(String)
    * @see java.lang.String#intern
    */
  public String intern (char ch[], int start, int length)
  {
    int index;
    int hash = 0;
				// Generate a hash code.
    for (int i = start; i < start + length; i++) {
      hash = ((hash << 1) & 0xffffff) + (int)ch[i];
    }
    hash = hash % SYMBOL_TABLE_LENGTH;
				// Get the bucket.
    Object bucket[] = (Object[])symbolTable[hash];
    if (bucket == null) {
      symbolTable[hash] = bucket = new Object[8];
    }
				// Search for a matching tuple, and
				// return the string if we find one.
    for (index = 0; index < bucket.length; index += 2) {
      char chFound[] = (char[])bucket[index];
				// Stop when we hit a null index.
      if (chFound == null) {
	break;
      }
				// If they're the same length,
				// check for a match.
				// If the loop finishes, 'index' will
				// contain the current bucket
				// position.
      if (chFound.length == length) {
	for (int i = 0; i < chFound.length; i++) {
				// Stop if there are no more tuples.
	  if (ch[start+i] != chFound[i]) {
	    break;
	  } else if (i == length-1) {
				// That's it, we have a match!
	    return (String)bucket[index+1];
	  }
	}
      }
    }
				// Not found -- we'll have to add it.
				// Do we have to grow the bucket?
    bucket =
      (Object[])extendArray(bucket, bucket.length, index);
				// OK, add it to the end of the
				// bucket.
    String s = new String(ch, start, length);
    bucket[index] = s.toCharArray();
    bucket[index+1] = s;
    symbolTable[hash] = bucket;
    return s;
  }
  /**
    * Ensure the capacity of an array, allocating a new one if
    * necessary.
    */
  Object extendArray (Object array, int currentSize, int requiredSize)
  {
    if (requiredSize < currentSize) {
      return array;
    } else {
      Object newArray = null;
      int newSize = currentSize * 2;
      if (newSize <= requiredSize) {
	newSize = requiredSize + 1;
      }
      if (array instanceof char[]) {
	newArray = new char[newSize];
      } else if (array instanceof Object[]) {
	newArray = new Object[newSize];
      }
      System.arraycopy(array, 0, newArray, 0, currentSize);
      return newArray;
    }
  }
  //////////////////////////////////////////////////////////////////////
  // XML query routines.
  //////////////////////////////////////////////////////////////////////
  //
  // Elements
  //
  /**
    * Get the declared elements for an XML document.
    * <p>The results will be valid only after the DTD (if any) has been
    * parsed.
    * @return An enumeration of all element types declared for this
    *         document (as Strings).
    * @see #getElementContentType
    * @see #getElementContentModel
    */
  public Enumeration declaredElements ()
  {
    return elementInfo.keys();
  }
  /**
    * Look up the content type of an element.
    * @param name The element type name.
    * @return An integer constant representing the content type.
    * @see #getElementContentModel
    * @see #CONTENT_UNDECLARED
    * @see #CONTENT_ANY
    * @see #CONTENT_EMPTY
    * @see #CONTENT_MIXED
    * @see #CONTENT_ELEMENTS
    */
  public int getElementContentType (String name)
  {
    Object element[] = (Object[])elementInfo.get(name);
    if (element == null) {
      return CONTENT_UNDECLARED;
    } else {
      return ((Integer)element[0]).intValue();
    }
  }
  /**
    * Look up the content model of an element.
    * <p>The result will always be null unless the content type is
    * CONTENT_ELEMENTS or CONTENT_MIXED.
    * @param name The element type name.
    * @return The normalised content model, as a string.
    * @see #getElementContentType
    */
  public String getElementContentModel (String name)
  {
    Object element[] = (Object[])elementInfo.get(name);
    if (element == null) {
      return null;
    } else {
      return (String)element[1];
    }
  }
  /**
    * Register an element.
    * Array format:
    *  element type
    *  attribute hash table
    */
  void setElement (String name, int contentType,
		   String contentModel, Hashtable attributes)
    throws java.lang.Exception
  {
    Object element[];
				// Try looking up the element
    element = (Object[])elementInfo.get(name);
				// Make a new one if necessary.
    if (element == null) {
      element = new Object[3];
      element[0] = new Integer(CONTENT_UNDECLARED);
      element[1] = null;
      element[2] = null;
    } else if (contentType != CONTENT_UNDECLARED &&
	       ((Integer)element[0]).intValue() != CONTENT_UNDECLARED) {
      error(""multiple declarations for element type"", name, null);
      return;
    }
				// Insert the content type, if any.
    if (contentType != CONTENT_UNDECLARED) {
      element[0] = new Integer(contentType);
    }
				// Insert the content model, if any.
    if (contentModel != null) {
      element[1] = contentModel;
    }
				// Insert the attributes, if any.
    if (attributes != null) {
      element[2] =attributes;
    }
				// Save the element info.
    elementInfo.put(name,element);
  }
  /**
    * Look up the attribute hash table for an element.
    * The hash table is the second item in the element array.
    */
  Hashtable getElementAttributes (String name)
  {
    Object element[] = (Object[])elementInfo.get(name);
    if (element == null) {
      return null;
    } else {
      return (Hashtable)element[2];
    }
  }
  //
  // Attributes
  //
  /**
    * Get the declared attributes for an element type.
    * @param elname The name of the element type.
    * @return An Enumeration of all the attributes declared for
    *         a specific element type.  The results will be valid only
    *         after the DTD (if any) has been parsed.
    * @see #getAttributeType
    * @see #getAttributeEnumeration
    * @see #getAttributeDefaultValueType
    * @see #getAttributeDefaultValue
    * @see #getAttributeExpandedValue
    */
  public Enumeration declaredAttributes (String elname)
  {
    Hashtable attlist = getElementAttributes(elname);
    if (attlist == null) {
      return null;
    } else {
      return attlist.keys();
    }
  }
  /**
    * Retrieve the declared type of an attribute.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return An integer constant representing the attribute type.
    * @see #ATTRIBUTE_UNDECLARED
    * @see #ATTRIBUTE_CDATA
    * @see #ATTRIBUTE_ID
    * @see #ATTRIBUTE_IDREF
    * @see #ATTRIBUTE_IDREFS
    * @see #ATTRIBUTE_ENTITY
    * @see #ATTRIBUTE_ENTITIES
    * @see #ATTRIBUTE_NMTOKEN
    * @see #ATTRIBUTE_NMTOKENS
    * @see #ATTRIBUTE_ENUMERATED
    * @see #ATTRIBUTE_NOTATION
    */
  public int getAttributeType (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return ATTRIBUTE_UNDECLARED;
    } else {
      return ((Integer)attribute[0]).intValue();
    }
  }
  /**
    * Retrieve the allowed values for an enumerated attribute type.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return A string containing the token list.
    * @see #ATTRIBUTE_ENUMERATED
    * @see #ATTRIBUTE_NOTATION
    */
  public String getAttributeEnumeration (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return null;
    } else {
      return (String)attribute[3];
    }
  }
  /**
    * Retrieve the default value of a declared attribute.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return The default value, or null if the attribute was
    *         #IMPLIED or simply undeclared and unspecified.
    * @see #getAttributeExpandedValue
    */
  public String getAttributeDefaultValue (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return null;
    } else {
      return (String)attribute[1];
    }
  }
  /**
    * Retrieve the expanded value of a declared attribute.
    * <p>All general entities will be expanded.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return The expanded default value, or null if the attribute was
    *         #IMPLIED or simply undeclared
    * @see #getAttributeDefaultValue
    */
  public String getAttributeExpandedValue (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return null;
    } else if (attribute[4] == null && attribute[1] != null) {
      try {
	pushString(null, (char)0 + (String)attribute[1] + (char)0);
	attribute[4] = readLiteral(LIT_NORMALIZE |
				   LIT_CHAR_REF |
				   LIT_ENTITY_REF);
      } catch (Exception e) {}
    }
    return (String)attribute[4];
  }
  /**
    * Retrieve the default value type of a declared attribute.
    * @see #ATTRIBUTE_DEFAULT_SPECIFIED
    * @see #ATTRIBUTE_DEFAULT_IMPLIED
    * @see #ATTRIBUTE_DEFAULT_REQUIRED
    * @see #ATTRIBUTE_DEFAULT_FIXED
    */
  public int getAttributeDefaultValueType (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return ATTRIBUTE_DEFAULT_UNDECLARED;
    } else {
      return ((Integer)attribute[2]).intValue();
    }
  }
  /**
    * Register an attribute declaration for later retrieval.
    * Format:
    * - String type
    * - String default value
    * - int value type
    * *TODO: do something with attribute types.
    */
  void setAttribute (String elName, String name, int type, String enumeration,
		     String value, int valueType)
    throws java.lang.Exception
  {
    Hashtable attlist;
    Object attribute[];
				// Create a new hashtable if necessary.
    attlist = getElementAttributes(elName);
    if (attlist == null) {
      attlist = new Hashtable();
    }
				// Check that the attribute doesn't
				// already exist!
    if (attlist.get(name) != null) {
      return;
    } else {
      attribute = new Object[5];
      attribute[0] = new Integer(type);
      attribute[1] = value;
      attribute[2] = new Integer(valueType);
      attribute[3] = enumeration;
      attribute[4] = null;
      attlist.put(name.intern(), attribute);
				// Use CONTENT_UNDECLARED to avoid overwriting
				// existing element declaration.
      setElement(elName,CONTENT_UNDECLARED, null, attlist);
    }
  }
  /**
    * Retrieve the three-member array representing an
    * attribute declaration.
    */
  Object[] getAttribute (String elName, String name)
  {
    Hashtable attlist;
    Object attribute[];
    attlist = getElementAttributes(elName);
    if (attlist == null) {
      return null;
    }
    attribute = (Object[])attlist.get(name);
    return attribute;
  }
  //
  // Entities
  //
  /**
    * Get declared entities.
    * @return An Enumeration of all the entities declared for
    *         this XML document.  The results will be valid only
    *         after the DTD (if any) has been parsed.
    * @see #getEntityType
    * @see #getEntityPublicId
    * @see #getEntitySystemId
    * @see #getEntityValue
    * @see #getEntityNotationName
    */
  public Enumeration declaredEntities ()
  {
    return entityInfo.keys();
  }
  /**
    * Find the type of an entity.
    * @returns An integer constant representing the entity type.
    * @see #ENTITY_UNDECLARED
    * @see #ENTITY_INTERNAL
    * @see #ENTITY_NDATA
    * @see #ENTITY_TEXT
    */
  public int getEntityType (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return ENTITY_UNDECLARED;
    } else {
      return ((Integer)entity[0]).intValue();
    }
  }
  /**
    * Return an external entity's public identifier, if any.
    * @param ename The name of the external entity.
    * @return The entity's system identifier, or null if the
    *         entity was not declared, if it is not an
    *         external entity, or if no public identifier was
    *         provided.
    * @see #getEntityType
    */
  public String getEntityPublicId (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[1];
    }
  }
  /**
    * Return an external entity's system identifier.
    * @param ename The name of the external entity.
    * @return The entity's system identifier, or null if the
    *         entity was not declared, or if it is not an
    *         external entity.
    * @see #getEntityType
    */
  public String getEntitySystemId (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[2];
    }
  }
  /**
    * Return the value of an internal entity.
    * @param ename The name of the internal entity.
    * @return The entity's value, or null if the entity was
    *         not declared, or if it is not an internal entity.
    * @see #getEntityType
    */
  public String getEntityValue (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[3];
    }
  }
  /**
    * Get the notation name associated with an NDATA entity.
    * @param ename The NDATA entity name.
    * @return The associated notation name, or null if the
    *         entity was not declared, or if it is not an
    *         NDATA entity.
    * @see #getEntityType
    */
  public String getEntityNotationName (String eName)
  {
    Object entity[] = (Object[])entityInfo.get(eName);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[4];
    }
  }
  /**
    * Register an entity declaration for later retrieval.
    */
  void setInternalEntity (String eName, String value)
  {
    setEntity(eName, ENTITY_INTERNAL, null, null, value, null);
  }
  /**
    * Register an external data entity.
    */
  void setExternalDataEntity (String eName, String pubid,
			      String sysid, String nName)
  {
    setEntity(eName, ENTITY_NDATA, pubid, sysid, null, nName);
  }
  /**
    * Register an external text entity.
    */
  void setExternalTextEntity (String eName, String pubid, String sysid)
  {
    setEntity(eName, ENTITY_TEXT, pubid, sysid, null, null);
  }
  /**
    * Register an entity declaration for later retrieval.
    */
  void setEntity (String eName, int eClass,
		  String pubid, String sysid,
		  String value, String nName)
  {
    Object entity[];
    if (entityInfo.get(eName) == null) {
      entity = new Object[5];
      entity[0] = new Integer(eClass);
      entity[1] = pubid;
      entity[2] = sysid;
      entity[3] = value;
      entity[4] = nName;
      entityInfo.put(eName,entity);
    }
  }
  //
  // Notations.
  //
  /**
    * Get declared notations.
    * @return An Enumeration of all the notations declared for
    *         this XML document.  The results will be valid only
    *         after the DTD (if any) has been parsed.
    * @see #getNotationPublicId
    * @see #getNotationSystemId
    */
  public Enumeration declaredNotations ()
  {
    return notationInfo.keys();
  }
  /**
    * Look up the public identifier for a notation.
    * You will normally use this method to look up a notation
    * that was provided as an attribute value or for an NDATA entity.
    * @param nname The name of the notation.
    * @return A string containing the public identifier, or null
    *         if none was provided or if no such notation was
    *         declared.
    * @see #getNotationSystemId
    */
  public String getNotationPublicId (String nname)
  {
    Object notation[] = (Object[])notationInfo.get(nname);
    if (notation == null) {
      return null;
    } else {
      return (String)notation[0];
    }
  }
  /**
    * Look up the system identifier for a notation.
    * You will normally use this method to look up a notation
    * that was provided as an attribute value or for an NDATA entity.
    * @param nname The name of the notation.
    * @return A string containing the system identifier, or null
    *         if no such notation was declared.
    * @see #getNotationPublicId
    */
  public String getNotationSystemId (String nname)
  {
    Object notation[] = (Object[])notationInfo.get(nname);
    if (notation == null) {
      return null;
    } else {
      return (String)notation[1];
    }
  }
  /**
    * Register a notation declaration for later retrieval.
    * Format:
    * - public id
    * - system id
    */
  void setNotation (String nname, String pubid, String sysid)
    throws java.lang.Exception
  {
    Object notation[];
    if (notationInfo.get(nname) == null) {
      notation = new Object[2];
      notation[0] = pubid;
      notation[1] = sysid;
      notationInfo.put(nname,notation);
    } else {
      error(""multiple declarations of notation"", nname, null);
    }
  }
  //
  // Location.
  //
  /**
    * Return the current line number.
    */
  public int getLineNumber ()
  {
    return line;
  }
  /**
    * Return the current column number.
    */
  public int getColumnNumber ()
  {
    return column;
  }
  //////////////////////////////////////////////////////////////////////
  // High-level I/O.
  //////////////////////////////////////////////////////////////////////
  /**
    * Read a single character from the readBuffer.
    * <p>The readDataChunk() method maintains the buffer.
    * <p>If we hit the end of an entity, try to pop the stack and
    * keep going.
    * <p>(This approach doesn't really enforce XML's rules about
    * entity boundaries, but this is not currently a validating
    * parser).
    * <p>This routine also attempts to keep track of the current
    * position in external entities, but it's not entirely accurate.
    * @return The next available input character.
    * @see #unread(char)
    * @see #unread(String)
    * @see #readDataChunk
    * @see #readBuffer
    * @see #line
    * @return The next character from the current input source.
    */
  char readCh ()
    throws java.lang.Exception
    {
    char c;
    // As long as there's nothing in the
    // read buffer, try reading more data
    // (for an external entity) or popping
    // the entity stack (for either).
    while (readBufferPos >= readBufferLength)
      {
      switch (sourceType)
        {
        case INPUT_READER:
        case INPUT_EXTERNAL:
        case INPUT_STREAM:
        readDataChunk();
        while (readBufferLength < 1)
          {
          popInput();
          if (readBufferLength <1)
            {
            readDataChunk();
            }
          }
        break;
        default:
        popInput();
        break;
        }
      }
    c = readBuffer[readBufferPos++];
    // This is a particularly nasty bit
    // of code, that checks for a parameter
    // entity reference but peeks ahead to
    // catch the '%' in parameter entity
    // declarations.
    if
      (
      c == '%' && 
      (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE)
      )
      {
      char c2 = readCh();
      unread(c2);
      if (!isWhitespace(c2))
        {
        parsePEReference(context == CONTEXT_ENTITYVALUE);
        return readCh();
        }
      }
    if (c == '\n')
      {
      line++;
      column = 0;
      }
    else
      {
      column++;
      }
    return c;
    }
  /**
    * Push a single character back onto the current input stream.
    * <p>This method usually pushes the character back onto
    * the readBuffer, while the unread(String) method treats the
    * string as a new internal entity.
    * <p>I don't think that this would ever be called with 
    * readBufferPos = 0, because the methods always reads a character
    * before unreading it, but just in case, I've added a boundary
    * condition.
    * @param c The character to push back.
    * @see #readCh
    * @see #unread(String)
    * @see #unread(char[])
    * @see #readBuffer
    */
  void unread (char c)
    throws java.lang.Exception
    {
    // Normal condition.
    if (c == '\n')
      {
      line--;
      column = -1;
      }
    if (readBufferPos > 0)
      {
      readBuffer[--readBufferPos] = c;
      }
    else
      {
      pushString(null, new Character(c).toString());
      }
    }
  /**
    * Push a char array back onto the current input stream.
    * <p>NOTE: you must <em>never</em> push back characters that you
    * haven't actually read: use pushString() instead.
    * @see #readCh
    * @see #unread(char)
    * @see #unread(String)
    * @see #readBuffer
    * @see #pushString
    */
  void unread (char ch[], int length) 
    throws java.lang.Exception
    {
    for (int i = 0; i < length; i++)
        {
        if (ch[i] == '\n')
          {line--;column = -1;}
        }
    if (length < readBufferPos)
      {readBufferPos -= length;}
    else
      {
      pushCharArray(null, ch, 0, length);
      sourceType = INPUT_BUFFER;
      }
    }
  /**
    * Push a new external input source.
    * <p>The source will be either an external text entity, or the DTD
    * external subset.
    * <p>TO DO: Right now, this method always attempts to autodetect
    * the encoding; in the future, it should allow the caller to 
    * request an encoding explicitly, and it should also look at the
    * headers with an HTTP connection.
    * @param url The java.net.URL object for the entity.
    * @see XmlHandler#resolveEntity
    * @see #pushString
    * @see #sourceType
    * @see #pushInput
    * @see #detectEncoding
    * @see #sourceType
    * @see #readBuffer
    */
  void pushURL (String ename, String publicId, String systemId,
		Reader reader, InputStream stream, String encoding)
    throws java.lang.Exception
  {
    URL url;
    boolean ignoreEncoding = false;
				// Push the existing status.
    pushInput(ename);
				// Create a new read buffer.
				// (Note the four-character margin)
    readBuffer = new char[READ_BUFFER_MAX+4];
    readBufferPos = 0;
    readBufferLength = 0;
    readBufferOverflow = -1;
    is = null;
    line = 1;
    currentByteCount = 0;
				// Flush any remaining data.
    dataBufferFlush();
				// Make the URL absolute.
    if (systemId != null && externalEntity != null) {
      systemId = new URL(externalEntity.getURL(), systemId).toString();
    } else if (baseURI != null) {
      try {
	systemId = new URL(new URL(baseURI), systemId).toString();
      } catch (Exception e) {}
    }
				// See if the application wants to
				// redirect the system ID and/or
				// supply its own character stream.
    if (systemId != null && handler != null) {
      Object input = handler.resolveEntity(publicId, systemId);
      if (input != null) {
	if (input instanceof String) {
	  systemId = (String)input;
	} else if (input instanceof InputStream) {
	  stream = (InputStream)input;
	} else if (input instanceof Reader) {
	  reader = (Reader)input;
	}
      }
    }
				// Start the entity.
    if (handler != null) {
      if (systemId != null) {
	handler.startExternalEntity(systemId);
      } else {
	handler.startExternalEntity(""[external stream]"");
      }
    }
				// Figure out what we're reading from.
    if (reader != null) {
				// There's an explicit character stream.
      sourceType = INPUT_READER;
      this.reader = reader;
      tryEncodingDecl(true);
      return;
    } else if (stream != null) {
      sourceType = INPUT_STREAM;
      is = stream;
    } else {
				// We have to open our own stream
				// to the URL.
				// Set the new status
      sourceType = INPUT_EXTERNAL;
      url = new URL(systemId);
      externalEntity = url.openConnection();
      externalEntity.connect();
      is = externalEntity.getInputStream();
    }
				// If we get to here, there must be
				// an InputStream available.
    if (!is.markSupported()) {
      is = new BufferedInputStream(is);
    }
				// Attempt to detect the encoding.
    if (encoding == null && externalEntity != null) {
      encoding = externalEntity.getContentEncoding();
    }
    if (encoding != null) {
      checkEncoding(encoding, false);
      ignoreEncoding = true;
    } else {
      detectEncoding();
      ignoreEncoding = false;
    }
				// Read an XML or text declaration.
    tryEncodingDecl(ignoreEncoding);
  }
  /**
    * Check for an encoding declaration.
    */
  void tryEncodingDecl (boolean ignoreEncoding)
    throws java.lang.Exception
  {
				// Read the XML/Encoding declaration.
    if (tryRead(""<?xml"")) {
      if (tryWhitespace()) {
	if (inputStack.size() > 0) {
	  parseTextDecl(ignoreEncoding);
	} else {
	  parseXMLDecl(ignoreEncoding);
	}
      } else {
	unread(""xml"".toCharArray(), 3);
	parsePI();
      }
    }
  }
  /**
    * Attempt to detect the encoding of an entity.
    * <p>The trick here (as suggested in the XML standard) is that
    * any entity not in UTF-8, or in UCS-2 with a byte-order mark, 
    * <b>must</b> begin with an XML declaration or an encoding
    * declaration; we simply have to look for ""&lt;?XML"" in various
    * encodings.
    * <p>This method has no way to distinguish among 8-bit encodings.
    * Instead, it assumes UTF-8, then (possibly) revises its assumption
    * later in checkEncoding().  Any ASCII-derived 8-bit encoding
    * should work, but most will be rejected later by checkEncoding().
    * <p>I don't currently detect EBCDIC, since I'm concerned that it
    * could also be a valid UTF-8 sequence; I'll have to do more checking
    * later.
    * @see #tryEncoding(byte[], byte, byte, byte, byte)
    * @see #tryEncoding(byte[], byte, byte)
    * @see #checkEncoding
    * @see #read8bitEncodingDeclaration
    */
  void detectEncoding ()
    throws java.lang.Exception
  {
    byte signature[] = new byte[4];
				// Read the first four bytes for
				// autodetection.
    is.mark(4);
    is.read(signature);
    is.reset();
				// Look for a known signature.
    if (tryEncoding(signature, (byte)0x00, (byte)0x00,
		    (byte)0x00, (byte)0x3c)) {
      // UCS-4 must begin with ""<!XML""
      // 0x00 0x00 0x00 0x3c: UCS-4, big-endian (1234)
      encoding = ENCODING_UCS_4_1234;
    } else if (tryEncoding(signature, (byte)0x3c, (byte)0x00,
			   (byte)0x00, (byte)0x00)) {
      // UCS-4 must begin with ""<!XML""
      // 0x3c 0x00 0x00 0x00: UCS-4, little-endian (4321)
      encoding = ENCODING_UCS_4_4321;
    } else if (tryEncoding(signature, (byte)0x00, (byte)0x00,
			   (byte)0x3c, (byte)0x00)) {
      // UCS-4 must begin with ""<!XML""
      // 0x00 0x00 0x3c 0x00: UCS-4, unusual (2143)
      encoding = ENCODING_UCS_4_2143;
    } else if (tryEncoding(signature, (byte)0x00, (byte)0x3c,
			   (byte)0x00, (byte)0x00)) {
      // UCS-4 must begin with ""<!XML""
      // 0x00 0x3c 0x00 0x00: UCS-4, unusual (3421)
      encoding = ENCODING_UCS_4_3412;
    } else if (tryEncoding(signature, (byte)0xfe, (byte)0xff)) {
      // UCS-2 with a byte-order marker.
      // 0xfe 0xff: UCS-2, big-endian (12)
      encoding = ENCODING_UCS_2_12;
      is.read(); is.read();
    } else if (tryEncoding(signature, (byte)0xff, (byte)0xfe)) {
      // UCS-2 with a byte-order marker.
      // 0xff 0xfe: UCS-2, little-endian (21)
      encoding = ENCODING_UCS_2_21;
      is.read(); is.read();
    } else if (tryEncoding(signature, (byte)0x00, (byte)0x3c,
			   (byte)0x00, (byte)0x3f)) {
      // UCS-2 without a BOM must begin with ""<?XML""
      // 0x00 0x3c 0x00 0x3f: UCS-2, big-endian, no byte-order mark
      encoding = ENCODING_UCS_2_12;
      error(""no byte-order mark for UCS-2 entity"", null, null);
    } else if (tryEncoding(signature, (byte)0x3c, (byte)0x00,
			   (byte)0x3f, (byte)0x00)) {
      // UCS-2 without a BOM must begin with ""<?XML""
      // 0x3c 0x00 0x3f 0x00: UCS-2, little-endian, no byte-order mark
      encoding = ENCODING_UCS_2_21;
      error(""no byte-order mark for UCS-2 entity"", null, null);
    } else if (tryEncoding(signature, (byte)0x3c, (byte)0x3f,
			   (byte)0x78, (byte)0x6d)) {
      // Some kind of 8-bit encoding with ""<?XML""
      // 0x3c 0x3f 0x78 0x6d: UTF-8 or other 8-bit markup (read ENCODING)
      encoding = ENCODING_UTF_8;
      read8bitEncodingDeclaration();
    } else {
      // Some kind of 8-bit encoding without ""<?XML""
      // (otherwise) UTF-8 without encoding/XML declaration
      encoding = ENCODING_UTF_8;
    }
  }
  /**
    * Check for a four-byte signature.
    * <p>Utility routine for detectEncoding().
    * <p>Always looks for some part of ""<?XML"" in a specific encoding.
    * @param sig The first four bytes read.
    * @param b1 The first byte of the signature
    * @param b2 The second byte of the signature
    * @param b3 The third byte of the signature
    * @param b4 The fourth byte of the signature
    * @see #detectEncoding
    */
  boolean tryEncoding (byte sig[], byte b1, byte b2, byte b3, byte b4)
  {
    return (sig[0] == b1 && sig[1] == b2 && sig[2] == b3 && sig[3] == b4);
  }
  /**
    * Check for a two-byte signature.
    * <p>Looks for a UCS-2 byte-order mark.
    * <p>Utility routine for detectEncoding().
    * @param sig The first four bytes read.
    * @param b1 The first byte of the signature
    * @param b2 The second byte of the signature
    * @see #detectEncoding
    */
  boolean tryEncoding (byte sig[], byte b1, byte b2)
  {
    return ((sig[0] == b1) && (sig[1] == b2));
  }
  /**
    * This method pushes a string back onto input.
    * <p>It is useful either as the expansion of an internal entity, 
    * or for backtracking during the parse.
    * <p>Call pushCharArray() to do the actual work.
    * @param s The string to push back onto input.
    * @see #pushCharArray
    */
  void pushString (String ename, String s) 
    throws java.lang.Exception
  {
    char ch[] = s.toCharArray();
    pushCharArray(ename, ch, 0, ch.length);
  }
  /**
    * Push a new internal input source.
    * <p>This method is useful for expanding an internal entity,
    * or for unreading a string of characters.  It creates a new
    * readBuffer containing the characters in the array, instead
    * of characters converted from an input byte stream.
    * <p>I've added a couple of optimisations: don't push zero-
    * length strings, and just push back a single character
    * for 1-character strings; this should save some time and memory.
    * @param ch The char array to push.
    * @see #pushString
    * @see #pushURL
    * @see #readBuffer
    * @see #sourceType
    * @see #pushInput
    */
  void pushCharArray (String ename, char ch[], int start, int length)
    throws java.lang.Exception
  {
				// Push the existing status
    pushInput(ename);
    sourceType = INPUT_INTERNAL;
    readBuffer = ch;
    readBufferPos = start;
    readBufferLength = length;
    readBufferOverflow = -1;
  }
  /**
    * Save the current input source onto the stack.
    * <p>This method saves all of the global variables associated with
    * the current input source, so that they can be restored when a new
    * input source has finished.  It also tests for entity recursion.
    * <p>The method saves the following global variables onto a stack
    * using a fixed-length array:
    * <ol>
    * <li>sourceType
    * <li>externalEntity
    * <li>readBuffer
    * <li>readBufferPos
    * <li>readBufferLength
    * <li>line
    * <li>encoding
    * </ol>
    * @param ename The name of the entity (if any) causing the new input.
    * @see #popInput
    * @see #sourceType
    * @see #externalEntity
    * @see #readBuffer
    * @see #readBufferPos
    * @see #readBufferLength
    * @see #line
    * @see #encoding
    */
  void pushInput (String ename)
    throws java.lang.Exception
  {
    Object input[] = new Object[12];
				// Check for entity recursion.
    if (ename != null) {
      Enumeration entities = entityStack.elements();
      while (entities.hasMoreElements()) {
	String e = (String)entities.nextElement();
	if (e == ename) {
	  error(""recursive reference to entity"", ename, null);
	}
      }
    }
    entityStack.push(ename);
				// Don't bother if there is no input.
    if (sourceType == INPUT_NONE) {
      return;
    }
				// Set up a snapshot of the current
				// input source.
    input[0] = new Integer(sourceType);
    input[1] = externalEntity;
    input[2] = readBuffer;
    input[3] = new Integer(readBufferPos);
    input[4] = new Integer(readBufferLength);
    input[5] = new Integer(line);
    input[6] = new Integer(encoding);
    input[7] = new Integer(readBufferOverflow);
    input[8] = is;
    input[9] = new Integer(currentByteCount);
    input[10] = new Integer(column);
    input[11] = reader;
				// Push it onto the stack.
    inputStack.push(input);
  }
  /**
    * Restore a previous input source.
    * <p>This method restores all of the global variables associated with
    * the current input source.
    * @exception java.io.EOFException
    *    If there are no more entries on the input stack.
    * @see #pushInput
    * @see #sourceType
    * @see #externalEntity
    * @see #readBuffer
    * @see #readBufferPos
    * @see #readBufferLength
    * @see #line
    * @see #encoding
    */
  void popInput ()
    throws java.lang.Exception
  {
    Object input[];
    switch (sourceType) {
    case INPUT_EXTERNAL:
      dataBufferFlush();
      if (handler != null && externalEntity != null) {
	handler.endExternalEntity(externalEntity.getURL().toString());
      }
      break;
    case INPUT_STREAM:
      dataBufferFlush();
      if (baseURI != null) {
	if (handler != null) {
	  handler.endExternalEntity(baseURI);
	}
      }
      break;
    case INPUT_READER:
      dataBufferFlush();
      if (baseURI != null) {
	if (handler != null) {
	  handler.endExternalEntity(baseURI);
	}
      }
      break;
    }
				// Throw an EOFException if there
				// is nothing else to pop.
    if (inputStack.isEmpty()) {
      throw new EOFException();
    } else {
      String s;
      input = (Object[])inputStack.pop();
      s = (String)entityStack.pop();
    }
    sourceType = ((Integer)input[0]).intValue();
    externalEntity = (URLConnection)input[1];
    readBuffer = (char[])input[2];
    readBufferPos = ((Integer)input[3]).intValue();
    readBufferLength = ((Integer)input[4]).intValue();
    line = ((Integer)input[5]).intValue();
    encoding = ((Integer)input[6]).intValue();
    readBufferOverflow = ((Integer)input[7]).intValue();
    is = (InputStream)input[8];
    currentByteCount = ((Integer)input[9]).intValue();
    column = ((Integer)input[10]).intValue();
    reader = (Reader)input[11];
  }
  /**
    * Return true if we can read the expected character.
    * <p>Note that the character will be removed from the input stream
    * on success, but will be put back on failure.  Do not attempt to
    * read the character again if the method succeeds.
    * @param delim The character that should appear next.  For a
    *              insensitive match, you must supply this in upper-case.
    * @return true if the character was successfully read, or false if
    *         it was not.
    * @see #tryRead(String)
    */
  boolean tryRead (char delim)
    throws java.lang.Exception
  {
    char c;
				// Read the character
    c = readCh();
				// Test for a match, and push the character
				// back if the match fails.
    if (c == delim) {
      return true;
    } else {
      unread(c);
      return false;
    }
  }
  /**
    * Return true if we can read the expected string.
    * <p>This is simply a convenience method.
    * <p>Note that the string will be removed from the input stream
    * on success, but will be put back on failure.  Do not attempt to
    * read the string again if the method succeeds.
    * <p>This method will push back a character rather than an
    * array whenever possible (probably the majority of cases).
    * <p><b>NOTE:</b> This method currently has a hard-coded limit
    * of 100 characters for the delimiter.
    * @param delim The string that should appear next.
    * @return true if the string was successfully read, or false if
    *         it was not.
    * @see #tryRead(char)
    */
  boolean tryRead (String delim)
    throws java.lang.Exception
    {
    char ch[] = delim.toCharArray();
    char c;
    // Compare the input, character-
    // by character.
    for (int i = 0; i < ch.length; i++)
      {
      c=readCh();
      if (c!=ch[i])
        {
        unread(c);
        if (i!=0)
          {unread(ch,i);}
        return false;
        }
      }
    return true;
    }
  /**
    * Return true if we can read some whitespace.
    * <p>This is simply a convenience method.
    * <p>This method will push back a character rather than an
    * array whenever possible (probably the majority of cases).
    * @return true if whitespace was found.
    */
  boolean tryWhitespace ()
    throws java.lang.Exception
  {
    char c;
    c = readCh();
    if (isWhitespace(c)) {
      skipWhitespace();
      return true;
    } else {
      unread(c);
      return false;
    }
  }
  /**
    * Read all data until we find the specified string.
    * <p>This is especially useful for scanning marked sections.
    * <p>This is a a little inefficient right now, since it calls tryRead()
    * for every character.
    * @param delim The string delimiter
    * @see #tryRead(String, boolean)
    * @see #readCh
    */
  void parseUntil (String delim)
    throws java.lang.Exception
  {
    char c;
    int startLine = line;
    try {
      while (!tryRead(delim)) {
	c = readCh();
	dataBufferAppend(c);
      }
    } catch (EOFException e) {
      error(""end of input while looking for delimiter (started on line "" +
	    startLine + ')', null, delim);
    }
  }
  /**
    * Skip all data until we find the specified string.
    * <p>This is especially useful for scanning comments.
    * <p>This is a a little inefficient right now, since it calls tryRead()
    * for every character.
    * @param delim The string delimiter
    * @see #tryRead(String, boolean)
    * @see #readCh
    */
  void skipUntil (String delim)
    throws java.lang.Exception
  {
    while (!tryRead(delim)) {
      readCh();
    }
  }
  /**
    * Read just the encoding declaration (or XML declaration) at the 
    * start of an external entity.
    * When this method is called, we know that the declaration is
    * present (or appears to be).  We also know that the entity is
    * in some sort of ASCII-derived 8-bit encoding.
    * The idea of this is to let us read what the 8-bit encoding is
    * before we've committed to converting any more of the file; the
    * XML or encoding declaration must be in 7-bit ASCII, so we're
    * safe as long as we don't go past it.
    */
  void read8bitEncodingDeclaration ()
    throws java.lang.Exception
  {
    int ch;
    readBufferPos = readBufferLength = 0;
    while (true) {
      ch = is.read();
      readBuffer[readBufferLength++] = (char)ch;
      switch (ch) {
      case (int)'>':
	return;
      case -1:
	error(""end of file before end of XML or encoding declaration."",
	      null, ""?>"");
	return;
      }
      if (readBuffer.length == readBufferLength) {
	error(""unfinished XML or encoding declaration"", null, null);
      }
    }
  }
  //////////////////////////////////////////////////////////////////////
  // Low-level I/O.
  //////////////////////////////////////////////////////////////////////
  /**
    * Read a chunk of data from an external input source.
    * <p>This is simply a front-end that fills the rawReadBuffer
    * with bytes, then calls the appropriate encoding handler.
    * @see #encoding
    * @see #rawReadBuffer
    * @see #readBuffer
    * @see #filterCR
    * @see #copyUtf8ReadBuffer
    * @see #copyIso8859_1ReadBuffer
    * @see #copyUcs_2ReadBuffer
    * @see #copyUcs_4ReadBuffer
    */
  void readDataChunk ()
    throws java.lang.Exception
    {
    int count, i, j;
    // See if we have any overflow.
    if (readBufferOverflow > -1)
      {
      readBuffer[0] = (char)readBufferOverflow;
      readBufferOverflow = -1;
      readBufferPos = 1;
      sawCR = true;
      }
    else
      {
      readBufferPos = 0;
      sawCR = false;
      }
    // Special situation -- we're taking
    // input from a character stream.
    if (sourceType == INPUT_READER)
      {
      count = reader.read(readBuffer, readBufferPos, READ_BUFFER_MAX-1);
      if (count < 0)
        {readBufferLength = -1;}
      else
        {
        readBufferLength = readBufferPos+count;
        filterCR();
        sawCR = false;
        }
      return;
      }
    // Read as many bytes as possible
    // into the read buffer.
    count = is.read(rawReadBuffer, 0, READ_BUFFER_MAX);
    // Dispatch to an encoding-specific
    // reader method to populate the
    // readBuffer.
    switch (encoding)
      {
      case ENCODING_UTF_8:
      copyUtf8ReadBuffer(count);
      break;
      case ENCODING_ISO_8859_1:
      copyIso8859_1ReadBuffer(count);
      break;
      case ENCODING_UCS_2_12:
      copyUcs2ReadBuffer(count, 8, 0);
      break;
      case ENCODING_UCS_2_21:
      copyUcs2ReadBuffer(count, 0, 8);
      break;
      case ENCODING_UCS_4_1234:
      copyUcs4ReadBuffer(count, 24, 16, 8, 0);
      break;
      case ENCODING_UCS_4_4321:
      copyUcs4ReadBuffer(count, 0, 8, 16, 24);
      break;
      case ENCODING_UCS_4_2143:
      copyUcs4ReadBuffer(count, 16, 24, 0, 8);
      break;
      case ENCODING_UCS_4_3412:
      copyUcs4ReadBuffer(count, 8, 0, 24, 16);
      break;
      }
    // Filter out all carriage returns
    // if we've seen any.
    if (sawCR)
      {
      filterCR();
      sawCR = false;
      }
    // Reset the position.
    readBufferPos = 0;
    currentByteCount += count;
    }
  /**
    * Filter carriage returns in the read buffer.
    * <p>CRLF becomes LF; CR becomes LF.
    * @see #readDataChunk
    * @see #readBuffer
    * @see #readBufferOverflow
    */
  void filterCR ()
    {
    int i, j;
    readBufferOverflow = -1;
    loop: for (i = 0, j = 0; j < readBufferLength; i++, j++)
      {
      switch (readBuffer[j])
        {
        case '\r':
        if (j == readBufferLength - 1)
          {
          readBufferOverflow = '\r';
          readBufferLength--;
          break loop;
          }
        else if (readBuffer[j+1] == '\n')
          {j++;}
        readBuffer[i] = '\n';
        break;
        case '\n':
        default:
        readBuffer[i] = readBuffer[j];
        break;
        }
      }
    readBufferLength = i;
    }
  /**
    * Convert a buffer of UTF-8-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * <p>The tricky part of this is dealing with UTF-8 multi-byte 
    * sequences, but it doesn't seem to slow things down too much.
    * @param count The number of bytes to convert.
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    * @see #getNextUtf8Byte
    */
  void copyUtf8ReadBuffer (int count)
    throws java.lang.Exception
  {
    int i = 0;
    int j = readBufferPos;
    int b1;
    boolean isSurrogate = false;
    while (i < count) {
      b1 = rawReadBuffer[i++];
      isSurrogate = false;
				// Determine whether we are dealing
				// with a one-, two-, three-, or four-
				// byte sequence.
      if ((b1 & 0x80) == 0) {
	// 1-byte sequence: 000000000xxxxxxx = 0xxxxxxx
	readBuffer[j++] = (char)b1;
      } else if ((b1 & 0xe0) == 0xc0) {
	// 2-byte sequence: 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
	readBuffer[j++] =
	  (char)(((b1 & 0x1f) << 6) |
		 getNextUtf8Byte(i++, count));
      } else if ((b1 & 0xf0) == 0xe0) {
	// 3-byte sequence: zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
	readBuffer[j++] =
	  (char)(((b1 & 0x0f) << 12) |
		 (getNextUtf8Byte(i++, count) << 6) |
		 getNextUtf8Byte(i++, count));
      } else if ((b1 & 0xf8) == 0xf0) {
	// 4-byte sequence: 11101110wwwwzzzzyy + 110111yyyyxxxxxx
	//     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
	// (uuuuu = wwww + 1)
	isSurrogate = true;
	int b2 = getNextUtf8Byte(i++, count);
	int b3 = getNextUtf8Byte(i++, count);
	int b4 = getNextUtf8Byte(i++, count);
	readBuffer[j++] =
	  (char)(0xd800 |
		 ((((b1 & 0x07) << 2) | ((b2 & 0x30) >> 4) - 1) << 6) |
		 ((b2 & 0x0f) << 2) |
		 ((b3 & 0x30) >> 4));
	readBuffer[j++] =
	  (char)(0xdc |
		 ((b3 & 0x0f) << 6) |
		 b4);
				// TODO: test that surrogate value is legal.
      } else {
	// Otherwise, the 8th bit may not be set in UTF-8
	encodingError(""bad start for UTF-8 multi-byte sequence"", b1, i);
      }
      if (readBuffer[j-1] == '\r') {
	sawCR = true;
      }
    }
				// How many characters have we read?
    readBufferLength = j;
  }
  /**
    * Return the next byte value in a UTF-8 sequence.
    * If it is not possible to get a byte from the current
    * entity, throw an exception.
    * @param pos The current position in the rawReadBuffer.
    * @param count The number of bytes in the rawReadBuffer
    * @return The significant six bits of a non-initial byte in
    *         a UTF-8 sequence.
    * @exception EOFException If the sequence is incomplete.
    */
  int getNextUtf8Byte (int pos, int count)
    throws java.lang.Exception
  {
    int val;
				// Take a character from the buffer
				// or from the actual input stream.
    if (pos < count) {
      val = rawReadBuffer[pos];
    } else {
      val = is.read();
      if (val == -1) {
	encodingError(""unfinished multi-byte UTF-8 sequence at EOF"", -1, pos);
      }
    }
				// Check for the correct bits at the
				// start.
    if ((val & 0xc0) != 0x80) {
      encodingError(""bad continuation of multi-byte UTF-8 sequence"", val,
		    pos + 1);
    }
				// Return the significant bits.
    return (val & 0x3f);
  }
  /**
    * Convert a buffer of ISO-8859-1-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * <p>This is a direct conversion, with no tricks.
    * @param count The number of bytes to convert.
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    */
  void copyIso8859_1ReadBuffer (int count)
  {
    int i, j;
    for (i = 0, j = readBufferPos; i < count; i++, j++) {
      readBuffer[j] = (char)(rawReadBuffer[i] & 0xff);
      if (readBuffer[j] == '\r') {
	sawCR = true;
      }
    }
    readBufferLength = j;
  }
  /**
    * Convert a buffer of UCS-2-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * @param count The number of bytes to convert.
    * @param shift1 The number of bits to shift byte 1.
    * @param shift2 The number of bits to shift byte 2
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    */
  void copyUcs2ReadBuffer (int count, int shift1, int shift2)
    throws java.lang.Exception
  {
    int j = readBufferPos;
    if (count > 0 && (count % 2) != 0) {
      encodingError(""odd number of bytes in UCS-2 encoding"", -1, count);
    }
    for (int i = 0; i < count; i+=2) {
      readBuffer[j++] =
	(char)(((rawReadBuffer[i] & 0xff) << shift1) |
	       ((rawReadBuffer[i+1] & 0xff) << shift2));
      if (readBuffer[j-1] == '\r') {
	sawCR = true;
      }
    }
    readBufferLength = j;
  }
  /**
    * Convert a buffer of UCS-4-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * <p>Java has 16-bit chars, but this routine will attempt to use
    * surrogates to encoding values between 0x00010000 and 0x000fffff.
    * @param count The number of bytes to convert.
    * @param shift1 The number of bits to shift byte 1.
    * @param shift2 The number of bits to shift byte 2
    * @param shift3 The number of bits to shift byte 2
    * @param shift4 The number of bits to shift byte 2
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    */
  void copyUcs4ReadBuffer (int count, int shift1, int shift2,
			   int shift3, int shift4)
    throws java.lang.Exception
  {
    int j = readBufferPos;
    int value;
    if (count > 0 && (count % 4) != 0) {
      encodingError(""number of bytes in UCS-4 encoding not divisible by 4"",
		    -1, count);
    }
    for (int i = 0; i < count; i+=4) {
      value = (((rawReadBuffer[i] & 0xff) << shift1) |
	       ((rawReadBuffer[i+1] & 0xff) << shift2) |
	       ((rawReadBuffer[i+2] & 0xff) << shift3) |
	       ((rawReadBuffer[i+3] & 0xff) << shift4));
      if (value < 0x0000ffff) {
	readBuffer[j++] = (char)value;
	if (value == (int)'\r') {
	  sawCR = true;
	}
      } else if (value < 0x000fffff) {
	readBuffer[j++] = (char)(0xd8 | ((value & 0x000ffc00) >> 10));
	readBuffer[j++] = (char)(0xdc | (value & 0x0003ff));
      } else {
	encodingError(""value cannot be represented in UTF-16"",
		      value, i);
      }
    }
    readBufferLength = j;
  }
  /**
    * Report a character encoding error.
    */
  void encodingError (String message, int value, int offset)
    throws java.lang.Exception
  {
    String uri;
    if (value >= 0) {
      message = message + "" (byte value: 0x"" +
	Integer.toHexString(value) + ')';
    }
    if (externalEntity != null) {
      uri = externalEntity.getURL().toString();
    } else {
      uri = baseURI;
    }
    handler.error(message, uri, -1, offset + currentByteCount);
  }
  //////////////////////////////////////////////////////////////////////
  // Local Variables.
  //////////////////////////////////////////////////////////////////////
  /**
    * Re-initialize the variables for each parse.
    */
  void initializeVariables ()
  {
				// No errors; first line
    errorCount = 0;
    line = 1;
    column = 0;
				// Set up the buffers for data and names
    dataBufferPos = 0;
    dataBuffer = new char[DATA_BUFFER_INITIAL];
    nameBufferPos = 0;
    nameBuffer = new char[NAME_BUFFER_INITIAL];
				// Set up the DTD hash tables
    elementInfo = new Hashtable();
    entityInfo = new Hashtable();
    notationInfo = new Hashtable();
				// Set up the variables for the current
				// element context.
    currentElement = null;
    currentElementContent = CONTENT_UNDECLARED;
				// Set up the input variables
    sourceType = INPUT_NONE;
    inputStack = new Stack();
    entityStack = new Stack();
    externalEntity = null;
    tagAttributePos = 0;
    tagAttributes = new String[100];
    rawReadBuffer = new byte[READ_BUFFER_MAX];
    readBufferOverflow = -1;
    context = CONTEXT_NONE;
    symbolTable = new Object[SYMBOL_TABLE_LENGTH];
  }
  /**
    * Clean up after the parse to allow some garbage collection.
    * Leave around anything that might be useful for queries.
    */
  void cleanupVariables ()
  {
    errorCount = -1;
    line = -1;
    column = -1;
    dataBuffer = null;
    nameBuffer = null;
    currentElement = null;
    currentElementContent = CONTENT_UNDECLARED;
    sourceType = INPUT_NONE;
    inputStack = null;
    externalEntity = null;
    entityStack = null;
  }
  //
  // The current XML handler interface.
  //
  XmlHandler handler;
  //
  // I/O information.
  //
  private Reader reader;	// current reader
  private InputStream is;	// current input stream
  private int line;		// current line number
  private int column;		// current column number
  private int sourceType;	// type of input source
  private Stack inputStack;	// stack of input soruces
  private URLConnection externalEntity;	// current external entity
  private int encoding;		// current character encoding.
  private int currentByteCount;	// how many bytes read from current source.
  //
  // Maintain a count of errors.
  //
  private int errorCount;
  //
  // Buffers for decoded but unparsed character input.
  //
  private final static int READ_BUFFER_MAX = 16384;
  private char readBuffer[];
  private int readBufferPos;
  private int readBufferLength;
  private int readBufferOverflow; // overflow character from last data chunk.
  //
  // Buffer for undecoded raw byte input.
  //
  private byte rawReadBuffer[];
  //
  // Buffer for parsed character data.
  //
  private static int DATA_BUFFER_INITIAL = 4096;
  private char dataBuffer[];
  private int dataBufferPos;
  //
  // Buffer for parsed names.
  //
  private static int NAME_BUFFER_INITIAL = 1024;
  private char nameBuffer[];
  private int nameBufferPos;
  //
  // Hashtables for DTD information on elements, entities, and notations.
  //
  private Hashtable elementInfo;
  private Hashtable entityInfo;
  private Hashtable notationInfo;
  //
  // Element type currently in force.
  //
  private String currentElement;
  private int currentElementContent;
  //
  // Base external identifiers for resolution.
  //
  private String basePublicId;
  private String baseURI;
  private int baseEncoding;
  private Reader baseReader;
  private InputStream baseInputStream;
  private char baseInputBuffer[];
  private int baseInputBufferStart;
  private int baseInputBufferLength;
  //
  // Stack of entity names, to help detect recursion.
  //
  private Stack entityStack;
  //
  // Are we in a context where PEs are allowed?
  //
  private int context;
  //
  // Symbol table, for internalising names.
  //
  private Object symbolTable[];
  private final static int SYMBOL_TABLE_LENGTH = 1087;
  //
  // Hash table of attributes found in current start tag.
  //
  private String tagAttributes[];
  private int tagAttributePos;
  //
  // Utility flag: have we noticed a CR while reading the last
  // data chunk?  If so, we will have to go back and normalise
  // CR/LF.
  //
  private boolean sawCR;
}
"
doclet.GenerateTocXML,"/*
 * GenerateTocXML.java
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package doclet;
import com.sun.javadoc.*;
import java.io.*;
import java.util.Arrays;
/**
 * This is very much of a hack.
 */
public class GenerateTocXML
{
	public static final String PATH = ""doc/api/"";
	public static final String OUT = PATH + ""toc.xml"";
	public static final String HEADER = ""<?xml version='1.0'?>\n<TOC>\n""
		+ ""<ENTRY HREF='overview-summary.html'><TITLE>jEdit API Reference</TITLE>"";
	public static final String FOOTER = ""</ENTRY></TOC>\n"";
	public static boolean start(RootDoc root)
	{
		try
		{
			FileWriter out = new FileWriter(OUT);
			out.write(HEADER);
			PackageDoc[] packages = root.specifiedPackages();
			for(int i = 0; i < packages.length; ++i)
			{
				processPackage(out,packages[i]);
			}
			out.write(FOOTER);
			out.close();
			return true;
		}
		catch(IOException e)
		{
			e.printStackTrace();
			return false;
		}
	}
	private static void processPackage(Writer out, PackageDoc pkg)
		throws IOException
	{
		out.write(""<ENTRY HREF='"");
		String pkgPath = pkg.name().replace('.','/') + ""/"";
		out.write(pkgPath);
		out.write(""package-summary.html'><TITLE>"");
		out.write(pkg.name());
		out.write(""</TITLE>\n"");
		ClassDoc[] classes = pkg.allClasses();
		String[] classNames = new String[classes.length];
		for(int i = 0; i < classes.length; i++)
		{
			classNames[i] = classes[i].name();
		}
		Arrays.sort(classNames);
		for(int i = 0; i < classes.length; i++)
		{
			processClass(out,pkgPath,classNames[i]);
		}
		out.write(""</ENTRY>"");
	}
	private static void processClass(Writer out, String pkgPath, String clazz)
		throws IOException
	{
		out.write(""<ENTRY HREF='"");
		out.write(pkgPath);
		out.write(clazz);
		out.write("".html'><TITLE>"");
		out.write(clazz);
		out.write(""</TITLE>\n"");
		out.write(""</ENTRY>"");
	}
}
"
gnu.regexp.CharIndexed,"/*
 *  gnu/regexp/CharIndexed.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
/**
 * Defines the interface used internally so that different types of source
 * text can be accessed in the same way.  Built-in concrete classes provide
 * support for String, StringBuffer, InputStream and char[] types.
 * A class that is CharIndexed supports the notion of a cursor within a
 * block of text.  The cursor must be able to be advanced via the move()
 * method.  The charAt() method returns the character at the cursor position
 * plus a given offset.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public interface CharIndexed {
    /**
     * Defines a constant (0xFFFF was somewhat arbitrarily chosen)
     * that can be returned by the charAt() function indicating that
     * the specified index is out of range.
     */
    char OUT_OF_BOUNDS = '\uFFFF';
    /**
     * Returns the character at the given offset past the current cursor
     * position in the input.  The index of the current position is zero.
     * It is possible for this method to be called with a negative index.
     * This happens when using the '^' operator in multiline matching mode
     * or the '\b' or '\<' word boundary operators.  In any case, the lower
     * bound is currently fixed at -2 (for '^' with a two-character newline).
     *
     * @param index the offset position in the character field to examine
     * @return the character at the specified index, or the OUT_OF_BOUNDS
     *   character defined by this interface.
     */
    char charAt(int index);
    /**
     * Shifts the input buffer by a given number of positions.  Returns
     * true if the new cursor position is valid.
     */
    boolean move(int index);
    /**
     * Returns true if the most recent move() operation placed the cursor
     * position at a valid position in the input.
     */
    boolean isValid();
}
"
gnu.regexp.CharIndexedCharArray,"/*
 *  gnu/regexp/CharIndexedCharArray.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
class CharIndexedCharArray implements CharIndexed, Serializable {
    private char[] s;
    private int anchor;
    CharIndexedCharArray(char[] str, int index) {
	s = str;
	anchor = index;
    }
    public char charAt(int index) {
	int pos = anchor + index;
	return ((pos < s.length) && (pos >= 0)) ? s[pos] : OUT_OF_BOUNDS;
    }
    public boolean isValid() {
	return (anchor < s.length);
    }
    public boolean move(int index) {
	return ((anchor += index) < s.length);
    }
}
"
gnu.regexp.CharIndexedInputStream,"/*
 *  gnu/regexp/CharIndexedReader.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
// TODO: move(x) shouldn't rely on calling next() x times
class CharIndexedInputStream implements CharIndexed {
    private static final int BUFFER_INCREMENT = 1024;
    private static final int UNKNOWN = Integer.MAX_VALUE; // value for end
    private BufferedInputStream br;
    // so that we don't try to reset() right away
    private int index = -1;
    private int bufsize = BUFFER_INCREMENT;
    private int end = UNKNOWN;
    private char cached = OUT_OF_BOUNDS;
    // Big enough for a \r\n pair
    // lookBehind[0] = most recent
    // lookBehind[1] = second most recent
    private char[] lookBehind = new char[] { OUT_OF_BOUNDS, OUT_OF_BOUNDS }; 
    CharIndexedInputStream(InputStream str, int index) {
	if (str instanceof BufferedInputStream) br = (BufferedInputStream) str;
	else br = new BufferedInputStream(str,BUFFER_INCREMENT);
	next();
	if (index > 0) move(index);
    }
    private boolean next() {
	if (end == 1) return false;
	end--; // closer to end
	try {
	    if (index != -1) {
		br.reset();
	    }
	    int i = br.read();
	    br.mark(bufsize);
	    if (i == -1) {
		end = 1;
		cached = OUT_OF_BOUNDS;
		return false;
	    }
	    cached = (char) i;
	    index = 1;
	} catch (IOException e) { 
	    e.printStackTrace();
	    cached = OUT_OF_BOUNDS;
	    return false; 
	}
	return true;
    }
    public char charAt(int index) {
	if (index == 0) {
	    return cached;
	} else if (index >= end) {
	    return OUT_OF_BOUNDS;
	} else if (index == -1) {
	    return lookBehind[0];
	} else if (index == -2) {
	    return lookBehind[1];
	} else if (index < -2) {
	    return OUT_OF_BOUNDS;
	} else if (index >= bufsize) {
	    // Allocate more space in the buffer.
	    try {
		while (bufsize <= index) bufsize += BUFFER_INCREMENT;
		br.reset();
		br.mark(bufsize);
		br.skip(index-1);
	    } catch (IOException e) { }
	} else if (this.index != index) {
	    try {
		br.reset();
		br.skip(index-1);
	    } catch (IOException e) { }
	}
	char ch = OUT_OF_BOUNDS;
	try {
	    int i = br.read();
	    this.index = index+1; // this.index is index of next pos relative to charAt(0)
	    if (i == -1) {
		// set flag that next should fail next time?
		end = index;
		return ch;
	    }
	    ch = (char) i;
	} catch (IOException ie) { }
	return ch;
    }
    public boolean move(int index) {
	// move read position [index] clicks from 'charAt(0)'
	boolean retval = true;
	while (retval && (index-- > 0)) retval = next();
	return retval;
    }
    public boolean isValid() {
	return (cached != OUT_OF_BOUNDS);
    }
}
"
gnu.regexp.CharIndexedReader,"/*
 *  gnu/regexp/CharIndexedReader.java
 *  Copyright (C) 2001 Lee Sau Dan
 *  Based on gnu.regexp.CharIndexedInputStream by Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.IOException;
// TODO: move(x) shouldn't rely on calling next() x times
class CharIndexedReader implements CharIndexed {
    private static final int BUFFER_INCREMENT = 1024;
    private static final int UNKNOWN = Integer.MAX_VALUE; // value for end
    private final BufferedReader br;
    // so that we don't try to reset() right away
    private int index = -1;
    private int bufsize = BUFFER_INCREMENT;
    private int end = UNKNOWN;
    private char cached = OUT_OF_BOUNDS;
    // Big enough for a \r\n pair
    // lookBehind[0] = most recent
    // lookBehind[1] = second most recent
    private char[] lookBehind = new char[] { OUT_OF_BOUNDS, OUT_OF_BOUNDS }; 
    CharIndexedReader(Reader reader, int index) {
	if (reader instanceof BufferedReader) {
	    br = (BufferedReader) reader; 
	} else {
	    br = new BufferedReader(reader,BUFFER_INCREMENT);
	}
	next();
	if (index > 0) move(index);
    }
    private boolean next() {
	lookBehind[1] = lookBehind[0];
	lookBehind[0] = cached;
	if (end == 1) {
	    cached = OUT_OF_BOUNDS;
	    return false;
	}
	end--; // closer to end
	try {
	    if (index != -1) {
		br.reset();
	    }
	    int i = br.read();
	    br.mark(bufsize);
	    if (i == -1) {
		end = 1;
		cached = OUT_OF_BOUNDS;
		return false;
	    }
	    // convert the byte read into a char
	    cached = (char) i;
	    index = 1;
	} catch (IOException e) { 
	    e.printStackTrace();
	    cached = OUT_OF_BOUNDS;
	    return false; 
	}
	return true;
    }
    public char charAt(int index) {
	if (index == 0) {
	    return cached;
	} else if (index >= end) {
	    return OUT_OF_BOUNDS;
	} else if (index >= bufsize) {
	    // Allocate more space in the buffer.
	    try {
		while (bufsize <= index) bufsize += BUFFER_INCREMENT;
		br.reset();
		br.mark(bufsize);
		br.skip(index-1);
	    } catch (IOException e) { }
	} else if (this.index != index) {
	    try {
		br.reset();
		br.skip(index-1);
	    } catch (IOException e) { }
	} else if (index == -1) {
	    return lookBehind[0];
	} else if (index == -2) {
	    return lookBehind[1];
	} else if (index < -2) {
	    return OUT_OF_BOUNDS;
	}
	char ch = OUT_OF_BOUNDS;
	try {
	    int i = br.read();
	    this.index = index+1; // this.index is index of next pos relative to charAt(0)
	    if (i == -1) {
		// set flag that next should fail next time?
		end = index;
		return ch;
	    }
	    ch = (char) i;
	} catch (IOException ie) { }
	return ch;
    }
    public boolean move(int index) {
	// move read position [index] clicks from 'charAt(0)'
	boolean retval = true;
	while (retval && (index-- > 0)) retval = next();
	return retval;
    }
    public boolean isValid() {
	return (cached != OUT_OF_BOUNDS);
    }
}
"
gnu.regexp.CharIndexedString,"/*
 *  gnu/regexp/CharIndexedString.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
class CharIndexedString implements CharIndexed, Serializable {
    private String s;
    private int anchor;
    private int len;
    CharIndexedString(String str, int index) {
	s = str;
	len = s.length();
	anchor = index;
    }
    public char charAt(int index) {
	int pos = anchor + index;
	return ((pos < len) && (pos >= 0)) ? s.charAt(pos) : OUT_OF_BOUNDS;
    }
    public boolean isValid() {
	return (anchor < len);
    }
    public boolean move(int index) {
	return ((anchor += index) < len);
    }
}
"
gnu.regexp.CharIndexedStringBuffer,"/*
 *  gnu/regexp/CharIndexedStringBuffer.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
class CharIndexedStringBuffer implements CharIndexed, Serializable {
    private StringBuffer s;
    private int anchor;
    CharIndexedStringBuffer(StringBuffer str, int index) {
	s = str;
	anchor = index;
    }
  public char charAt(int index) {
      int pos = anchor + index;
    return ((pos < s.length()) && (pos >= 0)) ? s.charAt(pos) : OUT_OF_BOUNDS;
  }
  public boolean isValid() {
    return (anchor < s.length());
  }
  public boolean move(int index) {
    return ((anchor += index) < s.length());
  }
}
"
gnu.regexp.RE,"/*
 *  gnu/regexp/RE.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.InputStream;
import java.io.Reader;
import java.io.Serializable;
import java.util.Locale;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Vector;
class IntPair implements Serializable {
  public int first, second;
}
class CharUnit implements Serializable {
  public char ch;
  public boolean bk;
}
/**
 * RE provides the user interface for compiling and matching regular
 * expressions.
 * <P>
 * A regular expression object (class RE) is compiled by constructing it
 * from a String, StringBuffer or character array, with optional 
 * compilation flags (below)
 * and an optional syntax specification (see RESyntax; if not specified,
 * <code>RESyntax.RE_SYNTAX_PERL5</code> is used).
 * <P>
 * Once compiled, a regular expression object is reusable as well as
 * threadsafe: multiple threads can use the RE instance simultaneously
 * to match against different input text.
 * <P>
 * Various methods attempt to match input text against a compiled
 * regular expression.  These methods are:
 * <LI><code>isMatch</code>: returns true if the input text in its
 * entirety matches the regular expression pattern.
 * <LI><code>getMatch</code>: returns the first match found in the
 * input text, or null if no match is found.
 * <LI><code>getAllMatches</code>: returns an array of all
 * non-overlapping matches found in the input text.  If no matches are
 * found, the array is zero-length.
 * <LI><code>substitute</code>: substitute the first occurence of the
 * pattern in the input text with a replacement string (which may
 * include metacharacters $0-$9, see REMatch.substituteInto).
 * <LI><code>substituteAll</code>: same as above, but repeat for each
 * match before returning.
 * <LI><code>getMatchEnumeration</code>: returns an REMatchEnumeration
 * object that allows iteration over the matches (see
 * REMatchEnumeration for some reasons why you may want to do this
 * instead of using <code>getAllMatches</code>.
 * <P>
 *
 * These methods all have similar argument lists.  The input can be a
 * String, a character array, a StringBuffer, a Reader or an
 * InputStream of some sort.  Note that when using a Reader or
 * InputStream, the stream read position cannot be guaranteed after
 * attempting a match (this is not a bug, but a consequence of the way
 * regular expressions work).  Using an REMatchEnumeration can
 * eliminate most positioning problems.
 *
 * <P>
 *
 * The optional index argument specifies the offset from the beginning
 * of the text at which the search should start (see the descriptions
 * of some of the execution flags for how this can affect positional
 * pattern operators).  For a Reader or InputStream, this means an
 * offset from the current read position, so subsequent calls with the
 * same index argument on a Reader or an InputStream will not
 * necessarily access the same position on the stream, whereas
 * repeated searches at a given index in a fixed string will return
 * consistent results.
 *
 * <P>
 * You can optionally affect the execution environment by using a
 * combination of execution flags (constants listed below).
 * 
 * <P>
 * All operations on a regular expression are performed in a
 * thread-safe manner.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 * @version 1.1.5-dev, to be released
 */
public class RE extends REToken {
  // This String will be returned by getVersion()
  private static final String VERSION = ""1.1.5-dev"";
  // The localized strings are kept in a separate file
  private static ResourceBundle messages = PropertyResourceBundle.getBundle(""gnu/regexp/MessagesBundle"", Locale.getDefault());
  // These are, respectively, the first and last tokens in our linked list
  // If there is only one token, firstToken == lastToken
  private REToken firstToken, lastToken;
  // This is the number of subexpressions in this regular expression,
  // with a minimum value of zero.  Returned by getNumSubs()
  private int numSubs;
    /** Minimum length, in characters, of any possible match. */
    private int minimumLength;
  /**
   * Compilation flag. Do  not  differentiate  case.   Subsequent
   * searches  using  this  RE will be case insensitive.
   */
  public static final int REG_ICASE = 2;
  /**
   * Compilation flag. The match-any-character operator (dot)
   * will match a newline character.  When set this overrides the syntax
   * bit RE_DOT_NEWLINE (see RESyntax for details).  This is equivalent to
   * the ""/s"" operator in Perl.
   */
  public static final int REG_DOT_NEWLINE = 4;
  /**
   * Compilation flag. Use multiline mode.  In this mode, the ^ and $
   * anchors will match based on newlines within the input. This is
   * equivalent to the ""/m"" operator in Perl.
   */
  public static final int REG_MULTILINE = 8;
  /**
   * Execution flag.
   * The match-beginning operator (^) will not match at the beginning
   * of the input string. Useful for matching on a substring when you
   * know the context of the input is such that position zero of the
   * input to the match test is not actually position zero of the text.
   * <P>
   * This example demonstrates the results of various ways of matching on
   * a substring.
   * <P>
   * <CODE>
   * String s = ""food bar fool"";<BR>
   * RE exp = new RE(""^foo."");<BR>
   * REMatch m0 = exp.getMatch(s);<BR>
   * REMatch m1 = exp.getMatch(s.substring(8));<BR>
   * REMatch m2 = exp.getMatch(s.substring(8),0,RE.REG_NOTBOL); <BR>
   * REMatch m3 = exp.getMatch(s,8);                            <BR>
   * REMatch m4 = exp.getMatch(s,8,RE.REG_ANCHORINDEX);         <BR>
   * <P>
   * // Results:<BR>
   * //  m0.toString(): ""food""<BR>
   * //  m1.toString(): ""fool""<BR>
   * //  m2.toString(): null<BR>
   * //  m3.toString(): null<BR>
   * //  m4.toString(): ""fool""<BR>
   * </CODE>
   */
  public static final int REG_NOTBOL = 16;
  /**
   * Execution flag.
   * The match-end operator ($) does not match at the end
   * of the input string. Useful for matching on substrings.
   */
  public static final int REG_NOTEOL = 32;
  /**
   * Execution flag.
   * When a match method is invoked that starts matching at a non-zero
   * index into the input, treat the input as if it begins at the index
   * given.  The effect of this flag is that the engine does not ""see""
   * any text in the input before the given index.  This is useful so
   * that the match-beginning operator (^) matches not at position 0
   * in the input string, but at the position the search started at
   * (based on the index input given to the getMatch function).  See
   * the example under REG_NOTBOL.  It also affects the use of the \&lt;
   * and \b operators.
   */
  public static final int REG_ANCHORINDEX = 64;
  /**
   * Execution flag.
   * The substitute and substituteAll methods will not attempt to
   * interpolate occurrences of $1-$9 in the replacement text with
   * the corresponding subexpressions.  For example, you may want to
   * replace all matches of ""one dollar"" with ""$1"".
   */
  public static final int REG_NO_INTERPOLATE = 128;
  /** Returns a string representing the version of the gnu.regexp package. */
  public static final String version() {
    return VERSION;
  }
  // Retrieves a message from the ResourceBundle
  static final String getLocalizedMessage(String key) {
    return messages.getString(key);
  }
  /**
   * Constructs a regular expression pattern buffer without any compilation
   * flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5).
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @exception REException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public RE(Object pattern) throws REException {
    this(pattern,0,RESyntax.RE_SYNTAX_PERL5,0,0);
  }
  /**
   * Constructs a regular expression pattern buffer using the specified
   * compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5).
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer, or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @param cflags The logical OR of any combination of the compilation flags listed above.
   * @exception REException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public RE(Object pattern, int cflags) throws REException {
    this(pattern,cflags,RESyntax.RE_SYNTAX_PERL5,0,0);
  }
  /**
   * Constructs a regular expression pattern buffer using the specified
   * compilation flags and regular expression syntax.
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer, or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @param cflags The logical OR of any combination of the compilation flags listed above.
   * @param syntax The type of regular expression syntax to use.
   * @exception REException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public RE(Object pattern, int cflags, RESyntax syntax) throws REException {
    this(pattern,cflags,syntax,0,0);
  }
  // internal constructor used for alternation
  private RE(REToken first, REToken last,int subs, int subIndex, int minLength) {
    super(subIndex);
    firstToken = first;
    lastToken = last;
    numSubs = subs;
    minimumLength = minLength;
    addToken(new RETokenEndSub(subIndex));
  }
  private RE(Object patternObj, int cflags, RESyntax syntax, int myIndex, int nextSub) throws REException {
    super(myIndex); // Subexpression index of this token.
    initialize(patternObj, cflags, syntax, myIndex, nextSub);
  }
    // For use by subclasses
    protected RE() { super(0); }
    // The meat of construction
  protected void initialize(Object patternObj, int cflags, RESyntax syntax, int myIndex, int nextSub) throws REException {
      char[] pattern;
    if (patternObj instanceof String) {
      pattern = ((String) patternObj).toCharArray();
    } else if (patternObj instanceof char[]) {
      pattern = (char[]) patternObj;
    } else if (patternObj instanceof StringBuffer) {
      pattern = new char [((StringBuffer) patternObj).length()];
      ((StringBuffer) patternObj).getChars(0,pattern.length,pattern,0);
    } else {
	pattern = patternObj.toString().toCharArray();
    }
    int pLength = pattern.length;
    numSubs = 0; // Number of subexpressions in this token.
    Vector branches = null;
    // linked list of tokens (sort of -- some closed loops can exist)
    firstToken = lastToken = null;
    // Precalculate these so we don't pay for the math every time we
    // need to access them.
    boolean insens = ((cflags & REG_ICASE) > 0);
    // Parse pattern into tokens.  Does anyone know if it's more efficient
    // to use char[] than a String.charAt()?  I'm assuming so.
    // index tracks the position in the char array
    int index = 0;
    // this will be the current parse character (pattern[index])
    CharUnit unit = new CharUnit();
    // This is used for {x,y} calculations
    IntPair minMax = new IntPair();
    // Buffer a token so we can create a TokenRepeated, etc.
    REToken currentToken = null;
    char ch;
    while (index < pLength) {
      // read the next character unit (including backslash escapes)
      index = getCharUnit(pattern,index,unit);
      // ALTERNATION OPERATOR
      //  \| or | (if RE_NO_BK_VBAR) or newline (if RE_NEWLINE_ALT)
      //  not available if RE_LIMITED_OPS is set
      // TODO: the '\n' literal here should be a test against REToken.newline,
      // which unfortunately may be more than a single character.
      if ( ( (unit.ch == '|' && (syntax.get(RESyntax.RE_NO_BK_VBAR) ^ unit.bk))
	     || (syntax.get(RESyntax.RE_NEWLINE_ALT) && (unit.ch == '\n') && !unit.bk) )
	   && !syntax.get(RESyntax.RE_LIMITED_OPS)) {
	// make everything up to here be a branch. create vector if nec.
	addToken(currentToken);
	RE theBranch = new RE(firstToken, lastToken, numSubs, subIndex, minimumLength);
	minimumLength = 0;
	if (branches == null) {
	    branches = new Vector();
	}
	branches.addElement(theBranch);
	firstToken = lastToken = currentToken = null;
      }
      // INTERVAL OPERATOR:
      //  {x} | {x,} | {x,y}  (RE_INTERVALS && RE_NO_BK_BRACES)
      //  \{x\} | \{x,\} | \{x,y\} (RE_INTERVALS && !RE_NO_BK_BRACES)
      //
      // OPEN QUESTION: 
      //  what is proper interpretation of '{' at start of string?
      else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)) {
	int newIndex = getMinMax(pattern,index,minMax,syntax);
        if (newIndex > index) {
          if (minMax.first > minMax.second)
            throw new REException(getLocalizedMessage(""interval.order""),REException.REG_BADRPT,newIndex);
          if (currentToken == null)
            throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,newIndex);
          if (currentToken instanceof RETokenRepeated) 
            throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,newIndex);
          if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
            throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,newIndex);
          if ((currentToken.getMinimumLength() == 0) && (minMax.second == Integer.MAX_VALUE))
            throw new REException(getLocalizedMessage(""repeat.empty.token""),REException.REG_BADRPT,newIndex);
          index = newIndex;
          currentToken = setRepeated(currentToken,minMax.first,minMax.second,index); 
        }
        else {
          addToken(currentToken);
          currentToken = new RETokenChar(subIndex,unit.ch,insens);
        } 
      }
      // LIST OPERATOR:
      //  [...] | [^...]
      else if ((unit.ch == '[') && !unit.bk) {
	Vector options = new Vector();
	boolean negative = false;
	char lastChar = 0;
	if (index == pLength) throw new REException(getLocalizedMessage(""unmatched.bracket""),REException.REG_EBRACK,index);
	// Check for initial caret, negation
	if ((ch = pattern[index]) == '^') {
	  negative = true;
	  if (++index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	  ch = pattern[index];
	}
	// Check for leading right bracket literal
	if (ch == ']') {
	  lastChar = ch;
	  if (++index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	}
	while ((ch = pattern[index++]) != ']') {
	  if ((ch == '-') && (lastChar != 0)) {
	    if (index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	    if ((ch = pattern[index]) == ']') {
	      options.addElement(new RETokenChar(subIndex,lastChar,insens));
	      lastChar = '-';
	    } else {
	      options.addElement(new RETokenRange(subIndex,lastChar,ch,insens));
	      lastChar = 0;
	      index++;
	    }
          } else if ((ch == '\\') && syntax.get(RESyntax.RE_BACKSLASH_ESCAPE_IN_LISTS)) {
            if (index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	    int posixID = -1;
	    boolean negate = false;
            char asciiEsc = 0;
	    if ((""dswDSW"".indexOf(pattern[index]) != -1) && syntax.get(RESyntax.RE_CHAR_CLASS_ESC_IN_LISTS)) {
	      switch (pattern[index]) {
	      case 'D':
		negate = true;
	      case 'd':
		posixID = RETokenPOSIX.DIGIT;
		break;
	      case 'S':
		negate = true;
	      case 's':
		posixID = RETokenPOSIX.SPACE;
		break;
	      case 'W':
		negate = true;
	      case 'w':
		posixID = RETokenPOSIX.ALNUM;
		break;
	      }
	    }
            else if (""nrt"".indexOf(pattern[index]) != -1) {
              switch (pattern[index]) {
                case 'n':
                  asciiEsc = '\n';
                  break;
                case 't':
                  asciiEsc = '\t';
                  break;
                case 'r':
                  asciiEsc = '\r';
                  break;
              }
            }
	    if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
	    if (posixID != -1) {
	      options.addElement(new RETokenPOSIX(subIndex,posixID,insens,negate));
	    } else if (asciiEsc != 0) {
	      lastChar = asciiEsc;
	    } else {
	      lastChar = pattern[index];
	    }
	    ++index;
	  } else if ((ch == '[') && (syntax.get(RESyntax.RE_CHAR_CLASSES)) && (index < pLength) && (pattern[index] == ':')) {
	    StringBuffer posixSet = new StringBuffer();
	    index = getPosixSet(pattern,index+1,posixSet);
	    int posixId = RETokenPOSIX.intValue(posixSet.toString());
	    if (posixId != -1)
	      options.addElement(new RETokenPOSIX(subIndex,posixId,insens,false));
	  } else {
	    if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
	    lastChar = ch;
	  }
	  if (index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	} // while in list
	// Out of list, index is one past ']'
	if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
	// Create a new RETokenOneOf
	addToken(currentToken);
	options.trimToSize();
	currentToken = new RETokenOneOf(subIndex,options,negative);
      }
      // SUBEXPRESSIONS
      //  (...) | \(...\) depending on RE_NO_BK_PARENS
      else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) {
	boolean pure = false;
	boolean comment = false;
        boolean lookAhead = false;
        boolean negativelh = false;
	if ((index+1 < pLength) && (pattern[index] == '?')) {
	  switch (pattern[index+1]) {
          case '!':
            if (syntax.get(RESyntax.RE_LOOKAHEAD)) {
              pure = true;
              negativelh = true;
              lookAhead = true;
              index += 2;
            }
            break;
          case '=':
            if (syntax.get(RESyntax.RE_LOOKAHEAD)) {
              pure = true;
              lookAhead = true;
              index += 2;
            }
            break;
	  case ':':
	    if (syntax.get(RESyntax.RE_PURE_GROUPING)) {
	      pure = true;
	      index += 2;
	    }
	    break;
	  case '#':
	    if (syntax.get(RESyntax.RE_COMMENTS)) {
	      comment = true;
	    }
	    break;
          default:
            throw new REException(getLocalizedMessage(""repeat.no.token""), REException.REG_BADRPT, index);
	  }
	}
	if (index >= pLength) {
	    throw new REException(getLocalizedMessage(""unmatched.paren""), REException.REG_ESUBREG,index);
	}
	// find end of subexpression
	int endIndex = index;
	int nextIndex = index;
	int nested = 0;
	while ( ((nextIndex = getCharUnit(pattern,endIndex,unit)) > 0)
		&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) )
	  if ((endIndex = nextIndex) >= pLength)
	    throw new REException(getLocalizedMessage(""subexpr.no.end""),REException.REG_ESUBREG,nextIndex);
	  else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))
	    nested++;
	  else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))
	    nested--;
	// endIndex is now position at a ')','\)' 
	// nextIndex is end of string or position after ')' or '\)'
	if (comment) index = nextIndex;
	else { // not a comment
	  // create RE subexpression as token.
	  addToken(currentToken);
	  if (!pure) {
	    numSubs++;
	  }
	  int useIndex = (pure || lookAhead) ? 0 : nextSub + numSubs;
	  currentToken = new RE(String.valueOf(pattern,index,endIndex-index).toCharArray(),cflags,syntax,useIndex,nextSub + numSubs);
	  numSubs += ((RE) currentToken).getNumSubs();
          if (lookAhead) {
	      currentToken = new RETokenLookAhead(currentToken,negativelh);
	  }
	  index = nextIndex;
	} // not a comment
      } // subexpression
      // UNMATCHED RIGHT PAREN
      // ) or \) throw exception if
      // !syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD)
      else if (!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD) && ((unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))) {
	throw new REException(getLocalizedMessage(""unmatched.paren""),REException.REG_EPAREN,index);
      }
      // START OF LINE OPERATOR
      //  ^
      else if ((unit.ch == '^') && !unit.bk) {
	addToken(currentToken);
	currentToken = null;
	addToken(new RETokenStart(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));
      }
      // END OF LINE OPERATOR
      //  $
      else if ((unit.ch == '$') && !unit.bk) {
	addToken(currentToken);
	currentToken = null;
	addToken(new RETokenEnd(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));
      }
      // MATCH-ANY-CHARACTER OPERATOR (except possibly newline and null)
      //  .
      else if ((unit.ch == '.') && !unit.bk) {
	addToken(currentToken);
	currentToken = new RETokenAny(subIndex,syntax.get(RESyntax.RE_DOT_NEWLINE) || ((cflags & REG_DOT_NEWLINE) > 0),syntax.get(RESyntax.RE_DOT_NOT_NULL));
      }
      // ZERO-OR-MORE REPEAT OPERATOR
      //  *
      else if ((unit.ch == '*') && !unit.bk) {
	if (currentToken == null)
          throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenRepeated)
          throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
	  throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,index);
	if (currentToken.getMinimumLength() == 0)
	  throw new REException(getLocalizedMessage(""repeat.empty.token""),REException.REG_BADRPT,index);
	currentToken = setRepeated(currentToken,0,Integer.MAX_VALUE,index);
      }
      // ONE-OR-MORE REPEAT OPERATOR
      //  + | \+ depending on RE_BK_PLUS_QM
      //  not available if RE_LIMITED_OPS is set
      else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {
	if (currentToken == null)
          throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenRepeated)
          throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
	  throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,index);
	if (currentToken.getMinimumLength() == 0)
	  throw new REException(getLocalizedMessage(""repeat.empty.token""),REException.REG_BADRPT,index);
	currentToken = setRepeated(currentToken,1,Integer.MAX_VALUE,index);
      }
      // ZERO-OR-ONE REPEAT OPERATOR / STINGY MATCHING OPERATOR
      //  ? | \? depending on RE_BK_PLUS_QM
      //  not available if RE_LIMITED_OPS is set
      //  stingy matching if RE_STINGY_OPS is set and it follows a quantifier
      else if ((unit.ch == '?') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {
	if (currentToken == null) throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
	// Check for stingy matching on RETokenRepeated
	if (currentToken instanceof RETokenRepeated) {
          if (syntax.get(RESyntax.RE_STINGY_OPS) && !((RETokenRepeated)currentToken).isStingy())
            ((RETokenRepeated)currentToken).makeStingy();
          else
            throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,index);
        }
        else if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
          throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,index);
	else
	  currentToken = setRepeated(currentToken,0,1,index);
      }
      // BACKREFERENCE OPERATOR
      //  \1 \2 ... \9
      // not available if RE_NO_BK_REFS is set
      else if (unit.bk && Character.isDigit(unit.ch) && !syntax.get(RESyntax.RE_NO_BK_REFS)) {
	addToken(currentToken);
	currentToken = new RETokenBackRef(subIndex,Character.digit(unit.ch,10),insens);
      }
      // START OF STRING OPERATOR
      //  \A if RE_STRING_ANCHORS is set
      else if (unit.bk && (unit.ch == 'A') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	addToken(currentToken);
	currentToken = new RETokenStart(subIndex,null);
      }
      // WORD BREAK OPERATOR
      //  \b if ????
      else if (unit.bk && (unit.ch == 'b') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, false);
      } 
      // WORD BEGIN OPERATOR 
      //  \< if ????
      else if (unit.bk && (unit.ch == '<')) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN, false);
      } 
      // WORD END OPERATOR 
      //  \> if ????
      else if (unit.bk && (unit.ch == '>')) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.END, false);
      } 
      // NON-WORD BREAK OPERATOR
      // \B if ????
      else if (unit.bk && (unit.ch == 'B') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, true);
      } 
      // DIGIT OPERATOR
      //  \d if RE_CHAR_CLASS_ESCAPES is set
      else if (unit.bk && (unit.ch == 'd') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	addToken(currentToken);
	currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,false);
      }
      // NON-DIGIT OPERATOR
      //  \D
	else if (unit.bk && (unit.ch == 'D') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,true);
	}
	// NEWLINE ESCAPE
        //  \n
	else if (unit.bk && (unit.ch == 'n')) {
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,'\n',false);
	}
	// RETURN ESCAPE
        //  \r
	else if (unit.bk && (unit.ch == 'r')) {
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,'\r',false);
	}
	// WHITESPACE OPERATOR
        //  \s if RE_CHAR_CLASS_ESCAPES is set
	else if (unit.bk && (unit.ch == 's') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,false);
	}
	// NON-WHITESPACE OPERATOR
        //  \S
	else if (unit.bk && (unit.ch == 'S') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,true);
	}
	// TAB ESCAPE
        //  \t
	else if (unit.bk && (unit.ch == 't')) {
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,'\t',false);
	}
	// ALPHANUMERIC OPERATOR
        //  \w
	else if (unit.bk && (unit.ch == 'w') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,false);
	}
	// NON-ALPHANUMERIC OPERATOR
        //  \W
	else if (unit.bk && (unit.ch == 'W') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,true);
	}
	// END OF STRING OPERATOR
        //  \Z
	else if (unit.bk && (unit.ch == 'Z') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	  addToken(currentToken);
	  currentToken = new RETokenEnd(subIndex,null);
	}
	// NON-SPECIAL CHARACTER (or escape to make literal)
        //  c | \* for example
	else {  // not a special character
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,unit.ch,insens);
	} 
      } // end while
    // Add final buffered token and an EndSub marker
    addToken(currentToken);
    if (branches != null) {
	branches.addElement(new RE(firstToken,lastToken,numSubs,subIndex,minimumLength));
	branches.trimToSize(); // compact the Vector
	minimumLength = 0;
	firstToken = lastToken = null;
	addToken(new RETokenOneOf(subIndex,branches,false));
    } 
    else addToken(new RETokenEndSub(subIndex));
  }
  private static int getCharUnit(char[] input, int index, CharUnit unit) throws REException {
    unit.ch = input[index++];
    if (unit.bk = (unit.ch == '\\'))
      if (index < input.length)
	unit.ch = input[index++];
      else throw new REException(getLocalizedMessage(""ends.with.backslash""),REException.REG_ESCAPE,index);
    return index;
  }
  /**
   * Checks if the regular expression matches the input in its entirety.
   *
   * @param input The input text.
   */
  public boolean isMatch(Object input) {
    return isMatch(input,0,0);
  }
  /**
   * Checks if the input string, starting from index, is an exact match of
   * this regular expression.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   */
  public boolean isMatch(Object input,int index) {
    return isMatch(input,index,0);
  }
  /**
   * Checks if the input, starting from index and using the specified
   * execution flags, is an exact match of this regular expression.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   */
  public boolean isMatch(Object input,int index,int eflags) {
    return isMatchImpl(makeCharIndexed(input,index),index,eflags);
  }
  private boolean isMatchImpl(CharIndexed input, int index, int eflags) {
    if (firstToken == null)  // Trivial case
      return (input.charAt(0) == CharIndexed.OUT_OF_BOUNDS);
    REMatch m = new REMatch(numSubs, index, eflags);
    if (firstToken.match(input, m)) {
	while (m != null) {
	    if (input.charAt(m.index) == CharIndexed.OUT_OF_BOUNDS) {
		return true;
	    }
	    m = m.next;
	}
    }
    return false;
  }
  /**
   * Returns the maximum number of subexpressions in this regular expression.
   * If the expression contains branches, the value returned will be the
   * maximum subexpressions in any of the branches.
   */
  public int getNumSubs() {
    return numSubs;
  }
  // Overrides REToken.setUncle
  void setUncle(REToken uncle) {
      if (lastToken != null) {
	  lastToken.setUncle(uncle);
      } else super.setUncle(uncle); // to deal with empty subexpressions
  }
  // Overrides REToken.chain
  boolean chain(REToken next) {
    super.chain(next);
    setUncle(next);
    return true;
  }
  /**
   * Returns the minimum number of characters that could possibly
   * constitute a match of this regular expression.
   */
  public int getMinimumLength() {
      return minimumLength;
  }
  /**
   * Returns an array of all matches found in the input.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @return a non-null (but possibly zero-length) array of matches
   */
  public REMatch[] getAllMatches(Object input) {
    return getAllMatches(input,0,0);
  }
  /**
   * Returns an array of all matches found in the input,
   * beginning at the specified index position.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @return a non-null (but possibly zero-length) array of matches
   */
  public REMatch[] getAllMatches(Object input, int index) {
    return getAllMatches(input,index,0);
  }
  /**
   * Returns an array of all matches found in the input string,
   * beginning at the specified index position and using the specified
   * execution flags.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @return a non-null (but possibly zero-length) array of matches
   */
  public REMatch[] getAllMatches(Object input, int index, int eflags) {
    return getAllMatchesImpl(makeCharIndexed(input,index),index,eflags);
  }
  // this has been changed since 1.03 to be non-overlapping matches
  private REMatch[] getAllMatchesImpl(CharIndexed input, int index, int eflags) {
    Vector all = new Vector();
    REMatch m = null;
    while ((m = getMatchImpl(input,index,eflags,null)) != null) {
      all.addElement(m);
      index = m.getEndIndex();
      if (m.end[0] == 0) {   // handle pathological case of zero-length match
	index++;
	input.move(1);
      } else {
	input.move(m.end[0]);
      }
      if (!input.isValid()) break;
    }
    REMatch[] mset = new REMatch[all.size()];
    all.copyInto(mset);
    return mset;
  }
    /* Implements abstract method REToken.match() */
    boolean match(CharIndexed input, REMatch mymatch) { 
	if (firstToken == null) return next(input, mymatch);
	// Note the start of this subexpression
	mymatch.start[subIndex] = mymatch.index;
	return firstToken.match(input, mymatch);
    }
  /**
   * Returns the first match found in the input.  If no match is found,
   * null is returned.
   *
   * @param input The input text.
   * @return An REMatch instance referencing the match, or null if none.
   */
  public REMatch getMatch(Object input) {
    return getMatch(input,0,0);
  }
  /**
   * Returns the first match found in the input, beginning
   * the search at the specified index.  If no match is found,
   * returns null.
   *
   * @param input The input text.
   * @param index The offset within the text to begin looking for a match.
   * @return An REMatch instance referencing the match, or null if none.
   */
  public REMatch getMatch(Object input, int index) {
    return getMatch(input,index,0);
  }
  /**
   * Returns the first match found in the input, beginning
   * the search at the specified index, and using the specified
   * execution flags.  If no match is found, returns null.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @return An REMatch instance referencing the match, or null if none.
   */
  public REMatch getMatch(Object input, int index, int eflags) {
    return getMatch(input,index,eflags,null);
  }
  /**
   * Returns the first match found in the input, beginning the search
   * at the specified index, and using the specified execution flags.
   * If no match is found, returns null.  If a StringBuffer is
   * provided and is non-null, the contents of the input text from the
   * index to the beginning of the match (or to the end of the input,
   * if there is no match) are appended to the StringBuffer.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @param buffer The StringBuffer to save pre-match text in.
   * @return An REMatch instance referencing the match, or null if none.  */
  public REMatch getMatch(Object input, int index, int eflags, StringBuffer buffer) {
    return getMatchImpl(makeCharIndexed(input,index),index,eflags,buffer);
  }
  REMatch getMatchImpl(CharIndexed input, int anchor, int eflags, StringBuffer buffer) {
      // Create a new REMatch to hold results
      REMatch mymatch = new REMatch(numSubs, anchor, eflags);
      do {
	  // Optimization: check if anchor + minimumLength > length
	  if (minimumLength == 0 || input.charAt(minimumLength-1) != CharIndexed.OUT_OF_BOUNDS) {
	      if (match(input, mymatch)) {
		  // Find longest match of them all to observe leftmost longest
		  REMatch longest = mymatch;
		  while ((mymatch = mymatch.next) != null) {
		      if (mymatch.index > longest.index) {
			  longest = mymatch;
		      }
		  }
		  longest.end[0] = longest.index;
		  longest.finish(input);
		  return longest;
	      }
	  }
	  mymatch.clear(++anchor);
	  // Append character to buffer if needed
	  if (buffer != null && input.charAt(0) != CharIndexed.OUT_OF_BOUNDS) {
	      buffer.append(input.charAt(0));
	  }
      } while (input.move(1));
      // Special handling at end of input for e.g. ""$""
      if (minimumLength == 0) {
	  if (match(input, mymatch)) {
	      mymatch.finish(input);
	      return mymatch;
	  }
      }
      return null;
  }
  /**
   * Returns an REMatchEnumeration that can be used to iterate over the
   * matches found in the input text.
   *
   * @param input The input text.
   * @return A non-null REMatchEnumeration instance.
   */
  public REMatchEnumeration getMatchEnumeration(Object input) {
    return getMatchEnumeration(input,0,0);
  }
  /**
   * Returns an REMatchEnumeration that can be used to iterate over the
   * matches found in the input text.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @return A non-null REMatchEnumeration instance, with its input cursor
   *  set to the index position specified.
   */
  public REMatchEnumeration getMatchEnumeration(Object input, int index) {
    return getMatchEnumeration(input,index,0);
  }
  /**
   * Returns an REMatchEnumeration that can be used to iterate over the
   * matches found in the input text.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @return A non-null REMatchEnumeration instance, with its input cursor
   *  set to the index position specified.
   */
  public REMatchEnumeration getMatchEnumeration(Object input, int index, int eflags) {
    return new REMatchEnumeration(this,makeCharIndexed(input,index),index,eflags);
  }
  /**
   * Substitutes the replacement text for the first match found in the input.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @return A String interpolating the substituted text.
   * @see REMatch#substituteInto
   */
  public String substitute(Object input,String replace) {
    return substitute(input,replace,0,0);
  }
  /**
   * Substitutes the replacement text for the first match found in the input
   * beginning at the specified index position.  Specifying an index
   * effectively causes the regular expression engine to throw away the
   * specified number of characters. 
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @return A String containing the substring of the input, starting
   *   at the index position, and interpolating the substituted text.
   * @see REMatch#substituteInto
   */
  public String substitute(Object input,String replace,int index) {
    return substitute(input,replace,index,0);
  }
  /**
   * Substitutes the replacement text for the first match found in the input
   * string, beginning at the specified index position and using the
   * specified execution flags.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @return A String containing the substring of the input, starting
   *   at the index position, and interpolating the substituted text.
   * @see REMatch#substituteInto
   */
  public String substitute(Object input,String replace,int index,int eflags) {
    return substituteImpl(makeCharIndexed(input,index),replace,index,eflags);
  }
  private String substituteImpl(CharIndexed input,String replace,int index,int eflags) {
    StringBuffer buffer = new StringBuffer();
    REMatch m = getMatchImpl(input,index,eflags,buffer);
    if (m==null) return buffer.toString();
    buffer.append( ((eflags & REG_NO_INTERPOLATE) > 0) ?
		   replace : m.substituteInto(replace) );
    if (input.move(m.end[0])) {
      do {
	buffer.append(input.charAt(0));
      } while (input.move(1));
    }
    return buffer.toString();
  }
  /**
   * Substitutes the replacement text for each non-overlapping match found 
   * in the input text.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @return A String interpolating the substituted text.
   * @see REMatch#substituteInto
   */
  public String substituteAll(Object input,String replace) {
    return substituteAll(input,replace,0,0);
  }
  /**
   * Substitutes the replacement text for each non-overlapping match found 
   * in the input text, starting at the specified index.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @return A String containing the substring of the input, starting
   *   at the index position, and interpolating the substituted text.
   * @see REMatch#substituteInto
   */
  public String substituteAll(Object input,String replace,int index) {
    return substituteAll(input,replace,index,0);
  }
  /**
   * Substitutes the replacement text for each non-overlapping match found 
   * in the input text, starting at the specified index and using the
   * specified execution flags.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @return A String containing the substring of the input, starting
   *   at the index position, and interpolating the substituted text.
   * @see REMatch#substituteInto
   */
  public String substituteAll(Object input,String replace,int index,int eflags) {
    return substituteAllImpl(makeCharIndexed(input,index),replace,index,eflags);
  }
  private String substituteAllImpl(CharIndexed input,String replace,int index,int eflags) {
    StringBuffer buffer = new StringBuffer();
    REMatch m;
    while ((m = getMatchImpl(input,index,eflags,buffer)) != null) {
	buffer.append( ((eflags & REG_NO_INTERPOLATE) > 0) ?
		       replace : m.substituteInto(replace) );
      index = m.getEndIndex();
      if (m.end[0] == 0) {
	char ch = input.charAt(0);
	if (ch != CharIndexed.OUT_OF_BOUNDS) 
	    buffer.append(ch);
	input.move(1);
      } else {
	  input.move(m.end[0]);
      }
      if (!input.isValid()) break;
    }
    return buffer.toString();
  }
  /* Helper function for constructor */
  private void addToken(REToken next) {
    if (next == null) return;
    minimumLength += next.getMinimumLength();
    if (firstToken == null) {
	lastToken = firstToken = next;
    } else {
      // if chain returns false, it ""rejected"" the token due to
      // an optimization, and next was combined with lastToken
      if (lastToken.chain(next)) {
	  lastToken = next;
      }
    }
  }
  private static REToken setRepeated(REToken current, int min, int max, int index) throws REException {
    if (current == null) throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
    return new RETokenRepeated(current.subIndex,current,min,max);
  }
  private static int getPosixSet(char[] pattern,int index,StringBuffer buf) {
    // Precondition: pattern[index-1] == ':'
    // we will return pos of closing ']'.
    int i;
    for (i=index; i<(pattern.length-1); i++) {
      if ((pattern[i] == ':') && (pattern[i+1] == ']'))
	return i+2;
      buf.append(pattern[i]);
    }
    return index; // didn't match up
  }
  private int getMinMax(char[] input,int index,IntPair minMax,RESyntax syntax) throws REException {
    // Precondition: input[index-1] == '{', minMax != null
    boolean mustMatch = !syntax.get(RESyntax.RE_NO_BK_BRACES);
    int startIndex = index;
    if (index == input.length) {
      if (mustMatch)
        throw new REException(getLocalizedMessage(""unmatched.brace""),REException.REG_EBRACE,index);
      else
        return startIndex;
    }
    int min,max=0;
    CharUnit unit = new CharUnit();
    StringBuffer buf = new StringBuffer();
    // Read string of digits
    do {
      index = getCharUnit(input,index,unit);
      if (Character.isDigit(unit.ch))
        buf.append(unit.ch);
    } while ((index != input.length) && Character.isDigit(unit.ch));
    // Check for {} tomfoolery
    if (buf.length() == 0) {
      if (mustMatch)
        throw new REException(getLocalizedMessage(""interval.error""),REException.REG_EBRACE,index);
      else
        return startIndex;
    }
    min = Integer.parseInt(buf.toString());
    if ((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk))
      max = min;
    else if (index == input.length)
      if (mustMatch)
        throw new REException(getLocalizedMessage(""interval.no.end""),REException.REG_EBRACE,index);
      else
        return startIndex;
    else if ((unit.ch == ',') && !unit.bk) {
      buf = new StringBuffer();
      // Read string of digits
      while (((index = getCharUnit(input,index,unit)) != input.length) && Character.isDigit(unit.ch))
	buf.append(unit.ch);
      if (!((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)))
        if (mustMatch)
          throw new REException(getLocalizedMessage(""interval.error""),REException.REG_EBRACE,index);
        else
          return startIndex;
      // This is the case of {x,}
      if (buf.length() == 0) max = Integer.MAX_VALUE;
      else max = Integer.parseInt(buf.toString());
    } else
      if (mustMatch)
        throw new REException(getLocalizedMessage(""interval.error""),REException.REG_EBRACE,index);
      else
        return startIndex;
    // We know min and max now, and they are valid.
    minMax.first = min;
    minMax.second = max;
    // return the index following the '}'
    return index;
  }
   /**
    * Return a human readable form of the compiled regular expression,
    * useful for debugging.
    */
   public String toString() {
     StringBuffer sb = new StringBuffer();
     dump(sb);
     return sb.toString();
   }
  void dump(StringBuffer os) {
    os.append('(');
    if (subIndex == 0)
      os.append(""?:"");
    if (firstToken != null)
      firstToken.dumpAll(os);
    os.append(')');
  }
  // Cast input appropriately or throw exception
  private static CharIndexed makeCharIndexed(Object input, int index) {
      // We could let a String fall through to final input, but since
      // it's the most likely input type, we check it first.
    if (input instanceof String)
      return new CharIndexedString((String) input,index);
    else if (input instanceof char[])
      return new CharIndexedCharArray((char[]) input,index);
    else if (input instanceof StringBuffer)
      return new CharIndexedStringBuffer((StringBuffer) input,index);
    else if (input instanceof InputStream)
      return new CharIndexedInputStream((InputStream) input,index);
    else if (input instanceof Reader)
	return new CharIndexedReader((Reader) input, index);
    else if (input instanceof CharIndexed)
	return (CharIndexed) input; // do we lose index info?
    else 
	return new CharIndexedString(input.toString(), index);
  }
}
"
gnu.regexp.REException,"/*
 *  gnu/regexp/REException.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.text.MessageFormat;
/**
 * This is the regular expression exception class.  An exception of this type
 * defines the three attributes:
 * <OL>
 * <LI> A descriptive message of the error.
 * <LI> An integral type code equivalent to one of the statically
 *      defined symbols listed below.
 * <LI> The approximate position in the input string where the error
 *      occurred.
 * </OL>
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public class REException extends Exception {
  private int type;
  private int pos;
  // Error conditions from GNU regcomp(3) manual
  /**
   * Error flag.
   * Invalid use of repetition operators such  as  using
   * `*' as the first character.
   */
  public static final int REG_BADRPT  =  1;
  /**
   * Error flag.
   * Invalid use of back reference operator.
   */
  public static final int REG_BADBR   =  2;
  /**
   * Error flag.
   * Un-matched brace interval operators.
   */
  public static final int REG_EBRACE  =  3;
  /**
   * Error flag.
   * Un-matched bracket list operators.
   */
  public static final int REG_EBRACK  =  4;
  /**
   * Error flag.
   * Invalid  use  of the range operator, eg. the ending
   * point of the range occurs  prior  to  the  starting
   * point.
   */
  public static final int REG_ERANGE  =  5;
  /**
   * Error flag.
   * Unknown character class name. <B>Not implemented</B>.
   */
  public static final int REG_ECTYPE  =  6;
  /**
   * Error flag.
   * Un-matched parenthesis group operators.
   */
  public static final int REG_EPAREN  =  7;
  /**
   * Error flag.
   * Invalid back reference to a subexpression.
   */
  public static final int REG_ESUBREG =  8;
  /**
   * Error flag.
   * Non specific error. <B>Not implemented</B>.
   */
  public static final int REG_EEND    =  9;
  /**
   * Error flag.
   * Invalid escape sequence. <B>Not implemented</B>.
   */
  public static final int REG_ESCAPE  = 10;
  /**
   * Error flag.
   * Invalid  use  of pattern operators such as group or list.
   */
  public static final int REG_BADPAT  = 11;
  /**
   * Error flag.
   * Compiled  regular  expression  requires  a  pattern
   * buffer larger than 64Kb. <B>Not implemented</B>.
   */
  public static final int REG_ESIZE   = 12;
  /**
   * Error flag.
   * The regex routines ran out of memory. <B>Not implemented</B>.
   */
  public static final int REG_ESPACE  = 13;
  REException(String msg, int type, int position) { 
    super(msg); 
    this.type = type;
    this.pos = position;
  }
  /**
   * Returns the type of the exception, one of the constants listed above.
   */
  public int getType() {
    return type;
  }
  /**
   * Returns the position, relative to the string or character array being
   * compiled, where the error occurred.  This position is generally the point
   * where the error was detected, not necessarily the starting index of
   * a bad subexpression.
   */
  public int getPosition() {
    return pos;
  }
  /**
   * Reports the descriptive message associated with this exception
   * as well as its index position in the string or character array
   * being compiled.
   */
  public String getMessage() {
    Object[] args = {new Integer(pos)};
    StringBuffer sb = new StringBuffer();
    String prefix = RE.getLocalizedMessage(""error.prefix"");
    sb.append(MessageFormat.format(prefix, args));
    sb.append('\n');
    sb.append(super.getMessage());
    return sb.toString();
  }
}
"
gnu.regexp.REFilterInputStream,"/*
 *  gnu/regexp/REFilterInputStream.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.FilterInputStream;
import java.io.InputStream;
/**
 * Replaces instances of a given RE found within an InputStream
 * with replacement text.   The replacements are interpolated into the
 * stream when a match is found.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 * @deprecated This class cannot properly handle all character
 *             encodings.  For proper handling, use the REFilterReader
 *             class instead.
 */
public class REFilterInputStream extends FilterInputStream {
    private RE expr;
    private String replace;
    private String buffer;
    private int bufpos;
    private int offset;
    private CharIndexedInputStream stream;
  /**
   * Creates an REFilterInputStream.  When reading from this stream,
   * occurrences of patterns matching the supplied regular expression
   * will be replaced with the supplied replacement text (the
   * metacharacters $0 through $9 may be used to refer to the full
   * match or subexpression matches).
   *
   * @param stream The InputStream to be filtered.
   * @param expr The regular expression to search for.
   * @param replace The text pattern to replace matches with.  
   */
  public REFilterInputStream(InputStream stream, RE expr, String replace) {
    super(stream);
    this.stream = new CharIndexedInputStream(stream,0);
    this.expr = expr;
    this.replace = replace;
  }
  /**
   * Reads the next byte from the stream per the general contract of
   * InputStream.read().  Returns -1 on error or end of stream.
   */
  public int read() {
    // If we have buffered replace data, use it.
    if ((buffer != null) && (bufpos < buffer.length())) {
      return (int) buffer.charAt(bufpos++);
    }
    // check if input is at a valid position
    if (!stream.isValid()) return -1;
    REMatch mymatch = new REMatch(expr.getNumSubs(),offset,0);
    if (expr.match(stream, mymatch)) {
      mymatch.end[0] = mymatch.index;
      mymatch.finish(stream);
      stream.move(mymatch.toString().length());
      offset += mymatch.toString().length();
      buffer = mymatch.substituteInto(replace);
      bufpos = 1;
      // This is prone to infinite loops if replace string turns out empty.
      if (buffer.length() > 0) {
	  return buffer.charAt(0);
      }
    }
    char ch = stream.charAt(0);
    if (ch == CharIndexed.OUT_OF_BOUNDS) return -1;
    stream.move(1);
    offset++;
    return ch;
  }
  /** 
   * Returns false.  REFilterInputStream does not support mark() and
   * reset() methods. 
   */
  public boolean markSupported() {
    return false;
  }
  /** Reads from the stream into the provided array. */
  public int read(byte[] b, int off, int len) {
    int i;
    int ok = 0;
    while (len-- > 0) {
      i = read();
      if (i == -1) return (ok == 0) ? -1 : ok;
      b[off++] = (byte) i;
      ok++;
    }
    return ok;
  }
  /** Reads from the stream into the provided array. */
  public int read(byte[] b) {
    return read(b,0,b.length);
  }
}
"
gnu.regexp.REFilterReader,"/*
 *  gnu/regexp/REFilterReader.java
 *  Copyright (C) 2001 Lee Sau Dan
 *  Based on gnu.regexp.REFilterInputStream by Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.FilterReader;
import java.io.Reader;
/**
 * Replaces instances of a given RE with replacement text. 
 *
 * @author <A HREF=""http://www.csis.hku.hk/~sdlee/"">Lee Sau Dan</A>
 * @since gnu.regexp 1.1.0
 */
public class REFilterReader extends FilterReader {
  private RE expr;
  private String replace;
  private String buffer;
  private int bufpos;
  private int offset;
  private CharIndexedReader stream;
  /**
   * Creates an REFilterReader.  When reading from this stream,
   * occurrences of patterns matching the supplied regular expression
   * will be replaced with the supplied replacement text (the
   * metacharacters $0 through $9 may be used to refer to the full
   * match or subexpression matches.
   *
   * @param stream The Reader to be filtered.
   * @param expr The regular expression to search for.
   * @param replace The text pattern to replace matches with.  
   */
  public REFilterReader(Reader stream, RE expr, String replace) {
    super(stream);
    this.stream = new CharIndexedReader(stream,0);
    this.expr = expr;
    this.replace = replace;
  }
  /**
   * Reads the next character from the stream per the general contract of
   * Reader.read().  Returns -1 on error or end of stream.
   */
  public int read() {
    // If we have buffered replace data, use it.
    if ((buffer != null) && (bufpos < buffer.length())) {
      return (int) buffer.charAt(bufpos++);
    }
    // check if input is at a valid position
    if (!stream.isValid()) return -1;
    REMatch mymatch = new REMatch(expr.getNumSubs(),offset,0);
    if (expr.match(stream,mymatch)) {
      mymatch.end[0] = mymatch.index;
      mymatch.finish(stream);
      stream.move(mymatch.toString().length());
      offset += mymatch.toString().length();
      buffer = mymatch.substituteInto(replace);
      bufpos = 1;
      if (buffer.length() > 0) {
	  return buffer.charAt(0);
      }
    }
    char ch = stream.charAt(0);
    if (ch == CharIndexed.OUT_OF_BOUNDS) return -1;
    stream.move(1);
    offset++;
    return ch;
  }
  /** 
   * Returns false.  REFilterReader does not support mark() and
   * reset() methods. 
   */
  public boolean markSupported() {
    return false;
  }
  /** Reads from the stream into the provided array. */
  public int read(char[] b, int off, int len) {
    int i;
    int ok = 0;
    while (len-- > 0) {
      i = read();
      if (i == -1) return (ok == 0) ? -1 : ok;
      b[off++] = (char) i;
      ok++;
    }
    return ok;
  }
  /** Reads from the stream into the provided array. */
  public int read(char[] b) {
    return read(b,0,b.length);
  }
}
"
gnu.regexp.REMatch,"/*
 *  gnu/regexp/REMatch.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
/**
 * An instance of this class represents a match
 * completed by a gnu.regexp matching function. It can be used
 * to obtain relevant information about the location of a match
 * or submatch.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public final class REMatch implements Serializable, Cloneable {
    private String matchedText;
    // These variables are package scope for fast access within the engine
    int eflags; // execution flags this match was made using
    // Offset in source text where match was tried.  This is zero-based;
    // the actual position in the source text is given by (offset + anchor).
    int offset;
    // Anchor position refers to the index into the source input
    // at which the matching operation began.
    // This is also useful for the ANCHORINDEX option.
    int anchor;
    // Package scope; used by RE.
    int index; // used while matching to mark current match position in input
    int[] start; // start positions (relative to offset) for each (sub)exp.
    int[] end;   // end positions for the same
    REMatch next; // other possibility (to avoid having to use arrays)
    public Object clone() {
	try {
	    REMatch copy = (REMatch) super.clone();
	    copy.next = null;
	    copy.start = (int[]) start.clone();
	    copy.end = (int[]) end.clone();
	    return copy;
	} catch (CloneNotSupportedException e) {
	    throw new Error(); // doesn't happen
	}
    }
    void assignFrom(REMatch other) {
	start = other.start;
	end = other.end;
	index = other.index;
	// need to deep clone?
	next = other.next;
    }
    REMatch(int subs, int anchor, int eflags) {
	start = new int[subs+1];
	end = new int[subs+1];
	this.anchor = anchor;
	this.eflags = eflags;
	clear(anchor);
    }
    void finish(CharIndexed text) {
	start[0] = 0;
	StringBuffer sb = new StringBuffer();
	int i;
	for (i = 0; i < end[0]; i++)
	    sb.append(text.charAt(i));
	matchedText = sb.toString();
	for (i = 0; i < start.length; i++) {
	    // If any subexpressions didn't terminate, they don't count
	    // TODO check if this code ever gets hit
	    if ((start[i] == -1) ^ (end[i] == -1)) {
		start[i] = -1;
		end[i] = -1;
	    }
	}
	next = null; // cut off alternates
    }
    /** Clears the current match and moves the offset to the new index. */
    void clear(int index) {
	offset = index;
	this.index = 0;
	for (int i = 0; i < start.length; i++) {
	    start[i] = end[i] = -1;
	}
	next = null; // cut off alternates
    }
    /**
     * Returns the string matching the pattern.  This makes it convenient
     * to write code like the following:
     * <P>
     * <code> 
     * REMatch myMatch = myExpression.getMatch(myString);<br>
     * if (myMatch != null) System.out.println(""Regexp found: ""+myMatch);
     * </code>
     */
    public String toString() {
	return matchedText;
    }
    /**
     * Returns the index within the input text where the match in its entirety
     * began.
     */
    public int getStartIndex() {
	return offset + start[0];
    }
    /**
     * Returns the index within the input string where the match in
     * its entirety ends.  The return value is the next position after
     * the end of the string; therefore, a match created by the
     * following call:
     *
     * <P>
     * <code>REMatch myMatch = myExpression.getMatch(myString);</code>
     * <P>
     * can be viewed (given that myMatch is not null) by creating
     * <P>
     * <code>String theMatch = myString.substring(myMatch.getStartIndex(),
     * myMatch.getEndIndex());</code>
     * <P>
     * But you can save yourself that work, since the <code>toString()</code>
     * method (above) does exactly that for you.  
     */
    public int getEndIndex() {
	return offset + end[0];
    }
    /**
     * Returns the string matching the given subexpression.  The subexpressions
     * are indexed starting with one, not zero.  That is, the subexpression
     * identified by the first set of parentheses in a regular expression
     * could be retrieved from an REMatch by calling match.toString(1).
     *
     * @param sub Index of the subexpression.
     */
    public String toString(int sub) {
	if ((sub >= start.length) || (start[sub] == -1)) return """";
	return (matchedText.substring(start[sub],end[sub]));
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> begins, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     * @deprecated Use getStartIndex(int) instead.
     */
    public int getSubStartIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = start[sub];
	return (x == -1) ? x : offset + x;
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> begins, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     * @since gnu.regexp 1.1.0
     */
    public int getStartIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = start[sub];
	return (x == -1) ? x : offset + x;
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> ends, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     * @deprecated Use getEndIndex(int) instead
     */
    public int getSubEndIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = end[sub];
	return (x == -1) ? x : offset + x;
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> ends, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     */
    public int getEndIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = end[sub];
	return (x == -1) ? x : offset + x;
    }
    /**
     * Substitute the results of this match to create a new string.
     * This is patterned after PERL, so the tokens to watch out for are
     * <code>$0</code> through <code>$9</code>.  <code>$0</code> matches
     * the full substring matched; <code>$<i>n</i></code> matches
     * subexpression number <i>n</i>.
     *
     * @param input A string consisting of literals and <code>$<i>n</i></code> tokens.
     */
    public String substituteInto(String input) {
	// a la Perl, $0 is whole thing, $1 - $9 are subexpressions
	StringBuffer output = new StringBuffer();
	int pos;
	for (pos = 0; pos < input.length()-1; pos++) {
	    if ((input.charAt(pos) == '$') && (Character.isDigit(input.charAt(pos+1)))) {
		int val = Character.digit(input.charAt(++pos),10);
		if (val < start.length) {
		    output.append(toString(val));
		} 
	    } else output.append(input.charAt(pos));
	}
	if (pos < input.length()) output.append(input.charAt(pos));
	return output.toString();
    }
}
"
gnu.regexp.REMatchEnumeration,"/*
 *  gnu/regexp/REMatchEnumeration.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.NoSuchElementException;
/**
 * An REMatchEnumeration enumerates regular expression matches over a
 * given input text.  You obtain a reference to an enumeration using
 * the <code>getMatchEnumeration()</code> methods on an instance of
 * RE. 
 *
 * <P>
 *
 * REMatchEnumeration does lazy computation; that is, it will not
 * search for a match until it needs to.  If you'd rather just get all
 * the matches at once in a big array, use the
 * <code>getAllMatches()</code> methods on RE.  However, using an
 * enumeration can help speed performance when the entire text does
 * not need to be searched immediately.
 *
 * <P>
 * 
 * The enumerated type is especially useful when searching on a Reader
 * or InputStream, because the InputStream read position cannot be
 * guaranteed after calling <code>getMatch()</code> (see the
 * description of that method for an explanation of why).  Enumeration
 * also saves a lot of overhead required when calling
 * <code>getMatch()</code> multiple times.
 * 
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A> 
 */
public class REMatchEnumeration implements Enumeration, Serializable {
  private static final int YES = 1;
  private static final int MAYBE = 0;
  private static final int NO = -1;
  private int more;
  private REMatch match;
  private RE expr;
  private CharIndexed input;
  private int eflags;
    private int index;
  // Package scope constructor is used by RE.getMatchEnumeration()
  REMatchEnumeration(RE expr, CharIndexed input, int index, int eflags) {
    more = MAYBE;
    this.expr = expr;
    this.input = input;
    this.index = index;
    this.eflags = eflags;
  }
  /** Returns true if there are more matches in the input text. */
  public boolean hasMoreElements() {
    return hasMoreMatches(null);
  }
  /** Returns true if there are more matches in the input text. */
  public boolean hasMoreMatches() {
    return hasMoreMatches(null);
  }
  /** Returns true if there are more matches in the input text.
   * Saves the text leading up to the match (or to the end of the input)
   * in the specified buffer.
   */
  public boolean hasMoreMatches(StringBuffer buffer) {
    if (more == MAYBE) {
	match = expr.getMatchImpl(input,index,eflags,buffer);
	if (match != null) {
	    input.move((match.end[0] > 0) ? match.end[0] : 1);
	    index = (match.end[0] > 0) ? match.end[0] + match.offset : index + 1;
	    more = YES;
	} else more = NO;
    }
    return (more == YES);
  }
  /** Returns the next match in the input text. */
  public Object nextElement() throws NoSuchElementException {
    return nextMatch();
  }
  /** 
   * Returns the next match in the input text. This method is provided
   * for convenience to avoid having to explicitly cast the return value
   * to class REMatch.
   */
  public REMatch nextMatch() throws NoSuchElementException {
    if (hasMoreElements()) {
	more = (input.isValid()) ? MAYBE : NO;
	return match;
    }
    throw new NoSuchElementException();
  }
}
"
gnu.regexp.RESyntax,"/*
 *  gnu/regexp/RESyntax.java
 *  Copyright (C) 1998-2002 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
import java.util.BitSet;
/**
 * An RESyntax specifies the way a regular expression will be compiled.
 * This class provides a number of predefined useful constants for
 * emulating popular regular expression syntaxes.  Additionally the
 * user may construct his or her own syntax, using any combination of the
 * syntax bit constants.  The syntax is an optional argument to any of the
 * matching methods on class RE.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public final class RESyntax implements Serializable {
    static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");
    private static final String SYNTAX_IS_FINAL = RE.getLocalizedMessage(""syntax.final"");
    private BitSet bits;
    // true for the constant defined syntaxes
    private boolean isFinal = false;
    private String lineSeparator = DEFAULT_LINE_SEPARATOR;
  // Values for constants are bit indexes
  /**
   * Syntax bit. Backslash is an escape character in lists.
   */
  public static final int RE_BACKSLASH_ESCAPE_IN_LISTS =  0;
  /**
   * Syntax bit. Use \? instead of ? and \+ instead of +.
   */
  public static final int RE_BK_PLUS_QM                =  1;
  /**
   * Syntax bit. POSIX character classes ([:...:]) in lists are allowed.
   */
  public static final int RE_CHAR_CLASSES              =  2;
  /**
   * Syntax bit. ^ and $ are special everywhere.
   * <B>Not implemented.</B>
   */
  public static final int RE_CONTEXT_INDEP_ANCHORS     =  3; 
  /**
   * Syntax bit. Repetition operators are only special in valid positions.
   * <B>Not implemented.</B>
   */
  public static final int RE_CONTEXT_INDEP_OPS         =  4; 
  /**
   * Syntax bit. Repetition and alternation operators are invalid
   * at start and end of pattern and other places. 
   * <B>Not implemented</B>.
   */
  public static final int RE_CONTEXT_INVALID_OPS       =  5; 
  /**
   * Syntax bit. Match-any-character operator (.) matches a newline.
   */
  public static final int RE_DOT_NEWLINE               =  6;
  /**
   * Syntax bit. Match-any-character operator (.) does not match a null.
   */
  public static final int RE_DOT_NOT_NULL              =  7;
  /**
   * Syntax bit. Intervals ({x}, {x,}, {x,y}) are allowed.
   */
  public static final int RE_INTERVALS                 =  8;
  /**
   * Syntax bit. No alternation (|), match one-or-more (+), or 
   * match zero-or-one (?) operators.
   */
  public static final int RE_LIMITED_OPS               =  9;
  /**
   * Syntax bit. Newline is an alternation operator.
   */
  public static final int RE_NEWLINE_ALT               = 10; // impl.
  /**
   * Syntax bit. Intervals use { } instead of \{ \}
   */
  public static final int RE_NO_BK_BRACES              = 11; 
  /**
   * Syntax bit. Grouping uses ( ) instead of \( \).
   */
  public static final int RE_NO_BK_PARENS              = 12;
  /**
   * Syntax bit. Backreferences not allowed.
   */
  public static final int RE_NO_BK_REFS                = 13;
  /**
   * Syntax bit. Alternation uses | instead of \|
   */
  public static final int RE_NO_BK_VBAR                = 14;
  /**
   * Syntax bit. <B>Not implemented</B>.
   */
  public static final int RE_NO_EMPTY_RANGES           = 15;
  /**
   * Syntax bit. An unmatched right parenthesis (')' or '\)', depending
   * on RE_NO_BK_PARENS) will throw an exception when compiling.
   */
  public static final int RE_UNMATCHED_RIGHT_PAREN_ORD = 16;
  /**
   * Syntax bit. <B>Not implemented.</B>
   */
  public static final int RE_HAT_LISTS_NOT_NEWLINE     = 17;
  /**
   * Syntax bit.  Stingy matching is allowed (+?, *?, ??, {x,y}?).
   */
  public static final int RE_STINGY_OPS                = 18;
  /**
   * Syntax bit. Allow character class escapes (\d, \D, \s, \S, \w, \W).
   */
  public static final int RE_CHAR_CLASS_ESCAPES        = 19;
  /**
   * Syntax bit. Allow use of (?:xxx) grouping (subexpression is not saved).
   */
  public static final int RE_PURE_GROUPING             = 20;
  /**
   * Syntax bit. Allow use of (?=xxx) and (?!xxx) apply the subexpression
   * to the text following the current position without consuming that text.
   */
  public static final int RE_LOOKAHEAD                 = 21;
  /**
   * Syntax bit. Allow beginning- and end-of-string anchors (\A, \Z).
   */
  public static final int RE_STRING_ANCHORS            = 22;
  /**
   * Syntax bit. Allow embedded comments, (?#comment), as in Perl5.
   */
  public static final int RE_COMMENTS                  = 23;
  /**
   * Syntax bit. Allow character class escapes within lists, as in Perl5.
   */
  public static final int RE_CHAR_CLASS_ESC_IN_LISTS   = 24;
  private static final int BIT_TOTAL                   = 25;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the awk utility.
   */
  public static final RESyntax RE_SYNTAX_AWK;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the ed utility.
   */
  public static final RESyntax RE_SYNTAX_ED;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the egrep utility.
   */
  public static final RESyntax RE_SYNTAX_EGREP;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the GNU Emacs editor.
   */
  public static final RESyntax RE_SYNTAX_EMACS;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the grep utility.
   */
  public static final RESyntax RE_SYNTAX_GREP;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the POSIX awk specification.
   */
  public static final RESyntax RE_SYNTAX_POSIX_AWK;
  /**
   * Predefined syntax.
   * Emulates POSIX basic regular expression support.
   */
  public static final RESyntax RE_SYNTAX_POSIX_BASIC;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the POSIX egrep specification.
   */
  public static final RESyntax RE_SYNTAX_POSIX_EGREP;
  /**
   * Predefined syntax.
   * Emulates POSIX extended regular expression support.
   */
  public static final RESyntax RE_SYNTAX_POSIX_EXTENDED;
  /**
   * Predefined syntax.
   * Emulates POSIX basic minimal regular expressions.
   */
  public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_BASIC;
  /**
   * Predefined syntax.
   * Emulates POSIX extended minimal regular expressions.
   */
  public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_EXTENDED;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the sed utility.
   */
  public static final RESyntax RE_SYNTAX_SED;
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 4,
   */
  public static final RESyntax RE_SYNTAX_PERL4;
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 4,
   * using single line mode (/s modifier).
   */
  public static final RESyntax RE_SYNTAX_PERL4_S; // single line mode (/s)
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 5.
   */
  public static final RESyntax RE_SYNTAX_PERL5;  
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 5,
   * using single line mode (/s modifier).
   */
  public static final RESyntax RE_SYNTAX_PERL5_S;
    /**
     * Predefined syntax.
     * Emulates regular expression support in Java 1.4's java.util.regex
     * package.
     */
    public static final RESyntax RE_SYNTAX_JAVA_1_4;
  static {
      // Define syntaxes
      RE_SYNTAX_EMACS = new RESyntax().makeFinal();
      RESyntax RE_SYNTAX_POSIX_COMMON = new RESyntax()
	  .set(RE_CHAR_CLASSES)
	  .set(RE_DOT_NEWLINE)
	  .set(RE_DOT_NOT_NULL)
	  .set(RE_INTERVALS)
	  .set(RE_NO_EMPTY_RANGES)
	  .makeFinal();
      RE_SYNTAX_POSIX_BASIC = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_BK_PLUS_QM)
	  .makeFinal();
      RE_SYNTAX_POSIX_EXTENDED = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INDEP_OPS)
	  .set(RE_NO_BK_BRACES)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)
	  .makeFinal();
      RE_SYNTAX_AWK = new RESyntax()
	  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)
	  .set(RE_DOT_NOT_NULL)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_REFS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_NO_EMPTY_RANGES)
	  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)
	  .makeFinal();
      RE_SYNTAX_POSIX_AWK = new RESyntax(RE_SYNTAX_POSIX_EXTENDED)
	  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)
	  .makeFinal();
      RE_SYNTAX_GREP = new RESyntax()
	  .set(RE_BK_PLUS_QM)
	  .set(RE_CHAR_CLASSES)
	  .set(RE_HAT_LISTS_NOT_NEWLINE)
	  .set(RE_INTERVALS)
	  .set(RE_NEWLINE_ALT)
	  .makeFinal();
      RE_SYNTAX_EGREP = new RESyntax()
	  .set(RE_CHAR_CLASSES)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INDEP_OPS)
	  .set(RE_HAT_LISTS_NOT_NEWLINE)
	  .set(RE_NEWLINE_ALT)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_VBAR)
	  .makeFinal();
      RE_SYNTAX_POSIX_EGREP = new RESyntax(RE_SYNTAX_EGREP)
	  .set(RE_INTERVALS)
	  .set(RE_NO_BK_BRACES)
	  .makeFinal();
      /* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
      RE_SYNTAX_ED = new RESyntax(RE_SYNTAX_POSIX_BASIC)
	  .makeFinal();
      RE_SYNTAX_SED = new RESyntax(RE_SYNTAX_POSIX_BASIC)
	  .makeFinal();
      RE_SYNTAX_POSIX_MINIMAL_BASIC = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_LIMITED_OPS)
	  .makeFinal();
      /* Differs from RE_SYNTAX_POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
	 replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added. */
      RE_SYNTAX_POSIX_MINIMAL_EXTENDED = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INVALID_OPS)
	  .set(RE_NO_BK_BRACES)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_REFS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)
	  .makeFinal();
      /* There is no official Perl spec, but here's a ""best guess"" */
      RE_SYNTAX_PERL4 = new RESyntax()
	  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INDEP_OPS)          // except for '{', apparently
	  .set(RE_INTERVALS)
	  .set(RE_NO_BK_BRACES)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_NO_EMPTY_RANGES)
	  .set(RE_CHAR_CLASS_ESCAPES)    // \d,\D,\w,\W,\s,\S
	  .makeFinal();
      RE_SYNTAX_PERL4_S = new RESyntax(RE_SYNTAX_PERL4)
	  .set(RE_DOT_NEWLINE)
	  .makeFinal();
      RE_SYNTAX_PERL5 = new RESyntax(RE_SYNTAX_PERL4)
	  .set(RE_PURE_GROUPING)          // (?:)
	  .set(RE_STINGY_OPS)             // *?,??,+?,{}?
	  .set(RE_LOOKAHEAD)              // (?=)(?!)
	  .set(RE_STRING_ANCHORS)         // \A,\Z
	  .set(RE_CHAR_CLASS_ESC_IN_LISTS)// \d,\D,\w,\W,\s,\S within []
	  .set(RE_COMMENTS)              // (?#)
	  .makeFinal();
      RE_SYNTAX_PERL5_S = new RESyntax(RE_SYNTAX_PERL5)
	  .set(RE_DOT_NEWLINE)
	  .makeFinal();
      RE_SYNTAX_JAVA_1_4 = new RESyntax(RE_SYNTAX_PERL5)
	  // XXX
	  .makeFinal();
  }
  /**
   * Construct a new syntax object with all bits turned off.
   * This is equivalent to RE_SYNTAX_EMACS.
   */
  public RESyntax() {
    bits = new BitSet(BIT_TOTAL);
  }
    /**
     * Called internally when constructing predefined syntaxes
     * so their interpretation cannot vary.  Conceivably useful
     * for your syntaxes as well.  Causes IllegalAccessError to
     * be thrown if any attempt to modify the syntax is made.
     *
     * @return this object for convenient chaining
     */
    public RESyntax makeFinal() {
	isFinal = true;
	return this;
    }
  /**
   * Construct a new syntax object with all bits set the same 
   * as the other syntax.
   */
  public RESyntax(RESyntax other) {
    bits = (BitSet) other.bits.clone();
  }
  /**
   * Check if a given bit is set in this syntax.
   */
  public boolean get(int index) {
    return bits.get(index);
  }
  /**
   * Set a given bit in this syntax. 
   *
   * @param index the constant (RESyntax.RE_xxx) bit to set.
   * @return a reference to this object for easy chaining.
   */
  public RESyntax set(int index) {
      if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);
    bits.set(index);
    return this;
  }
  /**
   * Clear a given bit in this syntax. 
   *
   * @param index the constant (RESyntax.RE_xxx) bit to clear.
   * @return a reference to this object for easy chaining.
   */
  public RESyntax clear(int index) {
      if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);
      bits.clear(index);
      return this;
  }
    /**
     * Changes the line separator string for regular expressions
     * created using this RESyntax.  The default separator is the
     * value returned by the system property ""line.separator"", which
     * should be correct when reading platform-specific files from a
     * filesystem.  However, many programs may collect input from
     * sources where the line separator is differently specified (for
     * example, in the applet environment, the text box widget
     * interprets line breaks as single-character newlines,
     * regardless of the host platform.
     *
     * Note that setting the line separator to a character or
     * characters that have specific meaning within the current syntax
     * can cause unexpected chronosynclastic infundibula.
     *
     * @return this object for convenient chaining 
     */
    public RESyntax setLineSeparator(String aSeparator) {
	if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);
	lineSeparator = aSeparator;
	return this;
    }
    /**
     * Returns the currently active line separator string.  The default
     * is the platform-dependent system property ""line.separator"".
     */
    public String getLineSeparator() {
	return lineSeparator;
    }
}
"
gnu.regexp.REToken,"/*
 *  gnu/regexp/REToken.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
abstract class REToken implements Serializable {
  protected REToken next = null;
  protected REToken uncle = null;
  protected int subIndex;
  protected REToken(int subIndex) {
      this.subIndex = subIndex;
  }
  int getMinimumLength() {
    return 0;
  }
  void setUncle(REToken anUncle) {
    uncle = anUncle;
  }
    /** Returns true if the match succeeded, false if it failed. */
    abstract boolean match(CharIndexed input, REMatch mymatch);
    /** Returns true if the rest of the tokens match, false if they fail. */
    protected boolean next(CharIndexed input, REMatch mymatch) {
	if (next == null) {
	    if (uncle == null) {
		return true;
	    } else {
		return uncle.match(input, mymatch);
	    }
	} else {
	    return next.match(input, mymatch);
	}
    }
  boolean chain(REToken token) {
      next = token;
      return true; // Token was accepted
  }
    abstract void dump(StringBuffer os);
  void dumpAll(StringBuffer os) {
    dump(os);
    if (next != null) next.dumpAll(os);
  }
}
"
gnu.regexp.RETokenAny,"/*
 *  gnu/regexp/RETokenAny.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenAny extends REToken {
  /** True if '.' can match a newline (RE_DOT_NEWLINE) */
  private boolean newline; 
  /** True if '.' can't match a null (RE_DOT_NOT_NULL) */
  private boolean matchNull;    
  RETokenAny(int subIndex, boolean newline, boolean matchNull) { 
    super(subIndex);
    this.newline = newline;
    this.matchNull = matchNull;
  }
  int getMinimumLength() {
    return 1;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
    char ch = input.charAt(mymatch.index);
    if ((ch == CharIndexed.OUT_OF_BOUNDS)
	|| (!newline && (ch == '\n'))
	|| (matchNull && (ch == 0))) {
	return false;
    }
    ++mymatch.index;
    return next(input, mymatch);
  }
  void dump(StringBuffer os) {
    os.append('.');
  }
}
"
gnu.regexp.RETokenBackRef,"/*
 *  gnu/regexp/RETokenBackRef.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenBackRef extends REToken {
  private int num;
  private boolean insens;
  RETokenBackRef(int subIndex, int num, boolean insens) {
    super(subIndex);
    this.num = num;
    this.insens = insens;
  }
  // should implement getMinimumLength() -- any ideas?
    boolean match(CharIndexed input, REMatch mymatch) {
	int b,e;
	b = mymatch.start[num];
	e = mymatch.end[num];
	if ((b==-1)||(e==-1)) return false; // this shouldn't happen, but...
	for (int i=b; i<e; i++) {
	    if (input.charAt(mymatch.index+i-b) != input.charAt(i)) {
		return false;
	    }
	}
	mymatch.index += e-b;
	return next(input, mymatch);
    }
    void dump(StringBuffer os) {
	os.append('\\').append(num);
    }
}
"
gnu.regexp.RETokenChar,"/*
 *  gnu/regexp/RETokenChar.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenChar extends REToken {
  private char[] ch;
  private boolean insens;
  RETokenChar(int subIndex, char c, boolean ins) {
    super(subIndex);
    ch = new char [1];
    ch[0] = (insens = ins) ? Character.toLowerCase(c) : c;
  }
  int getMinimumLength() {
    return ch.length;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
	int z = ch.length;
	char c;
	for (int i=0; i<z; i++) {
	    c = input.charAt(mymatch.index+i);
	    if (( (insens) ? Character.toLowerCase(c) : c ) != ch[i]) {
		return false;
	    }
	}
	mymatch.index += z;
	return next(input, mymatch);
    }
  // Overrides REToken.chain() to optimize for strings
  boolean chain(REToken next) {
    if (next instanceof RETokenChar) {
      RETokenChar cnext = (RETokenChar) next;
      // assume for now that next can only be one character
      int newsize = ch.length + cnext.ch.length;
      char[] chTemp = new char [newsize];
      System.arraycopy(ch,0,chTemp,0,ch.length);
      System.arraycopy(cnext.ch,0,chTemp,ch.length,cnext.ch.length);
      ch = chTemp;
      return false;
    } else return super.chain(next);
  }
  void dump(StringBuffer os) {
    os.append(ch);
  }
}
"
gnu.regexp.RETokenEnd,"/*
 *  gnu/regexp/RETokenEnd.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenEnd extends REToken {
    /**
     * Indicates whether this token should match on a line break.
     */
  private String newline;
  RETokenEnd(int subIndex,String newline) { 
    super(subIndex);
    this.newline = newline;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
	char ch = input.charAt(mymatch.index);
	if (ch == CharIndexed.OUT_OF_BOUNDS)
	    return ((mymatch.eflags & RE.REG_NOTEOL)>0) ? 
		false : next(input, mymatch);
	if (newline != null) {
	    char z;
	    int i = 0; // position in newline
	    do {
		z = newline.charAt(i);
		if (ch != z) return false;
		++i;
		ch = input.charAt(mymatch.index + i);
	    } while (i < newline.length());
	    return next(input, mymatch);
	}
	return false;
    }
  void dump(StringBuffer os) {
    os.append('$');
  }
}
"
gnu.regexp.RETokenEndSub,"/*
 *  gnu/regexp/RETokenEndSub.java
 *  Copyright (C) 2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenEndSub extends REToken {
    RETokenEndSub(int subIndex) {
	super(subIndex);
    }
    boolean match(CharIndexed input, REMatch mymatch) {
	mymatch.end[subIndex] = mymatch.index;
	return next(input, mymatch);
    }
    void dump(StringBuffer os) {
	// handled by RE
    }
}
"
gnu.regexp.RETokenLookAhead,"/*
 *  gnu/regexp/RETokenOneOf.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
/**
 * @since gnu.regexp 1.1.3
 * @author Shashank Bapat
 */
final class RETokenLookAhead extends REToken
{
  REToken re;
  boolean negative;
  RETokenLookAhead(REToken re, boolean negative) throws REException {
    super(0);
    this.re = re;
    this.negative = negative;
  }
  boolean match(CharIndexed input, REMatch mymatch)
  {
    REMatch trymatch = (REMatch)mymatch.clone();
    REMatch trymatch1 = (REMatch)mymatch.clone();
    REMatch newMatch = null;
    if (re.match(input, trymatch)) {
      if (negative) return false;
      if (next(input, trymatch1))
        newMatch = trymatch1;
    }
    if (newMatch != null) {
      if (negative) return false;
      //else
      mymatch.assignFrom(newMatch);
      return true;
    }
    else { // no match
      if (negative)
        return next(input, mymatch);
      //else
      return false;
    }
  }
    void dump(StringBuffer os) {
	os.append(""(?"");
	os.append(negative ? '!' : '=');
	re.dumpAll(os);
	os.append(')');
    }
}
"
gnu.regexp.RETokenOneOf,"/*
 *  gnu/regexp/RETokenOneOf.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.util.Vector;
final class RETokenOneOf extends REToken {
  private Vector options;
  private boolean negative;
  // This constructor is used for convenience when we know the set beforehand,
  // e.g. \d --> new RETokenOneOf(""0123456789"",false, ..)
  //      \D --> new RETokenOneOf(""0123456789"",true, ..)
  RETokenOneOf(int subIndex, String optionsStr, boolean negative, boolean insens) {
    super(subIndex);
    options = new Vector();
    this.negative = negative;
    for (int i = 0; i < optionsStr.length(); i++)
      options.addElement(new RETokenChar(subIndex,optionsStr.charAt(i),insens));
  }
  RETokenOneOf(int subIndex, Vector options, boolean negative) {
    super(subIndex);
    this.options = options;
    this.negative = negative;
  }
  int getMinimumLength() {
    int min = Integer.MAX_VALUE;
    int x;
    for (int i=0; i < options.size(); i++) {
      if ((x = ((REToken) options.elementAt(i)).getMinimumLength()) < min)
	min = x;
    }
    return min;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
    if (negative && (input.charAt(mymatch.index) == CharIndexed.OUT_OF_BOUNDS)) 
      return false;
    REMatch newMatch = null;
    REMatch last = null;
    REToken tk;
    boolean isMatch;
    for (int i=0; i < options.size(); i++) {
	tk = (REToken) options.elementAt(i);
	REMatch tryMatch = (REMatch) mymatch.clone();
	if (tk.match(input, tryMatch)) { // match was successful
	    if (negative) return false;
	    if (next(input, tryMatch)) {
		// Add tryMatch to list of possibilities.
		if (last == null) {
		    newMatch = tryMatch;
		    last = tryMatch;
		} else {
		    last.next = tryMatch;
		    last = tryMatch;
		}
	    } // next succeeds
	} // is a match
    } // try next option
    if (newMatch != null) {
	if (negative) {
	    return false;
	} else {
	    // set contents of mymatch equal to newMatch
	    // try each one that matched
	    mymatch.assignFrom(newMatch);
	    return true;
	}
    } else {
	if (negative) {
	    ++mymatch.index;
	    return next(input, mymatch);
	} else {
	    return false;
	}
    }
    // index+1 works for [^abc] lists, not for generic lookahead (--> index)
  }
  void dump(StringBuffer os) {
    os.append(negative ? ""[^"" : ""(?:"");
    for (int i = 0; i < options.size(); i++) {
      if (!negative && (i > 0)) os.append('|');
      ((REToken) options.elementAt(i)).dumpAll(os);
    }
    os.append(negative ? ']' : ')');
  }  
}
"
gnu.regexp.RETokenPOSIX,"/*
 *  gnu/regexp/RETokenPOSIX.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenPOSIX extends REToken {
  int type;
  boolean insens;
  boolean negated;
  static final int  ALNUM = 0;
  static final int  ALPHA = 1;
  static final int  BLANK = 2;
  static final int  CNTRL = 3;
  static final int  DIGIT = 4;
  static final int  GRAPH = 5;
  static final int  LOWER = 6;
  static final int  PRINT = 7;
  static final int  PUNCT = 8;
  static final int  SPACE = 9;
  static final int  UPPER = 10;
  static final int XDIGIT = 11;
  // Array indices correspond to constants defined above.
  static final String[] s_nameTable =  {
    ""alnum"", ""alpha"", ""blank"", ""cntrl"", ""digit"", ""graph"", ""lower"",
    ""print"", ""punct"", ""space"", ""upper"", ""xdigit"" 
  };
  // The RE constructor uses this to look up the constant for a string
  static int intValue(String key) {
    for (int i = 0; i < s_nameTable.length; i++) {
      if (s_nameTable[i].equals(key)) return i;
    }
    return -1;
  }
  RETokenPOSIX(int subIndex, int type, boolean insens, boolean negated) {
    super(subIndex);
    this.type = type;
    this.insens = insens;
    this.negated = negated;
  }
    int getMinimumLength() {
	return 1;
    }
    boolean match(CharIndexed input, REMatch mymatch) {
    char ch = input.charAt(mymatch.index);
    if (ch == CharIndexed.OUT_OF_BOUNDS)
      return false;
    boolean retval = false;
    switch (type) {
    case ALNUM:
	// Note that there is some debate over whether '_' should be included
	retval = Character.isLetterOrDigit(ch) || (ch == '_');
	break;
    case ALPHA:
	retval = Character.isLetter(ch);
	break;
    case BLANK:
	retval = ((ch == ' ') || (ch == '\t'));
	break;
    case CNTRL:
	retval = Character.isISOControl(ch);
	break;
    case DIGIT:
	retval = Character.isDigit(ch);
	break;
    case GRAPH:
	retval = (!(Character.isWhitespace(ch) || Character.isISOControl(ch)));
	break;
    case LOWER:
	retval = ((insens && Character.isLetter(ch)) || Character.isLowerCase(ch));
	break;
    case PRINT:
	retval = (!(Character.isWhitespace(ch) || Character.isISOControl(ch)))
	    || (ch == ' ');
	break;
    case PUNCT:
	// This feels sloppy, especially for non-U.S. locales.
	retval = (""`~!@#$%^&*()-_=+[]{}\\|;:'\""/?,.<>"".indexOf(ch)!=-1);
	break;
    case SPACE:
	retval = Character.isWhitespace(ch);
	break;
    case UPPER:
	retval = ((insens && Character.isLetter(ch)) || Character.isUpperCase(ch));
	break;
    case XDIGIT:
	retval = (Character.isDigit(ch) || (""abcdefABCDEF"".indexOf(ch)!=-1));
	break;
    }
    if (negated) retval = !retval;
    if (retval) {
	++mymatch.index;
	return next(input, mymatch);
    }
    else return false;
  }
  void dump(StringBuffer os) {
    if (negated) os.append('^');
    os.append(""[:"" + s_nameTable[type] + "":]"");
  }
}
"
gnu.regexp.RETokenRange,"/*
 *  gnu/regexp/RETokenRange.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenRange extends REToken {
  private char lo, hi;
  private boolean insens;
  RETokenRange(int subIndex, char lo, char hi, boolean ins) {
    super(subIndex);
    this.lo = (insens = ins) ? Character.toLowerCase(lo) : lo;
    this.hi = ins ? Character.toLowerCase(hi) : hi;
  }
  int getMinimumLength() {
    return 1;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
	char c = input.charAt(mymatch.index);
	if (c == CharIndexed.OUT_OF_BOUNDS) return false;
	if (insens) c = Character.toLowerCase(c);
	if ((c >= lo) && (c <= hi)) {
	    ++mymatch.index;
	    return next(input, mymatch);
	}
	return false;
    }
  void dump(StringBuffer os) {
    os.append(lo).append('-').append(hi);
  }
}
"
gnu.regexp.RETokenRepeated,"/*
 *  gnu/regexp/RETokenRepeated.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.util.Vector;
final class RETokenRepeated extends REToken {
    private REToken token;
    private int min,max;
    private boolean stingy;
    RETokenRepeated(int subIndex, REToken token, int min, int max) {
	super(subIndex);
	this.token = token;
	this.min = min;
	this.max = max;
    }
    /** Sets the minimal matching mode to true. */
    void makeStingy() {
	stingy = true;
    }
    /** Queries if this token has minimal matching enabled. */
    boolean isStingy() {
	return stingy;
    }
    /**
     * The minimum length of a repeated token is the minimum length
     * of the token multiplied by the minimum number of times it must
     * match.
     */
    int getMinimumLength() {
	return (min * token.getMinimumLength());
    }
    // We do need to save every possible point, but the number of clone()
    // invocations here is really a killer for performance on non-stingy
    // repeat operators.  I'm open to suggestions...
    // Hypothetical question: can you have a RE that matches 1 times,
    // 3 times, 5 times, but not 2 times or 4 times?  Does having
    // the subexpression back-reference operator allow that?
    boolean match(CharIndexed input, REMatch mymatch) {
	// number of times we've matched so far
	int numRepeats = 0; 
	// Possible positions for the next repeat to match at
	REMatch newMatch = mymatch;
	REMatch last = null;
	REMatch current;
	// Add the '0-repeats' index
	// positions.elementAt(z) == position [] in input after <<z>> matches
	Vector positions = new Vector();
	positions.addElement(newMatch);
	// Declare variables used in loop
	REMatch doables;
	REMatch doablesLast;
	REMatch recurrent;
	do {
	    // Check for stingy match for each possibility.
	    if (stingy && (numRepeats >= min)) {
		REMatch result = matchRest(input, newMatch);
		if (result != null) {
		    mymatch.assignFrom(result);
		    return true;
		}
	    }
	    doables = null;
	    doablesLast = null;
	    // try next repeat at all possible positions
	    for (current = newMatch; current != null; current = current.next) {
		recurrent = (REMatch) current.clone();
		if (token.match(input, recurrent)) {
		    // add all items in current to doables array
		    if (doables == null) {
			doables = recurrent;
			doablesLast = recurrent;
		    } else {
			// Order these from longest to shortest
			// Start by assuming longest (more repeats)
			doablesLast.next = recurrent;
		    }
		    // Find new doablesLast
		    while (doablesLast.next != null) {
			doablesLast = doablesLast.next;
		    }
		}
	    }
	    // if none of the possibilities worked out, break out of do/while
	    if (doables == null) break;
	    // reassign where the next repeat can match
	    newMatch = doables;
	    // increment how many repeats we've successfully found
	    ++numRepeats;
	    positions.addElement(newMatch);
	} while (numRepeats < max);
	// If there aren't enough repeats, then fail
	if (numRepeats < min) return false;
	// We're greedy, but ease off until a true match is found 
	int posIndex = positions.size();
	// At this point we've either got too many or just the right amount.
	// See if this numRepeats works with the rest of the regexp.
	REMatch allResults = null;
	REMatch allResultsLast = null;
	REMatch results = null;
	while (--posIndex >= min) {
	    newMatch = (REMatch) positions.elementAt(posIndex);
	    results = matchRest(input, newMatch);
	    if (results != null) {
		if (allResults == null) {
		    allResults = results;
		    allResultsLast = results;
		} else {
		    // Order these from longest to shortest
		    // Start by assuming longest (more repeats)
		    allResultsLast.next = results;
		}
		// Find new doablesLast
		while (allResultsLast.next != null) {
		    allResultsLast = allResultsLast.next;
		}
	    }
	    // else did not match rest of the tokens, try again on smaller sample
	}
	if (allResults != null) {
	    mymatch.assignFrom(allResults); // does this get all?
	    return true;
	}
	// If we fall out, no matches.
	return false;
    }
    private REMatch matchRest(CharIndexed input, final REMatch newMatch) {
	REMatch current, single;
	REMatch doneIndex = null;
	REMatch doneIndexLast = null;
	// Test all possible matches for this number of repeats
	for (current = newMatch; current != null; current = current.next) {
	    // clone() separates a single match from the chain
	    single = (REMatch) current.clone();
	    if (next(input, single)) {
		// chain results to doneIndex
		if (doneIndex == null) {
		    doneIndex = single;
		    doneIndexLast = single;
		} else {
		    doneIndexLast.next = single;
		}
		// Find new doneIndexLast
		while (doneIndexLast.next != null) {
		    doneIndexLast = doneIndexLast.next;
		}
	    }
	}
	return doneIndex;
    }
    void dump(StringBuffer os) {
	os.append(""(?:"");
	token.dumpAll(os);
	os.append(')');
	if ((max == Integer.MAX_VALUE) && (min <= 1))
	    os.append( (min == 0) ? '*' : '+' );
	else if ((min == 0) && (max == 1))
	    os.append('?');
	else {
	    os.append('{').append(min);
	    if (max > min) {
		os.append(',');
		if (max != Integer.MAX_VALUE) os.append(max);
	    }
	    os.append('}');
	}
	if (stingy) os.append('?');
    }
}
"
gnu.regexp.RETokenStart,"/*
 *  gnu/regexp/RETokenStart.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
class RETokenStart extends REToken {
    private String newline; // matches after a newline
    RETokenStart(int subIndex, String newline) {
	super(subIndex);
	this.newline = newline;
    }
    boolean match(CharIndexed input, REMatch mymatch) {
	// charAt(index-n) may be unknown on a Reader/InputStream. FIXME
	// Match after a newline if in multiline mode
	if (newline != null) {
	    int len = newline.length();
	    if (mymatch.offset >= len) {
		boolean found = true;
		char z;
		int i = 0; // position in REToken.newline
		char ch = input.charAt(mymatch.index - len);
		do {
		    z = newline.charAt(i);
		    if (ch != z) {
			found = false;
			break;
		    }
		    ++i;
		    ch = input.charAt(mymatch.index - len + i);
		} while (i < len);
		if (found) return next(input, mymatch);
	    }
	}
	// Don't match at all if REG_NOTBOL is set.
	if ((mymatch.eflags & RE.REG_NOTBOL) > 0) return false;
	if ((mymatch.eflags & RE.REG_ANCHORINDEX) > 0)
	    return (mymatch.anchor == mymatch.offset) ? 
		next(input, mymatch) : false;
	else
	    return ((mymatch.index == 0) && (mymatch.offset == 0)) ?
		next(input, mymatch) : false;
    }
    void dump(StringBuffer os) {
	os.append('^');
    }
}
"
gnu.regexp.RETokenWordBoundary,"/*
 *  gnu/regexp/RETokenWordBoundary.java
 *  Copyright (C) 2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
/**
 * Represents a combination lookahead/lookbehind for POSIX [:alnum:].
 */
final class RETokenWordBoundary extends REToken {
    private boolean negated;
    private int where;
    static final int BEGIN = 1;
    static final int END = 2;
    RETokenWordBoundary(int subIndex, int where, boolean negated) {
	super(subIndex);
	this.where = where;
	this.negated = negated;
    }
    boolean match(CharIndexed input, REMatch mymatch) {
	// Word boundary means input[index-1] was a word character
	// and input[index] is not, or input[index] is a word character
	// and input[index-1] was not
	//  In the string ""one two three"", these positions match:
	//  |o|n|e| |t|w|o| |t|h|r|e|e|
	//  ^     ^ ^     ^ ^         ^
	boolean after = false;  // is current character a letter or digit?
	boolean before = false; // is previous character a letter or digit?
	char ch;
	// TODO: Also check REG_ANCHORINDEX vs. anchor
	if (((mymatch.eflags & RE.REG_ANCHORINDEX) != RE.REG_ANCHORINDEX) 
	    || (mymatch.offset + mymatch.index > mymatch.anchor)) {
	    if ((ch = input.charAt(mymatch.index - 1)) != CharIndexed.OUT_OF_BOUNDS) {
		before = Character.isLetterOrDigit(ch) || (ch == '_');
	    }
	}
	if ((ch = input.charAt(mymatch.index)) != CharIndexed.OUT_OF_BOUNDS) {
	    after = Character.isLetterOrDigit(ch) || (ch == '_');
	}
	// if (before) and (!after), we're at end (\>)
	// if (after) and (!before), we're at beginning (\<)
	boolean doNext = false;
	if ((where & BEGIN) == BEGIN) {
	    doNext = after && !before;
	}
	if ((where & END) == END) {
	    doNext ^= before && !after;
	}
	if (negated) doNext = !doNext;
	return (doNext ? next(input, mymatch) : false);
    }
    void dump(StringBuffer os) {
	if (where == (BEGIN | END)) {
	    os.append( negated ? ""\\B"" : ""\\b"" );
	} else if (where == BEGIN) {
	    os.append(""\\<"");
	} else {
	    os.append(""\\>"");
	}
    }
}
"
gnu.regexp.UncheckedRE,"/*
 *  gnu/regexp/UncheckedRE.java
 *  Copyright (C) 2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
/**
 * UncheckedRE is a subclass of RE that allows programmers an easier means
 * of programmatically precompiling regular expressions.  It is constructed
 * and used in exactly the same manner as an instance of the RE class; the
 * only difference is that its constructors do not throw REException.
 * Instead, if a syntax error is encountered during construction, a
 * RuntimeException will be thrown.
 * <P>
 * Note that this makes UncheckedRE dangerous if constructed with
 * dynamic data.  Do not use UncheckedRE unless you are completely sure
 * that all input being passed to it contains valid, well-formed 
 * regular expressions for the syntax specified.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 * @see gnu.regexp.RE 
 * @since gnu.regexp 1.1.4
 */
public final class UncheckedRE extends RE {
  /**
   * Constructs a regular expression pattern buffer without any compilation
   * flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5).
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @exception RuntimeException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public UncheckedRE(Object pattern) {
      this(pattern,0,RESyntax.RE_SYNTAX_PERL5);
  }
  /**
   * Constructs a regular expression pattern buffer using the specified
   * compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5).
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer, or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @param cflags The logical OR of any combination of the compilation flags in the RE class.
   * @exception RuntimeException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public UncheckedRE(Object pattern, int cflags) {
      this(pattern,cflags,RESyntax.RE_SYNTAX_PERL5);
  }
  /**
   * Constructs a regular expression pattern buffer using the specified
   * compilation flags and regular expression syntax.
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer, or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @param cflags The logical OR of any combination of the compilation flags in the RE class.
   * @param syntax The type of regular expression syntax to use.
   * @exception RuntimeException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public UncheckedRE(Object pattern, int cflags, RESyntax syntax) {
      try {
	  initialize(pattern,cflags,syntax,0,0);
      } catch (REException e) { 
	  throw new RuntimeException(e.getMessage());
      }
  }
}
"
installer.BZip2Constants,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included with this distribution in
 * the LICENSE.txt file.
 */
package installer;
/**
 * Base class for both the compress and decompress classes. Holds common arrays,
 * and static data.
 *
 * @author <a href=""mailto:keiron@aftexsw.com"">Keiron Liddle</a>
 */
interface BZip2Constants
{
    int BASE_BLOCK_SIZE = 100000;
    int MAX_ALPHA_SIZE = 258;
    int MAX_CODE_LEN = 23;
    int RUNA = 0;
    int RUNB = 1;
    int N_GROUPS = 6;
    int G_SIZE = 50;
    int N_ITERS = 4;
    int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) );
    int NUM_OVERSHOOT_BYTES = 20;
    int[] RAND_NUMS = new int[]
    {
        619, 720, 127, 481, 931, 816, 813, 233, 566, 247,
        985, 724, 205, 454, 863, 491, 741, 242, 949, 214,
        733, 859, 335, 708, 621, 574, 73, 654, 730, 472,
        419, 436, 278, 496, 867, 210, 399, 680, 480, 51,
        878, 465, 811, 169, 869, 675, 611, 697, 867, 561,
        862, 687, 507, 283, 482, 129, 807, 591, 733, 623,
        150, 238, 59, 379, 684, 877, 625, 169, 643, 105,
        170, 607, 520, 932, 727, 476, 693, 425, 174, 647,
        73, 122, 335, 530, 442, 853, 695, 249, 445, 515,
        909, 545, 703, 919, 874, 474, 882, 500, 594, 612,
        641, 801, 220, 162, 819, 984, 589, 513, 495, 799,
        161, 604, 958, 533, 221, 400, 386, 867, 600, 782,
        382, 596, 414, 171, 516, 375, 682, 485, 911, 276,
        98, 553, 163, 354, 666, 933, 424, 341, 533, 870,
        227, 730, 475, 186, 263, 647, 537, 686, 600, 224,
        469, 68, 770, 919, 190, 373, 294, 822, 808, 206,
        184, 943, 795, 384, 383, 461, 404, 758, 839, 887,
        715, 67, 618, 276, 204, 918, 873, 777, 604, 560,
        951, 160, 578, 722, 79, 804, 96, 409, 713, 940,
        652, 934, 970, 447, 318, 353, 859, 672, 112, 785,
        645, 863, 803, 350, 139, 93, 354, 99, 820, 908,
        609, 772, 154, 274, 580, 184, 79, 626, 630, 742,
        653, 282, 762, 623, 680, 81, 927, 626, 789, 125,
        411, 521, 938, 300, 821, 78, 343, 175, 128, 250,
        170, 774, 972, 275, 999, 639, 495, 78, 352, 126,
        857, 956, 358, 619, 580, 124, 737, 594, 701, 612,
        669, 112, 134, 694, 363, 992, 809, 743, 168, 974,
        944, 375, 748, 52, 600, 747, 642, 182, 862, 81,
        344, 805, 988, 739, 511, 655, 814, 334, 249, 515,
        897, 955, 664, 981, 649, 113, 974, 459, 893, 228,
        433, 837, 553, 268, 926, 240, 102, 654, 459, 51,
        686, 754, 806, 760, 493, 403, 415, 394, 687, 700,
        946, 670, 656, 610, 738, 392, 760, 799, 887, 653,
        978, 321, 576, 617, 626, 502, 894, 679, 243, 440,
        680, 879, 194, 572, 640, 724, 926, 56, 204, 700,
        707, 151, 457, 449, 797, 195, 791, 558, 945, 679,
        297, 59, 87, 824, 713, 663, 412, 693, 342, 606,
        134, 108, 571, 364, 631, 212, 174, 643, 304, 329,
        343, 97, 430, 751, 497, 314, 983, 374, 822, 928,
        140, 206, 73, 263, 980, 736, 876, 478, 430, 305,
        170, 514, 364, 692, 829, 82, 855, 953, 676, 246,
        369, 970, 294, 750, 807, 827, 150, 790, 288, 923,
        804, 378, 215, 828, 592, 281, 565, 555, 710, 82,
        896, 831, 547, 261, 524, 462, 293, 465, 502, 56,
        661, 821, 976, 991, 658, 869, 905, 758, 745, 193,
        768, 550, 608, 933, 378, 286, 215, 979, 792, 961,
        61, 688, 793, 644, 986, 403, 106, 366, 905, 644,
        372, 567, 466, 434, 645, 210, 389, 550, 919, 135,
        780, 773, 635, 389, 707, 100, 626, 958, 165, 504,
        920, 176, 193, 713, 857, 265, 203, 50, 668, 108,
        645, 990, 626, 197, 510, 357, 358, 850, 858, 364,
        936, 638
    };
}
"
installer.CBZip2InputStream,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included with this distribution in
 * the LICENSE.txt file.
 */
package installer;
import java.io.IOException;
import java.io.InputStream;
/**
 * An input stream that decompresses from the BZip2 format (without the file
 * header chars) to be read as any other stream.
 *
 * @author <a href=""mailto:keiron@aftexsw.com"">Keiron Liddle</a>
 */
public class CBZip2InputStream
    extends InputStream
    implements BZip2Constants
{
    private static final int START_BLOCK_STATE = 1;
    private static final int RAND_PART_A_STATE = 2;
    private static final int RAND_PART_B_STATE = 3;
    private static final int RAND_PART_C_STATE = 4;
    private static final int NO_RAND_PART_A_STATE = 5;
    private static final int NO_RAND_PART_B_STATE = 6;
    private static final int NO_RAND_PART_C_STATE = 7;
    private CRC m_crc = new CRC();
    private boolean[] m_inUse = new boolean[ 256 ];
    private char[] m_seqToUnseq = new char[ 256 ];
    private char[] m_unseqToSeq = new char[ 256 ];
    private char[] m_selector = new char[ MAX_SELECTORS ];
    private char[] m_selectorMtf = new char[ MAX_SELECTORS ];
    /*
     * freq table collected to save a pass over the data
     * during decompression.
     */
    private int[] m_unzftab = new int[ 256 ];
    private int[][] m_limit = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];
    private int[][] m_base = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];
    private int[][] m_perm = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];
    private int[] m_minLens = new int[ N_GROUPS ];
    private boolean m_streamEnd;
    private int m_currentChar = -1;
    private int m_currentState = START_BLOCK_STATE;
    private int m_rNToGo;
    private int m_rTPos;
    private int m_tPos;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int j2;
    private char z;
    private boolean m_blockRandomised;
    /*
     * always: in the range 0 .. 9.
     * The current block size is 100000 * this number.
     */
    private int m_blockSize100k;
    private int m_bsBuff;
    private int m_bsLive;
    private InputStream m_input;
    private int m_computedBlockCRC;
    private int m_computedCombinedCRC;
    /*
     * index of the last char in the block, so
     * the block size == last + 1.
     */
    private int m_last;
    private char[] m_ll8;
    private int m_nInUse;
    /*
     * index in zptr[] of original string after sorting.
     */
    private int m_origPtr;
    private int m_storedBlockCRC;
    private int m_storedCombinedCRC;
    private int[] m_tt;
    public CBZip2InputStream( final InputStream input )
    {
        bsSetStream( input );
        initialize();
        initBlock();
        setupBlock();
    }
    private static void badBlockHeader()
    {
        cadvise();
    }
    private static void blockOverrun()
    {
        cadvise();
    }
    private static void cadvise()
    {
        System.out.println( ""CRC Error"" );
        //throw new CCoruptionError();
    }
    private static void compressedStreamEOF()
    {
        cadvise();
    }
    private static void crcError()
    {
        cadvise();
    }
    public int read()
    {
        if( m_streamEnd )
        {
            return -1;
        }
        else
        {
            int retChar = m_currentChar;
            switch( m_currentState )
            {
                case START_BLOCK_STATE:
                    break;
                case RAND_PART_A_STATE:
                    break;
                case RAND_PART_B_STATE:
                    setupRandPartB();
                    break;
                case RAND_PART_C_STATE:
                    setupRandPartC();
                    break;
                case NO_RAND_PART_A_STATE:
                    break;
                case NO_RAND_PART_B_STATE:
                    setupNoRandPartB();
                    break;
                case NO_RAND_PART_C_STATE:
                    setupNoRandPartC();
                    break;
                default:
                    break;
            }
            return retChar;
        }
    }
    private void setDecompressStructureSizes( int newSize100k )
    {
        if( !( 0 <= newSize100k && newSize100k <= 9 && 0 <= m_blockSize100k
            && m_blockSize100k <= 9 ) )
        {
            // throw new IOException(""Invalid block size"");
        }
        m_blockSize100k = newSize100k;
        if( newSize100k == 0 )
        {
            return;
        }
        int n = BASE_BLOCK_SIZE * newSize100k;
        m_ll8 = new char[ n ];
        m_tt = new int[ n ];
    }
    private void setupBlock()
    {
        int[] cftab = new int[ 257 ];
        char ch;
        cftab[ 0 ] = 0;
        for( int i = 1; i <= 256; i++ )
        {
            cftab[ i ] = m_unzftab[ i - 1 ];
        }
        for( int i = 1; i <= 256; i++ )
        {
            cftab[ i ] += cftab[ i - 1 ];
        }
        for( int i = 0; i <= m_last; i++ )
        {
            ch = m_ll8[ i ];
            m_tt[ cftab[ ch ] ] = i;
            cftab[ ch ]++;
        }
        cftab = null;
        m_tPos = m_tt[ m_origPtr ];
        count = 0;
        i2 = 0;
        ch2 = 256;
        /*
         * not a char and not EOF
         */
        if( m_blockRandomised )
        {
            m_rNToGo = 0;
            m_rTPos = 0;
            setupRandPartA();
        }
        else
        {
            setupNoRandPartA();
        }
    }
    private void setupNoRandPartA()
    {
        if( i2 <= m_last )
        {
            chPrev = ch2;
            ch2 = m_ll8[ m_tPos ];
            m_tPos = m_tt[ m_tPos ];
            i2++;
            m_currentChar = ch2;
            m_currentState = NO_RAND_PART_B_STATE;
            m_crc.updateCRC( ch2 );
        }
        else
        {
            endBlock();
            initBlock();
            setupBlock();
        }
    }
    private void setupNoRandPartB()
    {
        if( ch2 != chPrev )
        {
            m_currentState = NO_RAND_PART_A_STATE;
            count = 1;
            setupNoRandPartA();
        }
        else
        {
            count++;
            if( count >= 4 )
            {
                z = m_ll8[ m_tPos ];
                m_tPos = m_tt[ m_tPos ];
                m_currentState = NO_RAND_PART_C_STATE;
                j2 = 0;
                setupNoRandPartC();
            }
            else
            {
                m_currentState = NO_RAND_PART_A_STATE;
                setupNoRandPartA();
            }
        }
    }
    private void setupNoRandPartC()
    {
        if( j2 < z )
        {
            m_currentChar = ch2;
            m_crc.updateCRC( ch2 );
            j2++;
        }
        else
        {
            m_currentState = NO_RAND_PART_A_STATE;
            i2++;
            count = 0;
            setupNoRandPartA();
        }
    }
    private void setupRandPartA()
    {
        if( i2 <= m_last )
        {
            chPrev = ch2;
            ch2 = m_ll8[ m_tPos ];
            m_tPos = m_tt[ m_tPos ];
            if( m_rNToGo == 0 )
            {
                m_rNToGo = RAND_NUMS[ m_rTPos ];
                m_rTPos++;
                if( m_rTPos == 512 )
                {
                    m_rTPos = 0;
                }
            }
            m_rNToGo--;
            ch2 ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );
            i2++;
            m_currentChar = ch2;
            m_currentState = RAND_PART_B_STATE;
            m_crc.updateCRC( ch2 );
        }
        else
        {
            endBlock();
            initBlock();
            setupBlock();
        }
    }
    private void setupRandPartB()
    {
        if( ch2 != chPrev )
        {
            m_currentState = RAND_PART_A_STATE;
            count = 1;
            setupRandPartA();
        }
        else
        {
            count++;
            if( count >= 4 )
            {
                z = m_ll8[ m_tPos ];
                m_tPos = m_tt[ m_tPos ];
                if( m_rNToGo == 0 )
                {
                    m_rNToGo = RAND_NUMS[ m_rTPos ];
                    m_rTPos++;
                    if( m_rTPos == 512 )
                    {
                        m_rTPos = 0;
                    }
                }
                m_rNToGo--;
                z ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );
                j2 = 0;
                m_currentState = RAND_PART_C_STATE;
                setupRandPartC();
            }
            else
            {
                m_currentState = RAND_PART_A_STATE;
                setupRandPartA();
            }
        }
    }
    private void setupRandPartC()
    {
        if( j2 < z )
        {
            m_currentChar = ch2;
            m_crc.updateCRC( ch2 );
            j2++;
        }
        else
        {
            m_currentState = RAND_PART_A_STATE;
            i2++;
            count = 0;
            setupRandPartA();
        }
    }
    private void getAndMoveToFrontDecode()
    {
        int nextSym;
        int limitLast = BASE_BLOCK_SIZE * m_blockSize100k;
        m_origPtr = readVariableSizedInt( 24 );
        recvDecodingTables();
        int EOB = m_nInUse + 1;
        int groupNo = -1;
        int groupPos = 0;
        /*
         * Setting up the unzftab entries here is not strictly
         * necessary, but it does save having to do it later
         * in a separate pass, and so saves a block's worth of
         * cache misses.
         */
        for( int i = 0; i <= 255; i++ )
        {
            m_unzftab[ i ] = 0;
        }
        final char[] yy = new char[ 256 ];
        for( int i = 0; i <= 255; i++ )
        {
            yy[ i ] = (char)i;
        }
        m_last = -1;
        int zt;
        int zn;
        int zvec;
        int zj;
        groupNo++;
        groupPos = G_SIZE - 1;
        zt = m_selector[ groupNo ];
        zn = m_minLens[ zt ];
        zvec = bsR( zn );
        while( zvec > m_limit[ zt ][ zn ] )
        {
            zn++;
            while( m_bsLive < 1 )
            {
                int zzi;
                char thech = 0;
                try
                {
                    thech = (char)m_input.read();
                }
                catch( IOException e )
                {
                    compressedStreamEOF();
                }
                if( thech == -1 )
                {
                    compressedStreamEOF();
                }
                zzi = thech;
                m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );
                m_bsLive += 8;
            }
            zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;
            m_bsLive--;
            zvec = ( zvec << 1 ) | zj;
        }
        nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];
        while( true )
        {
            if( nextSym == EOB )
            {
                break;
            }
            if( nextSym == RUNA || nextSym == RUNB )
            {
                char ch;
                int s = -1;
                int N = 1;
                do
                {
                    if( nextSym == RUNA )
                    {
                        s = s + ( 0 + 1 ) * N;
                    }
                    else// if( nextSym == RUNB )
                    {
                        s = s + ( 1 + 1 ) * N;
                    }
                    N = N * 2;
                    if( groupPos == 0 )
                    {
                        groupNo++;
                        groupPos = G_SIZE;
                    }
                    groupPos--;
                    zt = m_selector[ groupNo ];
                    zn = m_minLens[ zt ];
                    zvec = bsR( zn );
                    while( zvec > m_limit[ zt ][ zn ] )
                    {
                        zn++;
                        while( m_bsLive < 1 )
                        {
                            int zzi;
                            char thech = 0;
                            try
                            {
                                thech = (char)m_input.read();
                            }
                            catch( IOException e )
                            {
                                compressedStreamEOF();
                            }
                            if( thech == -1 )
                            {
                                compressedStreamEOF();
                            }
                            zzi = thech;
                            m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );
                            m_bsLive += 8;
                        }
                        zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;
                        m_bsLive--;
                        zvec = ( zvec << 1 ) | zj;
                    }
                    nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];
                } while( nextSym == RUNA || nextSym == RUNB );
                s++;
                ch = m_seqToUnseq[ yy[ 0 ] ];
                m_unzftab[ ch ] += s;
                while( s > 0 )
                {
                    m_last++;
                    m_ll8[ m_last ] = ch;
                    s--;
                }
                if( m_last >= limitLast )
                {
                    blockOverrun();
                }
                continue;
            }
            else
            {
                char tmp;
                m_last++;
                if( m_last >= limitLast )
                {
                    blockOverrun();
                }
                tmp = yy[ nextSym - 1 ];
                m_unzftab[ m_seqToUnseq[ tmp ] ]++;
                m_ll8[ m_last ] = m_seqToUnseq[ tmp ];
                /*
                 * This loop is hammered during decompression,
                 * hence the unrolling.
                 * for (j = nextSym-1; j > 0; j--) yy[j] = yy[j-1];
                 */
                int j = nextSym - 1;
                for( ; j > 3; j -= 4 )
                {
                    yy[ j ] = yy[ j - 1 ];
                    yy[ j - 1 ] = yy[ j - 2 ];
                    yy[ j - 2 ] = yy[ j - 3 ];
                    yy[ j - 3 ] = yy[ j - 4 ];
                }
                for( ; j > 0; j-- )
                {
                    yy[ j ] = yy[ j - 1 ];
                }
                yy[ 0 ] = tmp;
                if( groupPos == 0 )
                {
                    groupNo++;
                    groupPos = G_SIZE;
                }
                groupPos--;
                zt = m_selector[ groupNo ];
                zn = m_minLens[ zt ];
                zvec = bsR( zn );
                while( zvec > m_limit[ zt ][ zn ] )
                {
                    zn++;
                    while( m_bsLive < 1 )
                    {
                        char ch = 0;
                        try
                        {
                            ch = (char)m_input.read();
                        }
                        catch( IOException e )
                        {
                            compressedStreamEOF();
                        }
                        m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );
                        m_bsLive += 8;
                    }
                    zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;
                    m_bsLive--;
                    zvec = ( zvec << 1 ) | zj;
                }
                nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];
                continue;
            }
        }
    }
    private void bsFinishedWithStream()
    {
        m_input = null;
    }
    private int readVariableSizedInt( final int numBits )
    {
        return bsR( numBits );
    }
    private char readUnsignedChar()
    {
        return (char)bsR( 8 );
    }
    private int readInt()
    {
        int u = 0;
        u = ( u << 8 ) | bsR( 8 );
        u = ( u << 8 ) | bsR( 8 );
        u = ( u << 8 ) | bsR( 8 );
        u = ( u << 8 ) | bsR( 8 );
        return u;
    }
    private int bsR( final int n )
    {
        while( m_bsLive < n )
        {
            char ch = 0;
            try
            {
                ch = (char)m_input.read();
            }
            catch( final IOException ioe )
            {
                compressedStreamEOF();
            }
            if( ch == -1 )
            {
                compressedStreamEOF();
            }
            m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );
            m_bsLive += 8;
        }
        final int result = ( m_bsBuff >> ( m_bsLive - n ) ) & ( ( 1 << n ) - 1 );
        m_bsLive -= n;
        return result;
    }
    private void bsSetStream( final InputStream input )
    {
        m_input = input;
        m_bsLive = 0;
        m_bsBuff = 0;
    }
    private void complete()
    {
        m_storedCombinedCRC = readInt();
        if( m_storedCombinedCRC != m_computedCombinedCRC )
        {
            crcError();
        }
        bsFinishedWithStream();
        m_streamEnd = true;
    }
    private void endBlock()
    {
        m_computedBlockCRC = m_crc.getFinalCRC();
        /*
         * A bad CRC is considered a fatal error.
         */
        if( m_storedBlockCRC != m_computedBlockCRC )
        {
            crcError();
        }
        m_computedCombinedCRC = ( m_computedCombinedCRC << 1 )
            | ( m_computedCombinedCRC >>> 31 );
        m_computedCombinedCRC ^= m_computedBlockCRC;
    }
    private void hbCreateDecodeTables( final int[] limit,
                                       final int[] base,
                                       final int[] perm,
                                       final char[] length,
                                       final int minLen,
                                       final int maxLen,
                                       final int alphaSize )
    {
        int pp = 0;
        for( int i = minLen; i <= maxLen; i++ )
        {
            for( int j = 0; j < alphaSize; j++ )
            {
                if( length[ j ] == i )
                {
                    perm[ pp ] = j;
                    pp++;
                }
            }
        }
        for( int i = 0; i < MAX_CODE_LEN; i++ )
        {
            base[ i ] = 0;
        }
        for( int i = 0; i < alphaSize; i++ )
        {
            base[ length[ i ] + 1 ]++;
        }
        for( int i = 1; i < MAX_CODE_LEN; i++ )
        {
            base[ i ] += base[ i - 1 ];
        }
        for( int i = 0; i < MAX_CODE_LEN; i++ )
        {
            limit[ i ] = 0;
        }
        int vec = 0;
        for( int i = minLen; i <= maxLen; i++ )
        {
            vec += ( base[ i + 1 ] - base[ i ] );
            limit[ i ] = vec - 1;
            vec <<= 1;
        }
        for( int i = minLen + 1; i <= maxLen; i++ )
        {
            base[ i ] = ( ( limit[ i - 1 ] + 1 ) << 1 ) - base[ i ];
        }
    }
    private void initBlock()
    {
        final char magic1 = readUnsignedChar();
        final char magic2 = readUnsignedChar();
        final char magic3 = readUnsignedChar();
        final char magic4 = readUnsignedChar();
        final char magic5 = readUnsignedChar();
        final char magic6 = readUnsignedChar();
        if( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 &&
            magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 )
        {
            complete();
            return;
        }
        if( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 ||
            magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 )
        {
            badBlockHeader();
            m_streamEnd = true;
            return;
        }
        m_storedBlockCRC = readInt();
        if( bsR( 1 ) == 1 )
        {
            m_blockRandomised = true;
        }
        else
        {
            m_blockRandomised = false;
        }
        //        currBlockNo++;
        getAndMoveToFrontDecode();
        m_crc.initialiseCRC();
        m_currentState = START_BLOCK_STATE;
    }
    private void initialize()
    {
        final char magic3 = readUnsignedChar();
        final char magic4 = readUnsignedChar();
        if( magic3 != 'h' || magic4 < '1' || magic4 > '9' )
        {
            bsFinishedWithStream();
            m_streamEnd = true;
            return;
        }
        setDecompressStructureSizes( magic4 - '0' );
        m_computedCombinedCRC = 0;
    }
    private void makeMaps()
    {
        m_nInUse = 0;
        for( int i = 0; i < 256; i++ )
        {
            if( m_inUse[ i ] )
            {
                m_seqToUnseq[ m_nInUse ] = (char)i;
                m_unseqToSeq[ i ] = (char)m_nInUse;
                m_nInUse++;
            }
        }
    }
    private void recvDecodingTables()
    {
        buildInUseTable();
        makeMaps();
        final int alphaSize = m_nInUse + 2;
        /*
         * Now the selectors
         */
        final int groupCount = bsR( 3 );
        final int selectorCount = bsR( 15 );
        for( int i = 0; i < selectorCount; i++ )
        {
            int run = 0;
            while( bsR( 1 ) == 1 )
            {
                run++;
            }
            m_selectorMtf[ i ] = (char)run;
        }
        /*
         * Undo the MTF values for the selectors.
         */
        final char[] pos = new char[ N_GROUPS ];
        for( char v = 0; v < groupCount; v++ )
        {
            pos[ v ] = v;
        }
        for( int i = 0; i < selectorCount; i++ )
        {
            int v = m_selectorMtf[ i ];
            final char tmp = pos[ v ];
            while( v > 0 )
            {
                pos[ v ] = pos[ v - 1 ];
                v--;
            }
            pos[ 0 ] = tmp;
            m_selector[ i ] = tmp;
        }
        final char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];
        /*
         * Now the coding tables
         */
        for( int i = 0; i < groupCount; i++ )
        {
            int curr = bsR( 5 );
            for( int j = 0; j < alphaSize; j++ )
            {
                while( bsR( 1 ) == 1 )
                {
                    if( bsR( 1 ) == 0 )
                    {
                        curr++;
                    }
                    else
                    {
                        curr--;
                    }
                }
                len[ i ][ j ] = (char)curr;
            }
        }
        /*
         * Create the Huffman decoding tables
         */
        for( int k = 0; k < groupCount; k++ )
        {
            int minLen = 32;
            int maxLen = 0;
            for( int i = 0; i < alphaSize; i++ )
            {
                if( len[ k ][ i ] > maxLen )
                {
                    maxLen = len[ k ][ i ];
                }
                if( len[ k ][ i ] < minLen )
                {
                    minLen = len[ k ][ i ];
                }
            }
            hbCreateDecodeTables( m_limit[ k ], m_base[ k ], m_perm[ k ], len[ k ], minLen,
                                  maxLen, alphaSize );
            m_minLens[ k ] = minLen;
        }
    }
    private void buildInUseTable()
    {
        final boolean[] inUse16 = new boolean[ 16 ];
        /*
         * Receive the mapping table
         */
        for( int i = 0; i < 16; i++ )
        {
            if( bsR( 1 ) == 1 )
            {
                inUse16[ i ] = true;
            }
            else
            {
                inUse16[ i ] = false;
            }
        }
        for( int i = 0; i < 256; i++ )
        {
            m_inUse[ i ] = false;
        }
        for( int i = 0; i < 16; i++ )
        {
            if( inUse16[ i ] )
            {
                for( int j = 0; j < 16; j++ )
                {
                    if( bsR( 1 ) == 1 )
                    {
                        m_inUse[ i * 16 + j ] = true;
                    }
                }
            }
        }
    }
}
"
installer.CBZip2OutputStream,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included with this distribution in
 * the LICENSE.txt file.
 */
package installer;
import java.io.IOException;
import java.io.OutputStream;
/**
 * An output stream that compresses into the BZip2 format (without the file
 * header chars) into another stream. TODO: Update to BZip2 1.0.1
 *
 * @author <a href=""mailto:keiron@aftexsw.com"">Keiron Liddle</a>
 */
public class CBZip2OutputStream
    extends OutputStream
    implements BZip2Constants
{
    private static final int LOWER_BYTE_MASK = 0x000000ff;
    private static final int UPPER_BYTE_MASK = 0xffffff00;
    private static final int SETMASK = ( 1 << 21 );
    private static final int CLEARMASK = ( ~SETMASK );
    private static final int GREATER_ICOST = 15;
    private static final int LESSER_ICOST = 0;
    private static final int SMALL_THRESH = 20;
    private static final int DEPTH_THRESH = 10;
    /*
     * If you are ever unlucky/improbable enough
     * to get a stack overflow whilst sorting,
     * increase the following constant and try
     * again.  In practice I have never seen the
     * stack go above 27 elems, so the following
     * limit seems very generous.
     */
    private static final int QSORT_STACK_SIZE = 1000;
    private CRC m_crc = new CRC();
    private boolean[] m_inUse = new boolean[ 256 ];
    private char[] m_seqToUnseq = new char[ 256 ];
    private char[] m_unseqToSeq = new char[ 256 ];
    private char[] m_selector = new char[ MAX_SELECTORS ];
    private char[] m_selectorMtf = new char[ MAX_SELECTORS ];
    private int[] m_mtfFreq = new int[ MAX_ALPHA_SIZE ];
    private int m_currentChar = -1;
    private int m_runLength;
    private boolean m_closed;
    /*
     * Knuth's increments seem to work better
     * than Incerpi-Sedgewick here.  Possibly
     * because the number of elems to sort is
     * usually small, typically <= 20.
     */
    private int[] m_incs = new int[]
    {
        1, 4, 13, 40, 121, 364, 1093, 3280,
        9841, 29524, 88573, 265720,
        797161, 2391484
    };
    private boolean m_blockRandomised;
    /*
     * always: in the range 0 .. 9.
     * The current block size is 100000 * this number.
     */
    private int m_blockSize100k;
    private int m_bsBuff;
    private int m_bsLive;
    /*
     * index of the last char in the block, so
     * the block size == last + 1.
     */
    private int m_last;
    /*
     * index in zptr[] of original string after sorting.
     */
    private int m_origPtr;
    private int m_allowableBlockSize;
    private char[] m_block;
    private int m_blockCRC;
    private int m_combinedCRC;
    private OutputStream m_bsStream;
    private boolean m_firstAttempt;
    private int[] m_ftab;
    private int m_nInUse;
    private int m_nMTF;
    private int[] m_quadrant;
    private short[] m_szptr;
    private int m_workDone;
    /*
     * Used when sorting.  If too many long comparisons
     * happen, we stop sorting, randomise the block
     * slightly, and try again.
     */
    private int m_workFactor;
    private int m_workLimit;
    private int[] m_zptr;
    public CBZip2OutputStream( final OutputStream output )
        throws IOException
    {
        this( output, 9 );
    }
    public CBZip2OutputStream( final OutputStream output, final int blockSize )
        throws IOException
    {
        bsSetStream( output );
        m_workFactor = 50;
        int outBlockSize = blockSize;
        if( outBlockSize > 9 )
        {
            outBlockSize = 9;
        }
        if( outBlockSize < 1 )
        {
            outBlockSize = 1;
        }
        m_blockSize100k = outBlockSize;
        allocateCompressStructures();
        initialize();
        initBlock();
    }
    private static void hbMakeCodeLengths( char[] len, int[] freq,
                                           int alphaSize, int maxLen )
    {
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int nNodes;
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int nHeap;
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int n1;
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int n2;
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int i;
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int j;
        /*
         * Nodes and heap entries run from 1.  Entry 0
         * for both the heap and nodes is a sentinel.
         */
        int k;
        boolean tooLong;
        int[] heap = new int[ MAX_ALPHA_SIZE + 2 ];
        int[] weights = new int[ MAX_ALPHA_SIZE * 2 ];
        int[] parent = new int[ MAX_ALPHA_SIZE * 2 ];
        for( i = 0; i < alphaSize; i++ )
        {
            weights[ i + 1 ] = ( freq[ i ] == 0 ? 1 : freq[ i ] ) << 8;
        }
        while( true )
        {
            nNodes = alphaSize;
            nHeap = 0;
            heap[ 0 ] = 0;
            weights[ 0 ] = 0;
            parent[ 0 ] = -2;
            for( i = 1; i <= alphaSize; i++ )
            {
                parent[ i ] = -1;
                nHeap++;
                heap[ nHeap ] = i;
                {
                    int zz;
                    int tmp;
                    zz = nHeap;
                    tmp = heap[ zz ];
                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )
                    {
                        heap[ zz ] = heap[ zz >> 1 ];
                        zz >>= 1;
                    }
                    heap[ zz ] = tmp;
                }
            }
            if( !( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) )
            {
                panic();
            }
            while( nHeap > 1 )
            {
                n1 = heap[ 1 ];
                heap[ 1 ] = heap[ nHeap ];
                nHeap--;
                {
                    int zz = 0;
                    int yy = 0;
                    int tmp = 0;
                    zz = 1;
                    tmp = heap[ zz ];
                    while( true )
                    {
                        yy = zz << 1;
                        if( yy > nHeap )
                        {
                            break;
                        }
                        if( yy < nHeap &&
                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )
                        {
                            yy++;
                        }
                        if( weights[ tmp ] < weights[ heap[ yy ] ] )
                        {
                            break;
                        }
                        heap[ zz ] = heap[ yy ];
                        zz = yy;
                    }
                    heap[ zz ] = tmp;
                }
                n2 = heap[ 1 ];
                heap[ 1 ] = heap[ nHeap ];
                nHeap--;
                {
                    int zz = 0;
                    int yy = 0;
                    int tmp = 0;
                    zz = 1;
                    tmp = heap[ zz ];
                    while( true )
                    {
                        yy = zz << 1;
                        if( yy > nHeap )
                        {
                            break;
                        }
                        if( yy < nHeap &&
                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )
                        {
                            yy++;
                        }
                        if( weights[ tmp ] < weights[ heap[ yy ] ] )
                        {
                            break;
                        }
                        heap[ zz ] = heap[ yy ];
                        zz = yy;
                    }
                    heap[ zz ] = tmp;
                }
                nNodes++;
                parent[ n1 ] = nNodes;
                parent[ n2 ] = nNodes;
                final int v1 = weights[ n1 ];
                final int v2 = weights[ n2 ];
                final int weight = calculateWeight( v1, v2 );
                weights[ nNodes ] = weight;
                parent[ nNodes ] = -1;
                nHeap++;
                heap[ nHeap ] = nNodes;
                {
                    int zz = 0;
                    int tmp = 0;
                    zz = nHeap;
                    tmp = heap[ zz ];
                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )
                    {
                        heap[ zz ] = heap[ zz >> 1 ];
                        zz >>= 1;
                    }
                    heap[ zz ] = tmp;
                }
            }
            if( !( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) )
            {
                panic();
            }
            tooLong = false;
            for( i = 1; i <= alphaSize; i++ )
            {
                j = 0;
                k = i;
                while( parent[ k ] >= 0 )
                {
                    k = parent[ k ];
                    j++;
                }
                len[ i - 1 ] = (char)j;
                if( j > maxLen )
                {
                    tooLong = true;
                }
            }
            if( !tooLong )
            {
                break;
            }
            for( i = 1; i < alphaSize; i++ )
            {
                j = weights[ i ] >> 8;
                j = 1 + ( j / 2 );
                weights[ i ] = j << 8;
            }
        }
    }
    private static int calculateWeight( final int v1, final int v2 )
    {
        final int upper = ( v1 & UPPER_BYTE_MASK ) + ( v2 & UPPER_BYTE_MASK );
        final int v1Lower = ( v1 & LOWER_BYTE_MASK );
        final int v2Lower = ( v2 & LOWER_BYTE_MASK );
        final int nnnn = ( v1Lower > v2Lower ) ? v1Lower : v2Lower;
        return upper | ( 1 + nnnn );
    }
    private static void panic()
    {
        System.out.println( ""panic"" );
        //throw new CError();
    }
    public void close()
        throws IOException
    {
        if( m_closed )
        {
            return;
        }
        if( m_runLength > 0 )
        {
            writeRun();
        }
        m_currentChar = -1;
        endBlock();
        endCompression();
        m_closed = true;
        super.close();
        m_bsStream.close();
    }
    public void finalize()
        throws Throwable
    {
        close();
    }
    public void flush()
        throws IOException
    {
        super.flush();
        m_bsStream.flush();
    }
    /**
     * modified by Oliver Merkel, 010128
     *
     * @param bv Description of Parameter
     * @exception java.io.IOException Description of Exception
     */
    public void write( int bv )
        throws IOException
    {
        int b = ( 256 + bv ) % 256;
        if( m_currentChar != -1 )
        {
            if( m_currentChar == b )
            {
                m_runLength++;
                if( m_runLength > 254 )
                {
                    writeRun();
                    m_currentChar = -1;
                    m_runLength = 0;
                }
            }
            else
            {
                writeRun();
                m_runLength = 1;
                m_currentChar = b;
            }
        }
        else
        {
            m_currentChar = b;
            m_runLength++;
        }
    }
    private void allocateCompressStructures()
    {
        int n = BASE_BLOCK_SIZE * m_blockSize100k;
        m_block = new char[ ( n + 1 + NUM_OVERSHOOT_BYTES ) ];
        m_quadrant = new int[ ( n + NUM_OVERSHOOT_BYTES ) ];
        m_zptr = new int[ n ];
        m_ftab = new int[ 65537 ];
        if( m_block == null || m_quadrant == null || m_zptr == null
            || m_ftab == null )
        {
            //int totalDraw = (n + 1 + NUM_OVERSHOOT_BYTES) + (n + NUM_OVERSHOOT_BYTES) + n + 65537;
            //compressOutOfMemory ( totalDraw, n );
        }
        /*
         * The back end needs a place to store the MTF values
         * whilst it calculates the coding tables.  We could
         * put them in the zptr array.  However, these values
         * will fit in a short, so we overlay szptr at the
         * start of zptr, in the hope of reducing the number
         * of cache misses induced by the multiple traversals
         * of the MTF values when calculating coding tables.
         * Seems to improve compression speed by about 1%.
         */
        //    szptr = zptr;
        m_szptr = new short[ 2 * n ];
    }
    private void bsFinishedWithStream()
        throws IOException
    {
        while( m_bsLive > 0 )
        {
            int ch = ( m_bsBuff >> 24 );
            try
            {
                m_bsStream.write( ch );// write 8-bit
            }
            catch( IOException e )
            {
                throw e;
            }
            m_bsBuff <<= 8;
            m_bsLive -= 8;
        }
    }
    private void bsPutIntVS( int numBits, int c )
        throws IOException
    {
        bsW( numBits, c );
    }
    private void bsPutUChar( int c )
        throws IOException
    {
        bsW( 8, c );
    }
    private void bsPutint( int u )
        throws IOException
    {
        bsW( 8, ( u >> 24 ) & 0xff );
        bsW( 8, ( u >> 16 ) & 0xff );
        bsW( 8, ( u >> 8 ) & 0xff );
        bsW( 8, u & 0xff );
    }
    private void bsSetStream( OutputStream f )
    {
        m_bsStream = f;
        m_bsLive = 0;
        m_bsBuff = 0;
    }
    private void bsW( int n, int v )
        throws IOException
    {
        while( m_bsLive >= 8 )
        {
            int ch = ( m_bsBuff >> 24 );
            try
            {
                m_bsStream.write( ch );// write 8-bit
            }
            catch( IOException e )
            {
                throw e;
            }
            m_bsBuff <<= 8;
            m_bsLive -= 8;
        }
        m_bsBuff |= ( v << ( 32 - m_bsLive - n ) );
        m_bsLive += n;
    }
    private void doReversibleTransformation()
    {
        int i;
        m_workLimit = m_workFactor * m_last;
        m_workDone = 0;
        m_blockRandomised = false;
        m_firstAttempt = true;
        mainSort();
        if( m_workDone > m_workLimit && m_firstAttempt )
        {
            randomiseBlock();
            m_workLimit = 0;
            m_workDone = 0;
            m_blockRandomised = true;
            m_firstAttempt = false;
            mainSort();
        }
        m_origPtr = -1;
        for( i = 0; i <= m_last; i++ )
        {
            if( m_zptr[ i ] == 0 )
            {
                m_origPtr = i;
                break;
            }
        }
        ;
        if( m_origPtr == -1 )
        {
            panic();
        }
    }
    private void endBlock()
        throws IOException
    {
        m_blockCRC = m_crc.getFinalCRC();
        m_combinedCRC = ( m_combinedCRC << 1 ) | ( m_combinedCRC >>> 31 );
        m_combinedCRC ^= m_blockCRC;
        /*
         * sort the block and establish posn of original string
         */
        doReversibleTransformation();
        /*
         * A 6-byte block header, the value chosen arbitrarily
         * as 0x314159265359 :-).  A 32 bit value does not really
         * give a strong enough guarantee that the value will not
         * appear by chance in the compressed datastream.  Worst-case
         * probability of this event, for a 900k block, is about
         * 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48 bits.
         * For a compressed file of size 100Gb -- about 100000 blocks --
         * only a 48-bit marker will do.  NB: normal compression/
         * decompression do *not* rely on these statistical properties.
         * They are only important when trying to recover blocks from
         * damaged files.
         */
        bsPutUChar( 0x31 );
        bsPutUChar( 0x41 );
        bsPutUChar( 0x59 );
        bsPutUChar( 0x26 );
        bsPutUChar( 0x53 );
        bsPutUChar( 0x59 );
        /*
         * Now the block's CRC, so it is in a known place.
         */
        bsPutint( m_blockCRC );
        /*
         * Now a single bit indicating randomisation.
         */
        if( m_blockRandomised )
        {
            bsW( 1, 1 );
        }
        else
        {
            bsW( 1, 0 );
        }
        /*
         * Finally, block's contents proper.
         */
        moveToFrontCodeAndSend();
    }
    private void endCompression()
        throws IOException
    {
        /*
         * Now another magic 48-bit number, 0x177245385090, to
         * indicate the end of the last block.  (sqrt(pi), if
         * you want to know.  I did want to use e, but it contains
         * too much repetition -- 27 18 28 18 28 46 -- for me
         * to feel statistically comfortable.  Call me paranoid.)
         */
        bsPutUChar( 0x17 );
        bsPutUChar( 0x72 );
        bsPutUChar( 0x45 );
        bsPutUChar( 0x38 );
        bsPutUChar( 0x50 );
        bsPutUChar( 0x90 );
        bsPutint( m_combinedCRC );
        bsFinishedWithStream();
    }
    private boolean fullGtU( int i1, int i2 )
    {
        int k;
        char c1;
        char c2;
        int s1;
        int s2;
        c1 = m_block[ i1 + 1 ];
        c2 = m_block[ i2 + 1 ];
        if( c1 != c2 )
        {
            return ( c1 > c2 );
        }
        i1++;
        i2++;
        c1 = m_block[ i1 + 1 ];
        c2 = m_block[ i2 + 1 ];
        if( c1 != c2 )
        {
            return ( c1 > c2 );
        }
        i1++;
        i2++;
        c1 = m_block[ i1 + 1 ];
        c2 = m_block[ i2 + 1 ];
        if( c1 != c2 )
        {
            return ( c1 > c2 );
        }
        i1++;
        i2++;
        c1 = m_block[ i1 + 1 ];
        c2 = m_block[ i2 + 1 ];
        if( c1 != c2 )
        {
            return ( c1 > c2 );
        }
        i1++;
        i2++;
        c1 = m_block[ i1 + 1 ];
        c2 = m_block[ i2 + 1 ];
        if( c1 != c2 )
        {
            return ( c1 > c2 );
        }
        i1++;
        i2++;
        c1 = m_block[ i1 + 1 ];
        c2 = m_block[ i2 + 1 ];
        if( c1 != c2 )
        {
            return ( c1 > c2 );
        }
        i1++;
        i2++;
        k = m_last + 1;
        do
        {
            c1 = m_block[ i1 + 1 ];
            c2 = m_block[ i2 + 1 ];
            if( c1 != c2 )
            {
                return ( c1 > c2 );
            }
            s1 = m_quadrant[ i1 ];
            s2 = m_quadrant[ i2 ];
            if( s1 != s2 )
            {
                return ( s1 > s2 );
            }
            i1++;
            i2++;
            c1 = m_block[ i1 + 1 ];
            c2 = m_block[ i2 + 1 ];
            if( c1 != c2 )
            {
                return ( c1 > c2 );
            }
            s1 = m_quadrant[ i1 ];
            s2 = m_quadrant[ i2 ];
            if( s1 != s2 )
            {
                return ( s1 > s2 );
            }
            i1++;
            i2++;
            c1 = m_block[ i1 + 1 ];
            c2 = m_block[ i2 + 1 ];
            if( c1 != c2 )
            {
                return ( c1 > c2 );
            }
            s1 = m_quadrant[ i1 ];
            s2 = m_quadrant[ i2 ];
            if( s1 != s2 )
            {
                return ( s1 > s2 );
            }
            i1++;
            i2++;
            c1 = m_block[ i1 + 1 ];
            c2 = m_block[ i2 + 1 ];
            if( c1 != c2 )
            {
                return ( c1 > c2 );
            }
            s1 = m_quadrant[ i1 ];
            s2 = m_quadrant[ i2 ];
            if( s1 != s2 )
            {
                return ( s1 > s2 );
            }
            i1++;
            i2++;
            if( i1 > m_last )
            {
                i1 -= m_last;
                i1--;
            }
            ;
            if( i2 > m_last )
            {
                i2 -= m_last;
                i2--;
            }
            ;
            k -= 4;
            m_workDone++;
        } while( k >= 0 );
        return false;
    }
    private void generateMTFValues()
    {
        char[] yy = new char[ 256 ];
        int i;
        int j;
        char tmp;
        char tmp2;
        int zPend;
        int wr;
        int EOB;
        makeMaps();
        EOB = m_nInUse + 1;
        for( i = 0; i <= EOB; i++ )
        {
            m_mtfFreq[ i ] = 0;
        }
        wr = 0;
        zPend = 0;
        for( i = 0; i < m_nInUse; i++ )
        {
            yy[ i ] = (char)i;
        }
        for( i = 0; i <= m_last; i++ )
        {
            char ll_i;
            ll_i = m_unseqToSeq[ m_block[ m_zptr[ i ] ] ];
            j = 0;
            tmp = yy[ j ];
            while( ll_i != tmp )
            {
                j++;
                tmp2 = tmp;
                tmp = yy[ j ];
                yy[ j ] = tmp2;
            }
            ;
            yy[ 0 ] = tmp;
            if( j == 0 )
            {
                zPend++;
            }
            else
            {
                if( zPend > 0 )
                {
                    zPend--;
                    while( true )
                    {
                        switch( zPend % 2 )
                        {
                            case 0:
                                m_szptr[ wr ] = (short)RUNA;
                                wr++;
                                m_mtfFreq[ RUNA ]++;
                                break;
                            case 1:
                                m_szptr[ wr ] = (short)RUNB;
                                wr++;
                                m_mtfFreq[ RUNB ]++;
                                break;
                        }
                        ;
                        if( zPend < 2 )
                        {
                            break;
                        }
                        zPend = ( zPend - 2 ) / 2;
                    }
                    ;
                    zPend = 0;
                }
                m_szptr[ wr ] = (short)( j + 1 );
                wr++;
                m_mtfFreq[ j + 1 ]++;
            }
        }
        if( zPend > 0 )
        {
            zPend--;
            while( true )
            {
                switch( zPend % 2 )
                {
                    case 0:
                        m_szptr[ wr ] = (short)RUNA;
                        wr++;
                        m_mtfFreq[ RUNA ]++;
                        break;
                    case 1:
                        m_szptr[ wr ] = (short)RUNB;
                        wr++;
                        m_mtfFreq[ RUNB ]++;
                        break;
                }
                if( zPend < 2 )
                {
                    break;
                }
                zPend = ( zPend - 2 ) / 2;
            }
        }
        m_szptr[ wr ] = (short)EOB;
        wr++;
        m_mtfFreq[ EOB ]++;
        m_nMTF = wr;
    }
    private void hbAssignCodes( int[] code, char[] length, int minLen,
                                int maxLen, int alphaSize )
    {
        int n;
        int vec;
        int i;
        vec = 0;
        for( n = minLen; n <= maxLen; n++ )
        {
            for( i = 0; i < alphaSize; i++ )
            {
                if( length[ i ] == n )
                {
                    code[ i ] = vec;
                    vec++;
                }
            }
            ;
            vec <<= 1;
        }
    }
    private void initBlock()
    {
        //        blockNo++;
        m_crc.initialiseCRC();
        m_last = -1;
        //        ch = 0;
        for( int i = 0; i < 256; i++ )
        {
            m_inUse[ i ] = false;
        }
        /*
         * 20 is just a paranoia constant
         */
        m_allowableBlockSize = BASE_BLOCK_SIZE * m_blockSize100k - 20;
    }
    private void initialize()
        throws IOException
    {
        /*
         * Write `magic' bytes h indicating file-format == huffmanised,
         * followed by a digit indicating blockSize100k.
         */
        bsPutUChar( 'h' );
        bsPutUChar( '0' + m_blockSize100k );
        m_combinedCRC = 0;
    }
    private void mainSort()
    {
        int i;
        int j;
        int ss;
        int sb;
        int[] runningOrder = new int[ 256 ];
        int[] copy = new int[ 256 ];
        boolean[] bigDone = new boolean[ 256 ];
        int c1;
        int c2;
        /*
         * In the various block-sized structures, live data runs
         * from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,
         * set up the overshoot area for block.
         */
        //   if (verbosity >= 4) fprintf ( stderr, ""        sort initialise ...\n"" );
        for( i = 0; i < NUM_OVERSHOOT_BYTES; i++ )
        {
            m_block[ m_last + i + 2 ] = m_block[ ( i % ( m_last + 1 ) ) + 1 ];
        }
        for( i = 0; i <= m_last + NUM_OVERSHOOT_BYTES; i++ )
        {
            m_quadrant[ i ] = 0;
        }
        m_block[ 0 ] = m_block[ m_last + 1 ];
        if( m_last < 4000 )
        {
            /*
             * Use simpleSort(), since the full sorting mechanism
             * has quite a large constant overhead.
             */
            for( i = 0; i <= m_last; i++ )
            {
                m_zptr[ i ] = i;
            }
            m_firstAttempt = false;
            m_workDone = 0;
            m_workLimit = 0;
            simpleSort( 0, m_last, 0 );
        }
        else
        {
            for( i = 0; i <= 255; i++ )
            {
                bigDone[ i ] = false;
            }
            for( i = 0; i <= 65536; i++ )
            {
                m_ftab[ i ] = 0;
            }
            c1 = m_block[ 0 ];
            for( i = 0; i <= m_last; i++ )
            {
                c2 = m_block[ i + 1 ];
                m_ftab[ ( c1 << 8 ) + c2 ]++;
                c1 = c2;
            }
            for( i = 1; i <= 65536; i++ )
            {
                m_ftab[ i ] += m_ftab[ i - 1 ];
            }
            c1 = m_block[ 1 ];
            for( i = 0; i < m_last; i++ )
            {
                c2 = m_block[ i + 2 ];
                j = ( c1 << 8 ) + c2;
                c1 = c2;
                m_ftab[ j ]--;
                m_zptr[ m_ftab[ j ] ] = i;
            }
            j = ( ( m_block[ m_last + 1 ] ) << 8 ) + ( m_block[ 1 ] );
            m_ftab[ j ]--;
            m_zptr[ m_ftab[ j ] ] = m_last;
            /*
             * Now ftab contains the first loc of every small bucket.
             * Calculate the running order, from smallest to largest
             * big bucket.
             */
            for( i = 0; i <= 255; i++ )
            {
                runningOrder[ i ] = i;
            }
            {
                int vv;
                int h = 1;
                do
                {
                    h = 3 * h + 1;
                } while( h <= 256 );
                do
                {
                    h = h / 3;
                    for( i = h; i <= 255; i++ )
                    {
                        vv = runningOrder[ i ];
                        j = i;
                        while( ( m_ftab[ ( ( runningOrder[ j - h ] ) + 1 ) << 8 ]
                            - m_ftab[ ( runningOrder[ j - h ] ) << 8 ] ) >
                            ( m_ftab[ ( ( vv ) + 1 ) << 8 ] - m_ftab[ ( vv ) << 8 ] ) )
                        {
                            runningOrder[ j ] = runningOrder[ j - h ];
                            j = j - h;
                            if( j <= ( h - 1 ) )
                            {
                                break;
                            }
                        }
                        runningOrder[ j ] = vv;
                    }
                } while( h != 1 );
            }
            /*
             * The main sorting loop.
             */
            for( i = 0; i <= 255; i++ )
            {
                /*
                 * Process big buckets, starting with the least full.
                 */
                ss = runningOrder[ i ];
                /*
                 * Complete the big bucket [ss] by quicksorting
                 * any unsorted small buckets [ss, j].  Hopefully
                 * previous pointer-scanning phases have already
                 * completed many of the small buckets [ss, j], so
                 * we don't have to sort them at all.
                 */
                for( j = 0; j <= 255; j++ )
                {
                    sb = ( ss << 8 ) + j;
                    if( !( ( m_ftab[ sb ] & SETMASK ) == SETMASK ) )
                    {
                        int lo = m_ftab[ sb ] & CLEARMASK;
                        int hi = ( m_ftab[ sb + 1 ] & CLEARMASK ) - 1;
                        if( hi > lo )
                        {
                            qSort3( lo, hi, 2 );
                            if( m_workDone > m_workLimit && m_firstAttempt )
                            {
                                return;
                            }
                        }
                        m_ftab[ sb ] |= SETMASK;
                    }
                }
                /*
                 * The ss big bucket is now done.  Record this fact,
                 * and update the quadrant descriptors.  Remember to
                 * update quadrants in the overshoot area too, if
                 * necessary.  The ""if (i < 255)"" test merely skips
                 * this updating for the last bucket processed, since
                 * updating for the last bucket is pointless.
                 */
                bigDone[ ss ] = true;
                if( i < 255 )
                {
                    int bbStart = m_ftab[ ss << 8 ] & CLEARMASK;
                    int bbSize = ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart;
                    int shifts = 0;
                    while( ( bbSize >> shifts ) > 65534 )
                    {
                        shifts++;
                    }
                    for( j = 0; j < bbSize; j++ )
                    {
                        int a2update = m_zptr[ bbStart + j ];
                        int qVal = ( j >> shifts );
                        m_quadrant[ a2update ] = qVal;
                        if( a2update < NUM_OVERSHOOT_BYTES )
                        {
                            m_quadrant[ a2update + m_last + 1 ] = qVal;
                        }
                    }
                    if( !( ( ( bbSize - 1 ) >> shifts ) <= 65535 ) )
                    {
                        panic();
                    }
                }
                /*
                 * Now scan this big bucket so as to synthesise the
                 * sorted order for small buckets [t, ss] for all t != ss.
                 */
                for( j = 0; j <= 255; j++ )
                {
                    copy[ j ] = m_ftab[ ( j << 8 ) + ss ] & CLEARMASK;
                }
                for( j = m_ftab[ ss << 8 ] & CLEARMASK;
                     j < ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ); j++ )
                {
                    c1 = m_block[ m_zptr[ j ] ];
                    if( !bigDone[ c1 ] )
                    {
                        m_zptr[ copy[ c1 ] ] = m_zptr[ j ] == 0 ? m_last : m_zptr[ j ] - 1;
                        copy[ c1 ]++;
                    }
                }
                for( j = 0; j <= 255; j++ )
                {
                    m_ftab[ ( j << 8 ) + ss ] |= SETMASK;
                }
            }
        }
    }
    private void makeMaps()
    {
        int i;
        m_nInUse = 0;
        for( i = 0; i < 256; i++ )
        {
            if( m_inUse[ i ] )
            {
                m_seqToUnseq[ m_nInUse ] = (char)i;
                m_unseqToSeq[ i ] = (char)m_nInUse;
                m_nInUse++;
            }
        }
    }
    private char med3( char a, char b, char c )
    {
        char t;
        if( a > b )
        {
            t = a;
            a = b;
            b = t;
        }
        if( b > c )
        {
            t = b;
            b = c;
            c = t;
        }
        if( a > b )
        {
            b = a;
        }
        return b;
    }
    private void moveToFrontCodeAndSend()
        throws IOException
    {
        bsPutIntVS( 24, m_origPtr );
        generateMTFValues();
        sendMTFValues();
    }
    private void qSort3( int loSt, int hiSt, int dSt )
    {
        int unLo;
        int unHi;
        int ltLo;
        int gtHi;
        int med;
        int n;
        int m;
        int sp;
        int lo;
        int hi;
        int d;
        StackElem[] stack = new StackElem[ QSORT_STACK_SIZE ];
        for( int count = 0; count < QSORT_STACK_SIZE; count++ )
        {
            stack[ count ] = new StackElem();
        }
        sp = 0;
        stack[ sp ].m_ll = loSt;
        stack[ sp ].m_hh = hiSt;
        stack[ sp ].m_dd = dSt;
        sp++;
        while( sp > 0 )
        {
            if( sp >= QSORT_STACK_SIZE )
            {
                panic();
            }
            sp--;
            lo = stack[ sp ].m_ll;
            hi = stack[ sp ].m_hh;
            d = stack[ sp ].m_dd;
            if( hi - lo < SMALL_THRESH || d > DEPTH_THRESH )
            {
                simpleSort( lo, hi, d );
                if( m_workDone > m_workLimit && m_firstAttempt )
                {
                    return;
                }
                continue;
            }
            med = med3( m_block[ m_zptr[ lo ] + d + 1 ],
                        m_block[ m_zptr[ hi ] + d + 1 ],
                        m_block[ m_zptr[ ( lo + hi ) >> 1 ] + d + 1 ] );
            unLo = lo;
            ltLo = lo;
            unHi = hi;
            gtHi = hi;
            while( true )
            {
                while( true )
                {
                    if( unLo > unHi )
                    {
                        break;
                    }
                    n = m_block[ m_zptr[ unLo ] + d + 1 ] - med;
                    if( n == 0 )
                    {
                        int temp = 0;
                        temp = m_zptr[ unLo ];
                        m_zptr[ unLo ] = m_zptr[ ltLo ];
                        m_zptr[ ltLo ] = temp;
                        ltLo++;
                        unLo++;
                        continue;
                    }
                    ;
                    if( n > 0 )
                    {
                        break;
                    }
                    unLo++;
                }
                while( true )
                {
                    if( unLo > unHi )
                    {
                        break;
                    }
                    n = m_block[ m_zptr[ unHi ] + d + 1 ] - med;
                    if( n == 0 )
                    {
                        int temp = 0;
                        temp = m_zptr[ unHi ];
                        m_zptr[ unHi ] = m_zptr[ gtHi ];
                        m_zptr[ gtHi ] = temp;
                        gtHi--;
                        unHi--;
                        continue;
                    }
                    ;
                    if( n < 0 )
                    {
                        break;
                    }
                    unHi--;
                }
                if( unLo > unHi )
                {
                    break;
                }
                int temp = 0;
                temp = m_zptr[ unLo ];
                m_zptr[ unLo ] = m_zptr[ unHi ];
                m_zptr[ unHi ] = temp;
                unLo++;
                unHi--;
            }
            if( gtHi < ltLo )
            {
                stack[ sp ].m_ll = lo;
                stack[ sp ].m_hh = hi;
                stack[ sp ].m_dd = d + 1;
                sp++;
                continue;
            }
            n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo );
            vswap( lo, unLo - n, n );
            m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi );
            vswap( unLo, hi - m + 1, m );
            n = lo + unLo - ltLo - 1;
            m = hi - ( gtHi - unHi ) + 1;
            stack[ sp ].m_ll = lo;
            stack[ sp ].m_hh = n;
            stack[ sp ].m_dd = d;
            sp++;
            stack[ sp ].m_ll = n + 1;
            stack[ sp ].m_hh = m - 1;
            stack[ sp ].m_dd = d + 1;
            sp++;
            stack[ sp ].m_ll = m;
            stack[ sp ].m_hh = hi;
            stack[ sp ].m_dd = d;
            sp++;
        }
    }
    private void randomiseBlock()
    {
        int i;
        int rNToGo = 0;
        int rTPos = 0;
        for( i = 0; i < 256; i++ )
        {
            m_inUse[ i ] = false;
        }
        for( i = 0; i <= m_last; i++ )
        {
            if( rNToGo == 0 )
            {
                rNToGo = (char)RAND_NUMS[ rTPos ];
                rTPos++;
                if( rTPos == 512 )
                {
                    rTPos = 0;
                }
            }
            rNToGo--;
            m_block[ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 );
            // handle 16 bit signed numbers
            m_block[ i + 1 ] &= 0xFF;
            m_inUse[ m_block[ i + 1 ] ] = true;
        }
    }
    private void sendMTFValues()
        throws IOException
    {
        char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];
        int v;
        int t;
        int i;
        int j;
        int gs;
        int ge;
        int bt;
        int bc;
        int iter;
        int nSelectors = 0;
        int alphaSize;
        int minLen;
        int maxLen;
        int selCtr;
        int nGroups;
        alphaSize = m_nInUse + 2;
        for( t = 0; t < N_GROUPS; t++ )
        {
            for( v = 0; v < alphaSize; v++ )
            {
                len[ t ][ v ] = (char)GREATER_ICOST;
            }
        }
        /*
         * Decide how many coding tables to use
         */
        if( m_nMTF <= 0 )
        {
            panic();
        }
        if( m_nMTF < 200 )
        {
            nGroups = 2;
        }
        else if( m_nMTF < 600 )
        {
            nGroups = 3;
        }
        else if( m_nMTF < 1200 )
        {
            nGroups = 4;
        }
        else if( m_nMTF < 2400 )
        {
            nGroups = 5;
        }
        else
        {
            nGroups = 6;
        }
        {
            /*
             * Generate an initial set of coding tables
             */
            int nPart;
            int remF;
            int tFreq;
            int aFreq;
            nPart = nGroups;
            remF = m_nMTF;
            gs = 0;
            while( nPart > 0 )
            {
                tFreq = remF / nPart;
                ge = gs - 1;
                aFreq = 0;
                while( aFreq < tFreq && ge < alphaSize - 1 )
                {
                    ge++;
                    aFreq += m_mtfFreq[ ge ];
                }
                if( ge > gs && nPart != nGroups && nPart != 1
                    && ( ( nGroups - nPart ) % 2 == 1 ) )
                {
                    aFreq -= m_mtfFreq[ ge ];
                    ge--;
                }
                for( v = 0; v < alphaSize; v++ )
                {
                    if( v >= gs && v <= ge )
                    {
                        len[ nPart - 1 ][ v ] = (char)LESSER_ICOST;
                    }
                    else
                    {
                        len[ nPart - 1 ][ v ] = (char)GREATER_ICOST;
                    }
                }
                nPart--;
                gs = ge + 1;
                remF -= aFreq;
            }
        }
        int[][] rfreq = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];
        int[] fave = new int[ N_GROUPS ];
        short[] cost = new short[ N_GROUPS ];
        /*
         * Iterate up to N_ITERS times to improve the tables.
         */
        for( iter = 0; iter < N_ITERS; iter++ )
        {
            for( t = 0; t < nGroups; t++ )
            {
                fave[ t ] = 0;
            }
            for( t = 0; t < nGroups; t++ )
            {
                for( v = 0; v < alphaSize; v++ )
                {
                    rfreq[ t ][ v ] = 0;
                }
            }
            nSelectors = 0;
            gs = 0;
            while( true )
            {
                /*
                 * Set group start & end marks.
                 */
                if( gs >= m_nMTF )
                {
                    break;
                }
                ge = gs + G_SIZE - 1;
                if( ge >= m_nMTF )
                {
                    ge = m_nMTF - 1;
                }
                /*
                 * Calculate the cost of this group as coded
                 * by each of the coding tables.
                 */
                for( t = 0; t < nGroups; t++ )
                {
                    cost[ t ] = 0;
                }
                if( nGroups == 6 )
                {
                    short cost0 = 0;
                    short cost1 = 0;
                    short cost2 = 0;
                    short cost3 = 0;
                    short cost4 = 0;
                    short cost5 = 0;
                    for( i = gs; i <= ge; i++ )
                    {
                        short icv = m_szptr[ i ];
                        cost0 += len[ 0 ][ icv ];
                        cost1 += len[ 1 ][ icv ];
                        cost2 += len[ 2 ][ icv ];
                        cost3 += len[ 3 ][ icv ];
                        cost4 += len[ 4 ][ icv ];
                        cost5 += len[ 5 ][ icv ];
                    }
                    cost[ 0 ] = cost0;
                    cost[ 1 ] = cost1;
                    cost[ 2 ] = cost2;
                    cost[ 3 ] = cost3;
                    cost[ 4 ] = cost4;
                    cost[ 5 ] = cost5;
                }
                else
                {
                    for( i = gs; i <= ge; i++ )
                    {
                        short icv = m_szptr[ i ];
                        for( t = 0; t < nGroups; t++ )
                        {
                            cost[ t ] += len[ t ][ icv ];
                        }
                    }
                }
                /*
                 * Find the coding table which is best for this group,
                 * and record its identity in the selector table.
                 */
                bc = 999999999;
                bt = -1;
                for( t = 0; t < nGroups; t++ )
                {
                    if( cost[ t ] < bc )
                    {
                        bc = cost[ t ];
                        bt = t;
                    }
                }
                ;
                fave[ bt ]++;
                m_selector[ nSelectors ] = (char)bt;
                nSelectors++;
                /*
                 * Increment the symbol frequencies for the selected table.
                 */
                for( i = gs; i <= ge; i++ )
                {
                    rfreq[ bt ][ m_szptr[ i ] ]++;
                }
                gs = ge + 1;
            }
            /*
             * Recompute the tables based on the accumulated frequencies.
             */
            for( t = 0; t < nGroups; t++ )
            {
                hbMakeCodeLengths( len[ t ], rfreq[ t ], alphaSize, 20 );
            }
        }
        rfreq = null;
        fave = null;
        cost = null;
        if( !( nGroups < 8 ) )
        {
            panic();
        }
        if( !( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) )
        {
            panic();
        }
        {
            /*
             * Compute MTF values for the selectors.
             */
            char[] pos = new char[ N_GROUPS ];
            char ll_i;
            char tmp2;
            char tmp;
            for( i = 0; i < nGroups; i++ )
            {
                pos[ i ] = (char)i;
            }
            for( i = 0; i < nSelectors; i++ )
            {
                ll_i = m_selector[ i ];
                j = 0;
                tmp = pos[ j ];
                while( ll_i != tmp )
                {
                    j++;
                    tmp2 = tmp;
                    tmp = pos[ j ];
                    pos[ j ] = tmp2;
                }
                pos[ 0 ] = tmp;
                m_selectorMtf[ i ] = (char)j;
            }
        }
        int[][] code = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];
        /*
         * Assign actual codes for the tables.
         */
        for( t = 0; t < nGroups; t++ )
        {
            minLen = 32;
            maxLen = 0;
            for( i = 0; i < alphaSize; i++ )
            {
                if( len[ t ][ i ] > maxLen )
                {
                    maxLen = len[ t ][ i ];
                }
                if( len[ t ][ i ] < minLen )
                {
                    minLen = len[ t ][ i ];
                }
            }
            if( maxLen > 20 )
            {
                panic();
            }
            if( minLen < 1 )
            {
                panic();
            }
            hbAssignCodes( code[ t ], len[ t ], minLen, maxLen, alphaSize );
        }
        {
            /*
             * Transmit the mapping table.
             */
            boolean[] inUse16 = new boolean[ 16 ];
            for( i = 0; i < 16; i++ )
            {
                inUse16[ i ] = false;
                for( j = 0; j < 16; j++ )
                {
                    if( m_inUse[ i * 16 + j ] )
                    {
                        inUse16[ i ] = true;
                    }
                }
            }
            for( i = 0; i < 16; i++ )
            {
                if( inUse16[ i ] )
                {
                    bsW( 1, 1 );
                }
                else
                {
                    bsW( 1, 0 );
                }
            }
            for( i = 0; i < 16; i++ )
            {
                if( inUse16[ i ] )
                {
                    for( j = 0; j < 16; j++ )
                    {
                        if( m_inUse[ i * 16 + j ] )
                        {
                            bsW( 1, 1 );
                        }
                        else
                        {
                            bsW( 1, 0 );
                        }
                    }
                }
            }
        }
        /*
         * Now the selectors.
         */
        bsW( 3, nGroups );
        bsW( 15, nSelectors );
        for( i = 0; i < nSelectors; i++ )
        {
            for( j = 0; j < m_selectorMtf[ i ]; j++ )
            {
                bsW( 1, 1 );
            }
            bsW( 1, 0 );
        }
        for( t = 0; t < nGroups; t++ )
        {
            int curr = len[ t ][ 0 ];
            bsW( 5, curr );
            for( i = 0; i < alphaSize; i++ )
            {
                while( curr < len[ t ][ i ] )
                {
                    bsW( 2, 2 );
                    curr++;
                    /*
                     * 10
                     */
                }
                while( curr > len[ t ][ i ] )
                {
                    bsW( 2, 3 );
                    curr--;
                    /*
                     * 11
                     */
                }
                bsW( 1, 0 );
            }
        }
        /*
         * And finally, the block data proper
         */
        selCtr = 0;
        gs = 0;
        while( true )
        {
            if( gs >= m_nMTF )
            {
                break;
            }
            ge = gs + G_SIZE - 1;
            if( ge >= m_nMTF )
            {
                ge = m_nMTF - 1;
            }
            for( i = gs; i <= ge; i++ )
            {
                bsW( len[ m_selector[ selCtr ] ][ m_szptr[ i ] ],
                     code[ m_selector[ selCtr ] ][ m_szptr[ i ] ] );
            }
            gs = ge + 1;
            selCtr++;
        }
        if( !( selCtr == nSelectors ) )
        {
            panic();
        }
    }
    private void simpleSort( int lo, int hi, int d )
    {
        int i;
        int j;
        int h;
        int bigN;
        int hp;
        int v;
        bigN = hi - lo + 1;
        if( bigN < 2 )
        {
            return;
        }
        hp = 0;
        while( m_incs[ hp ] < bigN )
        {
            hp++;
        }
        hp--;
        for( ; hp >= 0; hp-- )
        {
            h = m_incs[ hp ];
            i = lo + h;
            while( true )
            {
                /*
                 * copy 1
                 */
                if( i > hi )
                {
                    break;
                }
                v = m_zptr[ i ];
                j = i;
                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )
                {
                    m_zptr[ j ] = m_zptr[ j - h ];
                    j = j - h;
                    if( j <= ( lo + h - 1 ) )
                    {
                        break;
                    }
                }
                m_zptr[ j ] = v;
                i++;
                /*
                 * copy 2
                 */
                if( i > hi )
                {
                    break;
                }
                v = m_zptr[ i ];
                j = i;
                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )
                {
                    m_zptr[ j ] = m_zptr[ j - h ];
                    j = j - h;
                    if( j <= ( lo + h - 1 ) )
                    {
                        break;
                    }
                }
                m_zptr[ j ] = v;
                i++;
                /*
                 * copy 3
                 */
                if( i > hi )
                {
                    break;
                }
                v = m_zptr[ i ];
                j = i;
                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )
                {
                    m_zptr[ j ] = m_zptr[ j - h ];
                    j = j - h;
                    if( j <= ( lo + h - 1 ) )
                    {
                        break;
                    }
                }
                m_zptr[ j ] = v;
                i++;
                if( m_workDone > m_workLimit && m_firstAttempt )
                {
                    return;
                }
            }
        }
    }
    private void vswap( int p1, int p2, int n )
    {
        int temp = 0;
        while( n > 0 )
        {
            temp = m_zptr[ p1 ];
            m_zptr[ p1 ] = m_zptr[ p2 ];
            m_zptr[ p2 ] = temp;
            p1++;
            p2++;
            n--;
        }
    }
    private void writeRun()
        throws IOException
    {
        if( m_last < m_allowableBlockSize )
        {
            m_inUse[ m_currentChar ] = true;
            for( int i = 0; i < m_runLength; i++ )
            {
                m_crc.updateCRC( (char)m_currentChar );
            }
            switch( m_runLength )
            {
                case 1:
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    break;
                case 2:
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    break;
                case 3:
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    break;
                default:
                    m_inUse[ m_runLength - 4 ] = true;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)m_currentChar;
                    m_last++;
                    m_block[ m_last + 1 ] = (char)( m_runLength - 4 );
                    break;
            }
        }
        else
        {
            endBlock();
            initBlock();
            writeRun();
        }
    }
    private static class StackElem
    {
        int m_dd;
        int m_hh;
        int m_ll;
    }
}
"
installer.ConsoleInstall,"/*
 * ConsoleInstall.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import java.io.*;
import java.util.Vector;
/*
 * Performs text-only installation.
 */
public class ConsoleInstall
{
	public ConsoleInstall()
	{
		installer = new Install();
		String appName = installer.getProperty(""app.name"");
		String appVersion = installer.getProperty(""app.version"");
		BufferedReader in = new BufferedReader(new InputStreamReader(
			System.in));
		System.out.println(""*** "" + appName + "" "" + appVersion + "" installer"");
		OperatingSystem os = OperatingSystem.getOperatingSystem();
		String installDir = os.getInstallDirectory(appName,appVersion);
		System.out.print(""Installation directory: ["" + installDir + ""] "");
		System.out.flush();
		String _installDir = readLine(in);
		if(_installDir.length() != 0)
			installDir = _installDir;
		OperatingSystem.OSTask[] osTasks = os.getOSTasks(installer);
		for(int i = 0; i < osTasks.length; i++)
		{
			OperatingSystem.OSTask osTask = osTasks[i];
			String label = osTask.getLabel();
			// label == null means no configurable options
			if(label != null)
			{
				String dir = osTask.getDirectory();
				System.out.print(label + "" ["" + dir + ""] "");
				System.out.flush();
				dir = readLine(in);
				osTask.setEnabled(true);
				if(dir.length() != 0)
				{
					if(dir.equals(""off""))
						osTask.setEnabled(false);
					else
						osTask.setDirectory(dir);
				}
			}
		}
		int compCount = installer.getIntegerProperty(""comp.count"");
		Vector components = new Vector(compCount);
		System.out.println(""*** Program components to install"");
		for(int i = 0; i < compCount; i++)
		{
			String fileset = installer.getProperty(""comp."" + i + "".fileset"");
			String osDep = installer.getProperty(""comp."" + i + "".os"");
			if(osDep != null)
			{
				if(!os.getClass().getName().endsWith(osDep))
				{
					continue;
				}
			}
			System.out.print(""Install ""
				+ installer.getProperty(""comp."" + i + "".name"")
				+ "" (""
				+ installer.getProperty(""comp."" + i + "".disk-size"")
				+ ""Kb) [Y/n]? "");
			String line = readLine(in);
			if(line.length() == 0 || line.charAt(0) == 'y'
				|| line.charAt(0) == 'Y')
				components.addElement(fileset);
		}
		System.out.println(""*** Starting installation..."");
		ConsoleProgress progress = new ConsoleProgress();
		InstallThread thread = new InstallThread(
			installer,progress,installDir,osTasks,
			0 /* XXX */,components);
		thread.start();
	}
	// private members
	private Install installer;
	private String readLine(BufferedReader in)
	{
		try
		{
			String line = in.readLine();
			if(line == null)
			{
				System.err.println(""\nEOF in input!"");
				System.exit(1);
				// can't happen
				throw new InternalError();
			}
			return line;
		}
		catch(IOException io)
		{
			System.err.println(""\nI/O error: "" + io);
			System.exit(1);
			// can't happen
			throw new InternalError();
		}
	}
}
"
installer.ConsoleProgress,"/*
 * ConsoleProgress.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
/*
 * Displays install progress when running in text-only mode.
 */
public class ConsoleProgress implements Progress
{
	public void setMaximum(int max)
	{
	}
	public void advance(int value)
	{
	}
	public void done()
	{
		System.out.println(""*** Installation complete"");
	}
	public void error(String message)
	{
		System.err.println(""*** An error occurred: "" + message);
	}
}
"
installer.CRC,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included with this distribution in
 * the LICENSE.txt file.
 */
package installer;
/**
 * A simple class the hold and calculate the CRC for sanity checking of the
 * data.
 *
 * @author <a href=""mailto:keiron@aftexsw.com"">Keiron Liddle</a>
 */
class CRC
{
    private static int[] CRC32_TABLE = new int[]
    {
        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
    };
    private int m_globalCrc;
    protected CRC()
    {
        initialiseCRC();
    }
    int getFinalCRC()
    {
        return ~m_globalCrc;
    }
    void initialiseCRC()
    {
        m_globalCrc = 0xffffffff;
    }
    void updateCRC( final int inCh )
    {
        int temp = ( m_globalCrc >> 24 ) ^ inCh;
        if( temp < 0 )
        {
            temp = 256 + temp;
        }
        m_globalCrc = ( m_globalCrc << 8 ) ^ CRC32_TABLE[ temp ];
    }
}
"
installer.Install,"/*
 * Install.java - Main class of the installer
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import javax.swing.plaf.metal.*;
import javax.swing.*;
import java.io.*;
import java.util.Properties;
public class Install
{
	public static void main(String[] args)
	{
		String javaVersion = System.getProperty(""java.version"");
		if(javaVersion.compareTo(""1.3"") < 0)
		{
			System.err.println(""You are running Java version ""
				+ javaVersion + ""."");
			System.err.println(""This installer requires Java 1.3 or later."");
			System.exit(1);
		}
		if(args.length == 0)
			new SwingInstall();
		else if(args.length == 1 && args[0].equals(""text""))
			new ConsoleInstall();
		else if(args.length >= 2 && args[0].equals(""auto""))
			new NonInteractiveInstall(args);
		else
		{
			System.err.println(""Usage:"");
			System.err.println(""java -jar <installer JAR>"");
			System.err.println(""java -jar <installer JAR> text"");
			System.err.println(""java -jar <installer JAR> auto""
				+ "" <install dir> [unix-script=<dir>] [unix-man=<dir>]"");
			System.err.println(""text parameter starts installer in text-only mode."");
			System.err.println(""auto parameter starts installer in non-interactive mode."");
		}
	}
	public Install()
	{
		props = new Properties();
		try
		{
			InputStream in = getClass().getResourceAsStream(""/installer/install.props"");
			props.load(in);
			in.close();
		}
		catch(IOException io)
		{
			System.err.println(""Error loading 'install.props':"");
			io.printStackTrace();
		}
		buf = new byte[32768];
	}
	public String getProperty(String name)
	{
		return props.getProperty(name);
	}
	public int getIntegerProperty(String name)
	{
		try
		{
			return Integer.parseInt(props.getProperty(name));
		}
		catch(Exception e)
		{
			return -1;
		}
	}
	public void copy(InputStream in, String outfile, Progress progress)
		throws IOException
	{
		File outFile = new File(outfile);
		OperatingSystem.getOperatingSystem().mkdirs(outFile.getParent());
		BufferedOutputStream out = new BufferedOutputStream(
			new FileOutputStream(outFile));
		int count;
		for(;;)
		{
			count = in.read(buf,0,Math.min(in.available(),buf.length));
			if(count == -1 || count == 0)
				break;
			out.write(buf,0,count);
			if(progress != null)
				progress.advance(count);
		}
		//in.close();
		out.close();
	}
	// private members
	private Properties props;
	private byte[] buf;
}
"
installer.InstallThread,"/*
 * InstallThread.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import java.io.*;
import java.util.Vector;
/*
 * The thread that performs installation.
 */
public class InstallThread extends Thread
{
	public InstallThread(Install installer, Progress progress,
		String installDir, OperatingSystem.OSTask[] osTasks,
		int size, Vector components)
	{
		super(""Install thread"");
		this.installer = installer;
		this.progress = progress;
		this.installDir = installDir;
		this.osTasks = osTasks;
		this.size = size;
		this.components = components;
	}
	public void run()
	{
		progress.setMaximum(size * 1024);
		try
		{
			// install user-selected packages
			for(int i = 0; i < components.size(); i++)
			{
				String comp = (String)components.elementAt(i);
				System.err.println(""Installing "" + comp);
				installComponent(comp);
			}
			// do operating system specific stuff (creating startup
			// scripts, installing man pages, etc.)
			for(int i = 0; i < osTasks.length; i++)
			{
				System.err.println(""Performing task "" +
					osTasks[i].getName());
				osTasks[i].perform(installDir,components);
			}
		}
		catch(FileNotFoundException fnf)
		{
			progress.error(""The installer could not create the ""
				+ ""destination directory.\n""
				+ ""Maybe you do not have write permission?"");
			return;
		}
		catch(IOException io)
		{
			progress.error(io.toString());
			return;
		}
		progress.done();
	}
	// private members
	private Install installer;
	private Progress progress;
	private String installDir;
	private OperatingSystem.OSTask[] osTasks;
	private int size;
	private Vector components;
	private void installComponent(String name) throws IOException
	{
		InputStream in = new BufferedInputStream(
			getClass().getResourceAsStream(name + "".tar.bz2""));
		// skip header bytes
		// maybe should check if they're valid or not?
		in.read();
		in.read();
		TarInputStream tarInput = new TarInputStream(
			new CBZip2InputStream(in));
		TarEntry entry;
		while((entry = tarInput.getNextEntry()) != null)
		{
			if(entry.isDirectory())
				continue;
			String fileName = entry.getName();
			//System.err.println(fileName);
			String outfile = installDir + File.separatorChar
				+ fileName.replace('/',File.separatorChar);
			installer.copy(tarInput,outfile,progress);
		}
		tarInput.close();
	}
}
"
installer.InvalidHeaderException,"/*
** Authored by Timothy Gerard Endres
** <mailto:time@gjt.org>  <http://www.trustice.com>
** 
** This work has been placed into the public domain.
** You may use this work in any way and for any purpose you wish.
**
** THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND,
** NOT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR
** OF THIS SOFTWARE, ASSUMES _NO_ RESPONSIBILITY FOR ANY
** CONSEQUENCE RESULTING FROM THE USE, MODIFICATION, OR
** REDISTRIBUTION OF THIS SOFTWARE. 
** 
*/
package installer;
import java.io.IOException;
/**
 * This exception is used to indicate that there is a problem
 * with a TAR archive header.
 */
public class
InvalidHeaderException extends IOException
	{
	public
	InvalidHeaderException()
		{
		super();
		}
	public
	InvalidHeaderException( String msg )
		{
		super( msg );
		}
	}
"
installer.NonInteractiveInstall,"/*
 * NonInteractiveInstall.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import java.util.Vector;
/*
 * Performs non-interactive installation.
 */
public class NonInteractiveInstall
{
	public NonInteractiveInstall(String[] args)
	{
		String installDir = args[1];
		installer = new Install();
		OperatingSystem os = OperatingSystem.getOperatingSystem();
		OperatingSystem.OSTask[] osTasks = os.getOSTasks(installer);
		for(int i = 2; i < args.length; i++)
		{
			String arg = args[i];
			int index = arg.indexOf('=');
			if(index == -1)
			{
				System.err.println(""Invalid parameter: "" + arg);
				continue;
			}
			String taskName = arg.substring(0,index);
			String taskDir = arg.substring(index + 1);
			for(int j = 0; j < osTasks.length; j++)
			{
				OperatingSystem.OSTask osTask = osTasks[j];
				if(osTask.getName().equals(taskName))
				{
					if(taskDir.equals(""off""))
						osTask.setEnabled(false);
					else
					{
						osTask.setEnabled(true);
						osTask.setDirectory(taskDir);
					}
					break;
				}
			}
		}
		int compCount = installer.getIntegerProperty(""comp.count"");
		Vector components = new Vector(compCount);
		for(int i = 0; i < compCount; i++)
		{
			String fileset = installer.getProperty(""comp."" + i + "".fileset"");
			String osDep = installer.getProperty(""comp."" + i + "".os"");
			if(osDep != null)
			{
				if(!os.getClass().getName().endsWith(osDep))
				{
					continue;
				}
			}
			components.addElement(fileset);
		}
		//
		ConsoleProgress progress = new ConsoleProgress();
		InstallThread thread = new InstallThread(
			installer,progress,installDir,osTasks,
			0 /* XXX */,components);
		thread.start();
	}
	// private members
	private Install installer;
}
"
installer.OperatingSystem,"/*
 * OperatingSystem.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import java.io.*;
import java.util.Vector;
/*
 * Abstracts away operating-specific stuff, like finding out the installation
 * directory, creating a shortcut to start to program, and such.
 */
public abstract class OperatingSystem
{
	public abstract String getInstallDirectory(String name, String version);
	public abstract static class OSTask
	{
		protected Install installer;
		protected String name;
		protected String label;
		protected String directory;
		protected boolean enabled;
		public OSTask(Install installer, String name)
		{
			this.installer = installer;
			this.name = name;
			this.label = installer.getProperty(""ostask."" + name + "".label"");
			this.directory = getDefaultDirectory(installer);
			// on by default
			enabled = true;
		}
		public String getName()
		{
			return name;
		}
		public String getLabel()
		{
			return label;
		}
		public String getDefaultDirectory(Install installer)
		{
			return null;
		}
		public String getDirectory()
		{
			return directory;
		}
		public boolean isEnabled()
		{
			return enabled;
		}
		public void setEnabled(boolean enabled)
		{
			this.enabled = enabled;
		}
		public void setDirectory(String directory)
		{
			this.directory = directory;
		}
		public abstract void perform(String installDir,
			Vector filesets) throws IOException;
	}
	public OSTask[] getOSTasks(Install installer)
	{
		return new OSTask[0];
	}
	public void mkdirs(String directory) throws IOException
	{
		File file = new File(directory);
		if(!file.exists())
			file.mkdirs();
	}
	public static OperatingSystem getOperatingSystem()
	{
		if(os != null)
			return os;
		if(System.getProperty(""mrj.version"") != null)
			os = new MacOS();
		else
		{
			String osName = System.getProperty(""os.name"");
			if(osName.indexOf(""Windows"") != -1)
				os = new Windows();
			else if(osName.indexOf(""OS/2"") != -1)
				os = new HalfAnOS();
			else if(osName.indexOf(""VMS"") != -1)
				os = new VMS();
			else
				os = new Unix();
		}
		return os;
	}
	public static class Unix extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			String dir = ""/usr/local/share/"";
			if(!new File(dir).canWrite())
				dir = System.getProperty(""user.home"");
			return new File(dir,name.toLowerCase() + ""/"" + version).getPath();
		}
		public class ScriptOSTask extends OSTask
		{
			public ScriptOSTask(Install installer)
			{
				super(installer,""unix-script"");
			}
			public String getDefaultDirectory(Install installer)
			{
				String dir = ""/usr/local/"";
				if(!new File(dir).canWrite())
					dir = System.getProperty(""user.home"");
				return new File(dir,""bin"").getPath();
			}
			public void perform(String installDir,
				Vector filesets) throws IOException
			{
				if(!enabled)
					return;
				mkdirs(directory);
				String name = installer.getProperty(""app.name"");
				// create app start script
				String script = directory + File.separatorChar
					+ name.toLowerCase();
				// Delete existing copy
				new File(script).delete();
				// Write simple script
				FileWriter out = new FileWriter(script);
				out.write(""#!/bin/sh\n"");
				out.write(""# Java heap size, in megabytes\n"");
				out.write(""JAVA_HEAP_SIZE=32\n"");
				out.write(""DEFAULT_JAVA_HOME=\""""
					+ System.getProperty(""java.home"")
					+ ""\""\n"");
				out.write(""if [ \""$JAVA_HOME\"" = \""\"" ]; then\n"");
				out.write(""JAVA_HOME=\""$DEFAULT_JAVA_HOME\""\n"");
				out.write(""fi\n"");
				out.write(""exec \""$JAVA_HOME""
					+ ""/bin/java\"" -mx${JAVA_HEAP_SIZE}m ${""
					+ name.toUpperCase() + ""} "");
				String jar = installDir + File.separator
					+ name.toLowerCase() + "".jar"";
				out.write(""-jar \"""" + jar + ""\"" $@\n"");
				out.close();
				// Make it executable
				String[] chmodArgs = { ""chmod"", ""755"", script };
				exec(chmodArgs);
			}
		}
		public class ManPageOSTask extends OSTask
		{
			public ManPageOSTask(Install installer)
			{
				super(installer,""unix-man"");
			}
			public String getDefaultDirectory(Install installer)
			{
				String dir = ""/usr/local/"";
				if(!new File(dir).canWrite())
					dir = System.getProperty(""user.home"");
				return new File(dir,""man/man1"").getPath();
			}
			public void perform(String installDir,
				Vector filesets) throws IOException
			{
				if(!enabled)
					return;
				mkdirs(directory);
				String name = installer.getProperty(""app.name"");
				// install man page
				String manpage = installer.getProperty(""ostask.unix-man.manpage"");
				InputStream in = getClass().getResourceAsStream(""/"" + manpage);
				installer.copy(in,new File(directory,manpage).getPath(),
					null);
			}
		}
		public OSTask[] getOSTasks(Install installer)
		{
			return new OSTask[] { new ScriptOSTask(installer),
				new ManPageOSTask(installer) };
		}
		public void mkdirs(String directory) throws IOException
		{
			File file = new File(directory);
			if(!file.exists())
			{
				String[] mkdirArgs = { ""mkdir"", ""-m"", ""755"",
					""-p"", directory };
				exec(mkdirArgs);
			}
		}
		public void exec(String[] args) throws IOException
		{
			Process proc = Runtime.getRuntime().exec(args);
			proc.getInputStream().close();
			proc.getOutputStream().close();
			proc.getErrorStream().close();
			try
			{
				proc.waitFor();
			}
			catch(InterruptedException ie)
			{
			}
		}
	}
	public static class MacOS extends Unix
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""/Applications/"" + name + "" "" + version;
		}
	}
	public static class Windows extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""C:\\Program Files\\"" + name + "" "" + version;
		}
		public class JEditLauncherOSTask extends OSTask
		{
			public JEditLauncherOSTask(Install installer)
			{
				super(installer,""jedit-launcher"");
			}
			public String getDefaultDirectory(Install installer)
			{
				return null;
			}
			public void perform(String installDir,
				Vector filesets)
			{
				if(!enabled
					|| !filesets.contains(""jedit-windows""))
					return;
				// run jEditLauncher installation
				File executable = new File(installDir,""jedit.exe"");
				if(!executable.exists())
					return;
				String[] args = { executable.getPath(), ""/i"",
					System.getProperty(""java.home"")
					+ File.separator
					+ ""bin"" };
				try
				{
					Runtime.getRuntime().exec(args).waitFor();
				}
				catch(IOException io)
				{
				}
				catch(InterruptedException ie)
				{
				}
			}
		}
		public OSTask[] getOSTasks(Install installer)
		{
			return new OSTask[] { /* new JEditLauncherOSTask(installer) */ };
		}
	}
	public static class HalfAnOS extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""C:\\"" + name + "" "" + version;
		}
	}
	public static class VMS extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""./"" + name.toLowerCase() + ""/"" + version;
		}
	}
	// private members
	private static OperatingSystem os;
}
"
installer.Progress,"/*
 * Progress.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
/*
 * An interface for reporting installation progress. ConsoleProgress and
 * SwingProcess are the two existing implementations.
 */
public interface Progress
{
	public void setMaximum(int max);
	public void advance(int value);
	public void done();
	public void error(String message);
}
"
installer.SwingInstall,"/*
 * SwingInstall.java
 *
 * Originally written by Slava Pestov for the jEdit installer project. This work
 * has been placed into the public domain. You may use this work in any way and
 * for any purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
/*
 * Graphical front-end to installer.
 */
public class SwingInstall extends JFrame
{
	public SwingInstall()
	{
		installer = new Install();
		osTasks = OperatingSystem.getOperatingSystem().getOSTasks(installer);
		appName = installer.getProperty(""app.name"");
		appVersion = installer.getProperty(""app.version"");
		setTitle(appName + "" "" + appVersion + "" installer"");
		JPanel content = new JPanel(new WizardLayout());
		setContentPane(content);
		caption = new JLabel();
		caption.setFont(new Font(""SansSerif"",Font.BOLD,18));
		ActionHandler actionHandler = new ActionHandler();
		cancelButton = new JButton(""Cancel"");
		cancelButton.setRequestFocusEnabled(false);
		cancelButton.addActionListener(actionHandler);
		prevButton = new JButton(""Previous"");
		prevButton.setRequestFocusEnabled(false);
		prevButton.addActionListener(actionHandler);
		nextButton = new JButton();
		nextButton.setRequestFocusEnabled(false);
		nextButton.addActionListener(actionHandler);
		content.add(caption);
		content.add(cancelButton);
		content.add(prevButton);
		content.add(nextButton);
		String clazz = OperatingSystem.getOperatingSystem()
				.getClass().getName();
		String completedInfo = ""done-"" + clazz.substring(
			clazz.indexOf('$') + 1) + "".html"";
		pages = new Component[] {
			new TextPanel(installer.getProperty(""app.readme"")),
			new TextPanel(installer.getProperty(""app.license"")),
			chooseDirectory = new ChooseDirectory(),
			selectComponents = new SelectComponents(),
			progress = new SwingProgress(),
			new TextPanel(completedInfo)
		};
		for(int i = 0; i < pages.length; i++)
			content.add(pages[i]);
		pageChanged();
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());
		Dimension screen = getToolkit().getScreenSize();
		pack();
		setLocation((screen.width - getSize().width) / 2,
			(screen.height - getSize().height) / 2);
		setVisible(true);
	}
	// package-private members
	// package-private, not private, for speedy access by inner classes
	Install installer;
	OperatingSystem.OSTask[] osTasks;
	String appName;
	String appVersion;
	JLabel caption;
	ChooseDirectory chooseDirectory;
	SelectComponents selectComponents;
	SwingProgress progress;
	JButton cancelButton;
	JButton prevButton;
	JButton nextButton;
	Component[] pages;
	int currentPage;
	private static final int PADDING = 12;
	void install()
	{
		Vector components = new Vector();
		int size = 0;
		JPanel comp = selectComponents.comp;
		Vector ids = selectComponents.filesets;
		for(int i = 0; i < comp.getComponentCount(); i++)
		{
			if(((JCheckBox)comp.getComponent(i))
				.getModel().isSelected())
			{
				size += installer.getIntegerProperty(
					""comp."" + ids.elementAt(i) + "".real-size"");
				components.addElement(installer.getProperty(
					""comp."" + ids.elementAt(i) + "".fileset""));
			}
		}
		String installDir = chooseDirectory.installDir.getText();
		Map osTaskDirs = chooseDirectory.osTaskDirs;
		Iterator keys = osTaskDirs.keySet().iterator();
		while(keys.hasNext())
		{
			OperatingSystem.OSTask osTask = (OperatingSystem.OSTask)keys.next();
			String dir = ((JTextField)osTaskDirs.get(osTask)).getText();
			if(dir != null && dir.length() != 0)
			{
				osTask.setEnabled(true);
				osTask.setDirectory(dir);
			}
			else
				osTask.setEnabled(false);
		}
		InstallThread thread = new InstallThread(
			installer,progress,
			installDir,osTasks,
			size,components);
		progress.setThread(thread);
		thread.start();
	}
	private void pageChanged()
	{
		switch(currentPage)
		{
		case 0:
			caption.setText(""Installing "" + appName);
			nextButton.setText(""Next"");
			prevButton.setEnabled(false);
			break;
		case 1:
			caption.setText(installer.getProperty(""app.license.title""));
			nextButton.setText(""Next"");
			prevButton.setEnabled(true);
			break;
		case 2:
			caption.setText(""Specify where "" + appName
				+ "" is to be installed"");
			nextButton.setText(""Next"");
			prevButton.setEnabled(true);
			break;
		case 3:
			caption.setText(""Choose components to install"");
			nextButton.setText(""Install"");
			prevButton.setEnabled(true);
			break;
		case 4:
			caption.setText(""Installing "" + appName);
			nextButton.setText(""Finish"");
			prevButton.setEnabled(false);
			nextButton.setEnabled(false);
			install();
			break;
		case 5:
			caption.setText(""Installation complete"");
			nextButton.setText(""Finish"");
			prevButton.setEnabled(false);
			nextButton.setEnabled(true);
			break;
		}
		getRootPane().invalidate();
		getRootPane().validate();
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == cancelButton)
				System.exit(0);
			else if(source == prevButton)
			{
				currentPage--;
				pageChanged();
			}
			else if(source == nextButton)
			{
				if(currentPage == pages.length - 1)
					System.exit(0);
				else
				{
					currentPage++;
					pageChanged();
				}
			}
		}
	}
	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			System.exit(0);
		}
	}
	class WizardLayout implements LayoutManager
	{
		public void addLayoutComponent(String name, Component comp)
		{
		}
		public void removeLayoutComponent(Component comp)
		{
		}
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Dimension captionSize = caption.getPreferredSize();
			dim.width = captionSize.width;
			for(int i = 0; i < pages.length; i++)
			{
				Dimension _dim = pages[i].getPreferredSize();
				dim.width = Math.max(_dim.width,dim.width);
				dim.height = Math.max(_dim.height,dim.height);
			}
			dim.width += PADDING * 2;
			dim.height += PADDING * 2;
			dim.height += nextButton.getPreferredSize().height;
			dim.height += captionSize.height;
			return dim;
		}
		public Dimension minimumLayoutSize(Container parent)
		{
			return preferredLayoutSize(parent);
		}
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Dimension captionSize = caption.getPreferredSize();
			caption.setBounds(PADDING,PADDING,captionSize.width,
				captionSize.height);
			// make all buttons the same size
			Dimension buttonSize = cancelButton.getPreferredSize();
			buttonSize.width = Math.max(buttonSize.width,prevButton.getPreferredSize().width);
			buttonSize.width = Math.max(buttonSize.width,nextButton.getPreferredSize().width);
			// cancel button goes on far left
			cancelButton.setBounds(
				PADDING,
				size.height - buttonSize.height - PADDING,
				buttonSize.width,
				buttonSize.height);
			// prev and next buttons are on the right
			prevButton.setBounds(
				size.width - buttonSize.width * 2 - 6 - PADDING,
				size.height - buttonSize.height - PADDING,
				buttonSize.width,
				buttonSize.height);
			nextButton.setBounds(
				size.width - buttonSize.width - PADDING,
				size.height - buttonSize.height - PADDING,
				buttonSize.width,
				buttonSize.height);
			// calculate size for current page
			Rectangle currentPageBounds = new Rectangle();
			currentPageBounds.x = PADDING;
			currentPageBounds.y = PADDING * 2 + captionSize.height;
			currentPageBounds.width = size.width - currentPageBounds.x
				- PADDING;
			currentPageBounds.height = size.height - buttonSize.height
				- currentPageBounds.y - PADDING * 2;
			for(int i = 0; i < pages.length; i++)
			{
				Component page = pages[i];
				page.setBounds(currentPageBounds);
				page.setVisible(i == currentPage);
			}
		}
	}
	class TextPanel extends JPanel
	{
		TextPanel(String file)
		{
			super(new BorderLayout());
			JEditorPane text = new JEditorPane();
			try
			{
				text.setPage(TextPanel.this.getClass().getResource(file));
			}
			catch(Exception e)
			{
				text.setText(""Error loading '"" + file + ""'"");
				e.printStackTrace();
			}
			text.setEditable(false);
			JScrollPane scrollPane = new JScrollPane(text);
			Dimension dim = new Dimension();
			dim.width = 450;
			dim.height = 200;
			scrollPane.setPreferredSize(dim);
			TextPanel.this.add(BorderLayout.CENTER,scrollPane);
		}
	}
	class ChooseDirectory extends JPanel
	{
		JTextField installDir;
		Map osTaskDirs;
		ChooseDirectory()
		{
			super(new BorderLayout());
			osTaskDirs = new HashMap();
			JPanel directoryPanel = new JPanel(new VariableGridLayout(
				VariableGridLayout.FIXED_NUM_COLUMNS,3,12,12));
			installDir = addField(directoryPanel,""Install program in:"",
				OperatingSystem.getOperatingSystem()
				.getInstallDirectory(appName,appVersion));
			for(int i = 0; i < osTasks.length; i++)
			{
				OperatingSystem.OSTask osTask = osTasks[i];
				String label = osTask.getLabel();
				if(label != null)
				{
					JTextField field = addField(directoryPanel,label,
						osTask.getDirectory());
					osTaskDirs.put(osTask,field);
				}
			}
			ChooseDirectory.this.add(BorderLayout.NORTH,directoryPanel);
		}
		private JTextField addField(JPanel directoryPanel, String label,
			String defaultText)
		{
			JTextField field = new JTextField(defaultText);
			directoryPanel.add(new JLabel(label,SwingConstants.RIGHT));
			Box fieldBox = new Box(BoxLayout.Y_AXIS);
			fieldBox.add(Box.createGlue());
			Dimension dim = field.getPreferredSize();
			dim.width = Integer.MAX_VALUE;
			field.setMaximumSize(dim);
			fieldBox.add(field);
			fieldBox.add(Box.createGlue());
			directoryPanel.add(fieldBox);
			JButton choose = new JButton(""Choose..."");
			choose.setRequestFocusEnabled(false);
			choose.addActionListener(new ActionHandler(field));
			directoryPanel.add(choose);
			return field;
		}
		class ActionHandler implements ActionListener
		{
			JTextField field;
			ActionHandler(JTextField field)
			{
				this.field = field;
			}
			public void actionPerformed(ActionEvent evt)
			{
				File directory = new File(field.getText());
				JFileChooser chooser = new JFileChooser(directory.getParent());
				chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
				chooser.setSelectedFile(directory);
				if(chooser.showOpenDialog(SwingInstall.this)
					== JFileChooser.APPROVE_OPTION)
					field.setText(chooser.getSelectedFile().getPath());
			}
		}
	}
	class SelectComponents extends JPanel
	implements ActionListener
	{
		JPanel comp;
		JLabel sizeLabel;
		Vector filesets;
		SelectComponents()
		{
			super(new BorderLayout());
			comp = createCompPanel();
			SelectComponents.this.add(BorderLayout.NORTH,comp);
			sizeLabel = new JLabel("""",SwingConstants.LEFT);
			SelectComponents.this.add(BorderLayout.SOUTH,sizeLabel);
			updateSize();
		}
		public void actionPerformed(ActionEvent evt)
		{
			updateSize();
		}
		private JPanel createCompPanel()
		{
			filesets = new Vector();
			int count = installer.getIntegerProperty(""comp.count"");
			JPanel panel = new JPanel(new GridLayout(count,1));
			String osClass = OperatingSystem.getOperatingSystem()
				.getClass().getName();
			osClass = osClass.substring(osClass.indexOf('$') + 1);
			for(int i = 0; i < count; i++)
			{
				String os = installer.getProperty(""comp."" + i + "".os"");
				if(os != null && !osClass.equals(os))
					continue;
				JCheckBox checkBox = new JCheckBox(
					installer.getProperty(""comp."" + i + "".name"")
					+ "" ("" + installer.getProperty(""comp."" + i
					+ "".disk-size"") + ""Kb)"");
				checkBox.getModel().setSelected(true);
				checkBox.addActionListener(this);
				checkBox.setRequestFocusEnabled(false);
				filesets.addElement(new Integer(i));
				panel.add(checkBox);
			}
			Dimension dim = panel.getPreferredSize();
			dim.width = Integer.MAX_VALUE;
			panel.setMaximumSize(dim);
			return panel;
		}
		private void updateSize()
		{
			int size = 0;
			for(int i = 0; i < filesets.size(); i++)
			{
				if(((JCheckBox)comp.getComponent(i))
					.getModel().isSelected())
				{
					size += installer.getIntegerProperty(""comp.""
						+ filesets.elementAt(i)
						+ "".disk-size"");
				}
			}
			sizeLabel.setText(""Estimated disk usage of selected""
				+ "" components: "" + size + ""Kb"");
		}
	}
	class SwingProgress extends JPanel implements Progress
	{
		JProgressBar progress;
		InstallThread thread;
		SwingProgress()
		{
			super(new BorderLayout());
			progress = new JProgressBar();
			progress.setStringPainted(true);
			SwingProgress.this.add(BorderLayout.NORTH,progress);
		}
		public void setMaximum(final int max)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					progress.setMaximum(max);
				}
			});
		}
		public void advance(final int value)
		{
			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						progress.setValue(progress
							.getValue() + value);
					}
				});
				Thread.yield();
			}
			catch(Exception e)
			{
			}
		}
		public void done()
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					currentPage++;
					pageChanged();
				}
			});
		}
		public void error(final String message)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					dispose();
					JOptionPane.showMessageDialog(null,
						message,
						""Installation aborted"",
						JOptionPane.ERROR_MESSAGE);
					System.exit(1);
				}
			});
		}
		public void setThread(InstallThread thread)
		{
			this.thread = thread;
		}
	}
}
"
installer.TarBuffer,"/*
** Authored by Timothy Gerard Endres
** <mailto:time@gjt.org>  <http://www.trustice.com>
** 
** This work has been placed into the public domain.
** You may use this work in any way and for any purpose you wish.
**
** THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND,
** NOT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR
** OF THIS SOFTWARE, ASSUMES _NO_ RESPONSIBILITY FOR ANY
** CONSEQUENCE RESULTING FROM THE USE, MODIFICATION, OR
** REDISTRIBUTION OF THIS SOFTWARE. 
** 
*/
package installer;
import java.io.*;
/**
 * The TarBuffer class implements the tar archive concept
 * of a buffered input stream. This concept goes back to the
 * days of blocked tape drives and special io devices. In the
 * Java universe, the only real function that this class
 * performs is to ensure that files have the correct ""block""
 * size, or other tars will complain.
 * <p>
 * You should never have a need to access this class directly.
 * TarBuffers are created by Tar IO Streams.
 *
 * @version $Revision: 1.1 $
 * @author Timothy Gerard Endres,
 *  <a href=""mailto:time@gjt.org"">time@trustice.com</a>.
 * @see TarArchive
 */
public class
TarBuffer extends Object
	{
	public static final int		DEFAULT_RCDSIZE = ( 512 );
	public static final int		DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 );
	private InputStream		inStream;
	private OutputStream	outStream;
	private byte[]	blockBuffer;
	private int		currBlkIdx;
	private int		currRecIdx;
	private int		blockSize;
	private int		recordSize;
	private int		recsPerBlock;
	private boolean	debug;
	public
	TarBuffer( InputStream inStream )
		{
		this( inStream, TarBuffer.DEFAULT_BLKSIZE );
		}
	public
	TarBuffer( InputStream inStream, int blockSize )
		{
		this( inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE );
		}
	public
	TarBuffer( InputStream inStream, int blockSize, int recordSize )
		{
		this.inStream = inStream;
		this.outStream = null;
		this.initialize( blockSize, recordSize );
		}
	public
	TarBuffer( OutputStream outStream )
		{
		this( outStream, TarBuffer.DEFAULT_BLKSIZE );
		}
	public
	TarBuffer( OutputStream outStream, int blockSize )
		{
		this( outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE );
		}
	public
	TarBuffer( OutputStream outStream, int blockSize, int recordSize )
		{
		this.inStream = null;
		this.outStream = outStream;
		this.initialize( blockSize, recordSize );
		}
	/**
	 * Initialization common to all constructors.
	 */
	private void
	initialize( int blockSize, int recordSize )
		{
		this.debug = false;
		this.blockSize = blockSize;
		this.recordSize = recordSize;
		this.recsPerBlock = ( this.blockSize / this.recordSize );
		this.blockBuffer = new byte[ this.blockSize ];
		if ( this.inStream != null )
			{
			this.currBlkIdx = -1;
			this.currRecIdx = this.recsPerBlock;
			}
		else
			{
			this.currBlkIdx = 0;
			this.currRecIdx = 0;
			}
		}
	/**
	 * Get the TAR Buffer's block size. Blocks consist of multiple records.
	 */
	public int
	getBlockSize()
		{
		return this.blockSize;
		}
	/**
	 * Get the TAR Buffer's record size.
	 */
	public int
	getRecordSize()
		{
		return this.recordSize;
		}
	/**
	 * Set the debugging flag for the buffer.
	 *
	 * @param debug If true, print debugging output.
	 */
	public void
	setDebug( boolean debug )
		{
		this.debug = debug;
		}
	/**
	 * Determine if an archive record indicate End of Archive. End of
	 * archive is indicated by a record that consists entirely of null bytes.
	 *
	 * @param record The record data to check.
	 */
	public boolean
	isEOFRecord( byte[] record )
		{
		for ( int i = 0, sz = this.getRecordSize() ; i < sz ; ++i )
			if ( record[i] != 0 )
				return false;
		return true;
		}
	/**
	 * Skip over a record on the input stream.
	 */
	public void
	skipRecord()
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println
				( ""SkipRecord: recIdx = "" + this.currRecIdx
					+ "" blkIdx = "" + this.currBlkIdx );
			}
		if ( this.inStream == null )
			throw new IOException
				( ""reading (via skip) from an output buffer"" );
		if ( this.currRecIdx >= this.recsPerBlock )
			{
			if ( ! this.readBlock() )
				return; // UNDONE
			}
		this.currRecIdx++;
		}
	/**
	 * Read a record from the input stream and return the data.
	 *
	 * @return The record data.
	 */
	public byte[]
	readRecord()
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println
				( ""ReadRecord: recIdx = "" + this.currRecIdx
					+ "" blkIdx = "" + this.currBlkIdx );
			}
		if ( this.inStream == null )
			throw new IOException
				( ""reading from an output buffer"" );
		if ( this.currRecIdx >= this.recsPerBlock )
			{
			if ( ! this.readBlock() )
				return null;
			}
		byte[] result = new byte[ this.recordSize ];
		System.arraycopy(
			this.blockBuffer, (this.currRecIdx * this.recordSize),
			result, 0, this.recordSize );
		this.currRecIdx++;
		return result;
		}
	/**
	 * @return false if End-Of-File, else true
	 */
	private boolean
	readBlock()
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println
				( ""ReadBlock: blkIdx = "" + this.currBlkIdx );
			}
		if ( this.inStream == null )
			throw new IOException
				( ""reading from an output buffer"" );
		this.currRecIdx = 0;
		int offset = 0;
		int bytesNeeded = this.blockSize;
		for ( ; bytesNeeded > 0 ; )
			{
			long numBytes =
				this.inStream.read
					( this.blockBuffer, offset, bytesNeeded );
			//
			// NOTE
			// We have fit EOF, and the block is not full!
			//
			// This is a broken archive. It does not follow the standard
			// blocking algorithm. However, because we are generous, and
			// it requires little effort, we will simply ignore the error
			// and continue as if the entire block were read. This does
			// not appear to break anything upstream. We used to return
			// false in this case.
			//
			// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.
			//
			if ( numBytes == -1 )
				break;
			offset += numBytes;
			bytesNeeded -= numBytes;
			if ( numBytes != this.blockSize )
				{
				if ( this.debug )
					{
					System.err.println
						( ""ReadBlock: INCOMPLETE READ "" + numBytes
							+ "" of "" + this.blockSize + "" bytes read."" );
					}
				}
			}
		this.currBlkIdx++;
		return true;
		}
	/**
	 * Get the current block number, zero based.
	 *
	 * @return The current zero based block number.
	 */
	public int
	getCurrentBlockNum()
		{
		return this.currBlkIdx;
		}
	/**
	 * Get the current record number, within the current block, zero based.
	 * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.
	 *
	 * @return The current zero based record number.
	 */
	public int
	getCurrentRecordNum()
		{
		return this.currRecIdx - 1;
		}
	/**
	 * Write an archive record to the archive.
	 *
	 * @param record The record data to write to the archive.
	 */
	public void
	writeRecord( byte[] record )
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println
				( ""WriteRecord: recIdx = "" + this.currRecIdx
					+ "" blkIdx = "" + this.currBlkIdx );
			}
		if ( this.outStream == null )
			throw new IOException
				( ""writing to an input buffer"" );
		if ( record.length != this.recordSize )
			throw new IOException
				( ""record to write has length '"" + record.length
					+ ""' which is not the record size of '""
					+ this.recordSize + ""'"" );
		if ( this.currRecIdx >= this.recsPerBlock )
			{
			this.writeBlock();
			}
		System.arraycopy(
			record, 0,
			this.blockBuffer, (this.currRecIdx * this.recordSize),
			this.recordSize );
		this.currRecIdx++;
		}
	/**
	 * Write an archive record to the archive, where the record may be
	 * inside of a larger array buffer. The buffer must be ""offset plus
	 * record size"" long.
	 *
	 * @param buf The buffer containing the record data to write.
	 * @param offset The offset of the record data within buf.
	 */
	public void
	writeRecord( byte[] buf, int offset )
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println
				( ""WriteRecord: recIdx = "" + this.currRecIdx
					+ "" blkIdx = "" + this.currBlkIdx );
			}
		if ( this.outStream == null )
			throw new IOException
				( ""writing to an input buffer"" );
		if ( (offset + this.recordSize) > buf.length )
			throw new IOException
				( ""record has length '"" + buf.length
					+ ""' with offset '"" + offset
					+ ""' which is less than the record size of '""
					+ this.recordSize + ""'"" );
		if ( this.currRecIdx >= this.recsPerBlock )
			{
			this.writeBlock();
			}
		System.arraycopy(
			buf, offset,
			this.blockBuffer, (this.currRecIdx * this.recordSize),
			this.recordSize );
		this.currRecIdx++;
		}
	/**
	 * Write a TarBuffer block to the archive.
	 */
	private void
	writeBlock()
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println
				( ""WriteBlock: blkIdx = "" + this.currBlkIdx );
			}
		if ( this.outStream == null )
			throw new IOException
				( ""writing to an input buffer"" );
		this.outStream.write( this.blockBuffer, 0, this.blockSize );
		this.outStream.flush();
		this.currRecIdx = 0;
		this.currBlkIdx++;
		}
	/**
	 * Flush the current data block if it has any data in it.
	 */
	private void
	flushBlock()
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println( ""TarBuffer.flushBlock() called."" );
			}
		if ( this.outStream == null )
			throw new IOException
				( ""writing to an input buffer"" );
		if ( this.currRecIdx > 0 )
			{
			this.writeBlock();
			}
		}
	/**
	 * Close the TarBuffer. If this is an output buffer, also flush the
	 * current block before closing.
	 */
	public void
	close()
		throws IOException
		{
		if ( this.debug )
			{
			System.err.println( ""TarBuffer.closeBuffer()."" );
			}
		if ( this.outStream != null )
			{
			this.flushBlock();
			if ( this.outStream != System.out
					&& this.outStream != System.err )
				{
				this.outStream.close();
				this.outStream = null;
				}
			}
		else if ( this.inStream != null )
			{
			if ( this.inStream != System.in )
				{
				this.inStream.close();
				this.inStream = null;
				}
			}
		}
	}
"
installer.TarEntry,"/*
** Authored by Timothy Gerard Endres
** <mailto:time@gjt.org>  <http://www.trustice.com>
** 
** This work has been placed into the public domain.
** You may use this work in any way and for any purpose you wish.
**
** THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND,
** NOT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR
** OF THIS SOFTWARE, ASSUMES _NO_ RESPONSIBILITY FOR ANY
** CONSEQUENCE RESULTING FROM THE USE, MODIFICATION, OR
** REDISTRIBUTION OF THIS SOFTWARE. 
** 
*/
package installer;
import java.io.*;
import java.util.Date;
/**
 *
 * This class represents an entry in a Tar archive. It consists
 * of the entry's header, as well as the entry's File. Entries
 * can be instantiated in one of three ways, depending on how
 * they are to be used.
 * <p>
 * TarEntries that are created from the header bytes read from
 * an archive are instantiated with the TarEntry( byte[] )
 * constructor. These entries will be used when extracting from
 * or listing the contents of an archive. These entries have their
 * header filled in using the header bytes. They also set the File
 * to null, since they reference an archive entry not a file.
 * <p>
 * TarEntries that are created from Files that are to be written
 * into an archive are instantiated with the TarEntry( File )
 * constructor. These entries have their header filled in using
 * the File's information. They also keep a reference to the File
 * for convenience when writing entries.
 * <p>
 * Finally, TarEntries can be constructed from nothing but a name.
 * This allows the programmer to construct the entry by hand, for
 * instance when only an InputStream is available for writing to
 * the archive, and the header information is constructed from
 * other information. In this case the header fields are set to
 * defaults and the File is set to null.
 *
 * <p>
 * The C structure for a Tar Entry's header is:
 * <pre>
 * struct header {
 *		char	name[NAMSIZ];
 *		char	mode[8];
 *		char	uid[8];
 *		char	gid[8];
 *		char	size[12];
 *		char	mtime[12];
 *		char	chksum[8];
 *		char	linkflag;
 *		char	linkname[NAMSIZ];
 *		char	magic[8];
 *		char	uname[TUNMLEN];
 *		char	gname[TGNMLEN];
 *		char	devmajor[8];
 *		char	devminor[8];
 *	} header;
 * </pre>
 *
 * @see TarHeader
 *
 */
public
class		TarEntry
extends		Object
	{
	/**
	 * If this entry represents a File, this references it.
	 */
	protected File				file;
	/**
	 * This is the entry's header information.
	 */
	protected TarHeader			header;
	/**
	 * Construct an entry with only a name. This allows the programmer
	 * to construct the entry's header ""by hand"". File is set to null.
	 */
	public
	TarEntry( String name )
		{
		this.initialize();
		this.nameTarHeader( this.header, name );
		}
	/**
	 * Construct an entry for a file. File is set to file, and the
	 * header is constructed from information from the file.
	 *
	 * @param file The file that the entry represents.
	 */
	public
	TarEntry( File file )
		throws InvalidHeaderException
		{
		this.initialize();
		this.getFileTarHeader( this.header, file );
		}
	/**
	 * Construct an entry from an archive's header bytes. File is set
	 * to null.
	 *
	 * @param headerBuf The header bytes from a tar archive entry.
	 */
	public
	TarEntry( byte[] headerBuf )
		throws InvalidHeaderException
		{
		this.initialize();
		this.parseTarHeader( this.header, headerBuf );
		}
	/**
	 * Initialization code common to all constructors.
	 */
	private void
	initialize()
		{
		this.file = null;
		this.header = new TarHeader();
		}
	/**
	 * Determine if the two entries are equal. Equality is determined
	 * by the header names being equal.
	 *
	 * @return it Entry to be checked for equality.
	 * @return True if the entries are equal.
	 */
	public boolean
	equals( TarEntry it )
		{
		return
			this.header.name.toString().equals
				( it.header.name.toString() );
		}
	/**
	 * Determine if the given entry is a descendant of this entry.
	 * Descendancy is determined by the name of the descendant
	 * starting with this entry's name.
	 *
	 * @param desc Entry to be checked as a descendent of this.
	 * @return True if entry is a descendant of this.
	 */
	public boolean
	isDescendent( TarEntry desc )
		{
		return
			desc.header.name.toString().startsWith
				( this.header.name.toString() );
		}
	/**
	 * Get this entry's header.
	 *
	 * @return This entry's TarHeader.
	 */
	public TarHeader
	getHeader()
		{
		return this.header;
		}
	/**
	 * Get this entry's name.
	 *
	 * @return This entry's name.
	 */
	public String
	getName()
		{
		return this.header.name.toString();
		}
	/**
	 * Set this entry's name.
	 *
	 * @param name This entry's new name.
	 */
	public void
	setName( String name )
		{
		this.header.name =
			new StringBuffer( name );
		}
	/**
	 * Get this entry's user id.
	 *
	 * @return This entry's user id.
	 */
	public int
	getUserId()
		{
		return this.header.userId;
		}
	/**
	 * Set this entry's user id.
	 *
	 * @param userId This entry's new user id.
	 */
	public void
	setUserId( int userId )
		{
		this.header.userId = userId;
		}
	/**
	 * Get this entry's group id.
	 *
	 * @return This entry's group id.
	 */
	public int
	getGroupId()
		{
		return this.header.groupId;
		}
	/**
	 * Set this entry's group id.
	 *
	 * @param groupId This entry's new group id.
	 */
	public void
	setGroupId( int groupId )
		{
		this.header.groupId = groupId;
		}
	/**
	 * Get this entry's user name.
	 *
	 * @return This entry's user name.
	 */
	public String
	getUserName()
		{
		return this.header.userName.toString();
		}
	/**
	 * Set this entry's user name.
	 *
	 * @param userName This entry's new user name.
	 */
	public void
	setUserName( String userName )
		{
		this.header.userName =
			new StringBuffer( userName );
		}
	/**
	 * Get this entry's group name.
	 *
	 * @return This entry's group name.
	 */
	public String
	getGroupName()
		{
		return this.header.groupName.toString();
		}
	/**
	 * Set this entry's group name.
	 *
	 * @param groupName This entry's new group name.
	 */
	public void
	setGroupName( String groupName )
		{
		this.header.groupName =
			new StringBuffer( groupName );
		}
	/**
	 * Convenience method to set this entry's group and user ids.
	 *
	 * @param userId This entry's new user id.
	 * @param groupId This entry's new group id.
	 */
	public void
	setIds( int userId, int groupId )
		{
		this.setUserId( userId );
		this.setGroupId( groupId );
		}
	/**
	 * Convenience method to set this entry's group and user names.
	 *
	 * @param userName This entry's new user name.
	 * @param groupName This entry's new group name.
	 */
	public void
	setNames( String userName, String groupName )
		{
		this.setUserName( userName );
		this.setGroupName( groupName );
		}
	/**
	 * Set this entry's modification time. The parameter passed
	 * to this method is in ""Java time"".
	 *
	 * @param time This entry's new modification time.
	 */
	public void
	setModTime( long time )
		{
		this.header.modTime = time / 1000;
		}
	/**
	 * Set this entry's modification time.
	 *
	 * @param time This entry's new modification time.
	 */
	public void
	setModTime( Date time )
		{
		this.header.modTime = time.getTime() / 1000;
		}
	/**
	 * Set this entry's modification time.
	 *
	 * @param time This entry's new modification time.
	 */
	public Date
	getModTime()
		{
		return new Date( this.header.modTime * 1000 );
		}
	/**
	 * Get this entry's file.
	 *
	 * @return This entry's file.
	 */
	public File
	getFile()
		{
		return this.file;
		}
	/**
	 * Get this entry's file size.
	 *
	 * @return This entry's file size.
	 */
	public long
	getSize()
		{
		return this.header.size;
		}
	/**
	 * Set this entry's file size.
	 *
	 * @param size This entry's new file size.
	 */
	public void
	setSize( long size )
		{
		this.header.size = size;
		}
	/**
	 * Convenience method that will modify an entry's name directly
	 * in place in an entry header buffer byte array.
	 *
	 * @param outbuf The buffer containing the entry header to modify.
	 * @param newName The new name to place into the header buffer.
	 */
	public void
	adjustEntryName( byte[] outbuf, String newName )
		{
		int offset = 0;
		offset = TarHeader.getNameBytes
			( new StringBuffer( newName ),
				outbuf, offset, TarHeader.NAMELEN );
		}
	/**
	 * Return whether or not this entry represents a directory.
	 *
	 * @return True if this entry is a directory.
	 */
	public boolean
	isDirectory()
		{
		if ( this.file != null )
			return this.file.isDirectory();
		if ( this.header != null )
			{
			if ( this.header.linkFlag == TarHeader.LF_DIR )
				return true;
			if ( this.header.name.toString().endsWith( ""/"" ) )
				return true;
			}
		return false;
		}
	/**
	 * Fill in a TarHeader with information from a File.
	 *
	 * @param hdr The TarHeader to fill in.
	 * @param file The file from which to get the header information.
	 */
	public void
	getFileTarHeader( TarHeader hdr, File file )
		throws InvalidHeaderException
		{
		this.file = file;
		String name = file.getPath();
		String osname = System.getProperty( ""os.name"" );
		if ( osname != null )
			{
			// Strip off drive letters!
			// REVIEW Would a better check be ""(File.separator == '\')""?
			// String Win32Prefix = ""Windows"";
			// String prefix = osname.substring( 0, Win32Prefix.length() );
			// if ( prefix.equalsIgnoreCase( Win32Prefix ) )
			// if ( File.separatorChar == '\\' )
			// Per Patrick Beard:
			String Win32Prefix = ""windows"";
			if ( osname.toLowerCase().startsWith( Win32Prefix ) )
				{
				if ( name.length() > 2 )
					{
					char ch1 = name.charAt(0);
					char ch2 = name.charAt(1);
					if ( ch2 == ':'
						&& ( (ch1 >= 'a' && ch1 <= 'z')
							|| (ch1 >= 'A' && ch1 <= 'Z') ) )
						{
						name = name.substring( 2 );
						}
					}
				}
			}
		name = name.replace( File.separatorChar, '/' );
		// No absolute pathnames
		// Windows (and Posix?) paths can start with ""\\NetworkDrive\"",
		// so we loop on starting /'s.
		for ( ; name.startsWith( ""/"" ) ; )
			name = name.substring( 1 );
 		hdr.linkName = new StringBuffer( """" );
		hdr.name = new StringBuffer( name );
		if ( file.isDirectory() )
			{
			hdr.mode = 040755;
			hdr.linkFlag = TarHeader.LF_DIR;
			if ( hdr.name.charAt( hdr.name.length() - 1 ) != '/' )
				hdr.name.append( ""/"" );
			}
		else
			{
			hdr.mode = 0100644;
			hdr.linkFlag = TarHeader.LF_NORMAL;
			}
		// UNDONE When File lets us get the userName, use it!
		hdr.size = file.length();
		hdr.modTime = file.lastModified() / 1000;
		hdr.checkSum = 0;
		hdr.devMajor = 0;
		hdr.devMinor = 0;
		}
	/**
	 * If this entry represents a file, and the file is a directory, return
	 * an array of TarEntries for this entry's children.
	 *
	 * @return An array of TarEntry's for this entry's children.
	 */
	public TarEntry[]
	getDirectoryEntries()
		throws InvalidHeaderException
		{
		if ( this.file == null
				|| ! this.file.isDirectory() )
			{
			return new TarEntry[0];
			}
		String[] list = this.file.list();
		TarEntry[] result = new TarEntry[ list.length ];
		for ( int i = 0 ; i < list.length ; ++i )
			{
			result[i] =
				new TarEntry
					( new File( this.file, list[i] ) );
			}
		return result;
		}
	/**
	 * Compute the checksum of a tar entry header.
	 *
	 * @param buf The tar entry's header buffer.
	 * @return The computed checksum.
	 */
	public long
	computeCheckSum( byte[] buf )
		{
		long sum = 0;
		for ( int i = 0 ; i < buf.length ; ++i )
			{
			sum += 255 & buf[ i ];
			}
		return sum;
		}
	/**
	 * Write an entry's header information to a header buffer.
	 *
	 * @param outbuf The tar entry header buffer to fill in.
	 */
	public void
	writeEntryHeader( byte[] outbuf )
		{
		int offset = 0;
		offset = TarHeader.getNameBytes
			( this.header.name, outbuf, offset, TarHeader.NAMELEN );
		offset = TarHeader.getOctalBytes
			( this.header.mode, outbuf, offset, TarHeader.MODELEN );
		offset = TarHeader.getOctalBytes
			( this.header.userId, outbuf, offset, TarHeader.UIDLEN );
		offset = TarHeader.getOctalBytes
			( this.header.groupId, outbuf, offset, TarHeader.GIDLEN );
		long size = this.header.size;
		offset = TarHeader.getLongOctalBytes
			( size, outbuf, offset, TarHeader.SIZELEN );
		offset = TarHeader.getLongOctalBytes
			( this.header.modTime, outbuf, offset, TarHeader.MODTIMELEN );
		int csOffset = offset;
		for ( int c = 0 ; c < TarHeader.CHKSUMLEN ; ++c )
			outbuf[ offset++ ] = (byte) ' ';
		outbuf[ offset++ ] = this.header.linkFlag;
		offset = TarHeader.getNameBytes
			( this.header.linkName, outbuf, offset, TarHeader.NAMELEN );
		offset = TarHeader.getNameBytes
			( this.header.magic, outbuf, offset, TarHeader.MAGICLEN );
		offset = TarHeader.getNameBytes
			( this.header.userName, outbuf, offset, TarHeader.UNAMELEN );
		offset = TarHeader.getNameBytes
			( this.header.groupName, outbuf, offset, TarHeader.GNAMELEN );
		offset = TarHeader.getOctalBytes
			( this.header.devMajor, outbuf, offset, TarHeader.DEVLEN );
		offset = TarHeader.getOctalBytes
			( this.header.devMinor, outbuf, offset, TarHeader.DEVLEN );
		for ( ; offset < outbuf.length ; )
			outbuf[ offset++ ] = 0;
		long checkSum = this.computeCheckSum( outbuf );
		TarHeader.getCheckSumOctalBytes
			( checkSum, outbuf, csOffset, TarHeader.CHKSUMLEN );
		}
	/**
	 * Parse an entry's TarHeader information from a header buffer.
	 *
	 * @param hdr The TarHeader to fill in from the buffer information.
	 * @param header The tar entry header buffer to get information from.
	 */
	public void
	parseTarHeader( TarHeader hdr, byte[] header )
		throws InvalidHeaderException
		{
		int offset = 0;
		hdr.name =
			TarHeader.parseName( header, offset, TarHeader.NAMELEN );
		offset += TarHeader.NAMELEN;
		hdr.mode = (int)
			TarHeader.parseOctal( header, offset, TarHeader.MODELEN );
		offset += TarHeader.MODELEN;
		hdr.userId = (int)
			TarHeader.parseOctal( header, offset, TarHeader.UIDLEN );
		offset += TarHeader.UIDLEN;
		hdr.groupId = (int)
			TarHeader.parseOctal( header, offset, TarHeader.GIDLEN );
		offset += TarHeader.GIDLEN;
		hdr.size =
			TarHeader.parseOctal( header, offset, TarHeader.SIZELEN );
		offset += TarHeader.SIZELEN;
		hdr.modTime =
			TarHeader.parseOctal( header, offset, TarHeader.MODTIMELEN );
		offset += TarHeader.MODTIMELEN;
		hdr.checkSum = (int)
			TarHeader.parseOctal( header, offset, TarHeader.CHKSUMLEN );
		offset += TarHeader.CHKSUMLEN;
		hdr.linkFlag = header[ offset++ ];
		hdr.linkName =
			TarHeader.parseName( header, offset, TarHeader.NAMELEN );
		offset += TarHeader.NAMELEN;
		hdr.magic =
			TarHeader.parseName( header, offset, TarHeader.MAGICLEN );
		offset += TarHeader.MAGICLEN;
		hdr.userName =
			TarHeader.parseName( header, offset, TarHeader.UNAMELEN );
		offset += TarHeader.UNAMELEN;
		hdr.groupName =
			TarHeader.parseName( header, offset, TarHeader.GNAMELEN );
		offset += TarHeader.GNAMELEN;
		hdr.devMajor = (int)
			TarHeader.parseOctal( header, offset, TarHeader.DEVLEN );
		offset += TarHeader.DEVLEN;
		hdr.devMinor = (int)
			TarHeader.parseOctal( header, offset, TarHeader.DEVLEN );
		}
	/**
	 * Fill in a TarHeader given only the entry's name.
	 *
	 * @param hdr The TarHeader to fill in.
	 * @param name The tar entry name.
	 */
	public void
	nameTarHeader( TarHeader hdr, String name )
		{
		boolean isDir = name.endsWith( ""/"" );
		hdr.checkSum = 0;
		hdr.devMajor = 0;
		hdr.devMinor = 0;
		hdr.name = new StringBuffer( name );
		hdr.mode = isDir ? 040755 : 0100644;
		hdr.userId = 0;
		hdr.groupId = 0;
		hdr.size = 0;
		hdr.checkSum = 0;
		hdr.modTime =
			(new java.util.Date()).getTime() / 1000;
		hdr.linkFlag =
			isDir ? TarHeader.LF_DIR : TarHeader.LF_NORMAL;
		hdr.linkName = new StringBuffer( """" );
		hdr.userName = new StringBuffer( """" );
		hdr.groupName = new StringBuffer( """" );
		hdr.devMajor = 0;
		hdr.devMinor = 0;
		}
	}
"
installer.TarHeader,"/*
** Authored by Timothy Gerard Endres
** <mailto:time@gjt.org>  <http://www.trustice.com>
** 
** This work has been placed into the public domain.
** You may use this work in any way and for any purpose you wish.
**
** THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND,
** NOT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR
** OF THIS SOFTWARE, ASSUMES _NO_ RESPONSIBILITY FOR ANY
** CONSEQUENCE RESULTING FROM THE USE, MODIFICATION, OR
** REDISTRIBUTION OF THIS SOFTWARE. 
** 
*/
package installer;
/**
 * This class encapsulates the Tar Entry Header used in Tar Archives.
 * The class also holds a number of tar constants, used mostly in headers.
 */
public class
TarHeader extends Object
	{
	/**
	 * The length of the name field in a header buffer.
	 */
	public static final int		NAMELEN = 100;
	/**
	 * The length of the mode field in a header buffer.
	 */
	public static final int		MODELEN = 8;
	/**
	 * The length of the user id field in a header buffer.
	 */
	public static final int		UIDLEN = 8;
	/**
	 * The length of the group id field in a header buffer.
	 */
	public static final int		GIDLEN = 8;
	/**
	 * The length of the checksum field in a header buffer.
	 */
	public static final int		CHKSUMLEN = 8;
	/**
	 * The length of the size field in a header buffer.
	 */
	public static final int		SIZELEN = 12;
	/**
	 * The length of the magic field in a header buffer.
	 */
	public static final int		MAGICLEN = 8;
	/**
	 * The length of the modification time field in a header buffer.
	 */
	public static final int		MODTIMELEN = 12;
	/**
	 * The length of the user name field in a header buffer.
	 */
	public static final int		UNAMELEN = 32;
	/**
	 * The length of the group name field in a header buffer.
	 */
	public static final int		GNAMELEN = 32;
	/**
	 * The length of the devices field in a header buffer.
	 */
	public static final int		DEVLEN = 8;
	/**
	 * LF_ constants represent the ""link flag"" of an entry, or more commonly,
	 * the ""entry type"". This is the ""old way"" of indicating a normal file.
	 */
	public static final byte	LF_OLDNORM	= 0;
	/**
	 * Normal file type.
	 */
	public static final byte	LF_NORMAL	= (byte) '0';
	/**
	 * Link file type.
	 */
	public static final byte	LF_LINK		= (byte) '1';
	/**
	 * Symbolic link file type.
	 */
	public static final byte	LF_SYMLINK	= (byte) '2';
	/**
	 * Character device file type.
	 */
	public static final byte	LF_CHR		= (byte) '3';
	/**
	 * Block device file type.
	 */
	public static final byte	LF_BLK		= (byte) '4';
	/**
	 * Directory file type.
	 */
	public static final byte	LF_DIR		= (byte) '5';
	/**
	 * FIFO (pipe) file type.
	 */
	public static final byte	LF_FIFO		= (byte) '6';
	/**
	 * Contiguous file type.
	 */
	public static final byte	LF_CONTIG	= (byte) '7';
	/**
	 * The magic tag representing a POSIX tar archive.
	 */
	public static final String	TMAGIC		= ""ustar"";
	/**
	 * The magic tag representing a GNU tar archive.
	 */
	public static final String	GNU_TMAGIC	= ""ustar  "";
	/**
	 * The entry's name.
	 */
	public StringBuffer		name;
	/**
	 * The entry's permission mode.
	 */
	public int				mode;
	/**
	 * The entry's user id.
	 */
	public int				userId;
	/**
	 * The entry's group id.
	 */
	public int				groupId;
	/**
	 * The entry's size.
	 */
	public long				size;
	/**
	 * The entry's modification time.
	 */
	public long				modTime;
	/**
	 * The entry's checksum.
	 */
	public int				checkSum;
	/**
	 * The entry's link flag.
	 */
	public byte				linkFlag;
	/**
	 * The entry's link name.
	 */
	public StringBuffer		linkName;
	/**
	 * The entry's magic tag.
	 */
	public StringBuffer		magic;
	/**
	 * The entry's user name.
	 */
	public StringBuffer		userName;
	/**
	 * The entry's group name.
	 */
	public StringBuffer		groupName;
	/**
	 * The entry's major device number.
	 */
	public int				devMajor;
	/**
	 * The entry's minor device number.
	 */
	public int				devMinor;
	public
	TarHeader()
		{
		this.magic = new StringBuffer( TarHeader.TMAGIC );
		this.name = new StringBuffer();
		this.linkName = new StringBuffer();
		String user =
			System.getProperty( ""user.name"", """" );
		if ( user.length() > 31 )
			user = user.substring( 0, 31 );
		this.userId = 0;
		this.groupId = 0;
		this.userName = new StringBuffer( user );
		this.groupName = new StringBuffer( """" );
		}
	/**
	 * TarHeaders can be cloned.
	 */
	public Object
	clone()
		{
		TarHeader hdr = null;
		try {
			hdr = (TarHeader) super.clone();
			hdr.name =
				(this.name == null ) ? null
					: new StringBuffer( this.name.toString() );
			hdr.mode = this.mode;
			hdr.userId = this.userId;
			hdr.groupId = this.groupId;
			hdr.size = this.size;
			hdr.modTime = this.modTime;
			hdr.checkSum = this.checkSum;
			hdr.linkFlag = this.linkFlag;
			hdr.linkName =
				(this.linkName == null ) ? null
					: new StringBuffer( this.linkName.toString() );
			hdr.magic =
				(this.magic == null ) ? null
					: new StringBuffer( this.magic.toString() );
			hdr.userName =
				(this.userName == null ) ? null
					: new StringBuffer( this.userName.toString() );
			hdr.groupName =
				(this.groupName == null ) ? null
					: new StringBuffer( this.groupName.toString() );
			hdr.devMajor = this.devMajor;
			hdr.devMinor = this.devMinor;
			}
		catch ( CloneNotSupportedException ex )
			{
			ex.printStackTrace();
			}
		return hdr;
		}
	/**
	 * Get the name of this entry.
	 *
	 * @return Teh entry's name.
	 */
	public String
	getName()
		{
		return this.name.toString();
		}
	/**
	 * Parse an octal string from a header buffer. This is used for the
	 * file permission mode value.
	 *
	 * @param header The header buffer from which to parse.
	 * @param offset The offset into the buffer from which to parse.
	 * @param length The number of header bytes to parse.
	 * @return The long value of the octal string.
	 */
	public static long
	parseOctal( byte[] header, int offset, int length )
		throws InvalidHeaderException
		{
		long result = 0;
		boolean stillPadding = true;
		int end = offset + length;
		for ( int i = offset ; i < end ; ++i )
			{
			if ( header[i] == 0 )
				break;
			if ( header[i] == (byte) ' ' || header[i] == '0' )
				{
				if ( stillPadding )
					continue;
				if ( header[i] == (byte) ' ' )
					break;
				}
			stillPadding = false;
			result =
				(result << 3)
					+ (header[i] - '0');
			}
		return result;
		}
	/**
	 * Parse an entry name from a header buffer.
	 *
	 * @param header The header buffer from which to parse.
	 * @param offset The offset into the buffer from which to parse.
	 * @param length The number of header bytes to parse.
	 * @return The header's entry name.
	 */
	public static StringBuffer
	parseName( byte[] header, int offset, int length )
		throws InvalidHeaderException
		{
		StringBuffer result = new StringBuffer( length );
		int end = offset + length;
		for ( int i = offset ; i < end ; ++i )
			{
			if ( header[i] == 0 )
				break;
			result.append( (char)header[i] );
			}
		return result;
		}
	/**
	 * Determine the number of bytes in an entry name.
	 *
	 * @param header The header buffer from which to parse.
	 * @param offset The offset into the buffer from which to parse.
	 * @param length The number of header bytes to parse.
	 * @return The number of bytes in a header's entry name.
	 */
	public static int
	getNameBytes( StringBuffer name, byte[] buf, int offset, int length )
		{
		int i;
		for ( i = 0 ; i < length && i < name.length() ; ++i )
			{
			buf[ offset + i ] = (byte) name.charAt( i );
			}
		for ( ; i < length ; ++i )
			{
			buf[ offset + i ] = 0;
			}
		return offset + length;
		}
	/**
	 * Parse an octal integer from a header buffer.
	 *
	 * @param header The header buffer from which to parse.
	 * @param offset The offset into the buffer from which to parse.
	 * @param length The number of header bytes to parse.
	 * @return The integer value of the octal bytes.
	 */
	public static int
	getOctalBytes( long value, byte[] buf, int offset, int length )
		{
		byte[] result = new byte[ length ];
		int idx = length - 1;
		buf[ offset + idx ] = 0;
		--idx;
		buf[ offset + idx ] = (byte) ' ';
		--idx;
		if ( value == 0 )
			{
			buf[ offset + idx ] = (byte) '0';
			--idx;
			}
		else
			{
			for ( long val = value ; idx >= 0 && val > 0 ; --idx )
				{
				buf[ offset + idx ] = (byte)
					( (byte) '0' + (byte) (val & 7) );
				val = val >> 3;
				}
			}
		for ( ; idx >= 0 ; --idx )
			{
			buf[ offset + idx ] = (byte) ' ';
			}
		return offset + length;
		}
	/**
	 * Parse an octal long integer from a header buffer.
	 *
	 * @param header The header buffer from which to parse.
	 * @param offset The offset into the buffer from which to parse.
	 * @param length The number of header bytes to parse.
	 * @return The long value of the octal bytes.
	 */
	public static int
	getLongOctalBytes( long value, byte[] buf, int offset, int length )
		{
		byte[] temp = new byte[ length + 1 ];
		TarHeader.getOctalBytes( value, temp, 0, length + 1 );
		System.arraycopy( temp, 0, buf, offset, length );
		return offset + length;
		}
	/**
	 * Parse the checksum octal integer from a header buffer.
	 *
	 * @param header The header buffer from which to parse.
	 * @param offset The offset into the buffer from which to parse.
	 * @param length The number of header bytes to parse.
	 * @return The integer value of the entry's checksum.
	 */
	public static int
	getCheckSumOctalBytes( long value, byte[] buf, int offset, int length )
		{
		TarHeader.getOctalBytes( value, buf, offset, length );
		buf[ offset + length - 1 ] = (byte) ' ';
		buf[ offset + length - 2 ] = 0;
		return offset + length;
		}
	}
"
installer.TarInputStream,"/*
** Authored by Timothy Gerard Endres
** <mailto:time@gjt.org>  <http://www.trustice.com>
** 
** This work has been placed into the public domain.
** You may use this work in any way and for any purpose you wish.
**
** THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND,
** NOT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR
** OF THIS SOFTWARE, ASSUMES _NO_ RESPONSIBILITY FOR ANY
** CONSEQUENCE RESULTING FROM THE USE, MODIFICATION, OR
** REDISTRIBUTION OF THIS SOFTWARE. 
** 
*/
package installer;
import java.io.*;
/**
 * The TarInputStream reads a UNIX tar archive as an InputStream.
 * methods are provided to position at each successive entry in
 * the archive, and the read each entry as a normal input stream
 * using read().
 *
 * @version $Revision: 1.1 $
 * @author Timothy Gerard Endres,
 *  <a href=""mailto:time@gjt.org"">time@trustice.com</a>.
 * @see TarBuffer
 * @see TarHeader
 * @see TarEntry
 */
public
class		TarInputStream
extends		FilterInputStream
	{
	protected boolean			debug;
	protected boolean			hasHitEOF;
	protected int				entrySize;
	protected int				entryOffset;
	protected byte[]			oneBuf;
	protected byte[]			readBuf;
	protected TarBuffer			buffer;
	protected TarEntry			currEntry;
	protected EntryFactory		eFactory;
	public
	TarInputStream( InputStream is )
		{
		this( is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE );
		}
	public
	TarInputStream( InputStream is, int blockSize )
		{
		this( is, blockSize, TarBuffer.DEFAULT_RCDSIZE );
		}
	public
	TarInputStream( InputStream is, int blockSize, int recordSize )
		{
		super( is );
		this.buffer = new TarBuffer( is, blockSize, recordSize );
		this.readBuf = null;
		this.oneBuf = new byte[1];
		this.debug = false;
		this.hasHitEOF = false;
		this.eFactory = null;
		}
	/**
	 * Sets the debugging flag.
	 *
	 * @param debugF True to turn on debugging.
	 */
	public void
	setDebug( boolean debugF )
		{
		this.debug = debugF;
		}
	/**
	 * Sets the debugging flag.
	 *
	 * @param debugF True to turn on debugging.
	 */
	public void
	setEntryFactory( EntryFactory factory )
		{
		this.eFactory = factory;
		}
	/**
	 * Sets the debugging flag in this stream's TarBuffer.
	 *
	 * @param debugF True to turn on debugging.
	 */
	public void
	setBufferDebug( boolean debug )
		{
		this.buffer.setDebug( debug );
		}
	/**
	 * Closes this stream. Calls the TarBuffer's close() method.
	 */
	public void
	close()
		throws IOException
		{
		this.buffer.close();
		}
	/**
	 * Get the record size being used by this stream's TarBuffer.
	 *
	 * @return The TarBuffer record size.
	 */
	public int
	getRecordSize()
		{
		return this.buffer.getRecordSize();
		}
	/**
	 * Get the available data that can be read from the current
	 * entry in the archive. This does not indicate how much data
	 * is left in the entire archive, only in the current entry.
	 * This value is determined from the entry's size header field
	 * and the amount of data already read from the current entry.
	 * 
	 *
	 * @return The number of available bytes for the current entry.
	 */
	public int
	available()
		throws IOException
		{
		return this.entrySize - this.entryOffset;
		}
	/**
	 * Skip bytes in the input buffer. This skips bytes in the
	 * current entry's data, not the entire archive, and will
	 * stop at the end of the current entry's data if the number
	 * to skip extends beyond that point.
	 *
	 * @param numToSkip The number of bytes to skip.
	 */
	public void
	skip( int numToSkip )
		throws IOException
		{
		// REVIEW
		// This is horribly inefficient, but it ensures that we
		// properly skip over bytes via the TarBuffer...
		//
		byte[] skipBuf = new byte[ 8 * 1024 ];
		for ( int num = numToSkip ; num > 0 ; )
			{
			int numRead =
				this.read( skipBuf, 0,
					( num > skipBuf.length ? skipBuf.length : num ) );
			if ( numRead == -1 )
				break;
			num -= numRead;
			}
		}
	/**
	 * Since we do not support marking just yet, we return false.
	 *
	 * @return False.
	 */
	public boolean
	markSupported()
		{
		return false;
		}
	/**
	 * Since we do not support marking just yet, we do nothing.
	 *
	 * @param markLimit The limit to mark.
	 */
	public void
	mark( int markLimit )
		{
		}
	/**
	 * Since we do not support marking just yet, we do nothing.
	 */
	public void
	reset()
		{
		}
	/**
	 * Get the next entry in this tar archive. This will skip
	 * over any remaining data in the current entry, if there
	 * is one, and place the input stream at the header of the
	 * next entry, and read the header and instantiate a new
	 * TarEntry from the header bytes and return that entry.
	 * If there are no more entries in the archive, null will
	 * be returned to indicate that the end of the archive has
	 * been reached.
	 *
	 * @return The next TarEntry in the archive, or null.
	 */
	public TarEntry
	getNextEntry()
		throws IOException
		{
		if ( this.hasHitEOF )
			return null;
		if ( this.currEntry != null )
			{
			int numToSkip = this.entrySize - this.entryOffset;
			if ( this.debug )
			System.err.println
				( ""TarInputStream: SKIP currENTRY '""
				+ this.currEntry.getName() + ""' SZ ""
				+ this.entrySize + "" OFF "" + this.entryOffset
				+ ""  skipping "" + numToSkip + "" bytes"" );
			if ( numToSkip > 0 )
				{
				this.skip( numToSkip );
				}
			this.readBuf = null;
			}
		byte[] headerBuf = this.buffer.readRecord();
		if ( headerBuf == null )
			{
			if ( this.debug )
				{
				System.err.println( ""READ NULL RECORD"" );
				}
			this.hasHitEOF = true;
			}
		else if ( this.buffer.isEOFRecord( headerBuf ) )
			{
			if ( this.debug )
				{
				System.err.println( ""READ EOF RECORD"" );
				}
			this.hasHitEOF = true;
			}
		if ( this.hasHitEOF )
			{
			this.currEntry = null;
			}
		else
			{
			try {
				if ( this.eFactory == null )
					{
					this.currEntry = new TarEntry( headerBuf );
					}
				else
					{
					this.currEntry =
						this.eFactory.createEntry( headerBuf );
					}
				if ( ! ( headerBuf[257] == 'u' && headerBuf[258] == 's'
						&& headerBuf[259] == 't' && headerBuf[260] == 'a'
						&& headerBuf[261] == 'r' ) )
					{
					throw new InvalidHeaderException
						( ""header magic is not 'ustar', but '""
							+ headerBuf[257] + headerBuf[258] + headerBuf[259]
							+ headerBuf[260] + headerBuf[261] + ""', or (dec) ""
							+ ((int)headerBuf[257]) + "", ""
							+ ((int)headerBuf[258]) + "", ""
							+ ((int)headerBuf[259]) + "", ""
							+ ((int)headerBuf[260]) + "", ""
							+ ((int)headerBuf[261]) );
					}
				if ( this.debug )
				System.err.println
					( ""TarInputStream: SET CURRENTRY '""
						+ this.currEntry.getName()
						+ ""' size = "" + this.currEntry.getSize() );
				this.entryOffset = 0;
				// REVIEW How do we resolve this discrepancy?!
				this.entrySize = (int) this.currEntry.getSize();
				}
			catch ( InvalidHeaderException ex )
				{
				this.entrySize = 0;
				this.entryOffset = 0;
				this.currEntry = null;
				throw new InvalidHeaderException
					( ""bad header in block ""
						+ this.buffer.getCurrentBlockNum()
						+ "" record ""
						+ this.buffer.getCurrentRecordNum()
						+ "", "" + ex.getMessage() );
				}
			}
		return this.currEntry;
		}
	/**
	 * Reads a byte from the current tar archive entry.
	 *
	 * This method simply calls read( byte[], int, int ).
	 *
	 * @return The byte read, or -1 at EOF.
	 */
	public int
	read()
		throws IOException
		{
		int num = this.read( this.oneBuf, 0, 1 );
		if ( num == -1 )
			return num;
		else
			return (int) this.oneBuf[0];
		}
	/**
	 * Reads bytes from the current tar archive entry.
	 *
	 * This method simply calls read( byte[], int, int ).
	 *
	 * @param buf The buffer into which to place bytes read.
	 * @return The number of bytes read, or -1 at EOF.
	 */
	public int
	read( byte[] buf )
		throws IOException
		{
		return this.read( buf, 0, buf.length );
		}
	/**
	 * Reads bytes from the current tar archive entry.
	 *
	 * This method is aware of the boundaries of the current
	 * entry in the archive and will deal with them as if they
	 * were this stream's start and EOF.
	 *
	 * @param buf The buffer into which to place bytes read.
	 * @param offset The offset at which to place bytes read.
	 * @param numToRead The number of bytes to read.
	 * @return The number of bytes read, or -1 at EOF.
	 */
	public int
	read( byte[] buf, int offset, int numToRead )
		throws IOException
		{
		int totalRead = 0;
		if ( this.entryOffset >= this.entrySize )
			return -1;
		if ( (numToRead + this.entryOffset) > this.entrySize )
			{
			numToRead = (this.entrySize - this.entryOffset);
			}
		if ( this.readBuf != null )
			{
			int sz = ( numToRead > this.readBuf.length )
						? this.readBuf.length : numToRead;
			System.arraycopy( this.readBuf, 0, buf, offset, sz );
			if ( sz >= this.readBuf.length )
				{
				this.readBuf = null;
				}
			else
				{
				int newLen = this.readBuf.length - sz;
				byte[] newBuf = new byte[ newLen ];
				System.arraycopy( this.readBuf, sz, newBuf, 0, newLen );
				this.readBuf = newBuf;
				}
			totalRead += sz;
			numToRead -= sz;
			offset += sz;
			}
		for ( ; numToRead > 0 ; )
			{
			byte[] rec = this.buffer.readRecord();
			if ( rec == null )
				{
				// Unexpected EOF!
				throw new IOException
					( ""unexpected EOF with "" + numToRead + "" bytes unread"" );
				}
			int sz = numToRead;
			int recLen = rec.length;
			if ( recLen > sz )
				{
				System.arraycopy( rec, 0, buf, offset, sz );
				this.readBuf = new byte[ recLen - sz ];
				System.arraycopy( rec, sz, this.readBuf, 0, recLen - sz );
				}
			else
				{
				sz = recLen;
				System.arraycopy( rec, 0, buf, offset, recLen );
				}
			totalRead += sz;
			numToRead -= sz;
			offset += sz;
			}
		this.entryOffset += totalRead;
		return totalRead;
		}
	/**
	 * Copies the contents of the current tar archive entry directly into
	 * an output stream.
	 *
	 * @param out The OutputStream into which to write the entry's data.
	 */
	public void
	copyEntryContents( OutputStream out )
		throws IOException
		{
		byte[] buf = new byte[ 32 * 1024 ];
		for ( ; ; )
			{
			int numRead = this.read( buf, 0, buf.length );
			if ( numRead == -1 )
				break;
			out.write( buf, 0, numRead );
			}
		}
	/**
	 * This interface is provided, with the method setEntryFactory(), to allow
	 * the programmer to have their own TarEntry subclass instantiated for the
	 * entries return from getNextEntry().
	 */
	public
	interface	EntryFactory
		{
		public TarEntry
			createEntry( String name );
		public TarEntry
			createEntry( File path )
				throws InvalidHeaderException;
		public TarEntry
			createEntry( byte[] headerBuf )
				throws InvalidHeaderException;
		}
	public
	class		EntryAdapter
	implements	EntryFactory
		{
		public TarEntry
		createEntry( String name )
			{
			return new TarEntry( name );
			}
		public TarEntry
		createEntry( File path )
			throws InvalidHeaderException
			{
			return new TarEntry( path );
			}
		public TarEntry
		createEntry( byte[] headerBuf )
			throws InvalidHeaderException
			{
			return new TarEntry( headerBuf );
			}
		}
	}
"
installer.TarOutputStream,"/*
** Authored by Timothy Gerard Endres
** <mailto:time@gjt.org>  <http://www.trustice.com>
** 
** This work has been placed into the public domain.
** You may use this work in any way and for any purpose you wish.
**
** THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND,
** NOT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR
** OF THIS SOFTWARE, ASSUMES _NO_ RESPONSIBILITY FOR ANY
** CONSEQUENCE RESULTING FROM THE USE, MODIFICATION, OR
** REDISTRIBUTION OF THIS SOFTWARE. 
** 
*/
package installer;
import java.io.*;
/**
 * The TarOutputStream writes a UNIX tar archive as an OutputStream.
 * Methods are provided to put entries, and then write their contents
 * by writing to this stream using write().
 *
 *
 * @version $Revision: 1.1 $
 * @author Timothy Gerard Endres,
 *  <a href=""mailto:time@gjt.org"">time@trustice.com</a>.
 * @see TarBuffer
 * @see TarHeader
 * @see TarEntry
 */
public
class		TarOutputStream
extends		FilterOutputStream
	{
	protected boolean			debug;
	protected int				currSize;
	protected int				currBytes;
	protected byte[]			oneBuf;
	protected byte[]			recordBuf;
	protected int				assemLen;
	protected byte[]			assemBuf;
	protected TarBuffer			buffer;
	public
	TarOutputStream( OutputStream os )
		{
		this( os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE );
		}
	public
	TarOutputStream( OutputStream os, int blockSize )
		{
		this( os, blockSize, TarBuffer.DEFAULT_RCDSIZE );
		}
	public
	TarOutputStream( OutputStream os, int blockSize, int recordSize )
		{
		super( os );
		this.buffer = new TarBuffer( os, blockSize, recordSize );
		this.debug = false;
		this.assemLen = 0;
		this.assemBuf = new byte[ recordSize ];
		this.recordBuf = new byte[ recordSize ];
		this.oneBuf = new byte[1];
		}
	/**
	 * Sets the debugging flag.
	 *
	 * @param debugF True to turn on debugging.
	 */
	public void
	setDebug( boolean debugF )
		{
		this.debug = debugF;
		}
	/**
	 * Sets the debugging flag in this stream's TarBuffer.
	 *
	 * @param debugF True to turn on debugging.
	 */
	public void
	setBufferDebug( boolean debug )
		{
		this.buffer.setDebug( debug );
		}
	/**
	 * Ends the TAR archive without closing the underlying OutputStream.
	 * The result is that the EOF record of nulls is written.
	 */
	public void
	finish()
		throws IOException
		{
		this.writeEOFRecord();
		}
	/**
	 * Ends the TAR archive and closes the underlying OutputStream.
	 * This means that finish() is called followed by calling the
	 * TarBuffer's close().
	 */
	public void
	close()
		throws IOException
		{
		this.finish();
		this.buffer.close();
		}
	/**
	 * Get the record size being used by this stream's TarBuffer.
	 *
	 * @return The TarBuffer record size.
	 */
	public int
	getRecordSize()
		{
		return this.buffer.getRecordSize();
		}
	/**
	 * Put an entry on the output stream. This writes the entry's
	 * header record and positions the output stream for writing
	 * the contents of the entry. Once this method is called, the
	 * stream is ready for calls to write() to write the entry's
	 * contents. Once the contents are written, closeEntry()
	 * <B>MUST</B> be called to ensure that all buffered data
	 * is completely written to the output stream.
	 *
	 * @param entry The TarEntry to be written to the archive.
	 */
	public void
	putNextEntry( TarEntry entry )
		throws IOException
		{
		if ( entry.getHeader().name.length() > TarHeader.NAMELEN )
			throw new InvalidHeaderException
				( ""file name '"" + entry.getHeader().name
					+ ""' is too long ( > ""
					+ TarHeader.NAMELEN + "" bytes )"" );
		entry.writeEntryHeader( this.recordBuf );
		this.buffer.writeRecord( this.recordBuf );
		this.currBytes = 0;
		if ( entry.isDirectory() )
			this.currSize = 0;
		else
			this.currSize = (int)entry.getSize();
		}
	/**
	 * Close an entry. This method MUST be called for all file
	 * entries that contain data. The reason is that we must
	 * buffer data written to the stream in order to satisfy
	 * the buffer's record based writes. Thus, there may be
	 * data fragments still being assembled that must be written
	 * to the output stream before this entry is closed and the
	 * next entry written.
	 */
	public void
	closeEntry()
		throws IOException
		{
		if ( this.assemLen > 0 )
			{
			for ( int i = this.assemLen ; i < this.assemBuf.length ; ++i )
				this.assemBuf[i] = 0;
			this.buffer.writeRecord( this.assemBuf );
			this.currBytes += this.assemLen;
			this.assemLen = 0;
			}
		if ( this.currBytes < this.currSize )
			throw new IOException
				( ""entry closed at '"" + this.currBytes
					+ ""' before the '"" + this.currSize
					+ ""' bytes specified in the header were written"" );
		}
	/**
	 * Writes a byte to the current tar archive entry.
	 *
	 * This method simply calls read( byte[], int, int ).
	 *
	 * @param b The byte written.
	 */
	public void
	write( int b )
		throws IOException
		{
		this.oneBuf[0] = (byte) b;
		this.write( this.oneBuf, 0, 1 );
		}
	/**
	 * Writes bytes to the current tar archive entry.
	 *
	 * This method simply calls read( byte[], int, int ).
	 *
	 * @param wBuf The buffer to write to the archive.
	 * @return The number of bytes read, or -1 at EOF.
	 */
	public void
	write( byte[] wBuf )
		throws IOException
		{
		this.write( wBuf, 0, wBuf.length );
		}
	/**
	 * Writes bytes to the current tar archive entry. This method
	 * is aware of the current entry and will throw an exception if
	 * you attempt to write bytes past the length specified for the
	 * current entry. The method is also (painfully) aware of the
	 * record buffering required by TarBuffer, and manages buffers
	 * that are not a multiple of recordsize in length, including
	 * assembling records from small buffers.
	 *
	 * This method simply calls read( byte[], int, int ).
	 *
	 * @param wBuf The buffer to write to the archive.
	 * @param wOffset The offset in the buffer from which to get bytes.
	 * @param numToWrite The number of bytes to write.
	 */
	public void
	write( byte[] wBuf, int wOffset, int numToWrite )
		throws IOException
		{
		if ( (this.currBytes + numToWrite) > this.currSize )
			throw new IOException
				( ""request to write '"" + numToWrite
					+ ""' bytes exceeds size in header of '""
					+ this.currSize + ""' bytes"" );
		//
		// We have to deal with assembly!!!
		// The programmer can be writing little 32 byte chunks for all
		// we know, and we must assemble complete records for writing.
		// REVIEW Maybe this should be in TarBuffer? Could that help to
		//        eliminate some of the buffer copying.
		//
		if ( this.assemLen > 0 )
			{
			if ( (this.assemLen + numToWrite ) >= this.recordBuf.length )
				{
				int aLen = this.recordBuf.length - this.assemLen;
				System.arraycopy
					( this.assemBuf, 0, this.recordBuf, 0, this.assemLen );
				System.arraycopy
					( wBuf, wOffset, this.recordBuf, this.assemLen, aLen );
				this.buffer.writeRecord( this.recordBuf );
				this.currBytes += this.recordBuf.length;
				wOffset += aLen;
				numToWrite -= aLen;
				this.assemLen = 0;
				}
			else // ( (this.assemLen + numToWrite ) < this.recordBuf.length )
				{
				System.arraycopy
					( wBuf, wOffset, this.assemBuf,
						this.assemLen, numToWrite );
				wOffset += numToWrite;
				this.assemLen += numToWrite; 
				numToWrite -= numToWrite;
				}
			}
		//
		// When we get here we have EITHER:
		//   o An empty ""assemble"" buffer.
		//   o No bytes to write (numToWrite == 0)
		//
		for ( ; numToWrite > 0 ; )
			{
			if ( numToWrite < this.recordBuf.length )
				{
				System.arraycopy
					( wBuf, wOffset, this.assemBuf, this.assemLen, numToWrite );
				this.assemLen += numToWrite;
				break;
				}
			this.buffer.writeRecord( wBuf, wOffset );
			int num = this.recordBuf.length;
			this.currBytes += num;
			numToWrite -= num;
			wOffset += num;
			}
		}
	/**
	 * Write an EOF (end of archive) record to the tar archive.
	 * An EOF record consists of a record of all zeros.
	 */
	private void
	writeEOFRecord()
		throws IOException
		{
		for ( int i = 0 ; i < this.recordBuf.length ; ++i )
			this.recordBuf[i] = 0;
		this.buffer.writeRecord( this.recordBuf );
		}
	}
"
installer.VariableGridLayout,"/*
 * VariableGridLayout.java - a grid layout manager with variable cell sizes
 *
 * Originally written by Dirk Moebius for the jEdit project. This work has been
 * placed into the public domain. You may use this work in any way and for any
 * purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package installer;
import java.awt.*;
// This is copied from jEdit's org.gjt.sp.jedit.gui package.
/**
 * The <code>VariableGridLayout</code> class is a layout manager
 * that lays out a container's components in a rectangular grid
 * with variable cell sizes.<p>
 *
 * The container is divided into rectangles, and one component is placed
 * in each rectangle. Each row is as large as the largest component in
 * that row, and each column is as wide as the widest component in
 * that column.<p>
 *
 * This behavior is basically the same as in
 * <code>java.awt.GridLayout</code>, but with different row heights and
 * column widths for each row/column.<p>
 *
 * For example, the following is an applet that lays out six buttons
 * into three rows and two columns:<p>
 *
 * <blockquote><pre>
 * import java.awt.*;
 * import java.applet.Applet;
 * public class ButtonGrid extends Applet {
 *     public void init() {
 *         setLayout(new VariableGridLayout(VariableGridLayout.FIXED_NUM_COLUMNS, 2));
 *         add(new Button(""1""));
 *         add(new Button(""2""));
 *         add(new Button(""3""));
 *         add(new Button(""4""));
 *         add(new Button(""5""));
 *         add(new Button(""6""));
 *     }
 * }
 * </pre></blockquote><p>
 *
 * <b>Programmer's remark:</b> VariableGridLayout could be faster, if it would
 * reside in the package java.awt, because then it could access some
 * package private fields of <code>Container</code> or
 * <code>Component</code>. Instead, it has to call
 * <code>Component.getSize()</code>,
 * which allocates memory on the heap.<p>
 *
 * <b>Todo:</b>
 * <ul>
 * <li>Use alignmentX/Y property if the grid cell is larger than the preferred size of the component.
 * <li>Ability to span components over more than one cell horizontally
 * </ul>
 *
 * @author Dirk Moebius
 * @version 1.0
 * @see java.awt.GridLayout
 */
public class VariableGridLayout implements LayoutManager2, java.io.Serializable
{
	public static final int FIXED_NUM_ROWS = 1;
	public static final int FIXED_NUM_COLUMNS = 2;
	public VariableGridLayout(int mode, int size, int hgap, int vgap) {
		if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS) {
			throw new IllegalArgumentException(""illegal mode; value is "" + mode);
		}
		if (size <= 0) {
			throw new IllegalArgumentException(""size cannot be zero or less; value is "" + size);
		}
		if (hgap < 0) {
			throw new IllegalArgumentException(""hgap cannot be negative; value is "" + hgap);
		}
		if (vgap < 0) {
			throw new IllegalArgumentException(""vgap cannot be negative; value is "" + vgap);
		}
		this.mode = mode;
		this.size = size;
		this.hgap = hgap;
		this.vgap = vgap;
	}
	/**
	 * Creates a variable grid layout manager with the specified mode
	 * and zero horizontal and vertical gap.
	 */
	public VariableGridLayout(int mode, int size) {
		this(mode, size, 0, 0);
	}
	/**
	 * Creates a variable grid layout manager with mode FIXED_NUM_ROWS,
	 * number of rows == 1 and zero horizontal and vertical gap.
	 */
	public VariableGridLayout() {
		this(FIXED_NUM_ROWS, 1, 0, 0);
	}
	/**
	 * Not used in this class.
	 */
	public void addLayoutComponent(String name, Component component) { }
	/**
	 * Not used in this class.
	 */
	public void addLayoutComponent(Component component, Object constraints) { }
	/**
	 * Not used in this class.
	 */
	public void removeLayoutComponent(Component component) { }
	/**
	 * Always returns 0.5.
	 */
	public float getLayoutAlignmentX(Container container) {
		return 0.5f;
	}
	/**
	 * Always returns 0.5.
	 */
	public float getLayoutAlignmentY(Container container) {
		return 0.5f;
	}
	public Dimension preferredLayoutSize(Container parent) {
		return getLayoutSize(parent, 2);
	}
	public Dimension minimumLayoutSize(Container parent) {
		return getLayoutSize(parent, 0);
	}
	public Dimension maximumLayoutSize(Container parent) {
		return getLayoutSize(parent, 1);
	}
	public void layoutContainer(Container parent) {
		synchronized (parent.getTreeLock()) {
			update(parent);
			int ncomponents = parent.getComponentCount();
			if (ncomponents == 0) {
				return;
			}
			// Pass 1: compute preferred row heights / column widths
			int total_height = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						Dimension d = parent.getComponent(i).getPreferredSize();
						row_heights[r] = Math.max(row_heights[r], d.height);
						col_widths[c] = Math.max(col_widths[c], d.width);
					} else {
						break;
					}
				}
				total_height += row_heights[r];
			}
			int total_width = 0;
			for (int c = 0; c < ncols; c++) {
				total_width += col_widths[c];
			}
			// Pass 2: redistribute free space
			Dimension parent_size = parent.getSize();
			Insets insets = parent.getInsets();
			int free_height = parent_size.height - insets.top - insets.bottom - (nrows - 1) * vgap;
			int free_width = parent_size.width - insets.left - insets.right - (ncols - 1) * hgap;
			if (total_height != free_height) {
				double dy = (double)free_height / (double)total_height;
				for (int r = 0; r < nrows; r++) {
					row_heights[r] = (int) ((double)row_heights[r] * dy);
				}
			}
			if (total_width != free_width) {
				double dx = ((double)free_width) / ((double)total_width);
				for (int c = 0; c < ncols; c++) {
					col_widths[c] = (int) ((double)col_widths[c] * dx);
				}
			}
			// Pass 3: layout components
			for (int r = 0, y = insets.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++) {
				for (int c = 0, x = insets.left; c < ncols; x += col_widths[c] + hgap, c++, i++) {
					if (i < ncomponents) {
						parent.getComponent(i).setBounds(x, y, col_widths[c], row_heights[r]);
					}
				}
			}
		} // synchronized
	}
	public void invalidateLayout(Container container) {}
	/**
	 * Returns the string representation of this variable grid layout's values.
	 * @return  a string representation of this variable grid layout.
	 */
	public String toString() {
		return getClass().getName() + ""[mode="" + mode + "",size="" + size
			   + "",hgap="" + hgap + "",vgap="" + vgap + ""]"";
	}
	/**
	 * @param  which  if 0 compute minimum layout size,
	 *				if 1 compute maximum layout size,
	 *				otherwise compute preferred layout size.
	 */
	private Dimension getLayoutSize(Container parent, int which) {
		synchronized (parent.getTreeLock()){
			update(parent);
			int ncomponents = parent.getComponentCount();
			int h = 0;
			int w = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				int row_height = 0;
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						switch (which) {
							case 0:
								row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);
								break;
							case 1:
								row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);
								break;
							default:
								row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);
								break;
						}
					} else {
						break;
					}
				}
				h += row_height;
			}
			for (int c = 0; c < ncols; c++) {
				int col_width = 0;
				for (int r = 0; r < nrows; r++) {
					int i = r * ncols + c;
					if (i < ncomponents) {
						switch (which) {
							case 0:
								col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);
								break;
							case 1:
								col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);
								break;
							default:
								col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);
								break;
						}
					} else {
						break;
					}
				}
				w += col_width;
			}
			Insets insets = parent.getInsets();
			return new Dimension(w + insets.left + insets.right + ((ncols - 1) * hgap),
								 h + insets.top + insets.bottom + ((nrows - 1) * vgap));
		}
	}
	private void update(Container container) {
		int ncomponents = container.getComponentCount();
		int old_nrows = nrows;
		int old_ncols = ncols;
		if (this.mode == FIXED_NUM_ROWS) {
			nrows = this.size;
			ncols = (ncomponents + nrows - 1) / nrows;
		} else {
			ncols = this.size;
			nrows = (ncomponents + ncols - 1) / ncols;
		}
		if (old_nrows != nrows) {
			row_heights = new int[nrows];
		}
		if (old_ncols != ncols) {
			col_widths = new int[ncols];
		}
	}
	private int mode;
	private int size;
	private int hgap;
	private int vgap;
	private transient int nrows = -1;
	private transient int ncols = -1;
	private transient int[] row_heights = null;
	private transient int[] col_widths = null;
}
"
jars.LatestVersion.LatestVersionPlugin,"/*
 * LatestVersionPlugin.java - Latest Version Check Plugin
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
import javax.swing.JOptionPane;
import java.io.*;
import java.net.URL;
import org.gjt.sp.jedit.*;
public class LatestVersionPlugin extends EditPlugin
{
	public static void doVersionCheck(View view)
	{
		view.showWaitCursor();
		try
		{
			URL url = new URL(jEdit.getProperty(
				""version-check.url""));
			InputStream in = url.openStream();
			BufferedReader bin = new BufferedReader(
				new InputStreamReader(in));
			String line;
			String develBuild = null;
			String stableBuild = null;
			while((line = bin.readLine()) != null)
			{
				if(line.startsWith("".build""))
					develBuild = line.substring(6).trim();
				else if(line.startsWith("".stablebuild""))
					stableBuild = line.substring(12).trim();
			}
			bin.close();
			if(develBuild != null && stableBuild != null)
			{
				doVersionCheck(view,stableBuild,develBuild);
			}
		}
		catch(IOException e)
		{
			String[] args = { jEdit.getProperty(""version-check.url""),
				e.toString() };
			GUIUtilities.error(view,""read-error"",args);
		}
		view.hideWaitCursor();
	}
	public static void doVersionCheck(View view, String stableBuild,
		String develBuild)
	{
		String myBuild = jEdit.getBuild();
		String pre = myBuild.substring(6,7);
		String variant;
		String build;
		if(pre.equals(""99""))
		{
			variant = ""stable"";
			build = stableBuild;
		}
		else
		{
			variant = ""devel"";
			build = develBuild;
		}
		// special case: no current development version
		if(develBuild.compareTo(stableBuild) < 0)
			variant += ""-nodevel"";
		int retVal = GUIUtilities.confirm(view,""version-check."" + variant,
			new String[] { MiscUtilities.buildToVersion(myBuild),
				MiscUtilities.buildToVersion(stableBuild),
				MiscUtilities.buildToVersion(develBuild) },
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
		if(retVal == JOptionPane.YES_OPTION)
			jEdit.openFile(view,jEdit.getProperty(""version-check.url""));
	}
}
"
jars.MacOS.macos.Delegate,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Delegate.java - A delegate for NSApplication
 * Copyright (C) 2003 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos;
//{{{ Imports
import com.apple.eawt.*;
import com.apple.eio.*;
import com.apple.cocoa.application.*;
import com.apple.cocoa.foundation.*;
import java.util.*;
import java.io.File;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.options.GlobalOptions;
import org.gjt.sp.util.Log;
//}}}
public class Delegate extends ApplicationAdapter
{
	//{{{ Variables
	private final NSSelector actionSel = new NSSelector(""doAction"", new Class[] {});
	private List filenames = new LinkedList();
	//}}}
	//{{{ Constructor
	public Delegate()
	{
		if (jEdit.getBooleanProperty(""MacOSPlugin.useScreenMenuBar"",
			jEdit.getBooleanProperty(""MacOSPlugin.default.useScreenMenuBar""))
		)
			System.setProperty(""apple.laf.useScreenMenuBar"",""true"");
		else
			System.setProperty(""apple.laf.useScreenMenuBar"",""false"");
	} //}}}
	//{{{ Handlers
	//{{{ handleAbout() method
	public void handleAbout(ApplicationEvent event)
	{
		event.setHandled(true);
		new AboutDialog(jEdit.getActiveView());
	} //}}}
	//{{{ handleFileCodes() method
	public void handleFileCodes(BufferUpdate msg)
	{
		Buffer buffer = msg.getBuffer();
		// Set type/creator on save
		if (!buffer.isDirty() && msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			try {
				FileManager.setFileTypeAndCreator(buffer.getPath(),
					buffer.getIntegerProperty(""MacOSPlugin.type"",
						jEdit.getIntegerProperty(""MacOSPlugin.default.type"",0)),
					buffer.getIntegerProperty(""MacOSPlugin.creator"",
						jEdit.getIntegerProperty(""MacOSPlugin.default.creator"",0)));
			} catch (Exception e) {
				// Fail silently, since we may be using UFS
			}
		}
		// Add type/creator to local buffer property list on open
		else if (msg.getWhat() == BufferUpdate.CREATED)
		{			
			if (""true"".equals(
				jEdit.getProperty(""MacOSPlugin.preserveCodes"")))
			{
				try {
					int type = FileManager.getFileType(buffer.getPath());
					int creator = FileManager.getFileCreator(buffer.getPath());
					if (type != 0)
						buffer.setIntegerProperty(""MacOSPlugin.type"",type);
					if (creator != 0)
						buffer.setIntegerProperty(""MacOSPlugin.creator"",creator);
				} catch (Exception e) {
					// This will happen when a new file is created
				}
			}
		}
	} //}}}
	//{{{ handleOpenFile() method
	public void handleOpenFile(ApplicationEvent event)
	{
		filenames.add(event.getFilename());
		event.setHandled(true);
	} //}}}
	//{{{ handleOpenFile() method
	public void handleOpenFile(ViewUpdate msg)
	{
		if(msg.getWhat() == ViewUpdate.CREATED)
		{
			Iterator i = filenames.iterator();
			while (i.hasNext())
				jEdit.openFile(msg.getView(),(String)i.next());
			MacOSPlugin.started = true;
			NSApplication app = NSApplication.sharedApplication();
			app.setServicesProvider(new Delegate());
		}
	} //}}}
	//{{{ handlePreferences() method
	public void handlePreferences(ApplicationEvent event)
	{
		event.setHandled(true);
		new GlobalOptions(jEdit.getActiveView());
	} //}}}
	//{{{ handleQuit() method
	/**
	 * This never seems to be called when used with a delegate
	 */
	//public void handleQuit(ApplicationEvent event)
	//{
	//	event.setHandled(false);
	//	jEdit.exit(jEdit.getActiveView(),true);
	//} //}}}
	//}}}
	//{{{ Delegate methods
	//{{{ applicationDockMenu() method
	public NSMenu applicationDockMenu(NSApplication sender)
	{
		NSMenu dockMenu;
		BufferMenu bufMenu;
		MacrosMenu macMenu;
		RecentMenu recMenu;
		RecentDirMenu dirMenu;
		NSMenuItem showCurrItem;
		NSMenuItem showCurrDirItem;
		NSMenuItem newViewItem;
		// Buffers
		NSMenuItem miBuff = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.buffers.label""),null,"""");
		miBuff.setSubmenu(bufMenu = new BufferMenu());
		// Recent Buffers
		NSMenuItem miRec = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.recent.label""),null,"""");
		miRec.setSubmenu(recMenu = new RecentMenu());
		// Recent Directories
		NSMenuItem miDir = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.recentDir.label""),null,"""");
		miDir.setSubmenu(dirMenu = new RecentDirMenu());
		// Macros
		NSMenuItem miMac = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.macros.label""),null,"""");
		miMac.setSubmenu(macMenu = new MacrosMenu());
		dockMenu = new NSMenu();
		newViewItem = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.newView""),actionSel,"""");
		newViewItem.setTarget(new NewViewAction());
		dockMenu.addItem(newViewItem);
		dockMenu.addItem(new NSMenuItem().separatorItem());
		showCurrItem = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.showCurrent""),actionSel,"""");
		dockMenu.addItem(showCurrItem);
		showCurrDirItem = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.showCurrentDir""),actionSel,"""");
		dockMenu.addItem(showCurrDirItem);
		dockMenu.addItem(new NSMenuItem().separatorItem());
		dockMenu.addItem(miBuff);
		dockMenu.addItem(miRec);
		dockMenu.addItem(miDir);
		//dockMenu.addItem(new NSMenuItem().separatorItem());
		//dockMenu.addItem(miMac);
		if (jEdit.getViewCount() == 0)
			miMac.setEnabled(false);
		bufMenu.updateMenu();
		recMenu.updateMenu();
		dirMenu.updateMenu();
		macMenu.updateMenu();
		View view = jEdit.getActiveView();
		if (view != null)
		{
			File buff = new File(view.getBuffer().getPath());
			if (buff.exists())
			{
				showCurrItem.setTarget(new ShowFileAction(buff.getPath()));
				showCurrDirItem.setTarget(new ShowFileAction(buff.getParent()));
			}
		}
		else
		{
			showCurrItem.setEnabled(false);
			showCurrDirItem.setEnabled(false);
		}
		return dockMenu;
	} //}}}
	//{{{ applicationOpenFiles() method
	public void applicationOpenFiles(NSApplication sender, NSArray filenames)
	{
		int count = filenames.count();
		for (int i=0; i<count; i++)
		{
			File file = new File((String)filenames.objectAtIndex(i));
			Buffer buffer;
			View view = jEdit.getActiveView();
			if(view == null)
				view = PerspectiveManager.loadPerspective(true);
			if (file.isDirectory())
			{
				VFSBrowser.browseDirectory(jEdit.getActiveView(),file.getPath());
				return;
			}
			if (jEdit.openFile(view,file.getPath()) == null)
				Log.log(Log.ERROR,this,""Error opening file."");
		}
	} //}}}
	//{{{ applicationShouldHandleReopen() method
	public boolean applicationShouldHandleReopen(NSApplication theApplication, boolean flag)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if (jEdit.getViewCount() == 0)
					new NewViewAction().doAction();
			}
		});
		return false;
	} //}}}
	//{{{ applicationShouldTerminate() method
	public boolean applicationShouldTerminate(NSApplication sender)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				jEdit.exit(jEdit.getActiveView(),true);
			}
		});
		return false;
	}
	//}}}
	//}}}
	//{{{ Services
	//{{{ openFile() method
	public String openFile(NSPasteboard pboard, String userData)
	{
		if (jEdit.getViewCount() == 0)
			return null;
		NSData data = pboard.dataForType(""NSFilenamesPboardType"");
		String[] error = new String[1];
		int[] format = new int[1];
		NSArray filenames = (NSArray)NSPropertyListSerialization.propertyListFromData(data,
			NSPropertyListSerialization.PropertyListImmutable,
			format,
			error);
		int count = filenames.count();
		for (int i=0; i<count; i++)
		{
			File file = new File((String)filenames.objectAtIndex(i));
			if (file.isDirectory())
				VFSBrowser.browseDirectory(jEdit.getActiveView(),file.getPath());
			else
				jEdit.openFile(jEdit.getActiveView(),file.getPath());
		}
		return null;
	} //}}}
	//{{{ insertSelection() method
	public String insertSelection(NSPasteboard pboard, String userData)
	{
		String string = pboard.stringForType(""NSStringPboardType"");
		if (jEdit.getViewCount() > 0)
		{
			View view = jEdit.getActiveView();
			view.getBuffer().insert(view.getTextArea().getCaretPosition(),string);
		}
		return null;
	} //}}}
	//{{{ openSelection() method
	public String openSelection(NSPasteboard pboard, String userData)
	{
		String string = pboard.stringForType(""NSStringPboardType"");
		if (jEdit.getViewCount() == 0)
			new NewViewAction().doAction();
		jEdit.newFile(jEdit.getActiveView()).insert(0,pboard.stringForType(""NSStringPboardType""));
		return null;
	} //}}}
	//}}}
	//{{{ Dock Menu
	//{{{ BufferMenu class
	class BufferMenu extends NSMenu
	{
		public BufferMenu()
		{
			super();
		}
		public void updateMenu()
		{
			NSMenuItem item;
			for (int i=0; i<numberOfItems(); i++)
				removeItemAtIndex(0);
			Buffer[] buffs = jEdit.getBuffers();
			for (int i=0; i < buffs.length; i++)
			{
				if (!buffs[i].isUntitled())
				{
					item = new NSMenuItem(buffs[i].getName(),actionSel,"""");
					item.setTarget(new ShowFileAction(buffs[i].getPath()));
					//item.setImage(NSWorkspace.sharedWorkspace().iconForFile(
					//	buffs[i].getPath()));
					if (!new File(buffs[i].getPath()).exists())
						item.setEnabled(false);
					addItem(item);
				}
			}
			if (numberOfItems() == 0)
			{
				item = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.buffers.none""),null,"""");
				item.setEnabled(false);
				addItem(item);
			}
		}
	} //}}}
	//{{{ MacrosMenu class
	class MacrosMenu extends NSMenu
	{
		public MacrosMenu()
		{
			super();
		}
		public void updateMenu()
		{
			Vector macroVector = Macros.getMacroHierarchy();
			NSMenuItem item;
			File file;
			int max = macroVector.size();
			int length = numberOfItems();
			for (int i=0; i<length; i++)
				removeItemAtIndex(0);
			if (max == 0)
			{
				item = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.macros.none""),null,"""");
				item.setEnabled(false);
				addItem(item);
				return;
			}
			createMenu(this,macroVector);
		}
		public void createMenu(NSMenu menu, Vector vector)
		{
			for(int i=0; i < vector.size(); i++)
			{
				Object obj = vector.elementAt(i);
				if(obj instanceof Macros.Macro)
				{
					Macros.Macro macro = (Macros.Macro)obj;
					NSMenuItem item = new NSMenuItem(macro.getLabel(),actionSel,"""");
					item.setTarget(new MacroAction(macro));
					menu.addItem(item);
				}
				else if(obj instanceof Vector)
				{
					Vector subvector = (Vector)obj;
					String name = (String)subvector.elementAt(0);
					NSMenu submenu = new NSMenu();
					createMenu(submenu,subvector);
					if(submenu.numberOfItems() > 0)
					{
						NSMenuItem submenuitem = new NSMenuItem(name,null,"""");
						submenuitem.setSubmenu(submenu);
						menu.addItem(submenuitem);
					}
				}
			}
		}
	} //}}}
	//{{{ RecentMenu class
	class RecentMenu extends NSMenu
	{
		public RecentMenu()
		{
			super();
		}
		public void updateMenu()
		{
			List recent = BufferHistory.getHistory();
			NSMenuItem item;
			File file;
			int max = recent.size();
			int min = max - 20;
			int length = numberOfItems();
			for (int i=0; i<length; i++)
				removeItemAtIndex(0);
			if (max == 0)
			{
				item = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.recent.none""),null,"""");
				item.setEnabled(false);
				addItem(item);
				return;
			}
			if (min < 0)
				min = 0;
			for (int i=max-1; i >= min ; i--)
			{
				file = new File(((BufferHistory.Entry)recent.get(i)).path);
				item = new NSMenuItem(file.getName(),actionSel,"""");
				item.setTarget(new ShowFileAction(file.getPath()));
				if (!file.exists())
					item.setEnabled(false);
				addItem(item);
			}
		}
	} //}}}
	//{{{ RecentDirMenu class
	class RecentDirMenu extends NSMenu
	{
		public RecentDirMenu()
		{
			super();
		}
		public void updateMenu()
		{
			HistoryModel model = HistoryModel.getModel(""vfs.browser.path"");
			NSMenuItem item;
			File file;
			int max = model.getSize();
			int length = numberOfItems();
			for (int i=0; i<length; i++)
				removeItemAtIndex(0);
			if (max == 0)
			{
				item = new NSMenuItem(jEdit.getProperty(""MacOSPlugin.menu.recentDir.none""),null,"""");
				item.setEnabled(false);
				addItem(item);
				return;
			}
			for (int i=0; i < max ; i++)
			{
				file = new File(model.getItem(i));
				item = new NSMenuItem(file.getName(),actionSel,"""");
				item.setTarget(new ShowFileAction(file.getPath()));
				if (!file.exists())
					item.setEnabled(false);
				addItem(item);
			}
		}
	} //}}}
	//{{{ MacroAction class
	class MacroAction
	{
		private Macros.Macro macro;
		public MacroAction(Macros.Macro macro)
		{
			this.macro = macro;
		}
		public void doAction()
		{
			macro.invoke(jEdit.getActiveView());
		}
	} //}}}
	//{{{ NewViewAction class
	class NewViewAction
	{
		public void doAction()
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if (jEdit.getViewCount() == 0)
						PerspectiveManager.loadPerspective(true);
					else
						jEdit.newView(jEdit.getActiveView());
				}
			});
		}
	} //}}}
	//{{{ ShowFileAction class
	class ShowFileAction
	{
		private String path;
		public ShowFileAction(String path)
		{
			this.path = path;
		}
		public void doAction()
		{
			MacOSActions.showInFinder(path);
		}
	} //}}}
	//}}}
}
"
jars.MacOS.macos.MacOSActions,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * MacOSActions.java
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos;
//{{{ Imports
import java.io.*;
import javax.swing.*;
import com.apple.cocoa.application.*;
import com.apple.cocoa.foundation.*;
import org.gjt.sp.jedit.*;
//}}}
public class MacOSActions
{
	//{{{ showInFinder() method
	public static void showInFinder(String path)
	{
		if (new File(path).exists())
		{
			//Remember to make this an option later
			//NSApplication.sharedApplication().hide(jEdit.getPlugin(""MacOSPlugin""));
			NSWorkspace.sharedWorkspace().selectFile(path,path);
		}
	} //}}}
	//{{{ runScript() method
	public static void runScript(String path)
	{			
		new ScriptRunner(path).start();
		//SwingUtilities.invokeLater(new ScriptRunner(path));
	} //}}}
	//{{{ ScriptRunner class
	static class ScriptRunner extends Thread
	{
		private String path;
		public ScriptRunner(String path)
		{
			this.path = path;
		}
		public void run()
		{
			File file = new File(path);
			if (file.exists())
			{
				try {
					BufferedReader reader = new BufferedReader(new FileReader(file));
					StringBuffer code = new StringBuffer();
					String line;
					while ((line = reader.readLine()) != null)
						code.append(line+""\n"");
					NSAppleScript script = new NSAppleScript(code.toString());
					NSMutableDictionary compileErrInfo = new NSMutableDictionary();
					NSMutableDictionary execErrInfo = new NSMutableDictionary();
					if (script.compile(compileErrInfo))
					{
						if (script.execute(execErrInfo) == null)
						{
							JOptionPane.showMessageDialog(null,
								execErrInfo.objectForKey(""NSAppleScriptErrorBriefMessage""),
								jEdit.getProperty(""MacOSPlugin.dialog.script.title""),
								JOptionPane.ERROR_MESSAGE);
						}
					}
					else
					{
						JOptionPane.showMessageDialog(null,
							compileErrInfo.objectForKey(""NSAppleScriptErrorBriefMessage""),
							jEdit.getProperty(""MacOSPlugin.dialog.script.title""),
							JOptionPane.ERROR_MESSAGE);
					}
				} catch (Exception ex) {}
			}
		}
	} //}}}
}
"
jars.MacOS.macos.MacOSOptionPane,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * MacOSOptionPane.java - options pane for Mac OS Plugin
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos;
//{{{ Imports
import java.awt.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
//}}}
public class MacOSOptionPane extends AbstractOptionPane
{
	//{{{ Variables
	private JCheckBox menuBox;
	private JCheckBox preserveBox;
	private JCheckBox selectionBox;
	//}}}
	//{{{ Constructor
	public MacOSOptionPane()
	{
		super(""MacOSPlugin"");
	}//}}}
	//{{{ _init() method
	public void _init()
	{
		Dimension d = new Dimension(7,7);
		Dimension d_2 = new Dimension(20,20);
		menuBox = new JCheckBox(jEdit.getProperty(""options.MacOSPlugin.menubar.label""));
		addComponent(menuBox);
		addComponent(new JLabel(""(Requires restart for changes to take effect)""));
		addComponent(new Box.Filler(d,d,d));
		preserveBox = new JCheckBox(jEdit.getProperty(""options.MacOSPlugin.preserve.label""));
		addComponent(preserveBox);
		addComponent(new Box.Filler(d,d,d));
		selectionBox = new JCheckBox(jEdit.getProperty(""options.MacOSPlugin.useSelection.label""));
		addComponent(selectionBox);
		getSettings();
	}//}}}
	//{{{ _save() method
	public void _save()
	{
		jEdit.setBooleanProperty(""MacOSPlugin.useScreenMenuBar"", menuBox.isSelected());
		jEdit.setBooleanProperty(""MacOSPlugin.preserveCodes"", preserveBox.isSelected());
		jEdit.setBooleanProperty(""MacOSPlugin.useSelection"", selectionBox.isSelected());
	}//}}}
	//{{{ getSettings() method
	public void getSettings()
	{
		menuBox.setSelected(jEdit.getBooleanProperty(""MacOSPlugin.useScreenMenuBar"",
			jEdit.getBooleanProperty(""MacOSPlugin.default.useScreenMenuBar"")));
		preserveBox.setSelected(jEdit.getBooleanProperty(""MacOSPlugin.preserveCodes"",
			jEdit.getBooleanProperty(""MacOSPlugin.default.preserveCodes"")));
		selectionBox.setSelected(jEdit.getBooleanProperty(""MacOSPlugin.useSelection"",
			jEdit.getBooleanProperty(""MacOSPlugin.default.useSelection"")));
	}//}}}
}
"
jars.MacOS.macos.MacOSPlugin,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * MacOSPlugin.java - Main class Mac OS Plugin
 * Copyright (C) 2001, 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos;
//{{{ Imports
import java.util.Vector;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.util.Log;
import macos.menu.*;
import macos.script.*;
import com.apple.cocoa.application.*;
import com.apple.eawt.Application;
//}}}
public class MacOSPlugin extends EBPlugin
{
	//{{{ Variables
	static boolean started = false;
	private boolean osok;
	private Delegate delegate;
	//}}}
	//{{{ start() method
	public void start()
	{
		if(osok = osok())
		{
			delegate = new Delegate();
			NSApplication app = NSApplication.sharedApplication();
			Macros.registerHandler(new AppleScriptHandler());
			Application app2 = new Application();
			app2.addApplicationListener(delegate);
			app2.setEnabledPreferencesMenu(true);
			app2.setEnabledAboutMenu(true);
			app.setDelegate(delegate);
			//app.setServicesProvider(delegate);
		}
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage message)
	{
		if (osok)
		{
			// Set type/creator codes for files
			if (message instanceof BufferUpdate)
				delegate.handleFileCodes((BufferUpdate)message);
			else if (message instanceof PropertiesChanged)
			{
				boolean b = jEdit.getBooleanProperty(""MacOSPlugin.useSelection"",
					jEdit.getBooleanProperty(""MacOSPlugin.default.useSelection""));
				if (b)
					jEdit.setColorProperty(""view.selectionColor"",
						UIManager.getColor(""textHighlight""));
			}
			// This is necessary to have a file opened from the Finder
			// before jEdit is running set as the currently active
			// buffer.
			else if (!started && message instanceof ViewUpdate)
				delegate.handleOpenFile((ViewUpdate)message);
		}
	}//}}}
	//{{{ osok() method
	private boolean osok()
	{
		final String osname = jEdit.getProperty(""MacOSPlugin.depend.os.name"");
		final String mrjversion = jEdit.getProperty(""MacOSPlugin.depend.mrj.version"");
		if (!System.getProperty(""os.name"").equals(osname))
		{
			// According to Slava this is better
			Log.log(Log.ERROR,this,jEdit.getProperty(""MacOSPlugin.dialog.osname.message""));
			return false;
		}
		if (MiscUtilities.compareStrings(
			System.getProperty(""mrj.version""),mrjversion,false) < 0)
		{
			SwingUtilities.invokeLater( new Runnable() { public void run() {
				GUIUtilities.error(null,""MacOSPlugin.dialog.mrjversion"",new Object[] {mrjversion});
			}});
			return false;
		}
		return true;
	}//}}}
}
"
jars.MacOS.macos.menu.MacOSMenu,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * MacOSMenu.java - Menu providing features for Mac OS
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos.menu;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import javax.swing.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.menu.*;
import org.gjt.sp.util.Log;
import macos.*;
//}}}
public class MacOSMenu implements DynamicMenuProvider
{	
	//{{{ Constructor
	public MacOSMenu()
	{
		//super();
	} //}}}
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return true;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		File buff = new File(jEdit.getActiveView().getBuffer().getPath());
		JMenuItem showCurrent = new JMenuItem(
			jEdit.getProperty(""MacOSPlugin.menu.showCurrent""));
		showCurrent.addActionListener(new ShowFileAction(buff.getPath()));
		showCurrent.setEnabled(buff.exists());
		JMenuItem showCurrentDir = new JMenuItem(
			jEdit.getProperty(""MacOSPlugin.menu.showCurrentDir""));
		showCurrentDir.addActionListener(new ShowDirAction(buff.getParent()));
		showCurrent.setEnabled(buff.getParentFile().exists());
		menu.add(showCurrent);
		menu.add(showCurrentDir);
		menu.addSeparator();
		menu.add(new ShowBufferMenu());
		menu.add(new ShowRecentMenu());
		menu.add(new ShowRecentDirMenu());
	} //}}}
	//{{{ ShowFileAction class
	class ShowFileAction implements ActionListener
	{
		private String path;
		public ShowFileAction(String path)
		{
			this.path = path;
		}
		public void actionPerformed(ActionEvent e)
		{
			MacOSActions.showInFinder(path);
		}
	} //}}}
	//{{{ ShowDirAction class
	class ShowDirAction implements ActionListener
	{
		private String path;
		public ShowDirAction(String path)
		{
			this.path = path;
		}
		public void actionPerformed(ActionEvent e)
		{
			MacOSActions.showInFinder(path);
		}
	} //}}}
}
"
jars.MacOS.macos.menu.ShowBufferMenu,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * ShowBufferMenu.java
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos.menu;
//{{{ Imports
import java.awt.event.*;
import java.io.File;
import javax.swing.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.*;
import macos.*;
//}}}
public class ShowBufferMenu extends JMenu implements MenuListener
{
	//{{{ Constructor
	public ShowBufferMenu()
	{
		super(jEdit.getProperty(""MacOSPlugin.menu.buffers.label""));
		addMenuListener(this);
	} //}}}
	//{{{ construct() method
	private void construct()
	{
		JMenuItem item;
		removeAll();
		Buffer[] buffs = jEdit.getBuffers();
		for (int i=0; i < buffs.length; i++)
		{
			if (!buffs[i].isUntitled())
			{
				item = add(new ShowBufferMenuItem(
					buffs[i].getName(),buffs[i].getPath()));
				item.setIcon(FileCellRenderer.fileIcon);
				add(item);
			}
		}
		if (getItemCount() == 0)
		{
			item = new JMenuItem(jEdit.getProperty(""MacOSPlugin.menu.buffers.none""));
			item.setEnabled(false);
			add(item);
		}
	} //}}}
	//{{{ menuSelected() method
	public void menuSelected(MenuEvent e)
	{
		construct();
	} //}}}
	//{{{ menuDeselected() method
	public void menuDeselected(MenuEvent e)
	{
	} //}}}
	//{{{ menuCanceled() method
	public void menuCanceled(MenuEvent e)
	{
	} //}}}
	//{{{ ShowBufferMenuItem class
	class ShowBufferMenuItem extends JMenuItem
	{
		String path;
		public ShowBufferMenuItem(String name, String path)
		{
			super(name);
			this.path = path;
			addActionListener(new ShowFileAction());
		}
		class ShowFileAction implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				MacOSActions.showInFinder(path);
			}
		}
	} //}}}
}
"
jars.MacOS.macos.menu.ShowRecentDirMenu,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * ShowRecentDirMenu.java
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos.menu;
//{{{ Imports
import java.awt.event.*;
import java.io.File;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import macos.*;
//}}}
public class ShowRecentDirMenu extends JMenu implements MenuListener
{
	//{{{ Constructor
	public ShowRecentDirMenu()
	{
		super(jEdit.getProperty(""MacOSPlugin.menu.recentDir.label""));
		addMenuListener(this);
	} //}}}
	//{{{ construct() method
	private void construct()
	{
		HistoryModel model = HistoryModel.getModel(""vfs.browser.path"");
		JMenuItem item;
		File file;
		int max = model.getSize();
		if (max == 0)
		{
			item = new JMenuItem(jEdit.getProperty(""MacOSPlugin.menu.recentDir.none""));
			item.setEnabled(false);
			add(item);
			return;
		}
		for (int i=0; i < max ; i++)
		{
			file = new File(model.getItem(i));
			item = new ShowRecentDirMenuItem(file.getName(),file.getPath());
			item.setIcon(FileCellRenderer.dirIcon);
			add(item);
		}
	} //}}}
	//{{{ menuSelected() method
	public void menuSelected(MenuEvent e)
	{
		construct();
	} //}}}
	//{{{ menuDeselected() method
	public void menuDeselected(MenuEvent e)
	{
		removeAll();
	} //}}}
	//{{{ menuCanceled() method
	public void menuCanceled(MenuEvent e)
	{
	} //}}}
	//{{{ ShowRecentDirMenuItem class
	class ShowRecentDirMenuItem extends JMenuItem
	{
		String path;
		public ShowRecentDirMenuItem(String name, String path)
		{
			super(name);
			this.path = path;
			addActionListener(new ShowFileAction());
		}
		class ShowFileAction implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				MacOSActions.showInFinder(path);
			}
		}
	} //}}}
}
"
jars.MacOS.macos.menu.ShowRecentMenu,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * ShowRecentMenu.java
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos.menu;
//{{{ Imports
import java.awt.event.*;
import java.io.File;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.browser.*;
import macos.*;
//}}}
public class ShowRecentMenu extends JMenu implements MenuListener
{
	//{{{ Constructor
	public ShowRecentMenu()
	{
		super(jEdit.getProperty(""MacOSPlugin.menu.recent.label""));
		addMenuListener(this);
	} //}}}
	//{{{ construct() method
	private void construct()
	{
		List recent = BufferHistory.getHistory();
		JMenuItem item;
		File file;
		int max = recent.size();
		int min = max - 20;
		if (max == 0)
		{
			item = new JMenuItem(jEdit.getProperty(""MacOSPlugin.menu.recent.none""));
			item.setEnabled(false);
			add(item);
			return;
		}
		if (min < 0)
			min = 0;
		for (int i=max-1; i >= min ; i--)
		{
			file = new File(((BufferHistory.Entry)recent.get(i)).path);
			item = new ShowRecentMenuItem(file.getName(),file.getPath());
			item.setIcon(FileCellRenderer.fileIcon);
			add(item);
		}
	} //}}}
	//{{{ menuSelected() method
	public void menuSelected(MenuEvent e)
	{
		construct();
	} //}}}
	//{{{ menuDeselected() method
	public void menuDeselected(MenuEvent e)
	{
		removeAll();
	} //}}}
	//{{{ menuCanceled() method
	public void menuCanceled(MenuEvent e)
	{
	} //}}}
	//{{{ ShowRecentMenuItem class
	class ShowRecentMenuItem extends JMenuItem
	{
		String path;
		public ShowRecentMenuItem(String name, String path)
		{
			super(name);
			this.path = path;
			addActionListener(new ShowFileAction());
		}
		class ShowFileAction implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				MacOSActions.showInFinder(path);
			}
		}
	} //}}}
}
"
jars.MacOS.macos.script.AppleScriptHandler,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * AppleScriptHandler.java
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos.script;
//{{{ Imports
import java.io.*;
import org.gjt.sp.jedit.*;
import macos.*;
//}}}
public class AppleScriptHandler extends Macros.Handler
{
	//{{{ accept() method
	public boolean accept(String path)
	{
		return ffilter.accept(new File(path));
	} //}}}
	//{{{ createMacro() method
	public Macros.Macro createMacro(String macroName, String path)
	{
		if (macroName.toLowerCase().endsWith("".scpt""))
			macroName = macroName.substring(0, macroName.length() - 5);
		else if (macroName.toLowerCase().endsWith("".applescript""))
			macroName = macroName.substring(0, macroName.length() - 12);
		return new Macros.Macro(this,macroName,
			Macros.Macro.macroNameToLabel(macroName),path);
	} //}}}
	//{{{ runMacro() method
	public void runMacro(View view, Macros.Macro macro)
	{
		MacOSActions.runScript(macro.getPath());
	}
	//}}}
	//{{{ runMacro() method
	public void runMacro(View view, Macros.Macro macro, boolean ownNamespace)
	{
		runMacro(view,macro);
	} //}}}
	//{{{ Handler constructor
	public AppleScriptHandler()
	{
		super(""applescript"");
		ffilter = new ScriptFilter();
	} //}}}
	//{{{ Private members
	private FileFilter ffilter;
	//}}}
}
"
jars.MacOS.macos.script.ScriptFilter,"/* 
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * ScriptFilter.java
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package macos.script;
//{{{ Imports
import java.io.*;
//}}}
public class ScriptFilter implements FileFilter
{
	//{{{ accept() method
	public boolean accept(File pathname)
	{
		if (pathname.getName().endsWith("".scpt""))
			return true;
		if (pathname.getName().endsWith("".applescript""))
			return true;
		// Replace this is Cocoa API calls later
		/*try
		{
			MRJOSType type = MRJFileUtils.getFileType(pathname);
			MRJOSType creator = MRJFileUtils.getFileCreator(pathname);
			if (type.equals(new MRJOSType(""osas"")))
				return true;
			else if (type.equals(new MRJOSType(""APPL"")) && creator.equals(new MRJOSType(""dplt"")))
				return true;
		}
		catch (Exception e)
		{
			return false;
		}*/
		return false;
	} //}}}
}
"
jars.QuickNotepad.QuickNotepad,"/*
 * QuickNotepad.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: QuickNotepad.java,v 1.8 2004/04/30 20:23:08 spestov Exp $
 */
// from Java:
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.Vector;
// from Swing:
import javax.swing.*;
import javax.swing.event.*;
// from jEdit:
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.util.Log;
public class QuickNotepad extends JPanel implements EBComponent, QuickNotepadActions, DefaultFocusComponent
{
	private String filename;
	private String defaultFilename;
	private View view;
	private boolean floating;
	private QuickNotepadTextArea textArea;
	private QuickNotepadToolPanel toolPanel;
	//
	// Constructor
	//
	public QuickNotepad(View view, String position)
	{
		super(new BorderLayout());
		this.view = view;
		this.floating  = position.equals(DockableWindowManager.FLOATING);
		if(jEdit.getSettingsDirectory() != null)
		{
			this.filename = jEdit.getProperty(
				QuickNotepadPlugin.OPTION_PREFIX + ""filepath"");
			if(this.filename == null || this.filename.length() == 0)
			{
				this.filename = new String(jEdit.getSettingsDirectory()
					+ File.separator + ""qn.txt"");
				jEdit.setProperty(
					QuickNotepadPlugin.OPTION_PREFIX + ""filepath"",
					this.filename);
			}
			this.defaultFilename = this.filename;
		}
		this.toolPanel = new QuickNotepadToolPanel(this);
		add(BorderLayout.NORTH, this.toolPanel);
		if(floating)
			this.setPreferredSize(new Dimension(500, 250));
		textArea = new QuickNotepadTextArea();
		textArea.setFont(QuickNotepadOptionPane.makeFont());
		textArea.addKeyListener(new KeyHandler());
		JScrollPane pane = new JScrollPane(textArea);
		add(BorderLayout.CENTER, pane);
		readFile();
	}
	public void focusOnDefaultComponent()
	{
		textArea.requestFocus();
	}
	//
	// Attribute methods
	//
	// for toolbar display
	public String getFilename()
	{
		return filename;
	}
	//
	// EBComponent implementation
	//
	public void handleMessage(EBMessage message)
	{
		if (message instanceof PropertiesChanged)
		{
			propertiesChanged();
		}
	}
	private void propertiesChanged()
	{
		String propertyFilename = jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""filepath"");
		if(!MiscUtilities.objectsEqual(defaultFilename,propertyFilename))
		{
			saveFile();
			toolPanel.propertiesChanged();
			defaultFilename = propertyFilename;
			filename = defaultFilename;
			readFile();
		}
		Font newFont = QuickNotepadOptionPane.makeFont();
		if(!newFont.equals(textArea.getFont()))
		{
			textArea.setFont(newFont);
		}
	}
	// These JComponent methods provide the appropriate points
	// to subscribe and unsubscribe this object to the EditBus
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}
	public void removeNotify()
	{
		saveFile();
		super.removeNotify();
		EditBus.removeFromBus(this);
	}
	//
	// QuickNotepadActions implementation
	//
	public void saveFile()
	{
		if(filename == null || filename.length() == 0) return;
		try
		{
			FileWriter out = new FileWriter(filename);
			out.write(textArea.getText());
			out.close();
		}
		catch (IOException ioe)
		{
			Log.log(Log.ERROR, QuickNotepad.class,
				""Could not write notepad text to "" + filename);
		}
	}
	public void chooseFile()
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,false);
		if(paths != null && !paths[0].equals(filename))
		{
			saveFile();
			filename = paths[0];
			toolPanel.propertiesChanged();
			readFile();
		}
	}
	public void copyToBuffer()
	{
		jEdit.newFile(view);
		view.getEditPane().getTextArea().setText(textArea.getText());
	}
	//
	// helper methods
	//
	private void readFile()
	{
		if(filename == null || filename.length() == 0) return;
		BufferedReader bf = null;
		try
		{
			bf = new BufferedReader(new FileReader(filename));
			StringBuffer sb = new StringBuffer(2048);
			String str;
			while((str = bf.readLine()) != null)
			{
				sb.append(str).append('\n');
			}
			bf.close();
			textArea.setText(sb.toString());
		}
		catch (FileNotFoundException fnf)
		{
			Log.log(Log.ERROR, QuickNotepad.class,
				""notepad file "" + filename + "" does not exist"");
		}
		catch (IOException ioe)
		{
			Log.log(Log.ERROR, QuickNotepad.class,
				""could not read notepad file "" + filename);
		}
	}
	//
	// Listener objects
	//
	// <Esc> closes a floating window
	private class KeyHandler extends KeyAdapter {
		public void keyPressed(KeyEvent evt) {
			if(QuickNotepad.this.floating &&
				evt.getKeyCode() == KeyEvent.VK_ESCAPE) {
				evt.consume();
				DockableWindowManager wm =
					QuickNotepad.this.view.getDockableWindowManager();
				wm.removeDockableWindow(QuickNotepadPlugin.NAME);
			}
		}
	}
}
"
jars.QuickNotepad.QuickNotepadActions,"/*
 * QuickNotepadActions.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: QuickNotepadActions.java,v 1.2 2001/11/09 20:26:17 jgellene Exp $
 */
interface QuickNotepadActions
{
	void chooseFile();
	void saveFile();
	void copyToBuffer();
}
"
jars.QuickNotepad.QuickNotepadOptionPane,"/*
 * QuickNotepadOptionPane.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: QuickNotepadOptionPane.java,v 1.3 2001/11/11 12:26:20 jgellene Exp $
 */
import java.io.File;
import java.io.IOException;
import java.awt.Font;
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.JFileChooser;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.gui.FontSelector;
public class QuickNotepadOptionPane extends AbstractOptionPane
			implements ActionListener
{
	private JCheckBox showPath;
	private JTextField pathName;
	private FontSelector font;
	public QuickNotepadOptionPane()
	{
		super(QuickNotepadPlugin.NAME);
	}
	public void _init()
	{
		showPath = new JCheckBox(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath.title""),
			jEdit.getProperty(QuickNotepadPlugin.OPTION_PREFIX +
				""show-filepath"").equals(""true""));
		addComponent(showPath);
		pathName = new JTextField(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""filepath""));
		JButton pickPath = new JButton(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""choose-file""));
		pickPath.addActionListener(this);
		JPanel pathPanel = new JPanel(new BorderLayout(0, 0));
		pathPanel.add(pathName, BorderLayout.CENTER);
		pathPanel.add(pickPath, BorderLayout.EAST);
		addComponent(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""file""),
			pathPanel);
		font = new FontSelector(makeFont());
		addComponent(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""choose-font""),
			font);
	}
	public void _save()
	{
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""filepath"",
			pathName.getText());
		Font _font = font.getFont();
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""font"",
			_font.getFamily());
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""fontsize"",
			String.valueOf(_font.getSize()));
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""fontstyle"",
			String.valueOf(_font.getStyle()));
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath"",
			String.valueOf(showPath.isSelected()));
	}
	// end AbstractOptionPane implementation
	// begin ActionListener implementation
	public void actionPerformed(ActionEvent evt)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(null,
			null,JFileChooser.OPEN_DIALOG,false);
		if(paths != null)
		{
			pathName.setText(paths[0]);
		}
	}
	// helper method to get Font from plugin properties
	static public Font makeFont()
	{
		int style, size;
		String family = jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""font"");
		try
		{
			size = Integer.parseInt(jEdit.getProperty(
				QuickNotepadPlugin.OPTION_PREFIX + ""fontsize""));
		}
		catch(NumberFormatException nf)
		{
			size = 14;
		}
		try
		{
			style = Integer.parseInt(jEdit.getProperty(
				QuickNotepadPlugin.OPTION_PREFIX + ""fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			style = Font.PLAIN;
		}
		return new Font(family, style, size);
	}
}
"
jars.QuickNotepad.QuickNotepadPlugin,"/*
 * QuickNotepadPlugin.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: QuickNotepadPlugin.java,v 1.7 2003/04/30 05:28:54 spestov Exp $
 */
import org.gjt.sp.jedit.EditPlugin;
/**
 * The QuickNotepad plugin
 *
 * @author John Gellene
 */
public class QuickNotepadPlugin extends EditPlugin
{
	public static final String NAME = ""quicknotepad"";
	public static final String OPTION_PREFIX = ""options.quicknotepad."";
}
"
jars.QuickNotepad.QuickNotepadTextArea,"/*
 * QuickNotepadTextArea.java
 * part of the QuickNotepad plugin for the jEditTextArea
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: QuickNotepadTextArea.java,v 1.2 2001/11/09 20:26:17 jgellene Exp $
 */
import javax.swing.JTextArea;
public class QuickNotepadTextArea extends JTextArea
{
 	public QuickNotepadTextArea()
 	{
		super();
	 	setLineWrap(true);
	 	setWrapStyleWord(true);
	 	setTabSize(4);
 	}
}
"
jars.QuickNotepad.QuickNotepadToolPanel,"/*
 * QuickNotepadToolPanel.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: QuickNotepadToolPanel.java,v 1.4 2003/05/29 19:02:55 spestov Exp $
 */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;
public class QuickNotepadToolPanel extends JPanel
{
	private QuickNotepad pad;
	private JLabel label;
	public QuickNotepadToolPanel(QuickNotepad qnpad)
	{
		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
		pad = qnpad;
		Box labelBox = new Box(BoxLayout.Y_AXIS);
		labelBox.add(Box.createGlue());
		label = new JLabel(pad.getFilename());
		label.setVisible(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath"").equals(""true""));
		labelBox.add(label);
		labelBox.add(Box.createGlue());
		add(labelBox);
		add(Box.createGlue());
		add(makeCustomButton(""quicknotepad.choose-file"",
			new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					QuickNotepadToolPanel.this.pad.chooseFile();
				}
			}));
		add(makeCustomButton(""quicknotepad.save-file"",
			new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					QuickNotepadToolPanel.this.pad.saveFile();
				}
			}));
		add(makeCustomButton(""quicknotepad.copy-to-buffer"",
			new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					QuickNotepadToolPanel.this.pad.copyToBuffer();
				}
			}));
	}
	void propertiesChanged()
	{
		label.setText(pad.getFilename());
		label.setVisible(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath"").equals(""true""));
	}
	private AbstractButton makeCustomButton(String name, ActionListener listener)
	{
		String toolTip = jEdit.getProperty(name.concat("".label""));
		AbstractButton b = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(name + "".icon"")));
		if(listener != null)
		{
			b.addActionListener(listener);
			b.setEnabled(true);
		}
		else
		{
			b.setEnabled(false);
		}
		b.setToolTipText(toolTip);
		return b;
	}
}
"
jeditshell.jcmd.JcmdProcess,"/*
 * JcmdProcess.java - A Java class wrapping the jcmd.exe utility for
 * Windows; the utility is a command interpreter for use with the Java's
 * platform Runtime.exec, designed to prevent the display of console
 * windows when executing console-based programs
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the jEdit program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
/**
 * A wrapper class for the <code>jcmd</code> command interpreter for Windows.
 * @author John Gellene
 * @version $Id: JcmdProcess.java,v 1.8 2001/09/16 22:57:42 jgellene Exp $
 * <p>
 * <b>Note:</b> this class is currently under development and has not
 * been fully tested.
 */
public class JcmdProcess extends Process
{
	private String jcmdDirectory;
	private Process jcmdProcess = null;
	private Integer returnValue = null;
	static private final int CTRL_C = 3;
	/**
	 * Constructs a <code>JcmdProcess</code> object.
	 * @param jcmdDirectory The directory in which <code>jcmd.exe</code>
	 * is located.
	 * <br>
	 * A <code>null</code> parameter indicates that <code>jcmd.exe</code> should
	 * be found in the current working directory of the JVM's process.
	 */
	protected JcmdProcess(String jcmdDirectory)
	{
		this.jcmdDirectory = jcmdDirectory;
	}
	/**
	 * Executes the <code>jcmd</code> command interpreter on a given command line.
	 * @param cmdLine The full command line to be passed to the interpreter.
	 * @param cwd The current working directory for the interpreter process.
	 * <br>
	 * <b>Note:</b> In this version use of the <code>cwd</code> parameter is not
	 * implemented.
	 * @throws IOException The exception thrown by the call to
	 * <code>Runtime.exec</code> that starts <code>jcmd</code>.
	 */
	static public JcmdProcess exec(String cmdLine, String cwd) throws IOException
	{
		return exec(cmdLine, cwd, null);
	}
	/**
	 * Executes the <code>jcmd</code> command interpreter on a given command line.
	 * @param cmdLine The full command line to be passed to the interpreter.
	 * @param cwd The current working directory for the interpreter process.
	 * <br>
	 * <b>Note:</b> In this version use of the <code>cwd</code> parameter is not
	 * implemented.
	 * @param jcmdDir The directory in which the <code>jcmd</code> interpreter
	 * may be found.
	 * <br>
	 * If the <code>jcmdDir</code> parameter is <code>null</code>, the current
	 * working directory of the JVM's process will be used as the location of
	 * <code>jcmd</code>.
	 * @throws IOException The exception thrown by the call to
	 * <code>Runtime.exec</code> that starts <code>jcmd</code>.
	 */
	static public JcmdProcess exec(String cmdLine, String cwd, String jcmdDir)
		throws IOException
	{
		JcmdProcess jp = new JcmdProcess(jcmdDir);
		// cwd not implemented in this version
		jp.doExec(cmdLine);
		return jp;
	}
	/**
	 * Destroys the process in which the command interpreter is running.
	 * <p>
	 * To terminate jcmd and any running child process in an orderly fashion,
	 * use <code>sendBreak</code>.
	 * @see sendBreak
	 */
	public void destroy()
	{
		if(jcmdProcess != null)
		{
			jcmdProcess.destroy();
		}
	}
	/**
	 * Terminates the <code>jcmd</code> process by sending it a Ctrl+C character.
	 * <p>
	 * Using <code>sendBreak</code> instead of <code>destroy</code> will
	 * cause <code>jcmd</code> to terminate any running child process.
	 * @throws IOException any exception thrown by call to
	 * <code>OutputStream.write</code>.
	 */
	public void sendBreak() throws IOException
	{
		String testString = new String(""\003"");
		byte[] bytes = testString.getBytes();
		if(jcmdProcess != null)
		{
			OutputStream os = jcmdProcess.getOutputStream();
			os.write(bytes);
			os.flush();
		}
	}
	/**
	 * Returns the exit value of the command executed by <code>jcmd</code>.
	 * @return The exit value of the command executed by <code>jcmd</code>,
	 * or -1 if the command passed to <code>jcmd</code> cannot be found or
	 * cannot be executed.
	 * <p>
	 * <b>Note:</b> Since a command executed by <code>jcmd</code> may itself
	 * return -1, this return value is ambiguous.  Use <code>hasLaunched</code>
	 * to test whether a command was launched successfully by <code>jcmd</code>.
	 * @see hasLaunched
	 */
	public int exitValue()
	{
		if(returnValue == null)
		{
			int rawReturnValue = -1;
			if(jcmdProcess != null)
			{
				rawReturnValue = jcmdProcess.exitValue();
			}
			returnValue = new Integer(rawReturnValue);
		}
		return returnValue.intValue();
	}
	/**
	 * Returns the error stream of the process launched by <code>jcmd</code>.
	 * @return An <code>InputStream</code> representing the error stream
	 * of both <code>jcmd</code> (for purposes of its own error messages)
	 * and the process it has launched.
	 */
	public InputStream getErrorStream()
	{
		return jcmdProcess.getErrorStream();
	}
	/**
	 * Returns the input stream of the process launched by <code>jcmd</code>.
	 * @return An <code>InputStream</code> representing the input stream
	 * of both <code>jcmd</code> and the process it has launched.
	 * <p>
	 * Currently, <code>jcmd</code> does not write to this stream, so
	 * the only data in the stream would come from the process launched by
	 * <code>jcmd</code>.
	 */
	public InputStream getInputStream()
	{
		return jcmdProcess.getInputStream();
	}
	/**
	 * Returns the output stream of the process launched by <code>jcmd</code>.
	 * @return An <code>OutputStream</code> representing the output stream
	 * of both <code>jcmd</code> and the process it has launched.
	 * <p>
	 * Currently, <code>jcmd</code> does not process data written to
	 * this stream and does not forward data to the process it launches,
	 * except for command line parameters passed upon launching.
	 */
	public OutputStream getOutputStream()
	{
		return jcmdProcess.getOutputStream();
	}
	/**
	 * Blocks execution until <code>jcmd</code> exits. Returns immediately
	 * if <code>jcmd</code> has already exited.
	 * @return The exit code returned by <code>jcmd</code>.
	 * <br>
	 * If <code>jcmd</code> has successfully launched another process, the
	 * exit code will be that of the launched process, otherwise this
	 * method will return -1.
	 * @throws InterruptedException An exception thrown by the
	 * <code>Process</code> object in which <code>jcmd</code> is running.
	 * @see exitValue
	 * @see hasLaunched
	 */
	public int waitFor() throws InterruptedException
	{
		if(jcmdProcess == null)
		{
			return exitValue();
		}
		return jcmdProcess.waitFor();
	}
	/**
	 * Tests whether or not <code>jcmd</code> has launched a child process.
	 * @return The value <code>true</code> if a process has been launched and
	 * <code>false</code> otherwise.
	 * <p>
	 * This method is more reliable than <code>waitFor</code> or
	 * <code>exitValue</code> to test whether <code>jcmd</code> successfully
	 * launched a process, because some native executables encountering their
	 * own errors will return -1, the exit code indicating an <code>jcmd</code>
	 * launch failure.
	 */
	public boolean hasLaunched()
	{
		return jcmdProcess != null;
	}
	private void doExec(String cmdLine) throws IOException
	{
		StringBuffer cmdBuffer = new StringBuffer(512);
		if(jcmdDirectory != null)
		{
			cmdBuffer.append(jcmdDirectory);
			if(!jcmdDirectory.endsWith(File.separator))
			{
				cmdBuffer.append(File.separator);
			}
		}
		cmdBuffer.append(""jcmd.exe "").append(cmdLine);
		jcmdProcess = Runtime.getRuntime().exec(cmdBuffer.toString());
	}
}
// end JcmdProcess.java
"
jeditshell.jcmd.JcmdProcessTest,"/*
 * JcmdProcessTest.java - A Java class to test the JcmdProcess class.
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the jEdit program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
/**
 * A test routine for the <code>JcmdProcess</code> class.
 * @author John Gellene
 * @version $Id: JcmdProcessTest.java,v 1.3 2001/09/17 21:11:33 jgellene Exp $
 * <br>
 * The class consists solely of a <code>main</code> method.
 */
public class JcmdProcessTest
{
	/**
	 * The main test routine.
	 * @param argv Command line parameters.
	 * <br>
	 * This method expects a conventional command line that will be passed as
	 * a parameter string to the Windows executable <code>jcmd.exe</code>.
	 */
	public static void main(String argv[])
	{
		System.out.println(""Testing JcmdProcess class."");
		String cmdLine = null;
		JcmdProcess process = null;
		/* Get full command line */
		if(argv.length > 0)
		{
			StringBuffer sb = new StringBuffer(argv[0]);
			for(int i = 1; i < argv.length; ++i)
			{
				sb.append(' ').append(argv[i]);
			}
			cmdLine = sb.toString();
			System.out.println(""Command line: "" + cmdLine);
		}
		else
		{
			System.err.println(""No command line provided."");
			System.exit(1);
		}
		try
		{
			process = JcmdProcess.exec(cmdLine, null);
			BufferedReader pInput = new BufferedReader(
										new InputStreamReader(
                						process.getInputStream()));
		    String s = pInput.readLine();
			/* call sendBreak after fixed number of
			 * lines of stdout are read
			 */
			int nRead = 0;
		    while (s != null)
			{
			    System.out.println(s);
				if(++nRead == 5)
					process.sendBreak();
				s = pInput.readLine();
			}
		}
		catch(IOException e)
		{
    		System.err.println(""I/O error: "" + e.toString());
		}
		catch(Exception e)
		{
			System.err.println(""JcmdProcess error: "" + e.toString());
		}
		System.out.println(""Child process exited with code "" +
			String.valueOf(process.exitValue()));
		System.exit(0);
	}
}
// end JcmdProcessTest.java
"
org.gjt.sp.jedit.Abbrevs,"/*
 * Abbrevs.java - Abbreviation manager
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.gui.AddAbbrevDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Abbreviation manager.
 * @author Slava Pestov
 * @version $Id: Abbrevs.java,v 1.15 2004/07/05 18:25:23 spestov Exp $
 */
public class Abbrevs
{
	public static final String ENCODING = ""UTF8"";
	//{{{ getExpandOnInput() method
	/**
	 * Returns if abbreviations should be expanded after the
	 * user finishes typing a word.
	 */
	public static boolean getExpandOnInput()
	{
		return expandOnInput;
	} //}}}
	//{{{ setExpandOnInput() method
	/**
	 * Sets if abbreviations should be expanded after the
	 * user finishes typing a word.
	 * @param expandOnInput If true, typing a non-alphanumeric character
	 * will automatically attempt to expand the current abbrev
	 */
	public static void setExpandOnInput(boolean expandOnInput)
	{
		Abbrevs.expandOnInput = expandOnInput;
	} //}}}
	//{{{ expandAbbrev() method
	/**
	 * Expands the abbrev at the caret position in the specified
	 * view.
	 * @param view The view
	 * @param add If true and abbrev not found, will ask user if
	 * it should be added
	 * @since jEdit 2.6pre4
	 */
	public static boolean expandAbbrev(View view, boolean add)
	{
		//{{{ Figure out some minor things
		Buffer buffer = view.getBuffer();
		JEditTextArea textArea = view.getTextArea();
		if(!buffer.isEditable())
		{
			view.getToolkit().beep();
			return false;
		}
		int line = textArea.getCaretLine();
		int lineStart = buffer.getLineStartOffset(line);
		int caret = textArea.getCaretPosition();
		String lineText = buffer.getLineText(line);
		if(lineText.length() == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		}
		int pos = caret - lineStart;
		if(pos == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		} //}}}
		// we reuse the 'pp' vector to save time
		pp.removeAllElements();
		int wordStart;
		String abbrev;
		//{{{ Handle abbrevs of the form abbrev#pos1#pos2#pos3#...
		if(lineText.charAt(pos-1) == '#')
		{
			wordStart = lineText.indexOf('#');
			wordStart = TextUtilities.findWordStart(lineText,wordStart,
				buffer.getStringProperty(""noWordSep"") + '#');
			abbrev = lineText.substring(wordStart,pos - 1);
			// positional parameters will be inserted where $1, $2, $3, ...
			// occurs in the expansion
			int lastIndex = 0;
			for(int i = 0; i < abbrev.length(); i++)
			{
				if(abbrev.charAt(i) == '#')
				{
					pp.addElement(abbrev.substring(lastIndex,i));
					lastIndex = i + 1;
				}
			}
			pp.addElement(abbrev.substring(lastIndex));
			// the first element of pp is the abbrev itself
			abbrev = (String)pp.elementAt(0);
			pp.removeElementAt(0);
		} //}}}
		//{{{ Handle ordinary abbrevs
		else
		{
			wordStart = TextUtilities.findWordStart(lineText,pos - 1,
				buffer.getStringProperty(""noWordSep""));
			abbrev = lineText.substring(wordStart,pos);
		} //}}}
		Expansion expand = expandAbbrev(buffer.getMode().getName(),
			abbrev,(buffer.getBooleanProperty(""noTabs"") ?
			buffer.getTabSize() : 0),pp);
		//{{{ Maybe show add abbrev dialog
		if(expand == null)
		{
			if(add)
				new AddAbbrevDialog(view,abbrev);
			return false;
		} //}}}
		//{{{ Insert the expansion
		else
		{
			buffer.remove(lineStart + wordStart,
				pos - wordStart);
			int whitespace = buffer.insertIndented(
				lineStart + wordStart,
				expand.text);
			int newlines = countNewlines(expand.text,
				expand.caretPosition);
			if(expand.caretPosition != -1)
			{
				textArea.setCaretPosition(lineStart + wordStart
					+ expand.caretPosition
					+ newlines * whitespace);
			}
			if(expand.posParamCount != pp.size())
			{
				view.getStatus().setMessageAndClear(
					jEdit.getProperty(
					""view.status.incomplete-abbrev"",
					new Integer[] { new Integer(pp.size()),
					new Integer(expand.posParamCount) }));
			}
			return true;
		} //}}}
	} //}}}
	//{{{ getGlobalAbbrevs() method
	/**
	 * Returns the global abbreviation set.
	 * @since jEdit 2.3pre1
	 */
	public static Hashtable getGlobalAbbrevs()
	{
		if(!loaded)
			load();
		return globalAbbrevs;
	} //}}}
	//{{{ setGlobalAbbrevs() method
	/**
	 * Sets the global abbreviation set.
	 * @param globalAbbrevs The new global abbrev set
	 * @since jEdit 2.3pre1
	 */
	public static void setGlobalAbbrevs(Hashtable globalAbbrevs)
	{
		abbrevsChanged = true;
		Abbrevs.globalAbbrevs = globalAbbrevs;
	} //}}}
	//{{{ getModeAbbrevs() method
	/**
	 * Returns the mode-specific abbreviation set.
	 * @since jEdit 2.3pre1
	 */
	public static Hashtable getModeAbbrevs()
	{
		if(!loaded)
			load();
		return modes;
	} //}}}
	//{{{ setModeAbbrevs() method
	/**
	 * Sets the mode-specific abbreviation set.
	 * @param modes The new mode abbrev set
	 * @since jEdit 2.3pre1
	 */
	public static void setModeAbbrevs(Hashtable modes)
	{
		abbrevsChanged = true;
		Abbrevs.modes = modes;
	} //}}}
	//{{{ addGlobalAbbrev() method
	/**
	 * Adds an abbreviation to the global abbreviation list.
	 * @param abbrev The abbreviation
	 * @param expansion The expansion
	 * @since jEdit 3.1pre1
	 */
	public static void addGlobalAbbrev(String abbrev, String expansion)
	{
		if(!loaded)
			load();
		globalAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} //}}}
	//{{{ addModeAbbrev() method
	/**
	 * Adds a mode-specific abbrev.
	 * @param mode The edit mode
	 * @param abbrev The abbrev
	 * @param expansion The expansion
	 * @since jEdit 3.1pre1
	 */
	public static void addModeAbbrev(String mode, String abbrev, String expansion)
	{
		if(!loaded)
			load();
		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs == null)
		{
			modeAbbrevs = new Hashtable();
			modes.put(mode,modeAbbrevs);
		}
		modeAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} //}}}
	//{{{ save() method
	static void save()
	{
		jEdit.setBooleanProperty(""view.expandOnInput"",expandOnInput);
		String settings = jEdit.getSettingsDirectory();
		if(abbrevsChanged && settings != null)
		{
			File file1 = new File(MiscUtilities.constructPath(settings,""#abbrevs#save#""));
			File file2 = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			if(file2.exists() && file2.lastModified() != abbrevsModTime)
			{
				Log.log(Log.WARNING,Abbrevs.class,file2 + "" changed on disk;""
					+ "" will not save abbrevs"");
			}
			else
			{
				jEdit.backupSettingsFile(file2);
				try
				{
					saveAbbrevs(new OutputStreamWriter(
						new FileOutputStream(file1),
						ENCODING));
					file2.delete();
					file1.renameTo(file2);
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,Abbrevs.class,""Error while saving "" + file1);
					Log.log(Log.ERROR,Abbrevs.class,e);
				}
				abbrevsModTime = file2.lastModified();
			}
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private static boolean loaded;
	private static boolean abbrevsChanged;
	private static long abbrevsModTime;
	private static boolean expandOnInput;
	private static Hashtable globalAbbrevs;
	private static Hashtable modes;
	private static Vector pp = new Vector();
	//}}}
	private Abbrevs() {}
	static
	{
		expandOnInput = jEdit.getBooleanProperty(""view.expandOnInput"");
	}
	//{{{ load() method
	private static void load()
	{
		globalAbbrevs = new Hashtable();
		modes = new Hashtable();
		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			File file = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			abbrevsModTime = file.lastModified();
			try
			{
				loadAbbrevs(new InputStreamReader(
					new FileInputStream(file),ENCODING));
				loaded = true;
			}
			catch(FileNotFoundException fnf)
			{
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading "" + file);
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
		}
		// only load global abbrevs if user abbrevs file could not be loaded
		if(!loaded)
		{
			try
			{
				loadAbbrevs(new InputStreamReader(Abbrevs.class
					.getResourceAsStream(""default.abbrevs""),
					ENCODING));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading default.abbrevs"");
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
			loaded = true;
		}
	} //}}}
	//{{{ countNewlines() method
	private static int countNewlines(String s, int end)
	{
		int counter = 0;
		for(int i = 0; i < end; i++)
		{
			if(s.charAt(i) == '\n')
				counter++;
		}
		return counter;
	} //}}}
	//{{{ expandAbbrev() method
	private static Expansion expandAbbrev(String mode, String abbrev,
		int softTabSize, Vector pp)
	{
		if(!loaded)
			load();
		// try mode-specific abbrevs first
		String expand = null;
		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs != null)
			expand = (String)modeAbbrevs.get(abbrev);
		if(expand == null)
			expand = (String)globalAbbrevs.get(abbrev);
		if(expand == null)
			return null;
		else
			return new Expansion(expand,softTabSize,pp);
	} //}}}
	//{{{ loadAbbrevs() method
	private static void loadAbbrevs(Reader _in) throws Exception
	{
		BufferedReader in = new BufferedReader(_in);
		try
		{
			Hashtable currentAbbrevs = globalAbbrevs;
			String line;
			while((line = in.readLine()) != null)
			{
				int index = line.indexOf('|');
				if(line.length() == 0)
					continue;
				else if(line.startsWith(""["") && index == -1)
				{
					if(line.equals(""[global]""))
						currentAbbrevs = globalAbbrevs;
					else
					{
						String mode = line.substring(1,
							line.length() - 1);
						currentAbbrevs = (Hashtable)modes.get(mode);
						if(currentAbbrevs == null)
						{
							currentAbbrevs = new Hashtable();
							modes.put(mode,currentAbbrevs);
						}
					}
				}
				else if(index != -1)
				{
					currentAbbrevs.put(line.substring(0,index),
						line.substring(index + 1));
				}
			}
		}
		finally
		{
			in.close();
		}
	} //}}}
	//{{{ saveAbbrevs() method
	private static void saveAbbrevs(Writer _out) throws Exception
	{
		BufferedWriter out = new BufferedWriter(_out);
		String lineSep = System.getProperty(""line.separator"");
		// write global abbrevs
		out.write(""[global]"");
		out.write(lineSep);
		saveAbbrevs(out,globalAbbrevs);
		// write mode abbrevs
		Enumeration keys = modes.keys();
		Enumeration values = modes.elements();
		while(keys.hasMoreElements())
		{
			out.write('[');
			out.write((String)keys.nextElement());
			out.write(']');
			out.write(lineSep);
			saveAbbrevs(out,(Hashtable)values.nextElement());
		}
		out.close();
	} //}}}
	//{{{ saveAbbrevs() method
	private static void saveAbbrevs(Writer out, Hashtable abbrevs)
		throws Exception
	{
		String lineSep = System.getProperty(""line.separator"");
		Enumeration keys = abbrevs.keys();
		Enumeration values = abbrevs.elements();
		while(keys.hasMoreElements())
		{
			String abbrev = (String)keys.nextElement();
			out.write(abbrev);
			out.write('|');
			out.write(values.nextElement().toString());
			out.write(lineSep);
		}
	} //}}}
	//}}}
	//{{{ Expansion class
	static class Expansion
	{
		String text;
		int caretPosition = -1;
		int lineCount;
		// number of positional parameters in abbreviation expansion
		int posParamCount;
		//{{{ Expansion constructor
		Expansion(String text, int softTabSize, Vector pp)
		{
			StringBuffer buf = new StringBuffer();
			boolean backslash = false;
			for(int i = 0; i < text.length(); i++)
			{
				char ch = text.charAt(i);
				//{{{ Handle backslash
				if(backslash)
				{
					backslash = false;
					if(ch == '|')
						caretPosition = buf.length();
					else if(ch == 'n')
					{
						buf.append('\n');
						lineCount++;
					}
					else if(ch == 't')
					{
						if(softTabSize == 0)
							buf.append('\t');
						else
						{
							for(int j = 0; j < softTabSize; j++)
								buf.append(' ');
						}
					}
					else
						buf.append(ch);
				}
				else if(ch == '\\')
					backslash = true;
				//}}}
				//{{{ Handle $
				else if(ch == '$')
				{
					if(i != text.length() - 1)
					{
						ch = text.charAt(i + 1);
						if(Character.isDigit(ch) && ch != '0')
						{
							i++;
							int pos = ch - '0';
							posParamCount = Math.max(pos,posParamCount);
							// $n is 1-indexed, but vector
							// contents is zero indexed
							if(pos <= pp.size())
								buf.append(pp.elementAt(pos - 1));
						}
						else
						{
							// $key will be $key, for
							// example
							buf.append('$');
						}
					}
					else
						buf.append('$'); // $ at end is literal
				} //}}}
				else
					buf.append(ch);
			}
			this.text = buf.toString();
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.AbstractOptionPane,"/*
 * AbstractOptionPane.java - Abstract option pane
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
//}}}
/**
 * The default implementation of the option pane interface.<p>
 *
 * See {@link EditPlugin} for information on how jEdit obtains and constructs
 * option pane instances.<p>
 *
 * Most option panes extend this implementation of {@link OptionPane}, instead
 * of implementing {@link OptionPane} directly. This class provides a convenient
 * default framework for laying out configuration options.<p>
 *
 * It is derived from Java's <code>JPanel</code> class and uses a
 * <code>GridBagLayout</code> object for component management. Since
 * <code>GridBagLayout</code> can be a bit cumbersome to use, this class
 * contains shortcut methods to simplify layout:
 *
 * <ul>
 * <li>{@link #addComponent(Component)}</li>
 * <li>{@link #addComponent(String,Component)}</li>
 * <li>{@link #addComponent(String,Component,int)}</li>
 * <li>{@link #addComponent(Component,Component)}</li>
 * <li>{@link #addComponent(Component,Component,int)}</li>
 * <li>{@link #addSeparator()}</li>
 * <li>{@link #addSeparator(String)}</li>
 * </ul>
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: AbstractOptionPane.java,v 1.18 2004/03/28 00:07:26 spestov Exp $
 */
// even though this class is called AbstractOptionPane, it is not really
// abstract, since BufferOptions uses an instance of it to lay out its
// components.
public class AbstractOptionPane extends JPanel implements OptionPane
{
	//{{{ AbstractOptionPane constructor
	/**
	 * Creates a new option pane.
	 * @param name The internal name. The option pane's label is set to the
	 * value of the property named <code>options.<i>name</i>.label</code>.
	 */
	public AbstractOptionPane(String name)
	{
		this.name = name;
		setLayout(gridBag = new GridBagLayout());
	} //}}}
	//{{{ getName() method
	/**
	 * Returns the internal name of this option pane. The option pane's label
	 * is set to the value of the property named
	 * <code>options.<i>name</i>.label</code>.
	 */
	public String getName()
	{
		return name;
	} //}}}
	//{{{ getComponent() method
	/**
	 * Returns the component that should be displayed for this option pane.
	 * Because this class extends Component, it simply returns ""this"".
	 */
	public Component getComponent()
	{
		return this;
	} //}}}
	//{{{ init() method
	/**
	 * Do not override this method, override {@link #_init()} instead.
	 */
	// final in 4.2
	public void init()
	{
		if(!initialized)
		{
			initialized = true;
			_init();
		}
	} //}}}
	//{{{ save() method
	/**
	 * Do not override this method, override {@link #_save()} instead.
	 */
	// final in 4.2
	public void save()
	{
		if(initialized)
			_save();
	} //}}}
	//{{{ addComponent() method
	/**
	 * Adds a labeled component to the option pane. Components are
	 * added in a vertical fashion, one per row. The label is
	 * displayed to the left of the component.
	 * @param label The label
	 * @param comp The component
	 */
	public void addComponent(String label, Component comp)
	{
		JLabel l = new JLabel(label);
		l.setBorder(new EmptyBorder(0,0,0,12));
		addComponent(l,comp,GridBagConstraints.BOTH);
	} //}}}
	//{{{ addComponent() method
	/**
	 * Adds a labeled component to the option pane. Components are
	 * added in a vertical fashion, one per row. The label is
	 * displayed to the left of the component.
	 * @param label The label
	 * @param comp The component
	 * @param fill Fill parameter to GridBagConstraints for the right
	 * component
	 */
	public void addComponent(String label, Component comp, int fill)
	{
		JLabel l = new JLabel(label);
		l.setBorder(new EmptyBorder(0,0,0,12));
		addComponent(l,comp,fill);
	} //}}}
	//{{{ addComponent() method
	/**
	 * Adds a labeled component to the option pane. Components are
	 * added in a vertical fashion, one per row. The label is
	 * displayed to the left of the component.
	 * @param comp1 The label
	 * @param comp2 The component
	 *
	 * @since jEdit 4.1pre3
	 */
	public void addComponent(Component comp1, Component comp2)
	{
		addComponent(comp1,comp2,GridBagConstraints.BOTH);
	} //}}}
	//{{{ addComponent() method
	/**
	 * Adds a labeled component to the option pane. Components are
	 * added in a vertical fashion, one per row. The label is
	 * displayed to the left of the component.
	 * @param comp1 The label
	 * @param comp2 The component
	 * @param fill Fill parameter to GridBagConstraints for the right
	 * component
	 *
	 * @since jEdit 4.1pre3
	 */
	public void addComponent(Component comp1, Component comp2, int fill)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = 1;
		cons.weightx = 0.0f;
		cons.insets = new Insets(1,0,1,0);
		cons.fill = GridBagConstraints.BOTH;
		gridBag.setConstraints(comp1,cons);
		add(comp1);
		cons.fill = fill;
		cons.gridx = 1;
		cons.weightx = 1.0f;
		gridBag.setConstraints(comp2,cons);
		add(comp2);
	} //}}}
	//{{{ addComponent() method
	/**
	 * Adds a component to the option pane. Components are
	 * added in a vertical fashion, one per row.
	 * @param comp The component
	 */
	public void addComponent(Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.NONE;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);
		gridBag.setConstraints(comp,cons);
		add(comp);
	} //}}}
	//{{{ addComponent() method
	/**
	 * Adds a component to the option pane. Components are
	 * added in a vertical fashion, one per row.
	 * @param comp The component
	 * @param fill Fill parameter to GridBagConstraints
	 * @since jEdit 4.2pre2
	 */
	public void addComponent(Component comp, int fill)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = fill;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);
		gridBag.setConstraints(comp,cons);
		add(comp);
	} //}}}
	//{{{ addSeparator() method
	/**
	 * Adds a separator component.
	 * @since jEdit 4.1pre7
	 */
	public void addSeparator()
	{
		addComponent(Box.createVerticalStrut(6));
		JSeparator sep = new JSeparator(JSeparator.HORIZONTAL);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		//cons.insets = new Insets(1,0,1,0);
		gridBag.setConstraints(sep,cons);
		add(sep);
		addComponent(Box.createVerticalStrut(6));
	} //}}}
	//{{{ addSeparator() method
	/**
	 * Adds a separator component.
	 * @param label The separator label property
	 * @since jEdit 2.6pre2
	 */
	public void addSeparator(String label)
	{
		if(y != 0)
			addComponent(Box.createVerticalStrut(6));
		Box box = new Box(BoxLayout.X_AXIS);
		Box box2 = new Box(BoxLayout.Y_AXIS);
		box2.add(Box.createGlue());
		box2.add(new JSeparator(JSeparator.HORIZONTAL));
		box2.add(Box.createGlue());
		box.add(box2);
		JLabel l = new JLabel(jEdit.getProperty(label));
		l.setMaximumSize(l.getPreferredSize());
		box.add(l);
		Box box3 = new Box(BoxLayout.Y_AXIS);
		box3.add(Box.createGlue());
		box3.add(new JSeparator(JSeparator.HORIZONTAL));
		box3.add(Box.createGlue());
		box.add(box3);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);
		gridBag.setConstraints(box,cons);
		add(box);
	} //}}}
	//{{{ Protected members
	/**
	 * Has the option pane been initialized?
	 */
	protected boolean initialized;
	/**
	 * The layout manager.
	 */
	protected GridBagLayout gridBag;
	/**
	 * The number of components already added to the layout manager.
	 */
	protected int y;
	/**
	 * This method should create and arrange the components of the option pane
	 * and initialize the option data displayed to the user. This method
	 * is called when the option pane is first displayed, and is not
	 * called again for the lifetime of the object.
	 */
	protected void _init() {}
	/**
	 * Called when the options dialog's ""ok"" button is clicked.
	 * This should save any properties being edited in this option
	 * pane.
	 */
	protected void _save() {}
	//}}}
	//{{{ Private members
	private String name;
	//}}}
}
"
org.gjt.sp.jedit.ActionContext,"/*
 * ActionContext.java - For code sharing between jEdit and VFSBrowser
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.*;
/**
 * Manages a collection of action sets. There are two instances of this class
 * in jEdit:
 * <ul>
 * <li>{@link org.gjt.sp.jedit.jEdit#getActionContext()} - editor actions
 * <li>{@link org.gjt.sp.jedit.browser.VFSBrowser#getActionContext()} - browser
 * actions
 * </ul>
 *
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: ActionContext.java,v 1.4 2004/03/20 06:08:49 spestov Exp $
 */
public abstract class ActionContext
{
	//{{{ invokeAction() method
	/**
	 * Invokes the given action in response to a user-generated event.
	 * @param evt The event
	 * @param action The action
	 * @since jEdit 4.2pre1
	 */
	public abstract void invokeAction(EventObject evt, EditAction action);
	//}}}
	//{{{ addActionSet() method
	/**
	 * Adds a new action set to the context.
	 * @since jEdit 4.2pre1
	 */
	public void addActionSet(ActionSet actionSet)
	{
		actionNames = null;
		actionSets.addElement(actionSet);
		actionSet.context = this;
		String[] actions = actionSet.getActionNames();
		for(int i = 0; i < actions.length; i++)
		{
			actionHash.put(actions[i],actionSet);
		}
	} //}}}
	//{{{ removeActionSet() method
	/**
	 * Removes an action set from the context.
	 * @since jEdit 4.2pre1
	 */
	public void removeActionSet(ActionSet actionSet)
	{
		actionNames = null;
		actionSets.removeElement(actionSet);
		actionSet.context = null;
		String[] actions = actionSet.getActionNames();
		for(int i = 0; i < actions.length; i++)
		{
			actionHash.remove(actions[i]);
		}
	} //}}}
	//{{{ getActionSets() method
	/**
	 * Returns all registered action sets.
	 * @since jEdit 4.2pre1
	 */
	public ActionSet[] getActionSets()
	{
		ActionSet[] retVal = new ActionSet[actionSets.size()];
		actionSets.copyInto(retVal);
		return retVal;
	} //}}}
	//{{{ getAction() method
	/**
	 * Returns the specified action.
	 * @param name The action name
	 * @since jEdit 4.2pre1
	 */
	public EditAction getAction(String name)
	{
		ActionSet set = (ActionSet)actionHash.get(name);
		if(set == null)
			return null;
		else
			return set.getAction(name);
	} //}}}
	//{{{ getActionSetForAction() method
	/**
	 * Returns the action set that contains the specified action.
	 *
	 * @param action The action
	 * @since jEdit 4.2pre1
	 */
	public ActionSet getActionSetForAction(String action)
	{
		return (ActionSet)actionHash.get(action);
	} //}}}
	//{{{ getActionNames() method
	/**
	 * Returns all registered action names.
	 */
	public String[] getActionNames()
	{
		if(actionNames == null)
		{
			List vec = new LinkedList();
			for(int i = 0; i < actionSets.size(); i++)
				((ActionSet)actionSets.elementAt(i)).getActionNames(vec);
			actionNames = (String[])vec.toArray(
				new String[vec.size()]);
			Arrays.sort(actionNames,
				new MiscUtilities.StringICaseCompare());
		}
		return actionNames;
	} //}}}
	//{{{ Package-private members
	String[] actionNames;
	Hashtable actionHash = new Hashtable();
	//}}}
	//{{{ Private members
	private Vector actionSets = new Vector();
	//}}}
}
"
org.gjt.sp.jedit.ActionListHandler,"/*
 * ActionListHandler.java - XML handler for action files
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;
//}}}
class ActionListHandler extends HandlerBase
{
	//{{{ ActionListHandler constructor
	ActionListHandler(String path, ActionSet actionSet)
	{
		this.path = path;
		this.actionSet = actionSet;
		stateStack = new Stack();
	} //}}}
	//{{{ resolveEntity() method
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""actions.dtd"".equals(systemId))
		{
			// this will result in a slight speed up, since we
			// don't need to read the DTD anyway, as AElfred is
			// non-validating
			return new StringReader(""<!-- -->"");
			/* try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(""actions.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" actions.dtd:"");
				Log.log(Log.ERROR,this,e);
			} */
		}
		return null;
	} //}}}
	//{{{ attribute() method
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();
		if(aname == ""NAME"")
			actionName = value;
		else if(aname == ""NO_REPEAT"")
			noRepeat = (value == ""TRUE"");
		else if(aname == ""NO_RECORD"")
			noRecord = (value == ""TRUE"");
		else if(aname == ""NO_REMEMBER_LAST"")
			noRememberLast = (value == ""TRUE"");
	} //}}}
	//{{{ doctypeDecl() method
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""ACTIONS"".equals(name))
			return;
		Log.log(Log.ERROR,this,path + "": DOCTYPE must be ACTIONS"");
	} //}}}
	//{{{ charData() method
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if (tag == ""CODE"")
		{
			code = text;
		}
		else if (tag == ""IS_SELECTED"")
		{
			isSelected = text;
		}
	} //}}}
	//{{{ startElement() method
	public void startElement(String tag)
	{
		tag = pushElement(tag);
		if (tag == ""ACTION"")
		{
			code = null;
			isSelected = null;
		}
	} //}}}
	//{{{ endElement() method
	public void endElement(String name)
	{
		if(name == null)
			return;
		String tag = peekElement();
		if(name.equals(tag))
		{
			if(tag == ""ACTION"")
			{
				actionSet.addAction(new BeanShellAction(actionName,
					code,isSelected,noRepeat,noRecord,
					noRememberLast));
				noRepeat = noRecord = noRememberLast = false;
			}
			popElement();
		}
		else
		{
			// can't happen
			throw new InternalError();
		}
	} //}}}
	//{{{ startDocument() method
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private String path;
	private ActionSet actionSet;
	private String actionName;
	private String code;
	private String isSelected;
	private boolean noRepeat;
	private boolean noRecord;
	private boolean noRememberLast;
	private Stack stateStack;
	//}}}
	//{{{ pushElement() method
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	} //}}}
	//{{{ peekElement() method
	private String peekElement()
	{
		return (String) stateStack.peek();
	} //}}}
	//{{{ popElement() method
	private String popElement()
	{
		return (String) stateStack.pop();
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.ActionSet,"/*
 * ActionSet.java - A set of actions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.*;
import org.gjt.sp.jedit.gui.InputHandler;
import org.gjt.sp.util.Log;
/**
 * A set of actions, either loaded from an XML file, or constructed at runtime
 * by a plugin.<p>
 *
 * <h3>Action sets loaded from XML files</h3>
 *
 * Action sets are read from these files inside the plugin JAR:
 * <ul>
 * <li><code>actions.xml</code> - actions made available for use in jEdit views,
 * including the view's <b>Plugins</b> menu, the tool bar, etc.</li>
 * <li><code>browser.actions.xml</code> - actions for the file system browser's
 * <b>Plugins</b> menu.</li>
 * </ul>
 *
 * An action definition file has the following form:
 *
 * <pre>&lt;?xml version=""1.0""?&gt;
 *&lt;!DOCTYPE ACTIONS SYSTEM ""actions.dtd""&gt;
 *&lt;ACTIONS&gt;
 *    &lt;ACTION NAME=""some-action""&gt;
 *        &lt;CODE&gt;
 *            // BeanShell code evaluated when the action is invoked
 *        &lt;/CODE&gt;
 *    &lt;/ACTION&gt;
 *    &lt;ACTION NAME=""some-toggle-action""&gt;
 *        &lt;CODE&gt;
 *            // BeanShell code evaluated when the action is invoked
 *        &lt;/CODE&gt;
 *        &lt;IS_SELECTED&gt;
 *            // BeanShell code that should evaluate to true or false
 *        &lt;/IS_SELECTED&gt;
 *    &lt;/ACTION&gt;
 *&lt;/ACTIONS&gt;</pre>
 *
 * The following elements are valid:
 *
 * <ul>
 * <li>
 * <code>ACTIONS</code> is the top-level element and refers
 * to the set of actions used by the plugin.
 * </li>
 * <li>
 * An <code>ACTION</code> contains the data for a particular action.
 * It has three attributes: a required <code>NAME</code>;
 * an optional <code>NO_REPEAT</code>, which is a flag
 * indicating whether the action should not be repeated with the
 * <b>C+ENTER</b> command; and an optional
 * <code>NO_RECORD</code> which is a a flag indicating whether the
 * action should be recorded if it is invoked while the user is recording a
 * macro. The two flag attributes
 * can have two possible values, ""TRUE"" or
 * ""FALSE"". In both cases, ""FALSE"" is the
 * default if the attribute is not specified.
 * </li>
 * <li>
 * An <code>ACTION</code> can have two child elements
 * within it: a required <code>CODE</code> element which
 * specifies the
 * BeanShell code that will be executed when the action is invoked,
 * and an optional <code>IS_SELECTED</code> element, used for
 * checkbox
 * menu items.  The <code>IS_SELECTED</code> element contains
 * BeanShell code that returns a boolean flag that will
 * determine the state of the checkbox.
 * </li>
 * </ul>
 *
 * Each action must have a property <code><i>name</i>.label</code> containing
 * the action's menu item label.
 *
 * <h3>View actions</h3>
 *
 * Actions defined in <code>actions.xml</code> can be added to the view's
 * <b>Plugins</b> menu; see {@link EditPlugin}.
 * The action code may use any standard predefined
 * BeanShell variable; see {@link BeanShell}.
 *
 * <h3>File system browser actions</h3>
 *
 * Actions defined in <code>actions.xml</code> can be added to the file
 * system browser's <b>Plugins</b> menu; see {@link EditPlugin}.
 * The action code may use any standard predefined
 * BeanShell variable, in addition to a variable <code>browser</code> which
 * contains a reference to the current
 * {@link org.gjt.sp.jedit.browser.VFSBrowser} instance.<p>
 *
 * File system browser actions should not define
 * <code>&lt;IS_SELECTED&gt;</code> blocks.
 *
 * <h3>Custom action sets</h3>
 *
 * Call {@link jEdit#addActionSet(ActionSet)} to add a custom action set to
 * jEdit's action context. You must also call {@link #initKeyBindings()} for new
 * action sets. Don't forget to call {@link jEdit#removeActionSet(ActionSet)}
 * before your plugin is unloaded, too.
 *
 * @see jEdit#getActionContext()
 * @see org.gjt.sp.jedit.browser.VFSBrowser#getActionContext()
 * @see ActionContext#getActionNames()
 * @see ActionContext#getAction(String)
 * @see jEdit#addActionSet(ActionSet)
 * @see jEdit#removeActionSet(ActionSet)
 * @see PluginJAR#getActionSet()
 * @see BeanShell
 * @see View
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: ActionSet.java,v 1.31 2004/07/12 19:25:07 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class ActionSet
{
	//{{{ ActionSet constructor
	/**
	 * Creates a new action set.
	 * @since jEdit 4.0pre1
	 */
	public ActionSet()
	{
		actions = new Hashtable();
		loaded = true;
		label = ""<no label set; plugin bug>"";
	} //}}}
	//{{{ ActionSet constructor
	/**
	 * Creates a new action set.
	 * @param plugin The plugin
	 * @param cachedActionNames The list of cached action names
	 * @param cachedActionToggleFlags The list of cached action toggle flags
	 * @param uri The actions.xml URI
	 * @since jEdit 4.2pre2
	 */
	public ActionSet(PluginJAR plugin, String[] cachedActionNames,
		boolean[] cachedActionToggleFlags, URL uri)
	{
		this();
		this.plugin = plugin;
		this.uri = uri;
		if(cachedActionNames != null)
		{
			for(int i = 0; i < cachedActionNames.length; i++)
			{
				actions.put(cachedActionNames[i],placeholder);
				jEdit.setTemporaryProperty(cachedActionNames[i]
					+ "".toggle"",cachedActionToggleFlags[i]
					? ""true"" : ""false"");
			}
		}
		loaded = false;
	} //}}}
	//{{{ ActionSet constructor
	/**
	 * Creates a new action set.
	 * @param label The label, shown in the shortcuts option pane
	 * @since jEdit 4.0pre1
	 */
	public ActionSet(String label)
	{
		this();
		setLabel(label);
	} //}}}
	//{{{ getLabel() method
	/**
	 * Return the action source label.
	 * @since jEdit 4.0pre1
	 */
	public String getLabel()
	{
		return label;
	} //}}}
	//{{{ setLabel() method
	/**
	 * Sets the action source label.
	 * @param label The label
	 * @since jEdit 4.0pre1
	 */
	public void setLabel(String label)
	{
		if(label == null)
			throw new NullPointerException();
		this.label = label;
	} //}}}
	//{{{ getPluginJAR() method
	/**
	 * Return the plugin this action set was loaded from, or null.
	 * @since jEdit 4.2pre13
	 */
	public PluginJAR getPluginJAR()
	{
		return plugin;
	} //}}}
	//{{{ addAction() method
	/**
	 * Adds an action to the action set.
	 * @param action The action
	 * @since jEdit 4.0pre1
	 */
	public void addAction(EditAction action)
	{
		actions.put(action.getName(),action);
		if(context != null)
		{
			context.actionNames = null;
			context.actionHash.put(action.getName(),this);
		}
	} //}}}
	//{{{ removeAction() method
	/**
	 * Removes an action from the action set.
	 * @param name The action name
	 * @since jEdit 4.0pre1
	 */
	public void removeAction(String name)
	{
		actions.remove(name);
		if(context != null)
		{
			context.actionNames = null;
			context.actionHash.remove(name);
		}
	} //}}}
	//{{{ removeAllActions() method
	/**
	 * Removes all actions from the action set.
	 * @since jEdit 4.0pre1
	 */
	public void removeAllActions()
	{
		if(context != null)
		{
			context.actionNames = null;
			String[] actions = getActionNames();
			for(int i = 0; i < actions.length; i++)
			{
				context.actionHash.remove(actions[i]);
			}
		}
		this.actions.clear();
	} //}}}
	//{{{ getAction() method
	/**
	 * Returns an action with the specified name.<p>
	 *
	 * <b>Deferred loading:</b> this will load the action set if necessary.
	 *
	 * @param name The action name
	 * @since jEdit 4.0pre1
	 */
	public EditAction getAction(String name)
	{
		Object obj = actions.get(name);
		if(obj == placeholder)
		{
			load();
			obj = actions.get(name);
			if(obj == placeholder)
			{
				Log.log(Log.WARNING,this,""Outdated cache"");
				obj = null;
			}
		}
		return (EditAction)obj;
	} //}}}
	//{{{ getActionCount() method
	/**
	 * Returns the number of actions in the set.
	 * @since jEdit 4.0pre1
	 */
	public int getActionCount()
	{
		return actions.size();
	} //}}}
	//{{{ getActionNames() method
	/**
	 * Returns an array of all action names in this action set.
	 * @since jEdit 4.2pre1
	 */
	public String[] getActionNames()
	{
		String[] retVal = new String[actions.size()];
		Enumeration e = actions.keys();
		int i = 0;
		while(e.hasMoreElements())
		{
			retVal[i++] = (String)e.nextElement();
		}
		return retVal;
	} //}}}
	//{{{ getCacheableActionNames() method
	/**
	 * Returns an array of all action names in this action set that should
	 * be cached; namely, <code>BeanShellAction</code>s.
	 * @since jEdit 4.2pre1
	 */
	public String[] getCacheableActionNames()
	{
		LinkedList retVal = new LinkedList();
		Enumeration e = actions.elements();
		while(e.hasMoreElements())
		{
			Object obj = e.nextElement();
			if(obj == placeholder)
			{
				// ??? this should only be called with
				// fully loaded action set
				Log.log(Log.WARNING,this,""Action set not up ""
					+ ""to date"");
			}
			else if(obj instanceof BeanShellAction)
				retVal.add(((BeanShellAction)obj).getName());
		}
		return (String[])retVal.toArray(new String[retVal.size()]);
	} //}}}
	//{{{ getActions() method
	/**
	 * Returns an array of all actions in this action set.<p>
	 *
	 * <b>Deferred loading:</b> this will load the action set if necessary.
	 *
	 * @since jEdit 4.0pre1
	 */
	public EditAction[] getActions()
	{
		load();
		EditAction[] retVal = new EditAction[actions.size()];
		Enumeration e = actions.elements();
		int i = 0;
		while(e.hasMoreElements())
		{
			retVal[i++] = (EditAction)e.nextElement();
		}
		return retVal;
	} //}}}
	//{{{ contains() method
	/**
	 * Returns if this action set contains the specified action.
	 * @param action The action
	 * @since jEdit 4.2pre1
	 */
	public boolean contains(String action)
	{
		return actions.containsKey(action);
	} //}}}
	//{{{ size() method
	/**
	 * Returns the number of actions in this action set.
	 * @since jEdit 4.2pre2
	 */
	public int size()
	{
		return actions.size();
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		return label;
	} //}}}
	//{{{ initKeyBindings() method
	/**
	 * Initializes the action set's key bindings.
	 * jEdit calls this method for all registered action sets when the
	 * user changes key bindings in the <b>Global Options</b> dialog box.<p>
	 *
	 * Note if your plugin adds a custom action set to jEdit's collection,
	 * it must also call this method on the action set after adding it.
	 *
	 * @since jEdit 4.2pre1
	 */
	public void initKeyBindings()
	{
		InputHandler inputHandler = jEdit.getInputHandler();
		Iterator iter = actions.entrySet().iterator();
		while(iter.hasNext())
		{
			Map.Entry entry = (Map.Entry)iter.next();
			String name = (String)entry.getKey();
			String shortcut1 = jEdit.getProperty(name + "".shortcut"");
			if(shortcut1 != null)
				inputHandler.addKeyBinding(shortcut1,name);
			String shortcut2 = jEdit.getProperty(name + "".shortcut2"");
			if(shortcut2 != null)
				inputHandler.addKeyBinding(shortcut2,name);
		}
	} //}}}
	//{{{ load() method
	/**
	 * Forces the action set to be loaded. Plugins and macros should not
	 * call this method.
	 * @since jEdit 4.2pre1
	 */
	public void load()
	{
		if(loaded)
			return;
		loaded = true;
		//actions.clear();
		Reader stream = null;
		try
		{
			Log.log(Log.DEBUG,this,""Loading actions from "" + uri);
			ActionListHandler ah = new ActionListHandler(uri.toString(),this);
			stream = new BufferedReader(new InputStreamReader(
				uri.openStream()));
			XmlParser parser = new XmlParser();
			parser.setHandler(ah);
			parser.parse(null, null, stream);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,this,uri + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,uri,e);
		}
		finally
		{
			try
			{
				if(stream != null)
					stream.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
			}
		}
	} //}}}
	//{{{ Package-private members
	ActionContext context;
	//{{{ getActionNames() method
	void getActionNames(List vec)
	{
		Enumeration e = actions.keys();
		while(e.hasMoreElements())
			vec.add(e.nextElement());
	} //}}}
	//}}}
	//{{{ Private members
	private String label;
	private Hashtable actions;
	private PluginJAR plugin;
	private URL uri;
	private boolean loaded;
	private static final Object placeholder = new Object();
	//}}}
}
"
org.gjt.sp.jedit.Autosave,"/*
 * Autosave.java - Autosave manager
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import org.gjt.sp.util.Log;
//}}}
/**
 * @author Slava Pestov
 * @version $Id: Autosave.java,v 1.13 2004/05/06 22:35:11 spestov Exp $
 */
class Autosave implements ActionListener
{
	//{{{ setInterval() method
	public static void setInterval(int interval)
	{
		if(interval == 0)
		{
			if(timer != null)
			{
				timer.stop();
				timer = null;
			}
			return;
		}
		interval *= 1000;
		if(timer == null)
		{
			timer = new Timer(interval,new Autosave());
			timer.start();
		}
		else
			timer.setDelay(interval);
	} //}}}
	//{{{ stop() method
	public static void stop()
	{
		if(timer != null)
			timer.stop();
	} //}}}
	//{{{ actionPerformed() method
	public void actionPerformed(ActionEvent evt)
	{
		// might come in handy useful some time
		/* Runtime runtime = Runtime.getRuntime();
		int freeMemory = (int)(runtime.freeMemory() / 1024);
		int totalMemory = (int)(runtime.totalMemory() / 1024);
		int usedMemory = (totalMemory - freeMemory);
		Log.log(Log.DEBUG,this,""Java heap: "" + usedMemory + ""Kb / ""
			+ totalMemory + ""Kb, "" + (usedMemory * 100 / totalMemory)
			+ ""%""); */
		// save list of open files
		if(jEdit.getViewCount() != 0
			&& PerspectiveManager.isPerspectiveDirty())
		{
			PerspectiveManager.setPerspectiveDirty(false);
			PerspectiveManager.savePerspective(true);
		}
		Buffer[] bufferArray = jEdit.getBuffers();
		for(int i = 0; i < bufferArray.length; i++)
			bufferArray[i].autosave();
		// flush log
		Log.flushStream();
	} //}}}
	//{{{ Private members
	private static Timer timer;
	private Autosave() {}
	//}}}
}
"
org.gjt.sp.jedit.BeanShell,"/*
 * BeanShell.java - BeanShell scripting support
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import bsh.*;
import java.io.*;
import java.lang.ref.*;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * BeanShell is jEdit's extension language.<p>
 *
 * When run from jEdit, BeanShell code has access to the following predefined
 * variables:
 *
 * <ul>
 * <li><code>view</code> - the currently active {@link View}.</li>
 * <li><code>editPane</code> - the currently active {@link EditPane}.</li>
 * <li><code>textArea</code> - the edit pane's {@link JEditTextArea}.</li>
 * <li><code>buffer</code> - the edit pane's {@link Buffer}.</li>
 * <li><code>wm</code> - the view's {@link
 * org.gjt.sp.jedit.gui.DockableWindowManager}.</li>
 * <li><code>scriptPath</code> - the path name of the currently executing
 * BeanShell script.</li>
 * </ul>
 *
 * @author Slava Pestov
 * @version $Id: BeanShell.java,v 1.44 2004/02/22 20:00:50 spestov Exp $
 */
public class BeanShell
{
	private static final String REQUIRED_VERSION = ""2.0b1.1-jedit-1"";
	//{{{ evalSelection() method
	/**
	 * Evaluates the text selected in the specified text area.
	 * @since jEdit 2.7pre2
	 */
	public static void evalSelection(View view, JEditTextArea textArea)
	{
		String command = textArea.getSelectedText();
		if(command == null)
		{
			view.getToolkit().beep();
			return;
		}
		Object returnValue = eval(view,global,command);
		if(returnValue != null)
			textArea.setSelectedText(returnValue.toString());
	} //}}}
	//{{{ showEvaluateDialog() method
	/**
	 * Prompts for a BeanShell expression to evaluate.
	 * @since jEdit 2.7pre2
	 */
	public static void showEvaluateDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-input"",null);
		if(command != null)
		{
			if(!command.endsWith("";""))
				command = command + "";"";
			int repeat = view.getInputHandler().getRepeatCount();
			if(view.getMacroRecorder() != null)
			{
				view.getMacroRecorder().record(repeat,command);
			}
			Object returnValue = null;
			try
			{
				for(int i = 0; i < repeat; i++)
				{
					returnValue = _eval(view,global,command);
				}
			}
			catch(Throwable e)
			{
				Log.log(Log.ERROR,BeanShell.class,e);
				handleException(view,null,e);
			}
			if(returnValue != null)
			{
				String[] args = { returnValue.toString() };
				GUIUtilities.message(view,""beanshell-eval"",args);
			}
		}
	} //}}}
	//{{{ showEvaluateLinesDialog() method
	/**
	 * Evaluates the specified script for each selected line.
	 * @since jEdit 4.0pre1
	 */
	public static void showEvaluateLinesDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-line"",null);
		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();
		if(command == null || command.length() == 0)
			return;
		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return;
		}
		if(!command.endsWith("";""))
			command = command + "";"";
		String script = ""int[] lines = textArea.getSelectedLines();\n""
			+ ""for(int i = 0; i < lines.length; i++)\n""
			+ ""{\n""
				+ ""line = lines[i];\n""
				+ ""index = line - lines[0];\n""
				+ ""start = buffer.getLineStartOffset(line);\n""
				+ ""end = buffer.getLineEndOffset(line);\n""
				+ ""text = buffer.getText(start,end - start - 1);\n""
				+ ""newText = "" + command + ""\n""
				+ ""if(newText != null)\n""
				+ ""{\n""
					+ ""buffer.remove(start,end - start - 1);\n""
					+ ""buffer.insert(start,String.valueOf(newText));\n""
				+ ""}\n""
			+ ""}\n"";
		if(view.getMacroRecorder() != null)
			view.getMacroRecorder().record(1,script);
		try
		{
			buffer.beginCompoundEdit();
			BeanShell.eval(view,global,script);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		textArea.selectNone();
	} //}}}
	//{{{ runScript() method
	/**
	 * Runs a BeanShell script. Errors are shown in a dialog box.<p>
	 *
	 * If the <code>in</code> parameter is non-null, the script is
	 * read from that stream; otherwise it is read from the file identified
	 * by <code>path</code>.<p>
	 *
	 * The <code>scriptPath</code> BeanShell variable is set to the path
	 * name of the script.
	 *
	 * @param view The view. Within the script, references to
	 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>
	 * are determined with reference to this parameter.
	 * @param path The script file's VFS path.
	 * @param in The reader to read the script from, or <code>null</code>.
	 * @param ownNamespace If set to <code>false</code>, methods and
	 * variables defined in the script will be available to all future
	 * uses of BeanShell; if set to <code>true</code>, they will be lost as
	 * soon as the script finishes executing. jEdit uses a value of
	 * <code>false</code> when running startup scripts, and a value of
	 * <code>true</code> when running all other macros.
	 *
	 * @since jEdit 4.0pre7
	 */
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace)
	{
		try
		{
			_runScript(view,path,in,ownNamespace);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);
			handleException(view,path,e);
		}
	} //}}}
	//{{{ runScript() method
	/**
	 * Runs a BeanShell script. Errors are shown in a dialog box.<p>
	 *
	 * If the <code>in</code> parameter is non-null, the script is
	 * read from that stream; otherwise it is read from the file identified
	 * by <code>path</code>.<p>
	 *
	 * The <code>scriptPath</code> BeanShell variable is set to the path
	 * name of the script.
	 *
	 * @param view The view. Within the script, references to
	 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>
	 * are determined with reference to this parameter.
	 * @param path The script file's VFS path.
	 * @param in The reader to read the script from, or <code>null</code>.
	 * @param namespace The namespace to run the script in.
	 *
	 * @since jEdit 4.2pre5
	 */
	public static void runScript(View view, String path, Reader in,
		NameSpace namespace)
	{
		try
		{
			_runScript(view,path,in,namespace);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);
			handleException(view,path,e);
		}
	} //}}}
	//{{{ _runScript() method
	/**
	 * Runs a BeanShell script. Errors are passed to the caller.<p>
	 *
	 * If the <code>in</code> parameter is non-null, the script is
	 * read from that stream; otherwise it is read from the file identified
	 * by <code>path</code>.<p>
	 *
	 * The <code>scriptPath</code> BeanShell variable is set to the path
	 * name of the script.
	 *
	 * @param view The view. Within the script, references to
	 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>
	 * are determined with reference to this parameter.
	 * @param path The script file's VFS path.
	 * @param in The reader to read the script from, or <code>null</code>.
	 * @param ownNamespace If set to <code>false</code>, methods and
	 * variables defined in the script will be available to all future
	 * uses of BeanShell; if set to <code>true</code>, they will be lost as
	 * soon as the script finishes executing. jEdit uses a value of
	 * <code>false</code> when running startup scripts, and a value of
	 * <code>true</code> when running all other macros.
	 * @exception Exception instances are thrown when various BeanShell errors
	 * occur
	 * @since jEdit 4.0pre7
	 */
	public static void _runScript(View view, String path, Reader in,
		boolean ownNamespace) throws Exception
	{
		_runScript(view,path,in,ownNamespace
			? new NameSpace(global,""script namespace"")
			: global);
	} //}}}
	//{{{ _runScript() method
	/**
	 * Runs a BeanShell script. Errors are passed to the caller.<p>
	 *
	 * If the <code>in</code> parameter is non-null, the script is
	 * read from that stream; otherwise it is read from the file identified
	 * by <code>path</code>.<p>
	 *
	 * The <code>scriptPath</code> BeanShell variable is set to the path
	 * name of the script.
	 *
	 * @param view The view. Within the script, references to
	 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>
	 * are determined with reference to this parameter.
	 * @param path The script file's VFS path.
	 * @param in The reader to read the script from, or <code>null</code>.
	 * @param namespace The namespace to run the script in.
	 * @exception Exception instances are thrown when various BeanShell errors
	 * occur
	 * @since jEdit 4.2pre5
	 */
	public static void _runScript(View view, String path, Reader in,
		NameSpace namespace) throws Exception
	{
		Log.log(Log.MESSAGE,BeanShell.class,""Running script "" + path);
		Interpreter interp = createInterpreter(namespace);
		VFS vfs = null;
		Object session = null;
		try
		{
			if(in == null)
			{
				Buffer buffer = jEdit.getBuffer(path);
				vfs = VFSManager.getVFSForPath(path);
				session = vfs.createVFSSession(path,view);
				if(session == null)
				{
					// user cancelled???
					return;
				}
				if(buffer != null)
				{
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();
					in = new StringReader(buffer.getText(0,
						buffer.getLength()));
				}
				else
				{
					in = new BufferedReader(new InputStreamReader(
						vfs._createInputStream(session,
						path,false,view)));
				}
			}
			setupDefaultVariables(namespace,view);
			interp.set(""scriptPath"",path);
			running = true;
			interp.eval(in,namespace,path);
		}
		catch(Exception e)
		{
			unwrapException(e);
		}
		finally
		{
			running = false;
			if(session != null)
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,BeanShell.class,io);
					GUIUtilities.error(view,""read-error"",
						new String[] { path, io.toString() });
				}
			}
			try
			{
				// no need to do this for macros!
				if(namespace == global)
				{
					resetDefaultVariables(namespace);
					interp.unset(""scriptPath"");
				}
			}
			catch(EvalError e)
			{
				// do nothing
			}
		}
	} //}}}
	//{{{ eval() method
	/**
	 * Evaluates the specified BeanShell expression. Errors are reported in
	 * a dialog box.
	 * @param view The view. Within the script, references to
	 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>
	 * are determined with reference to this parameter.
	 * @param namespace The namespace
	 * @param command The expression
	 * @since jEdit 4.0pre8
	 */
	public static Object eval(View view, NameSpace namespace, String command)
	{
		try
		{
			return _eval(view,namespace,command);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);
			handleException(view,null,e);
		}
		return null;
	} //}}}
	//{{{ _eval() method
	/**
	 * Evaluates the specified BeanShell expression. Unlike
	 * <code>eval()</code>, this method passes any exceptions to the caller.
	 *
	 * @param view The view. Within the script, references to
	 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>
	 * are determined with reference to this parameter.
	 * @param namespace The namespace
	 * @param command The expression
	 * @exception Exception instances are thrown when various BeanShell
	 * errors occur
	 * @since jEdit 3.2pre7
	 */
	public static Object _eval(View view, NameSpace namespace, String command)
		throws Exception
	{
		Interpreter interp = createInterpreter(namespace);
		try
		{
			setupDefaultVariables(namespace,view);
			if(Debug.BEANSHELL_DEBUG)
				Log.log(Log.DEBUG,BeanShell.class,command);
			return interp.eval(command);
		}
		catch(Exception e)
		{
			unwrapException(e);
			// never called
			return null;
		}
		finally
		{
			try
			{
				resetDefaultVariables(namespace);
			}
			catch(UtilEvalError e)
			{
				// do nothing
			}
		}
	} //}}}
	//{{{ cacheBlock() method
	/**
	 * Caches a block of code, returning a handle that can be passed to
	 * runCachedBlock().
	 * @param id An identifier. If null, a unique identifier is generated
	 * @param code The code
	 * @param namespace If true, the namespace will be set
	 * @exception Exception instances are thrown when various BeanShell errors
	 * occur
	 * @since jEdit 4.1pre1
	 */
	public static BshMethod cacheBlock(String id, String code, boolean namespace)
		throws Exception
	{
		String name = ""__internal_"" + id;
		// evaluate a method declaration
		if(namespace)
		{
			_eval(null,global,name + ""(ns) {\nthis.callstack.set(0,ns);\n"" + code + ""\n}"");
			return global.getMethod(name,new Class[] { NameSpace.class });
		}
		else
		{
			_eval(null,global,name + ""() {\n"" + code + ""\n}"");
			return global.getMethod(name,new Class[0]);
		}
	} //}}}
	//{{{ runCachedBlock() method
	/**
	 * Runs a cached block of code in the specified namespace. Faster than
	 * evaluating the block each time.
	 * @param method The method instance returned by cacheBlock()
	 * @param view The view
	 * @param namespace The namespace to run the code in
	 * @exception Exception instances are thrown when various BeanShell
	 * errors occur
	 * @since jEdit 4.1pre1
	 */
	public static Object runCachedBlock(BshMethod method, View view,
		NameSpace namespace) throws Exception
	{
		boolean useNamespace;
		if(namespace == null)
		{
			useNamespace = false;
			namespace = global;
		}
		else
			useNamespace = true;
		try
		{
			setupDefaultVariables(namespace,view);
			Object retVal = method.invoke(useNamespace
				? new Object[] { namespace }
				: NO_ARGS,
				interpForMethods,new CallStack());
			if(retVal instanceof Primitive)
			{
				if(retVal == Primitive.VOID)
					return null;
				else
					return ((Primitive)retVal).getValue();
			}
			else
				return retVal;
		}
		catch(Exception e)
		{
			unwrapException(e);
			// never called
			return null;
		}
		finally
		{
			resetDefaultVariables(namespace);
		}
	} //}}}
	//{{{ isScriptRunning() method
	/**
	 * Returns if a BeanShell script or macro is currently running.
	 * @since jEdit 2.7pre2
	 */
	public static boolean isScriptRunning()
	{
		return running;
	} //}}}
	//{{{ getNameSpace() method
	/**
	 * Returns the global namespace.
	 * @since jEdit 3.2pre5
	 */
	public static NameSpace getNameSpace()
	{
		return global;
	} //}}}
	//{{{ Deprecated functions
	//{{{ runScript() method
	/**
	 * @deprecated The <code>rethrowBshErrors</code> parameter is now
	 * obsolete; call <code>_runScript()</code> or <code>runScript()</code>
	 * instead.
	 */
	public static void runScript(View view, String path,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,null,ownNamespace);
	} //}}}
	//{{{ runScript() method
	/**
	 * @deprecated The <code>rethrowBshErrors</code> parameter is now
	 * obsolete; call <code>_runScript()</code> or <code>runScript()</code>
	 * instead.
	 */
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,in,ownNamespace);
	} //}}}
	//{{{ eval() method
	/**
	 * @deprecated The <code>rethrowBshErrors</code> parameter is now
	 * obsolete; call <code>_eval()</code> or <code>eval()</code> instead.
	 */
	public static Object eval(View view, String command,
		boolean rethrowBshErrors)
	{
		return eval(view,global,command);
	} //}}}
	//{{{ eval() method
	/**
	 * @deprecated The <code>rethrowBshErrors</code> parameter is now
	 * obsolete; call <code>_eval()</code> or <code>eval()</code> instead.
	 */
	public static Object eval(View view, NameSpace namespace,
		String command, boolean rethrowBshErrors)
	{
		return eval(view,namespace,command);
	} //}}}
	//}}}
	//{{{ Package-private members
	//{{{ init() method
	static void init()
	{
		try
		{
			NameSpace.class.getMethod(""addCommandPath"",
				new Class[] { String.class, Class.class });
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BeanShell.class,""You have BeanShell version "" + Interpreter.VERSION + "" in your CLASSPATH."");
			Log.log(Log.ERROR,BeanShell.class,""Please remove it from the CLASSPATH since jEdit can only run with the bundled BeanShell version "" + REQUIRED_VERSION);
			System.exit(1);
		}
		classManager = new CustomClassManager();
		classManager.setClassLoader(new JARClassLoader());
		global = new NameSpace(classManager,
			""jEdit embedded BeanShell interpreter"");
		global.importPackage(""org.gjt.sp.jedit"");
		global.importPackage(""org.gjt.sp.jedit.browser"");
		global.importPackage(""org.gjt.sp.jedit.buffer"");
		global.importPackage(""org.gjt.sp.jedit.gui"");
		global.importPackage(""org.gjt.sp.jedit.help"");
		global.importPackage(""org.gjt.sp.jedit.io"");
		global.importPackage(""org.gjt.sp.jedit.menu"");
		global.importPackage(""org.gjt.sp.jedit.msg"");
		global.importPackage(""org.gjt.sp.jedit.options"");
		global.importPackage(""org.gjt.sp.jedit.pluginmgr"");
		global.importPackage(""org.gjt.sp.jedit.print"");
		global.importPackage(""org.gjt.sp.jedit.search"");
		global.importPackage(""org.gjt.sp.jedit.syntax"");
		global.importPackage(""org.gjt.sp.jedit.textarea"");
		global.importPackage(""org.gjt.sp.util"");
		interpForMethods = createInterpreter(global);
	} //}}}
	//{{{ resetClassManager() method
	/**
	 * Causes BeanShell internal structures to drop references to cached
	 * Class instances.
	 */
	static void resetClassManager()
	{
		classManager.reset();
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Static variables
	private static final Object[] NO_ARGS = new Object[0];
	private static CustomClassManager classManager;
	private static Interpreter interpForMethods;
	private static NameSpace global;
	private static boolean running;
	//}}}
	//{{{ setupDefaultVariables() method
	private static void setupDefaultVariables(NameSpace namespace, View view)
		throws UtilEvalError
	{
		if(view != null)
		{
			EditPane editPane = view.getEditPane();
			namespace.setVariable(""view"",view);
			namespace.setVariable(""editPane"",editPane);
			namespace.setVariable(""buffer"",editPane.getBuffer());
			namespace.setVariable(""textArea"",editPane.getTextArea());
			namespace.setVariable(""wm"",view.getDockableWindowManager());
		}
	} //}}}
	//{{{ resetDefaultVariables() method
	private static void resetDefaultVariables(NameSpace namespace)
		throws UtilEvalError
	{
		namespace.setVariable(""view"",null);
		namespace.setVariable(""editPane"",null);
		namespace.setVariable(""buffer"",null);
		namespace.setVariable(""textArea"",null);
		namespace.setVariable(""wm"",null);
	} //}}}
	//{{{ unwrapException() method
	/**
	 * This extracts an exception from a 'wrapping' exception, as BeanShell
	 * sometimes throws. This gives the user a more accurate error traceback
	 */
	private static void unwrapException(Exception e) throws Exception
	{
		if(e instanceof TargetError)
		{
			Throwable t = ((TargetError)e).getTarget();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}
		if(e instanceof InvocationTargetException)
		{
			Throwable t = ((InvocationTargetException)e).getTargetException();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}
		throw e;
	} //}}}
	//{{{ handleException() method
	private static void handleException(View view, String path, Throwable t)
	{
		if(t instanceof IOException)
		{
			VFSManager.error(view,path,""ioerror.read-error"",
				new String[] { t.toString() });
		}
		else
			new BeanShellErrorDialog(view,t);
	} //}}}
	//{{{ createInterpreter() method
	private static Interpreter createInterpreter(NameSpace nameSpace)
	{
		return new Interpreter(null,System.out,System.err,false,nameSpace);
	} //}}}
	//}}}
	//{{{ CustomClassManager class
	static class CustomClassManager extends BshClassManager
	{
		private LinkedList listeners = new LinkedList();
		private ReferenceQueue refQueue = new ReferenceQueue();
		// copy and paste from bsh/classpath/ClassManagerImpl.java...
		public synchronized void addListener( Listener l )
		{
			listeners.add( new WeakReference( l, refQueue) );
			// clean up old listeners
			Reference deadref;
			while ( (deadref = refQueue.poll()) != null )
			{
				boolean ok = listeners.remove( deadref );
				if ( ok )
				{
					//System.err.println(""cleaned up weak ref: ""+deadref);
				}
				else
				{
					if ( Interpreter.DEBUG ) Interpreter.debug(
						""tried to remove non-existent weak ref: ""+deadref);
				}
			}
		}
		public void removeListener( Listener l )
		{
			throw new Error(""unimplemented"");
		}
		public void reset()
		{
			classLoaderChanged();
		}
		protected synchronized void classLoaderChanged()
		{
			// clear the static caches in BshClassManager
			clearCaches();
			for (Iterator iter = listeners.iterator();
				iter.hasNext(); )
			{
				WeakReference wr = (WeakReference)
					iter.next();
				Listener l = (Listener)wr.get();
				if ( l == null )  // garbage collected
					iter.remove();
				else
					l.classLoaderChanged();
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.BeanShellAction,"/*
 * BeanShellAction.java - BeanShell action
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import bsh.*;
import java.awt.Component;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.util.Log;
/**
 * An action that evaluates BeanShell code when invoked. BeanShell actions are
 * usually loaded from <code>actions.xml</code> and
 * <code>browser.actions.xml</code> files; see {@link ActionSet} for syntax
 * information.
 *
 * @see jEdit#getAction(String)
 * @see jEdit#getActionNames()
 * @see ActionSet
 *
 * @author Slava Pestov
 * @version $Id: BeanShellAction.java,v 1.17 2003/07/17 23:49:44 spestov Exp $
 */
public class BeanShellAction extends EditAction
{
	//{{{ BeanShellAction constructor
	public BeanShellAction(String name, String code, String isSelected,
		boolean noRepeat, boolean noRecord, boolean noRememberLast)
	{
		super(name);
		this.code = code;
		this.isSelected = isSelected;
		this.noRepeat = noRepeat;
		this.noRecord = noRecord;
		this.noRememberLast = noRememberLast;
		/* Some characters that we like to use in action names
		 * ('.', '-') are not allowed in BeanShell identifiers. */
		sanitizedName = name.replace('.','_').replace('-','_');
		jEdit.setTemporaryProperty(name + "".toggle"",
			isSelected != null ? ""true"" : ""false"");
	} //}}}
	//{{{ invoke() method
	public void invoke(View view)
	{
		try
		{
			if(cachedCode == null)
			{
				String cachedCodeName = ""action_"" + sanitizedName;
				cachedCode = BeanShell.cacheBlock(cachedCodeName,code,true);
			}
			BeanShell.runCachedBlock(cachedCode,view,
				new NameSpace(BeanShell.getNameSpace(),
				""BeanShellAction.invoke()""));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);
			new BeanShellErrorDialog(view,e);
		}
	} //}}}
	//{{{ isSelected() method
	public boolean isSelected(Component comp)
	{
		if(isSelected == null)
			return false;
		NameSpace global = BeanShell.getNameSpace();
		try
		{
			if(cachedIsSelected == null)
			{
				String cachedIsSelectedName = ""selected_"" + sanitizedName;
				cachedIsSelected = BeanShell.cacheBlock(cachedIsSelectedName,
					isSelected,true);
			}
			View view = GUIUtilities.getView(comp);
			// undocumented hack to allow browser actions to work.
			// XXX - clean up in 4.3
			global.setVariable(""_comp"",comp);
			return Boolean.TRUE.equals(BeanShell.runCachedBlock(
				cachedIsSelected,view,
				new NameSpace(BeanShell.getNameSpace(),
				""BeanShellAction.isSelected()"")));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);
			// dialogs fuck things up if a menu is visible, etc!
			//new BeanShellErrorDialog(view,e);
			// so that in the future we don't see streams of
			// exceptions
			isSelected = null;
			return false;
		}
		finally
		{
			try
			{
				global.setVariable(""_comp"",null);
			}
			catch(UtilEvalError err)
			{
				Log.log(Log.ERROR,this,err);
			}
		}
	} //}}}
	//{{{ noRepeat() method
	public boolean noRepeat()
	{
		return noRepeat;
	} //}}}
	//{{{ noRecord() method
	public boolean noRecord()
	{
		return noRecord;
	} //}}}
	//{{{ noRememberLast() method
	/**
	 * Returns if this edit action should not be remembered as the most
	 * recently invoked action.
	 * @since jEdit 4.2pre1
	 */
	public boolean noRememberLast()
	{
		return noRememberLast;
	} //}}}
	//{{{ getCode() method
	public String getCode()
	{
		return code.trim();
	} //}}}
	//{{{ Private members
	private boolean noRepeat;
	private boolean noRecord;
	private boolean noRememberLast;
	private String code;
	private String isSelected;
	private BshMethod cachedCode;
	private BshMethod cachedIsSelected;
	private String sanitizedName;
	//}}}
}
"
org.gjt.sp.jedit.Buffer,"/*
 * Buffer.java - jEdit buffer
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2004 Slava Pestov
 * Portions copyright (C) 1999, 2000 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import gnu.regexp.*;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.Toolkit;
import java.io.File;
import java.io.IOException;
import java.net.Socket;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.RESearchMatcher;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.*;
//}}}
/**
 * A <code>Buffer</code> represents the contents of an open text
 * file as it is maintained in the computer's memory (as opposed to
 * how it may be stored on a disk).<p>
 *
 * In a BeanShell script, you can obtain the current buffer instance from the
 * <code>buffer</code> variable.<p>
 *
 * This class does not have a public constructor.
 * Buffers can be opened and closed using methods in the <code>jEdit</code>
 * class.<p>
 *
 * This class is partially thread-safe, however you must pay attention to two
 * very important guidelines:
 * <ul>
 * <li>Changes to a buffer can only be made from the AWT thread.
 * <li>When accessing the buffer from another thread, you must
 * grab a read lock if you plan on performing more than one call, to ensure that
 * the buffer contents are not changed by the AWT thread for the duration of the
 * lock. Only methods whose descriptions specify thread safety can be invoked
 * from other threads.
 * </ul>
 *
 * @author Slava Pestov
 * @version $Id: Buffer.java,v 1.218 2004/06/04 00:18:34 spestov Exp $
 */
public class Buffer
{
	//{{{ Some constants
	/**
	 * Line separator property.
	 */
	public static final String LINESEP = ""lineSeparator"";
	/**
	 * Backed up property.
	 * @since jEdit 3.2pre2
	 */
	public static final String BACKED_UP = ""Buffer__backedUp"";
	/**
	 * Caret info properties.
	 * @since jEdit 3.2pre1
	 */
	public static final String CARET = ""Buffer__caret"";
	public static final String SELECTION = ""Buffer__selection"";
	/**
	 * This should be a physical line number, so that the scroll
	 * position is preserved correctly across reloads (which will
	 * affect virtual line numbers, due to fold being reset)
	 */
	public static final String SCROLL_VERT = ""Buffer__scrollVert"";
	public static final String SCROLL_HORIZ = ""Buffer__scrollHoriz"";
	/**
	 * Character encoding used when loading and saving.
	 * @since jEdit 3.2pre4
	 */
	public static final String ENCODING = ""encoding"";
	/**
	 * Should jEdit try to set the encoding based on a UTF8, UTF16 or
	 * XML signature at the beginning of the file?
	 */
	public static final String ENCODING_AUTODETECT = ""encodingAutodetect"";
	/**
	 * This property is set to 'true' if the file has a trailing newline.
	 * @since jEdit 4.0pre1
	 */
	public static final String TRAILING_EOL = ""trailingEOL"";
	/**
	 * This property is set to 'true' if the file should be GZipped.
	 * @since jEdit 4.0pre4
	 */
	public static final String GZIPPED = ""gzipped"";
	//}}}
	//{{{ Input/output methods
	//{{{ reload() method
	/**
	 * Reloads the buffer from disk, asking for confirmation if the buffer
	 * has unsaved changes.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public void reload(View view)
	{
		if(getFlag(DIRTY))
		{
			String[] args = { path };
			int result = GUIUtilities.confirm(view,""changedreload"",
				args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		view.getEditPane().saveCaretInfo();
		load(view,true);
	} //}}}
	//{{{ load() method
	/**
	 * Loads the buffer from disk, even if it is loaded already.
	 * @param view The view
	 * @param reload If true, user will not be asked to recover autosave
	 * file, if any
	 *
	 * @since 2.5pre1
	 */
	public boolean load(final View view, final boolean reload)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);
		setFlag(LOADING,true);
		// view text areas temporarily blank out while a buffer is
		// being loaded, to indicate to the user that there is no
		// data available yet.
		if(!getFlag(TEMPORARY))
			EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));
		final boolean loadAutosave;
		if(reload || !getFlag(NEW_FILE))
		{
			if(file != null)
				modTime = file.lastModified();
			// Only on initial load
			if(!reload && autosaveFile != null && autosaveFile.exists())
				loadAutosave = recoverAutosave(view);
			else
			{
				if(autosaveFile != null)
					autosaveFile.delete();
				loadAutosave = false;
			}
			if(!loadAutosave)
			{
				VFS vfs = VFSManager.getVFSForPath(path);
				if(!checkFileForLoad(view,vfs,path))
				{
					setFlag(LOADING,false);
					return false;
				}
				// have to check again since above might set
				// NEW_FILE flag
				if(reload || !getFlag(NEW_FILE))
				{
					if(!vfs.load(view,this,path))
					{
						setFlag(LOADING,false);
						return false;
					}
				}
			}
		}
		else
			loadAutosave = false;
		//{{{ Do some stuff once loading is finished
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				String newPath = getStringProperty(
					BufferIORequest.NEW_PATH);
				Segment seg = (Segment)getProperty(
					BufferIORequest.LOAD_DATA);
				IntegerArray endOffsets = (IntegerArray)
					getProperty(BufferIORequest.END_OFFSETS);
				if(seg == null)
					seg = new Segment(new char[1024],0,0);
				if(endOffsets == null)
				{
					endOffsets = new IntegerArray();
					endOffsets.add(1);
				}
				try
				{
					writeLock();
					// For `reload' command
					firePreContentRemoved(0,0,getLineCount()
						- 1,getLength());
					contentMgr.remove(0,getLength());
					lineMgr.contentRemoved(0,0,getLineCount()
						- 1,getLength());
					positionMgr.contentRemoved(0,getLength());
					fireContentRemoved(0,0,getLineCount()
						- 1,getLength());
					// theoretically a segment could
					// have seg.offset != 0 but
					// SegmentBuffer never does that
					contentMgr._setContent(seg.array,seg.count);
					lineMgr._contentInserted(endOffsets);
					positionMgr.contentInserted(0,seg.count);
					fireContentInserted(0,0,
						endOffsets.getSize() - 1,
						seg.count - 1);
				}
				finally
				{
					writeUnlock();
				}
				unsetProperty(BufferIORequest.LOAD_DATA);
				unsetProperty(BufferIORequest.END_OFFSETS);
				unsetProperty(BufferIORequest.NEW_PATH);
				undoMgr.clear();
				undoMgr.setLimit(jEdit.getIntegerProperty(
					""buffer.undoCount"",100));
				if(!getFlag(TEMPORARY))
					finishLoading();
				setFlag(LOADING,false);
				// if reloading a file, clear dirty flag
				if(reload)
					setDirty(false);
				if(!loadAutosave && newPath != null)
					setPath(newPath);
				// if loadAutosave is false, we loaded an
				// autosave file, so we set 'dirty' to true
				// note that we don't use setDirty(),
				// because a) that would send an unnecessary
				// message, b) it would also set the
				// AUTOSAVE_DIRTY flag, which will make
				// the autosave thread write out a
				// redundant autosave file
				if(loadAutosave)
					setFlag(DIRTY,true);
				// send some EditBus messages
				if(!getFlag(TEMPORARY))
				{
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.LOADED));
					//EditBus.send(new BufferUpdate(Buffer.this,
					//	view,BufferUpdate.MARKERS_CHANGED));
				}
			}
		}; //}}}
		if(getFlag(TEMPORARY))
			runnable.run();
		else
			VFSManager.runInAWTThread(runnable);
		return true;
	} //}}}
	//{{{ insertFile() method
	/**
	 * Loads a file from disk, and inserts it into this buffer.
	 * @param view The view
	 *
	 * @since 4.0pre1
	 */
	public boolean insertFile(final View view, String path)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);
		path = MiscUtilities.constructPath(this.path,path);
		Buffer buffer = jEdit.getBuffer(path);
		if(buffer != null)
		{
			view.getTextArea().setSelectedText(
				buffer.getText(0,buffer.getLength()));
			return true;
		}
		VFS vfs = VFSManager.getVFSForPath(path);
		// this returns false if initial sanity
		// checks (if the file is a directory, etc)
		// fail
		return vfs.insert(view,this,path);
	} //}}}
	//{{{ autosave() method
	/**
	 * Autosaves this buffer.
	 */
	public void autosave()
	{
		if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)
			|| !getFlag(DIRTY)
			|| getFlag(LOADING)
			|| getFlag(IO))
			return;
		setFlag(AUTOSAVE_DIRTY,false);
		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.AUTOSAVE,null,this,null,
			VFSManager.getFileVFS(),autosaveFile.getPath()));
	} //}}}
	//{{{ saveAs() method
	/**
	 * Prompts the user for a file to save this buffer to.
	 * @param view The view
	 * @param rename True if the buffer's path should be changed, false
	 * if only a copy should be saved to the specified filename
	 * @since jEdit 2.6pre5
	 */
	public boolean saveAs(View view, boolean rename)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,path,
			VFSBrowser.SAVE_DIALOG,false);
		// files[] should have length 1, since the dialog type is
		// SAVE_DIALOG
		if(files == null)
			return false;
		return save(view,files[0],rename);
	} //}}}
	//{{{ save() method
	/**
	 * Saves this buffer to the specified path name, or the current path
	 * name if it's null.
	 * @param view The view
	 * @param path The path name to save the buffer to, or null to use
	 * the existing path
	 */
	public boolean save(View view, String path)
	{
		return save(view,path,true);
	} //}}}
	//{{{ save() method
	/**
	 * Saves this buffer to the specified path name, or the current path
	 * name if it's null.
	 * @param view The view
	 * @param path The path name to save the buffer to, or null to use
	 * the existing path
	 * @param rename True if the buffer's path should be changed, false
	 * if only a copy should be saved to the specified filename
	 * @since jEdit 2.6pre5
	 */
	public boolean save(final View view, String path, final boolean rename)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);
		if(path == null && getFlag(NEW_FILE))
			return saveAs(view,rename);
		if(path == null && file != null)
		{
			long newModTime = file.lastModified();
			if(newModTime != modTime
				&& jEdit.getBooleanProperty(""view.checkModStatus""))
			{
				Object[] args = { this.path };
				int result = GUIUtilities.confirm(view,
					""filechanged-save"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				if(result != JOptionPane.YES_OPTION)
					return false;
			}
		}
		EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));
		setFlag(IO,true);
		final String oldPath = this.path;
		final String oldSymlinkPath = this.symlinkPath;
		final String newPath = (path == null ? this.path : path);
		VFS vfs = VFSManager.getVFSForPath(newPath);
		if(!checkFileForSave(view,vfs,newPath))
		{
			setFlag(IO,false);
			return false;
		}
		if(!vfs.save(view,this,newPath))
		{
			setFlag(IO,false);
			return false;
		}
		// Once save is complete, do a few other things
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setFlag(IO,false);
				finishSaving(view,oldPath,oldSymlinkPath,
					newPath,rename,getBooleanProperty(
					BufferIORequest.ERROR_OCCURRED));
			}
		});
		return true;
	} //}}}
	//{{{ checkFileStatus() method
	public static final int FILE_NOT_CHANGED = 0;
	public static final int FILE_CHANGED = 1;
	public static final int FILE_DELETED = 2;
	/**
	 * Check if the buffer has changed on disk.
	 * @return One of <code>NOT_CHANGED</code>, <code>CHANGED</code>, or
	 * <code>DELETED</code>.
	 *
	 * @since jEdit 4.2pre1
	 */
	public int checkFileStatus(View view)
	{
		// - don't do these checks while a save is in progress,
		// because for a moment newModTime will be greater than
		// oldModTime, due to the multithreading
		// - only supported on local file system
		if(!getFlag(IO) && !getFlag(LOADING) && file != null
			&& !getFlag(NEW_FILE))
		{
			boolean newReadOnly = (file.exists() && !file.canWrite());
			if(newReadOnly != getFlag(READ_ONLY))
			{
				setFlag(READ_ONLY,newReadOnly);
				EditBus.send(new BufferUpdate(this,null,
					BufferUpdate.DIRTY_CHANGED));
			}
			long oldModTime = modTime;
			long newModTime = file.lastModified();
			if(newModTime != oldModTime)
			{
				modTime = newModTime;
				if(!file.exists())
				{
					setFlag(NEW_FILE,true);
					setDirty(true);
					return FILE_DELETED;
				}
				else
				{
					return FILE_CHANGED;
				}
			}
		}
		return FILE_NOT_CHANGED;
	} //}}}
	//}}}
	//{{{ Getters/setter methods for various buffer meta-data
	//{{{ getLastModified() method
	/**
	 * Returns the last time jEdit modified the file on disk.
	 * This method is thread-safe.
	 */
	public long getLastModified()
	{
		return modTime;
	} //}}}
	//{{{ setLastModified() method
	/**
	 * Sets the last time jEdit modified the file on disk.
	 * @param modTime The new modification time
	 */
	public void setLastModified(long modTime)
	{
		this.modTime = modTime;
	} //}}}
	//{{{ getVFS() method
	/**
	 * Returns the virtual filesystem responsible for loading and
	 * saving this buffer. This method is thread-safe.
	 */
	public VFS getVFS()
	{
		return VFSManager.getVFSForPath(path);
	} //}}}
	//{{{ getAutosaveFile() method
	/**
	 * Returns the autosave file for this buffer. This may be null if
	 * the file is non-local.
	 */
	public File getAutosaveFile()
	{
		return autosaveFile;
	} //}}}
	//{{{ getName() method
	/**
	 * Returns the name of this buffer. This method is thread-safe.
	 */
	public String getName()
	{
		return name;
	} //}}}
	//{{{ getPath() method
	/**
	 * Returns the path name of this buffer. This method is thread-safe.
	 */
	public String getPath()
	{
		return path;
	} //}}}
	//{{{ getSymlinkPath() method
	/**
	 * If this file is a symbolic link, returns the link destination.
	 * Otherwise returns the file's path. This method is thread-safe.
	 * @since jEdit 4.2pre1
	 */
	public String getSymlinkPath()
	{
		return symlinkPath;
	} //}}}
	//{{{ getDirectory() method
	/**
	 * Returns the directory containing this buffer.
	 * @since jEdit 4.1pre11
	 */
	public String getDirectory()
	{
		return directory;
	} //}}}
	//{{{ isClosed() method
	/**
	 * Returns true if this buffer has been closed with
	 * {@link org.gjt.sp.jedit.jEdit#closeBuffer(View,Buffer)}.
	 * This method is thread-safe.
	 */
	public boolean isClosed()
	{
		return getFlag(CLOSED);
	} //}}}
	//{{{ isLoaded() method
	/**
	 * Returns true if the buffer is loaded. This method is thread-safe.
	 */
	public boolean isLoaded()
	{
		return !getFlag(LOADING);
	} //}}}
	//{{{ isPerformingIO() method
	/**
	 * Returns true if the buffer is currently performing I/O.
	 * This method is thread-safe.
	 * @since jEdit 2.7pre1
	 */
	public boolean isPerformingIO()
	{
		return getFlag(LOADING) || getFlag(IO);
	} //}}}
	//{{{ isNewFile() method
	/**
	 * Returns whether this buffer lacks a corresponding version on disk.
	 * This method is thread-safe.
	 */
	public boolean isNewFile()
	{
		return getFlag(NEW_FILE);
	} //}}}
	//{{{ setNewFile() method
	/**
	 * Sets the new file flag.
	 * @param newFile The new file flag
	 */
	public void setNewFile(boolean newFile)
	{
		setFlag(NEW_FILE,newFile);
		if(!newFile)
			setFlag(UNTITLED,false);
	} //}}}
	//{{{ isUntitled() method
	/**
	 * Returns true if this file is 'untitled'. This method is thread-safe.
	 */
	public boolean isUntitled()
	{
		return getFlag(UNTITLED);
	} //}}}
	//{{{ isDirty() method
	/**
	 * Returns whether there have been unsaved changes to this buffer.
	 * This method is thread-safe.
	 */
	public boolean isDirty()
	{
		return getFlag(DIRTY);
	} //}}}
	//{{{ isReadOnly() method
	/**
	 * Returns true if this file is read only, false otherwise.
	 * This method is thread-safe.
	 */
	public boolean isReadOnly()
	{
		return getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE);
	} //}}}
	//{{{ isEditable() method
	/**
	 * Returns true if this file is editable, false otherwise. A file may
	 * become uneditable if it is read only, or if I/O is in progress.
	 * This method is thread-safe.
	 * @since jEdit 2.7pre1
	 */
	public boolean isEditable()
	{
		return !(getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE)
			|| getFlag(IO) || getFlag(LOADING));
	} //}}}
	//{{{ setReadOnly() method
	/**
	 * Sets the read only flag.
	 * @param readOnly The read only flag
	 */
	public void setReadOnly(boolean readOnly)
	{
		setFlag(READ_ONLY_OVERRIDE,readOnly);
	} //}}}
	//{{{ setDirty() method
	/**
	 * Sets the 'dirty' (changed since last save) flag of this buffer.
	 */
	public void setDirty(boolean d)
	{
		boolean old_d = getFlag(DIRTY);
		boolean editable = isEditable();
		if(d)
		{
			if(editable)
			{
				setFlag(DIRTY,true);
				setFlag(AUTOSAVE_DIRTY,true);
			}
		}
		else
		{
			setFlag(DIRTY,false);
			setFlag(AUTOSAVE_DIRTY,false);
			if(autosaveFile != null)
				autosaveFile.delete();
			// fixes dirty flag not being reset on
			// save/insert/undo/redo/undo
			if(!getFlag(UNDO_IN_PROGRESS))
			{
				// this ensures that undo can clear the dirty flag properly
				// when all edits up to a save are undone
				undoMgr.bufferSaved();
			}
		}
		if(d != old_d && editable)
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.DIRTY_CHANGED));
		}
	} //}}}
	//{{{ isTemporary() method
	/**
	 * Returns if this is a temporary buffer. This method is thread-safe.
	 * @see jEdit#openTemporary(View,String,String,boolean)
	 * @see jEdit#commitTemporary(Buffer)
	 * @since jEdit 2.2pre7
	 */
	public boolean isTemporary()
	{
		return getFlag(TEMPORARY);
	} //}}}
	//{{{ getIcon() method
	/**
	 * Returns this buffer's icon.
	 * @since jEdit 2.6pre6
	 */
	public Icon getIcon()
	{
		if(getFlag(DIRTY))
			return GUIUtilities.loadIcon(""dirty.gif"");
		else if(getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE))
			return GUIUtilities.loadIcon(""readonly.gif"");
		else if(getFlag(NEW_FILE))
			return GUIUtilities.loadIcon(""new.gif"");
		else
			return GUIUtilities.loadIcon(""normal.gif"");
	} //}}}
	//}}}
	//{{{ Thread safety
	//{{{ readLock() method
	/**
	 * The buffer is guaranteed not to change between calls to
	 * {@link #readLock()} and {@link #readUnlock()}.
	 */
	public void readLock()
	{
		lock.readLock();
	} //}}}
	//{{{ readUnlock() method
	/**
	 * The buffer is guaranteed not to change between calls to
	 * {@link #readLock()} and {@link #readUnlock()}.
	 */
	public void readUnlock()
	{
		lock.readUnlock();
	} //}}}
	//{{{ writeLock() method
	/**
	 * Attempting to obtain read lock will block between calls to
	 * {@link #writeLock()} and {@link #writeUnlock()}.
	 */
	public void writeLock()
	{
		lock.writeLock();
	} //}}}
	//{{{ writeUnlock() method
	/**
	 * Attempting to obtain read lock will block between calls to
	 * {@link #writeLock()} and {@link #writeUnlock()}.
	 */
	public void writeUnlock()
	{
		lock.writeUnlock();
	} //}}}
	//}}}
	//{{{ Line offset methods
	//{{{ getLength() method
	/**
	 * Returns the number of characters in the buffer. This method is thread-safe.
	 */
	public int getLength()
	{
		// no need to lock since this just returns a value and that's it
		return contentMgr.getLength();
	} //}}}
	//{{{ getLineCount() method
	/**
	 * Returns the number of physical lines in the buffer.
	 * This method is thread-safe.
	 * @since jEdit 3.1pre1
	 */
	public int getLineCount()
	{
		// no need to lock since this just returns a value and that's it
		return lineMgr.getLineCount();
	} //}}}
	//{{{ getLineOfOffset() method
	/**
	 * Returns the line containing the specified offset.
	 * This method is thread-safe.
	 * @param offset The offset
	 * @since jEdit 4.0pre1
	 */
	public int getLineOfOffset(int offset)
	{
		try
		{
			readLock();
			if(offset < 0 || offset > getLength())
				throw new ArrayIndexOutOfBoundsException(offset);
			return lineMgr.getLineOfOffset(offset);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getLineStartOffset() method
	/**
	 * Returns the start offset of the specified line.
	 * This method is thread-safe.
	 * @param line The line
	 * @return The start offset of the specified line
	 * @since jEdit 4.0pre1
	 */
	public int getLineStartOffset(int line)
	{
		try
		{
			readLock();
			if(line < 0 || line >= lineMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);
			else if(line == 0)
				return 0;
			return lineMgr.getLineEndOffset(line - 1);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getLineEndOffset() method
	/**
	 * Returns the end offset of the specified line.
	 * This method is thread-safe.
	 * @param line The line
	 * @return The end offset of the specified line
	 * invalid.
	 * @since jEdit 4.0pre1
	 */
	public int getLineEndOffset(int line)
	{
		try
		{
			readLock();
			if(line < 0 || line >= lineMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);
			return lineMgr.getLineEndOffset(line);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getLineLength() method
	/**
	 * Returns the length of the specified line.
	 * This method is thread-safe.
	 * @param line The line
	 * @since jEdit 4.0pre1
	 */
	public int getLineLength(int line)
	{
		try
		{
			readLock();
			return getLineEndOffset(line)
				- getLineStartOffset(line) - 1;
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ invalidateCachedScreenLineCounts() method
	/**
	 * Invalidates all cached screen line count information.
	 * @since jEdit 4.2pre7.
	 */
	public void invalidateCachedScreenLineCounts()
	{
		lineMgr.invalidateScreenLineCounts();
	} //}}}
	//}}}
	//{{{ Text getters and setters
	//{{{ getLineText() method
	/**
	 * Returns the text on the specified line.
	 * This method is thread-safe.
	 * @param line The line
	 * @return The text, or null if the line is invalid
	 * @since jEdit 4.0pre1
	 */
	public String getLineText(int line)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);
		try
		{
			readLock();
			int start = (line == 0 ? 0
				: lineMgr.getLineEndOffset(line - 1));
			int end = lineMgr.getLineEndOffset(line);
			return getText(start,end - start - 1);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getLineText() method
	/**
	 * Returns the specified line in a <code>Segment</code>.<p>
	 *
	 * Using a <classname>Segment</classname> is generally more
	 * efficient than using a <classname>String</classname> because it
	 * results in less memory allocation and array copying.<p>
	 *
	 * This method is thread-safe.
	 *
	 * @param line The line
	 * @since jEdit 4.0pre1
	 */
	public void getLineText(int line, Segment segment)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);
		try
		{
			readLock();
			int start = (line == 0 ? 0
				: lineMgr.getLineEndOffset(line - 1));
			int end = lineMgr.getLineEndOffset(line);
			getText(start,end - start - 1,segment);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getText() method
	/**
	 * Returns the specified text range. This method is thread-safe.
	 * @param start The start offset
	 * @param length The number of characters to get
	 */
	public String getText(int start, int length)
	{
		try
		{
			readLock();
			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);
			return contentMgr.getText(start,length);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getText() method
	/**
	 * Returns the specified text range in a <code>Segment</code>.<p>
	 *
	 * Using a <classname>Segment</classname> is generally more
	 * efficient than using a <classname>String</classname> because it
	 * results in less memory allocation and array copying.<p>
	 *
	 * This method is thread-safe.
	 *
	 * @param start The start offset
	 * @param length The number of characters to get
	 * @param seg The segment to copy the text to
	 */
	public void getText(int start, int length, Segment seg)
	{
		try
		{
			readLock();
			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);
			contentMgr.getText(start,length,seg);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ insert() method
	/**
	 * Inserts a string into the buffer.
	 * @param offset The offset
	 * @param str The string
	 * @since jEdit 4.0pre1
	 */
	public void insert(int offset, String str)
	{
		if(str == null)
			return;
		int len = str.length();
		if(len == 0)
			return;
		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");
		try
		{
			writeLock();
			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);
			contentMgr.insert(offset,str);
			integerArray.clear();
			for(int i = 0; i < len; i++)
			{
				if(str.charAt(i) == '\n')
					integerArray.add(i + 1);
			}
			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentInserted(offset,len,str,
					!getFlag(DIRTY));
			}
			contentInserted(offset,len,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} //}}}
	//{{{ insert() method
	/**
	 * Inserts a string into the buffer.
	 * @param offset The offset
	 * @param seg The segment
	 * @since jEdit 4.0pre1
	 */
	public void insert(int offset, Segment seg)
	{
		if(seg.count == 0)
			return;
		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");
		try
		{
			writeLock();
			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);
			contentMgr.insert(offset,seg);
			integerArray.clear();
			for(int i = 0; i < seg.count; i++)
			{
				if(seg.array[seg.offset + i] == '\n')
					integerArray.add(i + 1);
			}
			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentInserted(offset,seg.count,
					seg.toString(),!getFlag(DIRTY));
			}
			contentInserted(offset,seg.count,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} //}}}
	//{{{ remove() method
	/**
	 * Removes the specified rang efrom the buffer.
	 * @param offset The start offset
	 * @param length The number of characters to remove
	 */
	public void remove(int offset, int length)
	{
		if(length == 0)
			return;
		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");
		try
		{
			setFlag(TRANSACTION,true);
			writeLock();
			if(offset < 0 || length < 0
				|| offset + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset + "":"" + length);
			int startLine = lineMgr.getLineOfOffset(offset);
			int endLine = lineMgr.getLineOfOffset(offset + length);
			int numLines = endLine - startLine;
			if(!getFlag(UNDO_IN_PROGRESS) && !getFlag(LOADING))
			{
				undoMgr.contentRemoved(offset,length,
					getText(offset,length),
					!getFlag(DIRTY));
			}
			firePreContentRemoved(startLine,offset,numLines,length);
			contentMgr.remove(offset,length);
			lineMgr.contentRemoved(startLine,offset,numLines,length);
			positionMgr.contentRemoved(offset,length);
			fireContentRemoved(startLine,offset,numLines,length);
			/* otherwise it will be delivered later */
			if(!getFlag(UNDO_IN_PROGRESS) && !insideCompoundEdit())
				fireTransactionComplete();
			setDirty(true);
		}
		finally
		{
			setFlag(TRANSACTION,false);
			writeUnlock();
		}
	} //}}}
	//}}}
	//{{{ Undo
	//{{{ undo() method
	/**
	 * Undoes the most recent edit.
	 *
	 * @since jEdit 4.0pre1
	 */
	public void undo(JEditTextArea textArea)
	{
		if(undoMgr == null)
			return;
		if(!isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}
		try
		{
			writeLock();
			setFlag(UNDO_IN_PROGRESS,true);
			int caret = undoMgr.undo();
			if(caret == -1)
				textArea.getToolkit().beep();
			else
				textArea.setCaretPosition(caret);
			fireTransactionComplete();
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);
			writeUnlock();
		}
	} //}}}
	//{{{ redo() method
	/**
	 * Redoes the most recently undone edit.
	 *
	 * @since jEdit 2.7pre2
	 */
	public void redo(JEditTextArea textArea)
	{
		if(undoMgr == null)
			return;
		if(!isEditable())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		try
		{
			writeLock();
			setFlag(UNDO_IN_PROGRESS,true);
			int caret = undoMgr.redo();
			if(caret == -1)
				textArea.getToolkit().beep();
			else
				textArea.setCaretPosition(caret);
			fireTransactionComplete();
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);
			writeUnlock();
		}
	} //}}}
	//{{{ isTransactionInProgress() method
	/**
	 * Returns if an undo or compound edit is currently in progress. If this
	 * method returns true, then eventually a
	 * {@link org.gjt.sp.jedit.buffer.BufferChangeListener#transactionComplete(Buffer)}
	 * buffer event will get fired.
	 * @since jEdit 4.0pre6
	 */
	public boolean isTransactionInProgress()
	{
		return getFlag(TRANSACTION)
			|| getFlag(UNDO_IN_PROGRESS)
			|| insideCompoundEdit();
	} //}}}
	//{{{ beginCompoundEdit() method
	/**
	 * Starts a compound edit. All edits from now on until
	 * {@link #endCompoundEdit()} are called will be merged
	 * into one. This can be used to make a complex operation
	 * undoable in one step. Nested calls to
	 * {@link #beginCompoundEdit()} behave as expected,
	 * requiring the same number of {@link #endCompoundEdit()}
	 * calls to end the edit.
	 * @see #endCompoundEdit()
	 */
	public void beginCompoundEdit()
	{
		// Why?
		//if(getFlag(TEMPORARY))
		//	return;
		try
		{
			writeLock();
			undoMgr.beginCompoundEdit();
		}
		finally
		{
			writeUnlock();
		}
	} //}}}
	//{{{ endCompoundEdit() method
	/**
	 * Ends a compound edit. All edits performed since
	 * {@link #beginCompoundEdit()} was called can now
	 * be undone in one step by calling {@link #undo(JEditTextArea)}.
	 * @see #beginCompoundEdit()
	 */
	public void endCompoundEdit()
	{
		// Why?
		//if(getFlag(TEMPORARY))
		//	return;
		try
		{
			writeLock();
			undoMgr.endCompoundEdit();
			if(!insideCompoundEdit())
				fireTransactionComplete();
		}
		finally
		{
			writeUnlock();
		}
	}//}}}
	//{{{ insideCompoundEdit() method
	/**
	 * Returns if a compound edit is currently active.
	 * @since jEdit 3.1pre1
	 */
	public boolean insideCompoundEdit()
	{
		return undoMgr.insideCompoundEdit();
	} //}}}
	//}}}
	//{{{ Buffer events
	public static final int NORMAL_PRIORITY = 0;
	public static final int HIGH_PRIORITY = 1;
	static class Listener
	{
		BufferChangeListener listener;
		int priority;
		Listener(BufferChangeListener listener, int priority)
		{
			this.listener = listener;
			this.priority = priority;
		}
	}
	//{{{ addBufferChangeListener() method
	/**
	 * Adds a buffer change listener.
	 * @param listener The listener
	 * @param priority Listeners with HIGH_PRIORITY get the event before
	 * listeners with NORMAL_PRIORITY
	 * @since jEdit 4.2pre2
	 */
	public void addBufferChangeListener(BufferChangeListener listener,
		int priority)
	{
		Listener l = new Listener(listener,priority);
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			Listener _l = (Listener)bufferListeners.get(i);
			if(_l.priority < priority)
			{
				bufferListeners.insertElementAt(l,i);
				return;
			}
		}
		bufferListeners.addElement(l);
	} //}}}
	//{{{ addBufferChangeListener() method
	/**
	 * Adds a buffer change listener.
	 * @param listener The listener
	 * @since jEdit 4.0pre1
	 */
	public void addBufferChangeListener(BufferChangeListener listener)
	{
		addBufferChangeListener(listener,NORMAL_PRIORITY);
	} //}}}
	//{{{ removeBufferChangeListener() method
	/**
	 * Removes a buffer change listener.
	 * @param listener The listener
	 * @since jEdit 4.0pre1
	 */
	public void removeBufferChangeListener(BufferChangeListener listener)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			if(((Listener)bufferListeners.get(i)).listener == listener)
			{
				bufferListeners.removeElementAt(i);
				return;
			}
		}
	} //}}}
	//{{{ getBufferChangeListeners() method
	/**
	 * Returns an array of registered buffer change listeners.
	 * @since jEdit 4.1pre3
	 */
	public BufferChangeListener[] getBufferChangeListeners()
	{
		BufferChangeListener[] returnValue
			= new BufferChangeListener[
			bufferListeners.size()];
		for(int i = 0; i < returnValue.length; i++)
		{
			returnValue[i] = ((Listener)bufferListeners.get(i))
				.listener;
		}
		return returnValue;
	} //}}}
	//}}}
	//{{{ Property methods
	//{{{ propertiesChanged() method
	/**
	 * Reloads settings from the properties. This should be called
	 * after the <code>syntax</code> or <code>folding</code>
	 * buffer-local properties are changed.
	 */
	public void propertiesChanged()
	{
		String folding = getStringProperty(""folding"");
		FoldHandler handler = FoldHandler.getFoldHandler(folding);
		if(handler != null)
		{
			setFoldHandler(handler);
		}
		else
		{
			if (folding != null)
				Log.log(Log.WARNING, this, path + "": invalid 'folding' property: "" + folding);
			setFoldHandler(new DummyFoldHandler());
		}
		EditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));
	} //}}}
	//{{{ getTabSize() method
	/**
	 * Returns the tab size used in this buffer. This is equivalent
	 * to calling <code>getProperty(""tabSize"")</code>.
	 * This method is thread-safe.
	 */
	public int getTabSize()
	{
		int tabSize = getIntegerProperty(""tabSize"",8);
		if(tabSize <= 0)
			return 8;
		else
			return tabSize;
	} //}}}
	//{{{ getIndentSize() method
	/**
	 * Returns the indent size used in this buffer. This is equivalent
	 * to calling <code>getProperty(""indentSize"")</code>.
	 * This method is thread-safe.
	 * @since jEdit 2.7pre1
	 */
	public int getIndentSize()
	{
		int indentSize = getIntegerProperty(""indentSize"",8);
		if(indentSize <= 0)
			return 8;
		else
			return indentSize;
	} //}}}
	//{{{ getProperty() method
	/**
	 * Returns the value of a buffer-local property.<p>
	 *
	 * Using this method is generally discouraged, because it returns an
	 * <code>Object</code> which must be cast to another type
	 * in order to be useful, and this can cause problems if the object
	 * is of a different type than what the caller expects.<p>
	 *
	 * The following methods should be used instead:
	 * <ul>
	 * <li>{@link #getStringProperty(String)}</li>
	 * <li>{@link #getBooleanProperty(String)}</li>
	 * <li>{@link #getIntegerProperty(String,int)}</li>
	 * <li>{@link #getRegexpProperty(String,int,gnu.regexp.RESyntax)}</li>
	 * </ul>
	 *
	 * This method is thread-safe.
	 *
	 * @param name The property name. For backwards compatibility, this
	 * is an <code>Object</code>, not a <code>String</code>.
	 */
	public Object getProperty(Object name)
	{
		synchronized(propertyLock)
		{
			// First try the buffer-local properties
			PropValue o = (PropValue)properties.get(name);
			if(o != null)
				return o.value;
			// For backwards compatibility
			if(!(name instanceof String))
				return null;
			// Now try mode.<mode>.<property>
			if(mode != null)
			{
				Object retVal = mode.getProperty((String)name);
				if(retVal == null)
					return null;
				properties.put(name,new PropValue(retVal,true));
				return retVal;
			}
			else
			{
				// Now try buffer.<property>
				String value = jEdit.getProperty(""buffer."" + name);
				if(value == null)
					return null;
				// Try returning it as an integer first
				Object retVal;
				try
				{
					retVal = new Integer(value);
				}
				catch(NumberFormatException nf)
				{
					retVal = value;
				}
				properties.put(name,new PropValue(retVal,true));
				return retVal;
			}
		}
	} //}}}
	//{{{ setProperty() method
	/**
	 * Sets the value of a buffer-local property.
	 * @param name The property name
	 * @param value The property value
	 * @since jEdit 4.0pre1
	 */
	public void setProperty(String name, Object value)
	{
		if(value == null)
			properties.remove(name);
		else
		{
			PropValue test = (PropValue)properties.get(name);
			if(test == null)
				properties.put(name,new PropValue(value,false));
			else if(test.value.equals(value))
			{
				// do nothing
			}
			else
			{
				test.value = value;
				test.defaultValue = false;
			}
		}
	} //}}}
	//{{{ unsetProperty() method
	/**
	 * Clears the value of a buffer-local property.
	 * @param name The property name
	 * @since jEdit 4.0pre1
	 */
	public void unsetProperty(String name)
	{
		properties.remove(name);
	} //}}}
	//{{{ getStringProperty() method
	/**
	 * Returns the value of a string property. This method is thread-safe.
	 * @param name The property name
	 * @since jEdit 4.0pre1
	 */
	public String getStringProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj != null)
			return obj.toString();
		else
			return null;
	} //}}}
	//{{{ setStringProperty() method
	/**
	 * Sets a string property.
	 * @param name The property name
	 * @param value The value
	 * @since jEdit 4.0pre1
	 */
	public void setStringProperty(String name, String value)
	{
		setProperty(name,value);
	} //}}}
	//{{{ getBooleanProperty() method
	/**
	 * Returns the value of a boolean property. This method is thread-safe.
	 * @param name The property name
	 * @since jEdit 4.0pre1
	 */
	public boolean getBooleanProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj instanceof Boolean)
			return ((Boolean)obj).booleanValue();
		else if(""true"".equals(obj) || ""on"".equals(obj) || ""yes"".equals(obj))
			return true;
		else
			return false;
	} //}}}
	//{{{ setBooleanProperty() method
	/**
	 * Sets a boolean property.
	 * @param name The property name
	 * @param value The value
	 * @since jEdit 4.0pre1
	 */
	public void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? Boolean.TRUE : Boolean.FALSE);
	} //}}}
	//{{{ getIntegerProperty() method
	/**
	 * Returns the value of an integer property. This method is thread-safe.
	 * @param name The property name
	 * @since jEdit 4.0pre1
	 */
	public int getIntegerProperty(String name, int defaultValue)
	{
		boolean defaultValueFlag;
		Object obj;
		PropValue value = (PropValue)properties.get(name);
		if(value != null)
		{
			obj = value.value;
			defaultValueFlag = value.defaultValue;
		}
		else
		{
			obj = getProperty(name);
			// will be cached from now on...
			defaultValueFlag = true;
		}
		if(obj == null)
			return defaultValue;
		else if(obj instanceof Number)
			return ((Number)obj).intValue();
		else
		{
			try
			{
				int returnValue = Integer.parseInt(
					obj.toString().trim());
				properties.put(name,new PropValue(
					new Integer(returnValue),
					defaultValueFlag));
				return returnValue;
			}
			catch(Exception e)
			{
				return defaultValue;
			}
		}
	} //}}}
	//{{{ setIntegerProperty() method
	/**
	 * Sets an integer property.
	 * @param name The property name
	 * @param value The value
	 * @since jEdit 4.0pre1
	 */
	public void setIntegerProperty(String name, int value)
	{
		setProperty(name,new Integer(value));
	} //}}}
	//{{{ getRegexpProperty() method
	/**
	 * Returns the value of a property as a regular expression.
	 * This method is thread-safe.
	 * @param name The property name
	 * @param cflags Regular expression compilation flags
	 * @param syntax Regular expression syntax
	 * @since jEdit 4.1pre9
	 */
	public RE getRegexpProperty(String name, int cflags,
		RESyntax syntax) throws REException
	{
		synchronized(propertyLock)
		{
			boolean defaultValueFlag;
			Object obj;
			PropValue value = (PropValue)properties.get(name);
			if(value != null)
			{
				obj = value.value;
				defaultValueFlag = value.defaultValue;
			}
			else
			{
				obj = getProperty(name);
				// will be cached from now on...
				defaultValueFlag = true;
			}
			if(obj == null)
				return null;
			else if(obj instanceof RE)
				return (RE)obj;
			else
			{
				RE re = new RE(obj.toString(),cflags,syntax);
				properties.put(name,new PropValue(re,
					defaultValueFlag));
				return re;
			}
		}
	} //}}}
	//{{{ getRuleSetAtOffset() method
	/**
	 * Returns the syntax highlighting ruleset at the specified offset.
	 * @since jEdit 4.1pre1
	 */
	public ParserRuleSet getRuleSetAtOffset(int offset)
	{
		int line = getLineOfOffset(offset);
		offset -= getLineStartOffset(line);
		if(offset != 0)
			offset--;
		DefaultTokenHandler tokens = new DefaultTokenHandler();
		markTokens(line,tokens);
		Token token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);
		return token.rules;
	} //}}}
	//{{{ getKeywordMapAtOffset() method
	/**
	 * Returns the syntax highlighting keyword map in effect at the
	 * specified offset. Used by the <b>Complete Word</b> command to
	 * complete keywords.
	 * @param offset The offset
	 * @since jEdit 4.0pre3
	 */
	public KeywordMap getKeywordMapAtOffset(int offset)
	{
		return getRuleSetAtOffset(offset).getKeywords();
	} //}}}
	//{{{ getContextSensitiveProperty() method
	/**
	 * Some settings, like comment start and end strings, can
	 * vary between different parts of a buffer (HTML text and inline
	 * JavaScript, for example).
	 * @param offset The offset
	 * @param name The property name
	 * @since jEdit 4.0pre3
	 */
	public String getContextSensitiveProperty(int offset, String name)
	{
		ParserRuleSet rules = getRuleSetAtOffset(offset);
		Object value = null;
		Hashtable rulesetProps = rules.getProperties();
		if(rulesetProps != null)
			value = rulesetProps.get(name);
		if(value == null)
		{
			value = jEdit.getMode(rules.getModeName())
				.getProperty(name);
			if(value == null)
				value = mode.getProperty(name);
		}
		if(value == null)
			return null;
		else
			return String.valueOf(value);
	} //}}}
	//{{{ Used to store property values
	static class PropValue
	{
		PropValue(Object value, boolean defaultValue)
		{
			if(value == null)
				throw new NullPointerException();
			this.value = value;
			this.defaultValue = defaultValue;
		}
		Object value;
		/**
		 * If this is true, then this value is cached from the mode
		 * or global defaults, so when the defaults change this property
		 * value must be reset.
		 */
		boolean defaultValue;
		/**
		 * For debugging purposes.
		 */
		public String toString()
		{
			return value.toString();
		}
	} //}}}
	//{{{ toggleWordWrap() method
	/**
	 * Toggles word wrap between the three available modes. This is used
	 * by the status bar.
	 * @param view We show a message in the view's status bar
	 * @since jEdit 4.1pre3
	 */
	public void toggleWordWrap(View view)
	{
		String wrap = getStringProperty(""wrap"");
		if(wrap.equals(""none""))
			wrap = ""soft"";
		else if(wrap.equals(""soft""))
			wrap = ""hard"";
		else if(wrap.equals(""hard""))
			wrap = ""none"";
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.wrap-changed"",new String[] {
			wrap }));
		setProperty(""wrap"",wrap);
		propertiesChanged();
	} //}}}
	//{{{ toggleLineSeparator() method
	/**
	 * Toggles the line separator between the three available settings.
	 * This is used by the status bar.
	 * @param view We show a message in the view's status bar
	 * @since jEdit 4.1pre3
	 */
	public void toggleLineSeparator(View view)
	{
		String status = null;
		String lineSep = getStringProperty(""lineSeparator"");
		if(""\n"".equals(lineSep))
		{
			status = ""windows"";
			lineSep = ""\r\n"";
		}
		else if(""\r\n"".equals(lineSep))
		{
			status = ""mac"";
			lineSep = ""\r"";
		}
		else if(""\r"".equals(lineSep))
		{
			status = ""unix"";
			lineSep = ""\n"";
		}
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.linesep-changed"",new String[] {
			jEdit.getProperty(""lineSep."" + status) }));
		setProperty(""lineSeparator"",lineSep);
		setDirty(true);
		propertiesChanged();
	} //}}}
	//}}}
	//{{{ Edit modes, syntax highlighting
	//{{{ getMode() method
	/**
	 * Returns this buffer's edit mode. This method is thread-safe.
	 */
	public Mode getMode()
	{
		return mode;
	} //}}}
	//{{{ setMode() method
	/**
	 * Sets this buffer's edit mode. Note that calling this before a buffer
	 * is loaded will have no effect; in that case, set the ""mode"" property
	 * to the name of the mode. A bit inelegant, I know...
	 * @param mode The mode name
	 * @since jEdit 4.2pre1
	 */
	public void setMode(String mode)
	{
		setMode(jEdit.getMode(mode));
	} //}}}
	//{{{ setMode() method
	/**
	 * Sets this buffer's edit mode. Note that calling this before a buffer
	 * is loaded will have no effect; in that case, set the ""mode"" property
	 * to the name of the mode. A bit inelegant, I know...
	 * @param mode The mode
	 */
	public void setMode(Mode mode)
	{
		/* This protects against stupid people (like me)
		 * doing stuff like buffer.setMode(jEdit.getMode(...)); */
		if(mode == null)
			throw new NullPointerException(""Mode must be non-null"");
		this.mode = mode;
		textMode = ""text"".equals(mode.getName());
		setTokenMarker(mode.getTokenMarker());
		resetCachedProperties();
		propertiesChanged();
	} //}}}
	//{{{ setMode() method
	/**
	 * Sets this buffer's edit mode by calling the accept() method
	 * of each registered edit mode.
	 */
	public void setMode()
	{
		String userMode = getStringProperty(""mode"");
		if(userMode != null)
		{
			Mode m = jEdit.getMode(userMode);
			if(m != null)
			{
				setMode(m);
				return;
			}
		}
		String nogzName = name.substring(0,name.length() -
			(name.endsWith("".gz"") ? 3 : 0));
		Mode[] modes = jEdit.getModes();
		String firstLine = getLineText(0);
		// this must be in reverse order so that modes from the user
		// catalog get checked first!
		for(int i = modes.length - 1; i >= 0; i--)
		{
			if(modes[i].accept(nogzName,firstLine))
			{
				setMode(modes[i]);
				return;
			}
		}
		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);
	} //}}}
	//{{{ markTokens() method
	/**
	 * Returns the syntax tokens for the specified line.
	 * @param lineIndex The line number
	 * @param tokenHandler The token handler that will receive the syntax
	 * tokens
	 * @since jEdit 4.1pre1
	 */
	public void markTokens(int lineIndex, TokenHandler tokenHandler)
	{
		Segment seg;
		if(SwingUtilities.isEventDispatchThread())
			seg = this.seg;
		else
			seg = new Segment();
		if(lineIndex < 0 || lineIndex >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(lineIndex);
		int firstInvalidLineContext = lineMgr.getFirstInvalidLineContext();
		int start;
		if(textMode || firstInvalidLineContext == -1)
		{
			start = lineIndex;
		}
		else
		{
			start = Math.min(firstInvalidLineContext,
				lineIndex);
		}
		if(Debug.TOKEN_MARKER_DEBUG)
			Log.log(Log.DEBUG,this,""tokenize from "" + start + "" to "" + lineIndex);
		TokenMarker.LineContext oldContext = null;
		TokenMarker.LineContext context = null;
		for(int i = start; i <= lineIndex; i++)
		{
			getLineText(i,seg);
			oldContext = lineMgr.getLineContext(i);
			TokenMarker.LineContext prevContext = (
				(i == 0 || textMode) ? null
				: lineMgr.getLineContext(i - 1)
			);
			context = tokenMarker.markTokens(prevContext,
				(i == lineIndex ? tokenHandler
				: DummyTokenHandler.INSTANCE),seg);
			lineMgr.setLineContext(i,context);
		}
		int lineCount = lineMgr.getLineCount();
		if(lineCount - 1 == lineIndex)
			lineMgr.setFirstInvalidLineContext(-1);
		else if(oldContext != context)
			lineMgr.setFirstInvalidLineContext(lineIndex + 1);
		else if(firstInvalidLineContext == -1)
			/* do nothing */;
		else
		{
			lineMgr.setFirstInvalidLineContext(Math.max(
				firstInvalidLineContext,lineIndex + 1));
		}
	} //}}}
	//}}}
	//{{{ Indentation
	//{{{ removeTrailingWhiteSpace() method
	/**
	 * Removes trailing whitespace from all lines in the specified list.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void removeTrailingWhiteSpace(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
			{
				int pos, lineStart, lineEnd, tail;
				getLineText(lines[i],seg);
				// blank line
				if (seg.count == 0) continue;
				lineStart = seg.offset;
				lineEnd = seg.offset + seg.count - 1;
				for (pos = lineEnd; pos >= lineStart; pos--)
				{
					if (!Character.isWhitespace(seg.array[pos]))
						break;
				}
				tail = lineEnd - pos;
				// no whitespace
				if (tail == 0) continue;
				remove(getLineEndOffset(lines[i]) - 1 - tail,tail);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} //}}}
	//{{{ shiftIndentLeft() method
	/**
	 * Shifts the indent of each line in the specified list to the left.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void shiftIndentLeft(int[] lines)
	{
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				String line = getLineText(lines[i]);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);
				if(whiteSpace == 0)
					continue;
				int whiteSpaceWidth = Math.max(0,MiscUtilities
					.getLeadingWhiteSpaceWidth(line,tabSize)
					- indentSize);
				insert(lineStart + whiteSpace,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)));
				remove(lineStart,whiteSpace);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} //}}}
	//{{{ shiftIndentRight() method
	/**
	 * Shifts the indent of each line in the specified list to the right.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void shiftIndentRight(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			int tabSize = getTabSize();
			int indentSize = getIndentSize();
			boolean noTabs = getBooleanProperty(""noTabs"");
			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				String line = getLineText(lines[i]);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);
				// silly usability hack
				//if(lines.length != 1 && whiteSpace == 0)
				//	continue;
				int whiteSpaceWidth = MiscUtilities
					.getLeadingWhiteSpaceWidth(
					line,tabSize) + indentSize;
				insert(lineStart + whiteSpace,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)));
				remove(lineStart,whiteSpace);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} //}}}
	//{{{ indentLines() method
	/**
	 * Indents all specified lines.
	 * @param start The first line to indent
	 * @param end The last line to indent
	 * @since jEdit 3.1pre3
	 */
	public void indentLines(int start, int end)
	{
		try
		{
			beginCompoundEdit();
			for(int i = start; i <= end; i++)
				indentLine(i,true);
		}
		finally
		{
			endCompoundEdit();
		}
	} //}}}
	//{{{ indentLines() method
	/**
	 * Indents all specified lines.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void indentLines(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
				indentLine(lines[i],true);
		}
		finally
		{
			endCompoundEdit();
		}
	} //}}}
	//{{{ indentLine() method
	/**
	 * @deprecated Use {@link #indentLine(int,boolean)} instead.
	 */
	public boolean indentLine(int lineIndex, boolean canIncreaseIndent,
		boolean canDecreaseIndent)
	{
		return indentLine(lineIndex,canDecreaseIndent);
	} //}}}
	//{{{ indentLine() method
	/**
	 * Indents the specified line.
	 * @param lineIndex The line number to indent
	 * @param canDecreaseIndent If true, the indent can be decreased as a
	 * result of this. Set this to false for Tab key.
	 * @return true If indentation took place, false otherwise.
	 * @since jEdit 4.2pre2
	 */
	public boolean indentLine(int lineIndex, boolean canDecreaseIndent)
	{
		int[] whitespaceChars = new int[1];
		int currentIndent = getCurrentIndentForLine(lineIndex,
			whitespaceChars);
		int idealIndent = getIdealIndentForLine(lineIndex);
		if(idealIndent == -1 || idealIndent == currentIndent
			|| (!canDecreaseIndent && idealIndent < currentIndent))
			return false;
		// Do it
		try
		{
			beginCompoundEdit();
			int start = getLineStartOffset(lineIndex);
			remove(start,whitespaceChars[0]);
			insert(start,MiscUtilities.createWhiteSpace(
				idealIndent,(getBooleanProperty(""noTabs"")
				? 0 : getTabSize())));
		}
		finally
		{
			endCompoundEdit();
		}
		return true;
	} //}}}
	//{{{ getCurrentIndentForLine() method
	/**
	 * Returns the line's current leading indent.
	 * @param lineIndex The line number
	 * @param whitespaceChars If this is non-null, the number of whitespace
	 * characters is stored at the 0 index
	 * @since jEdit 4.2pre2
	 */
	public int getCurrentIndentForLine(int lineIndex, int[] whitespaceChars)
	{
		getLineText(lineIndex,seg);
		int tabSize = getTabSize();
		int currentIndent = 0;
loop:		for(int i = 0; i < seg.count; i++)
		{
			char c = seg.array[seg.offset + i];
			switch(c)
			{
			case ' ':
				currentIndent++;
				if(whitespaceChars != null)
					whitespaceChars[0]++;
				break;
			case '\t':
				currentIndent += (tabSize - (currentIndent
					% tabSize));
				if(whitespaceChars != null)
					whitespaceChars[0]++;
				break;
			default:
				break loop;
			}
		}
		return currentIndent;
	} //}}}
	//{{{ getIdealIndentForLine() method
	/**
	 * Returns the ideal leading indent for the specified line.
	 * This will apply the various auto-indent rules.
	 * @param lineIndex The line number
	 */
	public int getIdealIndentForLine(int lineIndex)
	{
		final String EXPLICIT_START = ""{{{"";
		final String EXPLICIT_END = ""}}}"";
		if(lineIndex == 0)
			return -1;
		//{{{ Get properties
		String openBrackets = getStringProperty(""indentOpenBrackets"");
		if(openBrackets == null)
			openBrackets = """";
		String closeBrackets = getStringProperty(""indentCloseBrackets"");
		if(closeBrackets == null)
			closeBrackets = """";
		RE indentNextLineRE;
		try
		{
			indentNextLineRE = getRegexpProperty(""indentNextLine"",
				RE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);
		}
		catch(REException re)
		{
			indentNextLineRE = null;
			Log.log(Log.ERROR,this,""Invalid indentNextLine regexp"");
			Log.log(Log.ERROR,this,re);
		}
		RE indentNextLinesRE;
		try
		{
			indentNextLinesRE = getRegexpProperty(""indentNextLines"",
				RE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);
		}
		catch(REException re)
		{
			indentNextLinesRE = null;
			Log.log(Log.ERROR,this,""Invalid indentNextLines regexp"");
			Log.log(Log.ERROR,this,re);
		}
		boolean doubleBracketIndent = getBooleanProperty(""doubleBracketIndent"");
		boolean lineUpClosingBracket = getBooleanProperty(""lineUpClosingBracket"");
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		//}}}
		//{{{ Get indent attributes of previous line
		int prevLineIndex = getPriorNonEmptyLine(lineIndex);
		if(prevLineIndex == -1)
			return -1;
		String prevLine = getLineText(prevLineIndex);
		/*
		 * On the previous line,
		 * if(bob) { --> +1
		 * if(bob) { } --> 0
		 * } else if(bob) { --> +1
		 */
		boolean prevLineStart = true; // False after initial indent
		int indent = 0; // Indent width (tab expanded)
		int prevLineBrackets = 0; // Additional bracket indent
		int prevLineCloseBracketIndex = -1; // For finding whether we're in
						    // this kind of construct:
						    // if (cond1)
						    //   while (cond2)
						    //     if (cond3){
						    //
						    //     }
						    // So we know to indent the next line under the 1st if.
		int prevLineUnclosedParenIndex = -1; // Index of the last unclosed parenthesis
		int prevLineParenWeight = 0; // (openParens - closeParens)
		Stack openParens = new Stack();
		for(int i = 0; i < prevLine.length(); i++)
		{
			char c = prevLine.charAt(i);
			switch(c)
			{
			case ' ':
				if(prevLineStart)
					indent++;
				break;
			case '\t':
				if(prevLineStart)
				{
					indent += (tabSize
						- (indent
						% tabSize));
				}
				break;
			default:
				prevLineStart = false;
				if(closeBrackets.indexOf(c) != -1)
				{
					if(prevLine.regionMatches(false,
						i,EXPLICIT_END,0,3))
						i += 2;
					else
					{
						prevLineBrackets--;
						if(prevLineBrackets < 0)
						{
							if(lineUpClosingBracket)
								prevLineBrackets = 0;
							prevLineCloseBracketIndex = i;
						}
					}
				}
				else if(openBrackets.indexOf(c) != -1)
				{
					if(prevLine.regionMatches(false,
						i,EXPLICIT_START,0,3))
						i += 2;
					else
						prevLineBrackets++;
				} 
				else if (c == '(')
				{
					openParens.push(new Integer(i));
					prevLineParenWeight++;
				}
				else if (c == ')')
				{
					if(openParens.size() > 0)
						openParens.pop();
					prevLineParenWeight--;
				}
				break;
			}
		}
		if(openParens.size() > 0)
		{
			prevLineUnclosedParenIndex = ((Integer) openParens.pop()).intValue();
		} //}}}
		if(Debug.INDENT_DEBUG)
		{
			Log.log(Log.DEBUG,this,""Determined previous line"");
			Log.log(Log.DEBUG,this,""indent="" + indent
				+ "",prevLineBrackets="" + prevLineBrackets
				+ "",prevLineCloseBracketIndex=""
				+ prevLineCloseBracketIndex);
		}
		//{{{ Get indent attributes for current line
		String line = getLineText(lineIndex);
		/*
		 * On the current line,
		 * } --> -1
		 * } else if(bob) { --> -1
		 * if(bob) { } --> 0
		 */
		int lineBrackets = 0; // Additional bracket indent
		int closeBracketIndex = -1; // For lining up closing
			// and opening brackets
		for(int i = 0; i < line.length(); i++)
		{
			char c = line.charAt(i);
			if(closeBrackets.indexOf(c) != -1)
			{
				if(line.regionMatches(false,
					i,EXPLICIT_END,0,3))
					i += 2;
				else
				{
					closeBracketIndex = i;
					lineBrackets--;
				}
			}
			else if(openBrackets.indexOf(c) != -1)
			{
				if(line.regionMatches(false,
					i,EXPLICIT_START,0,3))
					i += 2;
				else if(lineBrackets >= 0)
					lineBrackets++;
			}
		} //}}}
		if(Debug.INDENT_DEBUG)
		{
			Log.log(Log.DEBUG,this,""Determined current line"");
			Log.log(Log.DEBUG,this,""lineBrackets="" + lineBrackets
				+ "",closeBracketIndex="" + closeBracketIndex);
		}
		//{{{ Deep indenting
		if(getBooleanProperty(""deepIndent""))
		{
			if(prevLineParenWeight > 0)
			{
				indent = prevLineUnclosedParenIndex+1;
				for (int i = 0; i < prevLine.length(); i++) {
					if (prevLine.charAt(i) == '\t')
						indent += tabSize-1;
				}
				return indent;
			}
			else if(prevLineParenWeight < 0)
			{
				int openParenOffset = TextUtilities.findMatchingBracket(this,prevLineIndex,prevLine.lastIndexOf("")""));
				if(openParenOffset >= 0)
				{
					int startLine = getLineOfOffset(openParenOffset);
					int startLineParenWeight = getLineParenWeight(startLine);
					if(startLineParenWeight == 1)
						indent = getCurrentIndentForLine(startLine,null);
					else
						indent = getOpenParenIndent(startLine,lineIndex);
				}
			}
			// no parenthesis on previous line (prevLineParenWeight == 0) so the normal indenting rules are used
		}
		//}}}
		//{{{ Handle brackets
		if(prevLineBrackets > 0)
			indent += (indentSize * prevLineBrackets);
		if(lineUpClosingBracket)
		{
			if(lineBrackets < 0)
			{
				int openBracketIndex = TextUtilities.findMatchingBracket(
					this,lineIndex,closeBracketIndex);
				if(openBracketIndex != -1)
				{
					int openLineIndex = getLineOfOffset(openBracketIndex);
					String openLine = getLineText(openLineIndex);
					Log.log(Log.DEBUG,this,""parenWeight of ""+openLine+"" is ""+getLineParenWeight(openLineIndex));
					if (getLineParenWeight(openLineIndex) < 0)
					{
						openBracketIndex = TextUtilities.findMatchingBracket(this,openLineIndex,openLine.indexOf("")""));
						Log.log(Log.DEBUG,this,""openBracketIndex: ""+openBracketIndex);
					}
					openLine = getLineText(getLineOfOffset(openBracketIndex));
					Log.log(Log.DEBUG,this,""openLine: ""+openLine);
					indent = MiscUtilities.getLeadingWhiteSpaceWidth(
						openLine,tabSize);
					Log.log(Log.DEBUG,this,""indent: ""+indent);
				}
				else
					return -1;
			}
		}
		else
		{
			if(prevLineBrackets < 0)
			{
				int offset = TextUtilities.findMatchingBracket(
					this,prevLineIndex,prevLineCloseBracketIndex);
				if(offset != -1)
				{
					String closeLine = getLineText(getLineOfOffset(offset));
					indent = MiscUtilities.getLeadingWhiteSpaceWidth(
						closeLine,tabSize);
				}
				else
					return -1;
			}
		}//}}}
		//{{{ Handle regexps
		if(lineBrackets >= 0)
		{
			// If the previous line matches indentNextLine or indentNextLines,
			// add a level of indent
			if((lineBrackets == 0 || doubleBracketIndent)
				&& indentNextLinesRE != null
				&& indentNextLinesRE.isMatch(prevLine))
			{
				if(Debug.INDENT_DEBUG)
				{
					Log.log(Log.DEBUG,this,""Matches indentNextLines"");
				}
				indent += indentSize;
			}
			else if(indentNextLineRE != null)
			{
				if((lineBrackets == 0 || doubleBracketIndent)
					&& indentNextLineRE.isMatch(prevLine))
					indent += indentSize;
				// we don't want
				// if(foo)
				// {
				// <--- decreased indent
				else if(prevLineBrackets == 0)
				{
					// While prior lines match indentNextLine, remove a level of indent
					// this correctly handles constructs like:
					// if(foo)
					//     if(bar)
					//         if(baz)
					// <--- put indent here
					int prevPrevLineIndex;
					/* if(prevLineCloseBracketIndex != -1)
					{
						int offset = TextUtilities.findMatchingBracket(
							this,prevLineIndex,prevLineCloseBracketIndex);
						if(offset == -1)
							return -1;
						prevPrevLineIndex = getLineOfOffset(offset);
					}
					else */
						prevPrevLineIndex = getPriorNonEmptyLine(prevLineIndex);
					while(prevPrevLineIndex != -1)
					{
						if(indentNextLineRE.isMatch(getLineText(prevPrevLineIndex)))
							indent = getCurrentIndentForLine(prevPrevLineIndex,null);
						else
							break;
						if(Debug.INDENT_DEBUG)
						{
							Log.log(Log.DEBUG,this,
								prevPrevLineIndex
								+ "" matches "" +
								""indentNextLine"");
						}
						prevPrevLineIndex = getPriorNonEmptyLine(prevPrevLineIndex);
					}
				}
			}
		} //}}}
		return indent;
	} //}}}
	//{{{ getLineParenWeight() method
	/**
	 * Returns the number of open parenthesis minus the number of close parenthesis.
	 * @param line The line number
	 * @since jEdit 4.2pre9
	 */
	private int getLineParenWeight(int line)
	{
		String lineText = getLineText(line);
		int parenWeight = 0;
		for(int i = 0; i < lineText.length(); i++)
		{
			char c = lineText.charAt(i);
			switch(c)
			{
				case '(':
					parenWeight++;
					break;
				case ')':
					parenWeight--;
					break;
				default:
			}
		}
		return parenWeight;
	} //}}}
	//{{{ getOpenParenIndent() method
	/**
	 * Returns the appropriate indent based on open parenthesis on previous lines.
	 *
	 * @param startLine The line where parens were last balanced
	 * @param targetLine The line we're finding the indent for
	 */
	private int getOpenParenIndent(int startLine, int targetLine)
	{
		Stack openParens = new Stack();
		String lineText;
		for(int lineIndex = startLine; lineIndex < targetLine; lineIndex++)
		{
			lineText = getLineText(lineIndex);
			for(int i = 0; i < lineText.length(); i++)
			{
				char c = lineText.charAt(i);
				switch(c)
				{
					case '(':
						openParens.push(new Integer(i));
						break;
					case ')':
						if(openParens.size() > 0)
							openParens.pop();
						break;
					default:
				}
			}
		}
		int indent = getCurrentIndentForLine(startLine,null);
		if(openParens.size() > 0)
			indent += ((Integer) openParens.pop()).intValue();
		return indent;
	}
	//}}}
	//{{{ getVirtualWidth() method
	/**
	 * Returns the virtual column number (taking tabs into account) of the
	 * specified position.
	 *
	 * @param line The line number
	 * @param column The column number
	 * @since jEdit 4.1pre1
	 */
	public int getVirtualWidth(int line, int column)
	{
		try
		{
			readLock();
			int start = getLineStartOffset(line);
			getText(start,column,seg);
			return MiscUtilities.getVirtualWidth(seg,getTabSize());
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ getOffsetOfVirtualColumn() method
	/**
	 * Returns the offset of a virtual column number (taking tabs
	 * into account) relative to the start of the line in question.
	 *
	 * @param line The line number
	 * @param column The virtual column number
	 * @param totalVirtualWidth If this array is non-null, the total
	 * virtual width will be stored in its first location if this method
	 * returns -1.
	 *
	 * @return -1 if the column is out of bounds
	 *
	 * @since jEdit 4.1pre1
	 */
	public int getOffsetOfVirtualColumn(int line, int column,
		int[] totalVirtualWidth)
	{
		try
		{
			readLock();
			getLineText(line,seg);
			return MiscUtilities.getOffsetOfVirtualColumn(seg,
				getTabSize(),column,totalVirtualWidth);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//{{{ insertAtColumn() method
	/**
	 * Like the {@link #insert(int,String)} method, but inserts the string at
	 * the specified virtual column. Inserts spaces as appropriate if
	 * the line is shorter than the column.
	 * @param line The line number
	 * @param col The virtual column number
	 * @param str The string
	 */
	public void insertAtColumn(int line, int col, String str)
	{
		try
		{
			writeLock();
			int[] total = new int[1];
			int offset = getOffsetOfVirtualColumn(line,col,total);
			if(offset == -1)
			{
				offset = getLineEndOffset(line) - 1;
				str = MiscUtilities.createWhiteSpace(col - total[0],0) + str;
			}
			else
				offset += getLineStartOffset(line);
			insert(offset,str);
		}
		finally
		{
			writeUnlock();
		}
	} //}}}
	//{{{ insertIndented() method
	/**
	 * Inserts a string into the buffer, indenting each line of the string
	 * to match the indent of the first line.
	 *
	 * @param offset The offset
	 * @param text The text
	 *
	 * @return The number of characters of indent inserted on each new
	 * line. This is used by the abbreviations code.
	 *
	 * @since jEdit 4.2pre14
	 */
	public int insertIndented(int offset, String text)
	{
		try
		{
			beginCompoundEdit();
			// obtain the leading indent for later use
			int firstLine = getLineOfOffset(offset);
			String lineText = getLineText(firstLine);
			int leadingIndent
				= MiscUtilities.getLeadingWhiteSpaceWidth(
				lineText,getTabSize());
			String whiteSpace = MiscUtilities.createWhiteSpace(
				leadingIndent,getBooleanProperty(""noTabs"")
				? 0 : getTabSize());
			insert(offset,text);
			int lastLine = getLineOfOffset(offset + text.length());
			// note that if firstLine == lastLine, loop does not
			// execute
			for(int i = firstLine + 1; i <= lastLine; i++)
			{
				insert(getLineStartOffset(i),whiteSpace);
			}
			return whiteSpace.length();
		}
		finally
		{
			endCompoundEdit();
		}
	} //}}}
	//}}}
	//{{{ Deprecated methods
	//{{{ putProperty() method
	/**
	 * @deprecated Call <code>setProperty()</code> instead.
	 */
	public void putProperty(Object name, Object value)
	{
		// for backwards compatibility
		if(!(name instanceof String))
			return;
		setProperty((String)name,value);
	} //}}}
	//{{{ putBooleanProperty() method
	/**
	 * @deprecated Call <code>setBooleanProperty()</code> instead
	 */
	public void putBooleanProperty(String name, boolean value)
	{
		setBooleanProperty(name,value);
	} //}}}
	//{{{ markTokens() method
	/**
	 * @deprecated Use org.gjt.sp.jedit.syntax.DefaultTokenHandler instead
	 */
	public static class TokenList extends DefaultTokenHandler
	{
		public Token getFirstToken()
		{
			return getTokens();
		}
	}
	/**
	 * @deprecated Use the other form of <code>markTokens()</code> instead
	 */
	public TokenList markTokens(int lineIndex)
	{
		TokenList list = new TokenList();
		markTokens(lineIndex,list);
		return list;
	} //}}}
	//{{{ getRootElements() method
	/**
	 * @deprecated
	 */
	public Element[] getRootElements()
	{
		return new Element[] { getDefaultRootElement() };
	} //}}}
	//{{{ getParagraphElement() method
	/**
	 * @deprecated
	 */
	public Element getParagraphElement(int offset)
	{
		return new LineElement(this,getLineOfOffset(offset));
	} //}}}
	//{{{ getDefaultRootElement() method
	/**
	 * @deprecated Use <code>getLineOfOffset()</code>,
	 * <code>getLineStartOffset()</code>, and
	 * <code>getLineEndOffset()</code> instead.
	 */
	public Element getDefaultRootElement()
	{
		return new RootElement(this);
	} //}}}
	//{{{ insertString() method
	/**
	 * @deprecated Call <code>insert()</code> instead.
	 */
	public void insertString(int offset, String str, AttributeSet attr)
	{
		insert(offset,str);
	} //}}}
	//{{{ getFile() method
	/**
	 * @deprecated Do not call this method, use {@link #getPath()}
	 * instead.
	 */
	public File getFile()
	{
		return file;
	} //}}}
	//{{{ getCurrentIdentForLine() method
	/**
	 * @deprecated Use the correctly spelled getCurrentIndentForLine() instead.
	 */
	public int getCurrentIdentForLine(int lineIndex, int[] whitespaceChars) {
		return getCurrentIndentForLine(lineIndex,whitespaceChars);
	}//}}}
	//}}}
	//{{{ Folding methods
	//{{{ isFoldStart() method
	/**
	 * Returns if the specified line begins a fold.
	 * @since jEdit 3.1pre1
	 */
	public boolean isFoldStart(int line)
	{
		return (line != getLineCount() - 1
			&& getFoldLevel(line) < getFoldLevel(line + 1));
	} //}}}
	//{{{ isFoldEnd() method
	/**
	 * Returns if the specified line ends a fold.
	 * @since jEdit 4.2pre5
	 */
	public boolean isFoldEnd(int line)
	{
		return (line != getLineCount() - 1
			&& getFoldLevel(line) > getFoldLevel(line + 1));
	} //}}}
	//{{{ invalidateCachedFoldLevels() method
	/**
	 * Invalidates all cached fold level information.
	 * @since jEdit 4.1pre11
	 */
	public void invalidateCachedFoldLevels()
	{
		lineMgr.setFirstInvalidFoldLevel(0);
		fireFoldLevelChanged(0,getLineCount());
	} //}}}
	//{{{ getFoldLevel() method
	/**
	 * Returns the fold level of the specified line.
	 * @param line A physical line index
	 * @since jEdit 3.1pre1
	 */
	public int getFoldLevel(int line)
	{
		if(line < 0 || line >= lineMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);
		if(foldHandler instanceof DummyFoldHandler)
			return 0;
		int firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel();
		if(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)
		{
			return lineMgr.getFoldLevel(line);
		}
		else
		{
			if(Debug.FOLD_DEBUG)
				Log.log(Log.DEBUG,this,""Invalid fold levels from "" + firstInvalidFoldLevel + "" to "" + line);
			int newFoldLevel = 0;
			boolean changed = false;
			for(int i = firstInvalidFoldLevel; i <= line; i++)
			{
				newFoldLevel = foldHandler.getFoldLevel(this,i,seg);
				if(newFoldLevel != lineMgr.getFoldLevel(i))
				{
					if(Debug.FOLD_DEBUG)
						Log.log(Log.DEBUG,this,i + "" fold level changed"");
					changed = true;
				}
				lineMgr.setFoldLevel(i,newFoldLevel);
			}
			if(line == lineMgr.getLineCount() - 1)
				lineMgr.setFirstInvalidFoldLevel(-1);
			else
				lineMgr.setFirstInvalidFoldLevel(line + 1);
			if(changed)
			{
				if(Debug.FOLD_DEBUG)
					Log.log(Log.DEBUG,this,""fold level changed: "" + firstInvalidFoldLevel + "","" + line);
				fireFoldLevelChanged(firstInvalidFoldLevel,line);
			}
			return newFoldLevel;
		}
	} //}}}
	//{{{ getFoldAtLine() method
	/**
	 * Returns an array. The first element is the start line, the
	 * second element is the end line, of the fold containing the
	 * specified line number.
	 * @param line The line number
	 * @since jEdit 4.0pre3
	 */
	public int[] getFoldAtLine(int line)
	{
		int start, end;
		if(isFoldStart(line))
		{
			start = line;
			int foldLevel = getFoldLevel(line);
			line++;
			while(getFoldLevel(line) > foldLevel)
			{
				line++;
				if(line == getLineCount())
					break;
			}
			end = line - 1;
		}
		else
		{
			start = line;
			int foldLevel = getFoldLevel(line);
			while(getFoldLevel(start) >= foldLevel)
			{
				if(start == 0)
					break;
				else
					start--;
			}
			end = line;
			while(getFoldLevel(end) >= foldLevel)
			{
				end++;
				if(end == getLineCount())
					break;
			}
			end--;
		}
		while(getLineLength(end) == 0 && end > start)
			end--;
		return new int[] { start, end };
	} //}}}
	//{{{ getFoldHandler() method
	/**
	 * Returns the current buffer's fold handler.
	 * @since jEdit 4.2pre1
	 */
	public FoldHandler getFoldHandler()
	{
		return foldHandler;
	} //}}}
	//{{{ setFoldHandler() method
	/**
	 * Sets the buffer's fold handler.
	 * @since jEdit 4.2pre2
	 */
	public void setFoldHandler(FoldHandler foldHandler)
	{
		FoldHandler oldFoldHandler = this.foldHandler;
		if(foldHandler.equals(oldFoldHandler))
			return;
		this.foldHandler = foldHandler;
		lineMgr.setFirstInvalidFoldLevel(0);
		fireFoldHandlerChanged();
	} //}}}
	//}}}
	//{{{ Position methods
	//{{{ createPosition() method
	/**
	 * Creates a floating position.
	 * @param offset The offset
	 */
	public Position createPosition(int offset)
	{
		try
		{
			readLock();
			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);
			return positionMgr.createPosition(offset);
		}
		finally
		{
			readUnlock();
		}
	} //}}}
	//}}}
	//{{{ Marker methods
	//{{{ getMarkers() method
	/**
	 * Returns a vector of markers.
	 * @since jEdit 3.2pre1
	 */
	public Vector getMarkers()
	{
		return markers;
	} //}}}
	//{{{ getMarkerStatusPrompt() method
	/**
	 * Returns the status prompt for the given marker action. Only
	 * intended to be called from <code>actions.xml</code>.
	 * @since jEdit 4.2pre2
	 */
	public String getMarkerStatusPrompt(String action)
	{
		return jEdit.getProperty(""view.status."" + action,
			new String[] { getMarkerNameString() });
	} //}}}
	//{{{ getMarkerNameString() method
	/**
	 * Returns a string of all set markers, used by the status bar
	 * (eg, ""a b $ % ^"").
	 * @since jEdit 4.2pre2
	 */
	public String getMarkerNameString()
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(marker.getShortcut() != '\0')
			{
				if(buf.length() != 0)
					buf.append(' ');
				buf.append(marker.getShortcut());
			}
		}
		if(buf.length() == 0)
			return jEdit.getProperty(""view.status.no-markers"");
		else
			return buf.toString();
	} //}}}
	//{{{ addOrRemoveMarker() method
	/**
	 * If a marker is set on the line of the position, it is removed. Otherwise
	 * a new marker with the specified shortcut is added.
	 * @param pos The position of the marker
	 * @param shortcut The shortcut ('\0' if none)
	 * @since jEdit 3.2pre5
	 */
	public void addOrRemoveMarker(char shortcut, int pos)
	{
		int line = getLineOfOffset(pos);
		if(getMarkerAtLine(line) != null)
			removeMarker(line);
		else
			addMarker(shortcut,pos);
	} //}}}
	//{{{ addMarker() method
	/**
	 * Adds a marker to this buffer.
	 * @param pos The position of the marker
	 * @param shortcut The shortcut ('\0' if none)
	 * @since jEdit 3.2pre1
	 */
	public void addMarker(char shortcut, int pos)
	{
		Marker markerN = new Marker(this,shortcut,pos);
		boolean added = false;
		// don't sort markers while buffer is being loaded
		if(!getFlag(LOADING))
		{
			if(jEdit.getBooleanProperty(""persistentMarkers""))
				setDirty(true);
			markerN.createPosition();
			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(shortcut != '\0' && marker.getShortcut() == shortcut)
					marker.setShortcut('\0');
				if(marker.getPosition() == pos)
				{
					markers.removeElementAt(i);
					i--;
				}
			}
			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(marker.getPosition() > pos)
				{
					markers.insertElementAt(markerN,i);
					added = true;
					break;
				}
			}
		}
		if(!added)
			markers.addElement(markerN);
		if(!getFlag(LOADING) && !getFlag(TEMPORARY))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} //}}}
	//{{{ getMarkerInRange() method
	/**
	 * Returns the first marker within the specified range.
	 * @param start The start offset
	 * @param end The end offset
	 * @since jEdit 4.0pre4
	 */
	public Marker getMarkerInRange(int start, int end)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			int pos = marker.getPosition();
			if(pos >= start && pos < end)
				return marker;
		}
		return null;
	} //}}}
	//{{{ getMarkerAtLine() method
	/**
	 * Returns the first marker at the specified line, or <code>null</code>
	 * if there is none.
	 * @param line The line number
	 * @since jEdit 3.2pre2
	 */
	public Marker getMarkerAtLine(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)
				return marker;
		}
		return null;
	} //}}}
	//{{{ removeMarker() method
	/**
	 * Removes all markers at the specified line.
	 * @param line The line number
	 * @since jEdit 3.2pre2
	 */
	public void removeMarker(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)
			{
				if(jEdit.getBooleanProperty(""persistentMarkers""))
					setDirty(true);
				marker.removePosition();
				markers.removeElementAt(i);
				i--;
			}
		}
		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	} //}}}
	//{{{ removeAllMarkers() method
	/**
	 * Removes all defined markers.
	 * @since jEdit 2.6pre1
	 */
	public void removeAllMarkers()
	{
		if(jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);
		for(int i = 0; i < markers.size(); i++)
			((Marker)markers.elementAt(i)).removePosition();
		markers.removeAllElements();
		if(!getFlag(LOADING))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} //}}}
	//{{{ getMarker() method
	/**
	 * Returns the marker with the specified shortcut.
	 * @param shortcut The shortcut
	 * @since jEdit 3.2pre2
	 */
	public Marker getMarker(char shortcut)
	{
		Enumeration e = markers.elements();
		while(e.hasMoreElements())
		{
			Marker marker = (Marker)e.nextElement();
			if(marker.getShortcut() == shortcut)
				return marker;
		}
		return null;
	} //}}}
	//}}}
	//{{{ Miscellaneous methods
	//{{{ setWaitSocket() method
	/**
	 * This socket is closed when the buffer is closed.
	 */
	public void setWaitSocket(Socket waitSocket)
	{
		this.waitSocket = waitSocket;
	} //}}}
	//{{{ getNext() method
	/**
	 * Returns the next buffer in the list.
	 */
	public Buffer getNext()
	{
		return next;
	} //}}}
	//{{{ getPrev() method
	/**
	 * Returns the previous buffer in the list.
	 */
	public Buffer getPrev()
	{
		return prev;
	} //}}}
	//{{{ getIndex() method
	/**
	 * Returns the position of this buffer in the buffer list.
	 */
	public int getIndex()
	{
		int count = 0;
		Buffer buffer = prev;
		for(;;)
		{
			if(buffer == null)
				break;
			count++;
			buffer = buffer.prev;
		}
		return count;
	} //}}}
	//{{{ toString() method
	/**
	 * Returns a string representation of this buffer.
	 * This simply returns the path name.
	 */
	public String toString()
	{
		return name + "" ("" + directory + "")"";
	} //}}}
	//}}}
	//{{{ Methods that really shouldn't be public...
	//{{{ _getLineManager() method
	/**
	 * Plugins and macros should not call this method.
	 * @since jEdit 4.2pre3
	 */
	public LineManager _getLineManager()
	{
		return lineMgr;
	} //}}}
	//}}}
	//{{{ Package-private members
	Buffer prev;
	Buffer next;
	//{{{ Buffer constructor
	Buffer(String path, boolean newFile, boolean temp, Hashtable props)
	{
		lock = new ReadWriteLock();
		propertyLock = new Object();
		contentMgr = new ContentManager();
		lineMgr = new LineManager();
		positionMgr = new PositionManager();
		integerArray = new IntegerArray();
		undoMgr = new UndoManager(this);
		bufferListeners = new Vector();
		seg = new Segment();
		markers = new Vector();
		properties = new HashMap();
		//{{{ need to convert entries of 'props' to PropValue instances
		Enumeration e = props.keys();
		while(e.hasMoreElements())
		{
			Object key = e.nextElement();
			Object value = props.get(key);
			properties.put(key,new PropValue(value,false));
		} //}}}
		// fill in defaults for these from system properties if the
		// corresponding buffer.XXX properties not set
		if(getProperty(ENCODING) == null)
			properties.put(ENCODING,new PropValue(System.getProperty(""file.encoding""),false));
		if(getProperty(LINESEP) == null)
			properties.put(LINESEP,new PropValue(System.getProperty(""line.separator""),false));
		setFlag(TEMPORARY,temp);
		// this must be called before any EditBus messages are sent
		setPath(path);
		/* Magic: UNTITLED is only set if newFile param to
		 * constructor is set, NEW_FILE is also set if file
		 * doesn't exist on disk.
		 *
		 * This is so that we can tell apart files created
		 * with jEdit.newFile(), and those that just don't
		 * exist on disk.
		 *
		 * Why do we need to tell the difference between the
		 * two? jEdit.addBufferToList() checks if the only
		 * opened buffer is an untitled buffer, and if so,
		 * replaces it with the buffer to add. We don't want
		 * this behavior to occur with files that don't
		 * exist on disk; only untitled ones.
		 */
		setFlag(UNTITLED,newFile);
		setFlag(NEW_FILE,newFile);
	} //}}}
	//{{{ commitTemporary() method
	void commitTemporary()
	{
		setFlag(TEMPORARY,false);
		finishLoading();
	} //}}}
	//{{{ resetCachedProperties() method
	void resetCachedProperties()
	{
		// Need to reset properties that were cached defaults,
		// since the defaults might have changed.
		Iterator iter = properties.values().iterator();
		while(iter.hasNext())
		{
			PropValue value = (PropValue)iter.next();
			if(value.defaultValue)
				iter.remove();
		}
	} //}}}
	//{{{ close() method
	void close()
	{
		setFlag(CLOSED,true);
		if(autosaveFile != null)
			autosaveFile.delete();
		// notify clients with -wait
		if(waitSocket != null)
		{
			try
			{
				waitSocket.getOutputStream().write('\0');
				waitSocket.getOutputStream().flush();
				waitSocket.getInputStream().close();
				waitSocket.getOutputStream().close();
				waitSocket.close();
			}
			catch(IOException io)
			{
				//Log.log(Log.ERROR,this,io);
			}
		}
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Flags
	//{{{ setFlag() method
	private void setFlag(int flag, boolean value)
	{
		if(value)
			flags |= (1 << flag);
		else
			flags &= ~(1 << flag);
	} //}}}
	//{{{ getFlag() method
	private boolean getFlag(int flag)
	{
		int mask = (1 << flag);
		return (flags & mask) == mask;
	} //}}}
	//{{{ Flag values
	private static final int CLOSED = 0;
	private static final int LOADING = 1;
	private static final int IO = 2;
	private static final int NEW_FILE = 3;
	private static final int UNTITLED = 4;
	private static final int AUTOSAVE_DIRTY = 5;
	private static final int DIRTY = 6;
	private static final int READ_ONLY = 7;
	private static final int READ_ONLY_OVERRIDE = 8;
	private static final int UNDO_IN_PROGRESS = 9;
	private static final int TEMPORARY = 10;
	private static final int TRANSACTION = 11;
	//}}}
	private int flags;
	//}}}
	//{{{ Instance variables
	private String path;
	private String symlinkPath;
	private String name;
	private String directory;
	private File file;
	private File autosaveFile;
	private long modTime;
	private Mode mode;
	private HashMap properties;
	private ReadWriteLock lock;
	private Object propertyLock;
	private ContentManager contentMgr;
	private LineManager lineMgr;
	private PositionManager positionMgr;
	private IntegerArray integerArray;
	private UndoManager undoMgr;
	private Vector bufferListeners;
	private Vector markers;
	// Display
	private boolean textMode;
	private TokenMarker tokenMarker;
	private Segment seg;
	private FoldHandler foldHandler;
	private Socket waitSocket;
	//}}}
	//{{{ setPath() method
	private void setPath(String path)
	{
		this.path = path;
		VFS vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
			setFlag(READ_ONLY,true);
		this.name = vfs.getFileName(path);
		this.directory = vfs.getParentOfPath(path);
		if(vfs instanceof FileVFS)
		{
			file = new File(path);
			symlinkPath = MiscUtilities.resolveSymlinks(path);
			// if we don't do this, the autosave file won't be
			// deleted after a save as
			if(autosaveFile != null)
				autosaveFile.delete();
			autosaveFile = new File(file.getParent(),'#' + name + '#');
		}
		else
		{
			// I wonder if the lack of this broke anything in the
			// past?
			file = null;
			autosaveFile = null;
			symlinkPath = path;
		}
	} //}}}
	//{{{ recoverAutosave() method
	private boolean recoverAutosave(final View view)
	{
		if(!autosaveFile.canRead())
			return false;
		// this method might get called at startup
		GUIUtilities.hideSplashScreen();
		final Object[] args = { autosaveFile.getPath() };
		int result = GUIUtilities.confirm(view,""autosave-found"",args,
			JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
		if(result == JOptionPane.YES_OPTION)
		{
			VFSManager.getFileVFS().load(view,this,autosaveFile.getPath());
			// show this message when all I/O requests are
			// complete
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					GUIUtilities.message(view,""autosave-loaded"",args);
				}
			});
			return true;
		}
		else
			return false;
	} //}}}
	//{{{ checkFileForLoad() method
	private boolean checkFileForLoad(View view, VFS vfs, String path)
	{
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
		{
			Object session = vfs.createVFSSession(path,view);
			if(session == null)
				return false;
			try
			{
				VFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);
				if(file == null)
				{
					setNewFile(true);
					return true;
				}
				if(!file.canRead)
				{
					VFSManager.error(view,path,""ioerror.no-read"",null);
					setNewFile(false);
					return false;
				}
				setFlag(READ_ONLY,!file.canWrite);
				if(file.type != VFS.DirectoryEntry.FILE)
				{
					VFSManager.error(view,path,
						""ioerror.open-directory"",null);
					setNewFile(false);
					return false;
				}
			}
			catch(IOException io)
			{
				VFSManager.error(view,path,""ioerror"",
					new String[] { io.toString() });
				return false;
			}
			finally
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					VFSManager.error(view,path,""ioerror"",
						new String[] { io.toString() });
					return false;
				}
			}
		}
		return true;
	} //}}}
	//{{{ checkFileForSave() method
	private boolean checkFileForSave(View view, VFS vfs, String path)
	{
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
		{
			Object session = vfs.createVFSSession(path,view);
			if(session == null)
				return false;
			try
			{
				VFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);
				if(file == null)
					return true;
				if(file.type != VFS.DirectoryEntry.FILE)
				{
					VFSManager.error(view,path,
						""ioerror.save-directory"",null);
					return false;
				}
			}
			catch(IOException io)
			{
				VFSManager.error(view,path,""ioerror"",
					new String[] { io.toString() });
				return false;
			}
			finally
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					VFSManager.error(view,path,""ioerror"",
						new String[] { io.toString() });
					return false;
				}
			}
		}
		return true;
	} //}}}
	//{{{ finishLoading() method
	private void finishLoading()
	{
		parseBufferLocalProperties();
		// AHA!
		// this is probably the only way to fix this
		FoldHandler oldFoldHandler = foldHandler;
		setMode();
		if(foldHandler == oldFoldHandler)
		{
			// on a reload, the fold handler doesn't change, but
			// we still need to re-collapse folds.
			// don't do this on initial fold handler creation
			lineMgr.setFirstInvalidFoldLevel(0);
			fireFoldHandlerChanged();
		}
		// Create marker positions
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			marker.removePosition();
			int pos = marker.getPosition();
			if(pos > getLength())
				marker.setPosition(getLength());
			else if(pos < 0)
				marker.setPosition(0);
			marker.createPosition();
		}
	} //}}}
	//{{{ finishSaving() method
	private void finishSaving(View view, String oldPath,
		String oldSymlinkPath, String path,
		boolean rename, boolean error)
	{
		//{{{ Set the buffer's path
		// Caveat: won't work if save() called with a relative path.
		// But I don't think anyone calls it like that anyway.
		if(!error && !path.equals(oldPath))
		{
			Buffer buffer = jEdit.getBuffer(path);
			if(rename)
			{
				/* if we save a file with the same name as one
				 * that's already open, we presume that we can
				 * close the existing file, since the user
				 * would have confirmed the overwrite in the
				 * 'save as' dialog box anyway */
				if(buffer != null && /* can't happen? */
					!buffer.getPath().equals(oldPath))
				{
					buffer.setDirty(false);
					jEdit.closeBuffer(view,buffer);
				}
				setPath(path);
			}
			else
			{
				/* if we saved over an already open file using
				 * 'save a copy as', then reload the existing
				 * buffer */
				if(buffer != null && /* can't happen? */
					!buffer.getPath().equals(oldPath))
				{
					buffer.load(view,true);
				}
			}
		} //}}}
		//{{{ Update this buffer for the new path
		if(rename)
		{
			if(file != null)
				modTime = file.lastModified();
			if(!error)
			{
				// we do a write lock so that the
				// autosave, which grabs a read lock,
				// is not executed between the
				// deletion of the autosave file
				// and clearing of the dirty flag
				try
				{
					writeLock();
					if(autosaveFile != null)
						autosaveFile.delete();
					setFlag(AUTOSAVE_DIRTY,false);
					setFlag(READ_ONLY,false);
					setFlag(NEW_FILE,false);
					setFlag(UNTITLED,false);
					setFlag(DIRTY,false);
					// this ensures that undo can clear
					// the dirty flag properly when all
					// edits up to a save are undone
					undoMgr.bufferSaved();
				}
				finally
				{
					writeUnlock();
				}
				parseBufferLocalProperties();
				if(!getPath().equals(oldPath))
				{
					jEdit.updatePosition(oldSymlinkPath,this);
					setMode();
				}
				else
				{
					// if user adds mode buffer-local property
					String newMode = getStringProperty(""mode"");
					if(newMode != null &&
						!newMode.equals(getMode()
						.getName()))
						setMode();
					else
						propertiesChanged();
				}
				EditBus.send(new BufferUpdate(Buffer.this,
					view,BufferUpdate.DIRTY_CHANGED));
				// new message type introduced in 4.0pre4
				EditBus.send(new BufferUpdate(Buffer.this,
					view,BufferUpdate.SAVED));
			}
		} //}}}
	} //}}}
	//{{{ parseBufferLocalProperties() method
	private void parseBufferLocalProperties()
	{
		int lastLine = Math.min(9,getLineCount() - 1);
		parseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));
		// first line for last 10 lines, make sure not to overlap
		// with the first 10
		int firstLine = Math.max(lastLine + 1, getLineCount() - 10);
		if(firstLine < getLineCount())
		{
			int length = getLineEndOffset(getLineCount() - 1)
				- (getLineStartOffset(firstLine) + 1);
			parseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));
		}
	} //}}}
	//{{{ parseBufferLocalProperties() method
	private void parseBufferLocalProperties(String prop)
	{
		StringBuffer buf = new StringBuffer();
		String name = null;
		boolean escape = false;
		for(int i = 0; i < prop.length(); i++)
		{
			char c = prop.charAt(i);
			switch(c)
			{
			case ':':
				if(escape)
				{
					escape = false;
					buf.append(':');
					break;
				}
				if(name != null)
				{
					// use the low-level property setting code
					// so that if we have a buffer-local
					// property with the same value as a default,
					// later changes in the default don't affect
					// the buffer-local property
					properties.put(name,new PropValue(buf.toString(),false));
					name = null;
				}
				buf.setLength(0);
				break;
			case '=':
				if(escape)
				{
					escape = false;
					buf.append('=');
					break;
				}
				name = buf.toString();
				buf.setLength(0);
				break;
			case '\\':
				if(escape)
					buf.append('\\');
				escape = !escape;
				break;
			case 'n':
				if(escape)
				{	buf.append('\n');
					escape = false;
					break;
				}
			case 'r':
				if(escape)
				{	buf.append('\r');
					escape = false;
					break;
				}
			case 't':
				if(escape)
				{
					buf.append('\t');
					escape = false;
					break;
				}
			default:
				buf.append(c);
				break;
			}
		}
	} //}}}
	//{{{ setTokenMarker() method
	private void setTokenMarker(TokenMarker tokenMarker)
	{
		TokenMarker oldTokenMarker = this.tokenMarker;
		this.tokenMarker = tokenMarker;
		// don't do this on initial token marker
		if(oldTokenMarker != null && tokenMarker != oldTokenMarker)
		{
			lineMgr.setFirstInvalidLineContext(0);
		}
	} //}}}
	//{{{ getPriorNonEmptyLine() method
	/**
	 * Auto indent needs this.
	 */
	private int getPriorNonEmptyLine(int lineIndex)
	{
		int returnValue = -1;
		for(int i = lineIndex - 1; i >= 0; i--)
		{
			getLineText(i,seg);
			if(seg.count != 0)
				returnValue = i;
			for(int j = 0; j < seg.count; j++)
			{
				char ch = seg.array[seg.offset + j];
				if(!Character.isWhitespace(ch))
					return i;
			}
		}
		// didn't find a line that contains non-whitespace chars
		// so return index of prior whitespace line
		return returnValue;
	} //}}}
	//{{{ contentInserted() method
	private void contentInserted(int offset, int length,
		IntegerArray endOffsets)
	{
		try
		{
			setFlag(TRANSACTION,true);
			int startLine = lineMgr.getLineOfOffset(offset);
			int numLines = endOffsets.getSize();
			lineMgr.contentInserted(startLine,offset,numLines,length,
				endOffsets);
			positionMgr.contentInserted(offset,length);
			setDirty(true);
			if(!getFlag(LOADING))
			{
				fireContentInserted(startLine,offset,numLines,length);
				if(!getFlag(UNDO_IN_PROGRESS)
					&& !insideCompoundEdit())
				{
					fireTransactionComplete();
				}
			}
		}
		finally
		{
			setFlag(TRANSACTION,false);
		}
	} //}}}
	//{{{ Event firing methods
	//{{{ getListener() method
	private BufferChangeListener getListener(int index)
	{
		return ((Listener)bufferListeners.elementAt(index)).listener;
	} //}}}
	//{{{ fireFoldLevelChanged() method
	private void fireFoldLevelChanged(int start, int end)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				getListener(i).foldLevelChanged(this,start,end);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+getListener(i)+"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} //}}}
	//{{{ fireContentInserted() method
	private void fireContentInserted(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				getListener(i).contentInserted(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+getListener(i)+"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} //}}}
	//{{{ fireContentRemoved() method
	private void fireContentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				getListener(i).contentRemoved(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+getListener(i)+"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} //}}}
	//{{{ firePreContentRemoved() method
	private void firePreContentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				getListener(i).preContentRemoved(this,startLine,
					offset,numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+getListener(i)+"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} //}}}
	//{{{ fireTransactionComplete() method
	private void fireTransactionComplete()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				getListener(i).transactionComplete(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+getListener(i)+"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} //}}}
	//{{{ fireFoldHandlerChanged() method
	private void fireFoldHandlerChanged()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				getListener(i).foldHandlerChanged(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event to ""+getListener(i)+"" :"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} //}}}
	//}}}
	//}}}
}
"
org.gjt.sp.jedit.BufferHistory,"/*
 * BufferHistory.java - Remembers caret positions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import com.microstar.xml.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.msg.DynamicMenuChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Recent file list.
 * @author Slava Pestov
 * @version $Id: BufferHistory.java,v 1.16 2004/08/12 22:42:43 spestov Exp $
 */
public class BufferHistory
{
	//{{{ getEntry() method
	public static Entry getEntry(String path)
	{
		Iterator iter = history.iterator();
		while(iter.hasNext())
		{
			Entry entry = (Entry)iter.next();
			if(pathsCaseInsensitive)
			{
				if(entry.path.equalsIgnoreCase(path))
					return entry;
			}
			else
			{
				if(entry.path.equals(path))
					return entry;
			}
		}
		return null;
	} //}}}
	//{{{ setEntry() method
	public static void setEntry(String path, int caret, Selection[] selection,
		String encoding)
	{
		removeEntry(path);
		addEntry(new Entry(path,caret,selectionToString(selection),
			encoding));
		EditBus.send(new DynamicMenuChanged(""recent-files""));
	} //}}}
	//{{{ getHistory() method
	/**
	 * @since jEdit 4.2pre2
	 */
	public static List getHistory()
	{
		return history;
	} //}}}
	//{{{ getBufferHistory() method
	/**
	 * @deprecated Call {@link #getHistory()} instead.
	 */
	public static Vector getBufferHistory()
	{
		Vector retVal = new Vector(history.size());
		Iterator iter = history.iterator();
		while(iter.hasNext())
			retVal.add(iter.next());
		return retVal;
	} //}}}
	//{{{ load() method
	public static void load()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		File recent = new File(MiscUtilities.constructPath(
			settingsDirectory,""recent.xml""));
		if(!recent.exists())
			return;
		recentModTime = recent.lastModified();
		Log.log(Log.MESSAGE,BufferHistory.class,""Loading recent.xml"");
		RecentHandler handler = new RecentHandler();
		XmlParser parser = new XmlParser();
		Reader in = null;
		parser.setHandler(handler);
		try
		{
			in = new BufferedReader(new FileReader(recent));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,BufferHistory.class,recent + "":"" + line
				+ "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
			//Log.log(Log.DEBUG,BufferHistory.class,fnf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,BufferHistory.class,io);
			}
		}
	} //}}}
	//{{{ save() method
	public static void save()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		File file1 = new File(MiscUtilities.constructPath(
			settingsDirectory, ""#recent.xml#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			settingsDirectory, ""recent.xml""));
		if(file2.exists() && file2.lastModified() != recentModTime)
		{
			Log.log(Log.WARNING,BufferHistory.class,file2
				+ "" changed on disk; will not save recent""
				+ "" files"");
			return;
		}
		jEdit.backupSettingsFile(file2);
		Log.log(Log.MESSAGE,BufferHistory.class,""Saving "" + file1);
		String lineSep = System.getProperty(""line.separator"");
		boolean ok = false;
		BufferedWriter out = null;
		try
		{
			out = new BufferedWriter(new FileWriter(file1));
			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE RECENT SYSTEM \""recent.dtd\"">"");
			out.write(lineSep);
			out.write(""<RECENT>"");
			out.write(lineSep);
			Iterator iter = history.iterator();
			while(iter.hasNext())
			{
				out.write(""<ENTRY>"");
				out.write(lineSep);
				Entry entry = (Entry)iter.next();
				out.write(""<PATH>"");
				out.write(MiscUtilities.charsToEntities(entry.path));
				out.write(""</PATH>"");
				out.write(lineSep);
				out.write(""<CARET>"");
				out.write(String.valueOf(entry.caret));
				out.write(""</CARET>"");
				out.write(lineSep);
				if(entry.selection != null
					&& entry.selection.length() > 0)
				{
					out.write(""<SELECTION>"");
					out.write(entry.selection);
					out.write(""</SELECTION>"");
					out.write(lineSep);
				}
				if(entry.encoding != null)
				{
					out.write(""<ENCODING>"");
					out.write(entry.encoding);
					out.write(""</ENCODING>"");
					out.write(lineSep);
				}
				out.write(""</ENTRY>"");
				out.write(lineSep);
			}
			out.write(""</RECENT>"");
			out.write(lineSep);
			out.close();
			ok = true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
		finally
		{
			try
			{
				if(out != null)
					out.close();
			}
			catch(IOException e)
			{
			}
		}
		if(ok)
		{
			/* to avoid data loss, only do this if the above
			 * completed successfully */
			file2.delete();
			file1.renameTo(file2);
		}
		recentModTime = file2.lastModified();
	} //}}}
	//{{{ Private members
	private static LinkedList history;
	private static boolean pathsCaseInsensitive;
	private static long recentModTime;
	//{{{ Class initializer
	static
	{
		history = new LinkedList();
		pathsCaseInsensitive = OperatingSystem.isDOSDerived()
			|| OperatingSystem.isMacOS();
	} //}}}
	//{{{ addEntry() method
	/* private */ static void addEntry(Entry entry)
	{
		history.addFirst(entry);
		int max = jEdit.getIntegerProperty(""recentFiles"",50);
		while(history.size() > max)
			history.removeLast();
	} //}}}
	//{{{ removeEntry() method
	/* private */ static void removeEntry(String path)
	{
		Iterator iter = history.iterator();
		while(iter.hasNext())
		{
			Entry entry = (Entry)iter.next();
			if(pathsCaseInsensitive)
			{
				if(entry.path.equalsIgnoreCase(path))
				{
					iter.remove();
					return;
				}
			}
			else
			{
				if(entry.path.equals(path))
				{
					iter.remove();
					return;
				}
			}
		}
	} //}}}
	//{{{ selectionToString() method
	private static String selectionToString(Selection[] s)
	{
		if(s == null)
			return null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < s.length; i++)
		{
			if(i != 0)
				buf.append(' ');
			Selection sel = s[i];
			if(sel instanceof Selection.Range)
				buf.append(""range "");
			else //if(sel instanceof Selection.Rect)
				buf.append(""rect "");
			buf.append(sel.getStart());
			buf.append(' ');
			buf.append(sel.getEnd());
		}
		return buf.toString();
	} //}}}
	//{{{ stringToSelection() method
	private static Selection[] stringToSelection(String s)
	{
		if(s == null)
			return null;
		Vector selection = new Vector();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String type = st.nextToken();
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			if(end < start)
			{
				// I'm not sure when this can happen,
				// but it does sometimes, witness the
				// jEdit bug tracker.
				continue;
			}
			Selection sel;
			if(type.equals(""range""))
				sel = new Selection.Range(start,end);
			else //if(type.equals(""rect""))
				sel = new Selection.Rect(start,end);
			selection.addElement(sel);
		}
		Selection[] returnValue = new Selection[selection.size()];
		selection.copyInto(returnValue);
		return returnValue;
	} //}}}
	//}}}
	//{{{ Entry class
	/**
	 * Recent file list entry.
	 */
	public static class Entry
	{
		public String path;
		public int caret;
		public String selection;
		public String encoding;
		public Selection[] getSelection()
		{
			return stringToSelection(selection);
		}
		public Entry(String path, int caret, String selection, String encoding)
		{
			this.path = path;
			this.caret = caret;
			this.selection = selection;
			this.encoding = encoding;
		}
		public String toString()
		{
			return path + "": "" + caret;
		}
	} //}}}
	//{{{ RecentHandler class
	static class RecentHandler extends HandlerBase
	{
		public void endDocument()
			throws java.lang.Exception
		{
			int max = jEdit.getIntegerProperty(""recentFiles"",50);
			while(history.size() > max)
				history.removeLast();
		}
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""recent.dtd"".equals(systemId))
			{
				// this will result in a slight speed up, since we
				// don't need to read the DTD anyway, as AElfred is
				// non-validating
				return new StringReader(""<!-- -->"");
				/* try
				{
					return new BufferedReader(new InputStreamReader(
						getClass().getResourceAsStream(""recent.dtd"")));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,""Error while opening""
						+ "" recent.dtd:"");
					Log.log(Log.ERROR,this,e);
				} */
			}
			return null;
		}
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""RECENT"".equals(name))
				return;
			Log.log(Log.ERROR,this,""recent.xml: DOCTYPE must be RECENT"");
		}
		public void endElement(String name)
		{
			if(name.equals(""ENTRY""))
			{
				history.addLast(new Entry(
					path,caret,selection,
					encoding));
				path = null;
				caret = 0;
				selection = null;
				encoding = null;
			}
			else if(name.equals(""PATH""))
				path = charData;
			else if(name.equals(""CARET""))
				caret = Integer.parseInt(charData);
			else if(name.equals(""SELECTION""))
				selection = charData;
			else if(name.equals(""ENCODING""))
				encoding = charData;
		}
		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		}
		// end HandlerBase implementation
		// private members
		private String path;
		private int caret;
		private String selection;
		private String encoding;
		private String charData;
	} //}}}
}
"
org.gjt.sp.jedit.Debug,"/*
 * Debug.java - Various debugging flags
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
/**
 * This class contains various debugging flags mainly useful for core
 * development.
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: Debug.java,v 1.28 2004/02/22 20:00:52 spestov Exp $
 */
public class Debug
{
	/**
	 * Print messages when the gap moves, and other offset manager state
	 * changes.
	 */
	public static boolean OFFSET_DEBUG = false;
	/**
	 * Print messages when text area and display manager perform scroll
	 * updates.
	 */
	public static boolean SCROLL_DEBUG = false;
	/**
	 * Print messages when text area tries to make the caret visible.
	 */
	public static boolean SCROLL_TO_DEBUG = false;
	/**
	 * Display an error if the scrolling code detects an inconsistency.
	 * This kills performance!
	 */
	public static boolean SCROLL_VERIFY = false;
	/**
	 * Print messages when screen line counts change.
	 */
	public static boolean SCREEN_LINES_DEBUG = false;
	/**
	 * For checking context, etc.
	 */
	public static boolean TOKEN_MARKER_DEBUG = false;
	/**
	 * For checking fold level invalidation, etc.
	 */
	public static boolean FOLD_DEBUG = false;
	/**
	 * For checking the line visibility structure..
	 */
	public static boolean FOLD_VIS_DEBUG = false;
	/**
	 * For checking invalidation, etc.
	 */
	public static boolean CHUNK_CACHE_DEBUG = false;
	/**
	 * Paints boxes around chunks.
	 */
	public static boolean CHUNK_PAINT_DEBUG = false;
	/**
	 * Show time taken to repaint text area painter.
	 */
	public static boolean PAINT_TIMER = false;
	/**
	 * Show time taken for each EBComponent.
	 */
	public static boolean EB_TIMER = false;
	/**
	 * Disable monospaced font optimization.
	 */
	public static boolean DISABLE_MONOSPACE_HACK = false;
	/**
	 * Paint strings instead of glyph vectors.
	 */
	public static boolean DISABLE_GLYPH_VECTOR = false;
	/**
	 * Logs messages when BeanShell code is evaluated.
	 */
	public static boolean BEANSHELL_DEBUG = false;
	/**
	 * If true, an alternative dispatcher using key typed events will be
	 * used to handle a modifier key press in conjunction with an alphabet
	 * key. <b>On by default on MacOS.</b>
	 */
	public static boolean ALTERNATIVE_DISPATCHER = OperatingSystem.isMacOS();
	/**
	 * If true, A+ shortcuts are disabled. If you use this, you should also
	 * remap the the modifiers so that A+ is actually something else.
	 * <b>On by default on MacOS.</b>
	 */
	public static boolean ALT_KEY_PRESSED_DISABLED = OperatingSystem.isMacOS();
	/**
	 * Geometry workaround for X11.
	 */
	public static boolean GEOMETRY_WORKAROUND = false;
	/**
	 * Dump key events received by text area?
	 */
	public static boolean DUMP_KEY_EVENTS = false;
	/**
	 * Indent debug.
	 */
	public static boolean INDENT_DEBUG = false;
	/**
	 * Printing debug.
	 */
	public static boolean PRINT_DEBUG = false;
	/**
	 * Create new search dialogs instead of reusing instances.
	 */
	public static boolean DISABLE_SEARCH_DIALOG_POOL = false;
}
"
org.gjt.sp.jedit.EBComponent,"/*
 * EBComponent.java - An EditBus component
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
/**
 * A component on the EditBus. Every plugin class that uses the EditBus for
 * receiving messages must implement this interface.
 *
 * @see org.gjt.sp.jedit.EBMessage
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: EBComponent.java,v 1.6 2003/02/11 02:55:57 spestov Exp $
 *
 * @since jEdit 2.2pre6
 */
public interface EBComponent
{
	/**
	 * Handles a message sent on the EditBus.
	 *
	 * This method must specify the type of responses the plugin will have
	 * for various subclasses of the {@link EBMessage} class. Typically
	 * this is done with one or more <code>if</code> blocks that test
	 * whether the message is an instance of a derived message class in
	 * which the component has an interest. For example:
	 *
	 * <pre> if(msg instanceof BufferUpdate) {
         *     // a buffer's state has changed!
         * }
         * else if(msg instanceof ViewUpdate) {
         *     // a view's state has changed!
         * }
         * // ... and so on</pre>
	 *
	 * @param message The message
	 */
	void handleMessage(EBMessage message);
}
"
org.gjt.sp.jedit.EBMessage,"/*
 * EBMessage.java - An EditBus message
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
/**
 * The base class of all EditBus messages.<p>
 *
 * Message classes extending this class typically add
 * other data members and methods to provide subscribers with whatever is
 * needed to handle the message appropriately.<p>
 *
 * Message types sent by jEdit can be found in the
 * {@link org.gjt.sp.jedit.msg} package.
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: EBMessage.java,v 1.7 2003/05/02 21:12:43 spestov Exp $
 *
 * @since jEdit 2.2pre6
 */
public abstract class EBMessage
{
	//{{{ EBMessage constructor
	/**
	 * Creates a new message.
	 * @param source The message source
	 * @since jEdit 4.2pre1
	 */
	public EBMessage(Object source)
	{
		this.source = source;
	} //}}}
	//{{{ EBMessage constructor
	/**
	 * Creates a new message.
	 * @param source The message source
	 */
	public EBMessage(EBComponent source)
	{
		this.source = source;
	} //}}}
	//{{{ getSource() method
	/**
	 * Returns the sender of this message.
	 * @since jEdit 4.2pre1
	 */
	public Object getSource()
	{
		return source;
	} //}}}
	//{{{ toString() method
	/**
	 * Returns a string representation of this message.
	 */
	public String toString()
	{
		String className = getClass().getName();
		int index = className.lastIndexOf('.');
		return className.substring(index + 1)
			+ ""["" + paramString() + ""]"";
	} //}}}
	//{{{ paramString() method
	/**
	 * Returns a string representation of this message's parameters.
	 */
	public String paramString()
	{
		return ""source="" + source;
	} //}}}
	//{{{ Private members
	private Object source;
	//}}}
	//{{{ Deprecated methods
	/**
	 * @deprecated Does nothing.
	 */
	public void veto()
	{
	}
	/**
	 * @deprecated Returns false.
	 */
	public boolean isVetoed()
	{
		return false;
	}
	/**
	 * @deprecated Subclass <code>EBMessage</code> instead.
	 */
	public static abstract class NonVetoable extends EBMessage
	{
		/**
		 * Creates a new non-vetoable message.
		 * @param source The message source
		 */
		public NonVetoable(EBComponent source)
		{
			super(source);
		}
		/**
		 * Disallows this message from being vetoed.
		 */
		public void veto()
		{
			throw new InternalError(""Can't veto this message"");
		}
	} //}}}
}
"
org.gjt.sp.jedit.EBPlugin,"/*
 * EBPlugin.java - An EditBus plugin
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import org.gjt.sp.util.Log;
/**
 * Plugins extending this class are automatically added to the EditBus.
 * Otherwise, this class is identical to the {@link EditPlugin}
 * class.
 *
 * @see org.gjt.sp.jedit.EditBus
 * @see org.gjt.sp.jedit.EBComponent
 * @see org.gjt.sp.jedit.EBMessage
 *
 * @author Slava Pestov
 * @version $Id: EBPlugin.java,v 1.7 2003/05/01 02:21:26 spestov Exp $
 */
public abstract class EBPlugin extends EditPlugin implements EBComponent
{
	/**
	 * Handles a message sent on the EditBus.
	 */
	// next version: remove this
	public void handleMessage(EBMessage message)
	{
		EditBus.removeFromBus(this);
		if(seenWarning)
			return;
		seenWarning = true;
		Log.log(Log.WARNING,this,getClassName() + "" should extend""
			+ "" EditPlugin not EBPlugin since it has an empty""
			+ "" handleMessage()"");
	}
	// protected members
	protected EBPlugin() {}
	// private members
	private boolean seenWarning;
}
"
org.gjt.sp.jedit.EditAction,"/*
 * EditAction.java - jEdit action listener
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.Component;
import org.gjt.sp.jedit.gui.InputHandler;
import org.gjt.sp.util.Log;
//}}}
/**
 * An action that can be bound to a menu item, tool bar button or keystroke.
 *
 * @see jEdit#getAction(String)
 * @see jEdit#getActionNames()
 * @see ActionSet
 *
 * @author Slava Pestov
 * @version $Id: EditAction.java,v 1.23 2003/05/01 04:17:13 spestov Exp $
 */
public abstract class EditAction
{
	//{{{ EditAction constructor
	/**
	 * Creates a new edit action with the specified name.
	 * @param name The action name
	 */
	public EditAction(String name)
	{
		this.name = name;
	} //}}}
	//{{{ getName() method
	/**
	 * Returns the internal name of this action.
	 */
	public String getName()
	{
		return name;
	} //}}}
	//{{{ getLabel() method
	/**
	 * Returns the action's label. This returns the
	 * value of the property named by {@link #getName()} suffixed
	 * with <code>.label</code>.
	 */
	public final String getLabel()
	{
		return jEdit.getProperty(name + "".label"");
	} //}}}
	//{{{ getMouseOverText() method
	/**
	 * Returns the action's mouse over message. This returns the
	 * value of the property named by {@link #getName()} suffixed
	 * with <code>.mouse-over</code>.
	 */
	public final String getMouseOverText()
	{
		return jEdit.getProperty(name + "".mouse-over"");
	} //}}}
	//{{{ invoke() method
	/**
	 * Invokes the action.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public void invoke(View view)
	{
	} //}}}
	//{{{ getView() method
	/**
	 * @deprecated Call <code>GUIUtilities.getView()</code> instead.
	 */
	public static View getView(Component comp)
	{
		// moved to GUIUtilities as it makes no sense being here.
		return GUIUtilities.getView(comp);
	} //}}}
	//{{{ isToggle() method
	/**
	 * Returns if this edit action should be displayed as a check box
	 * in menus. This returns the
	 * value of the property named by {@link #getName()} suffixed
	 * with <code>.toggle</code>.
	 *
	 * @since jEdit 2.2pre4
	 */
	public final boolean isToggle()
	{
		return jEdit.getBooleanProperty(name + "".toggle"");
	} //}}}
	//{{{ isSelected() method
	/**
	 * If this edit action is a toggle, returns if it is selected or not.
	 * @param comp The component
	 * @since jEdit 4.2pre1
	 */
	public boolean isSelected(Component comp)
	{
		return false;
	} //}}}
	//{{{ noRepeat() method
	/**
	 * Returns if this edit action should not be repeated. Returns false
	 * by default.
	 * @since jEdit 2.7pre2
	 */
	public boolean noRepeat()
	{
		return false;
	} //}}}
	//{{{ noRecord() method
	/**
	 * Returns if this edit action should not be recorded. Returns false
	 * by default.
	 * @since jEdit 2.7pre2
	 */
	public boolean noRecord()
	{
		return false;
	} //}}}
	//{{{ noRememberLast() method
	/**
	 * Returns if this edit action should not be remembered as the most
	 * recently invoked action.
	 * @since jEdit 4.2pre1
	 */
	public boolean noRememberLast()
	{
		return false;
	} //}}}
	//{{{ getCode() method
	/**
	 * Returns the BeanShell code that will replay this action.
	 * @since jEdit 2.7pre2
	 */
	public abstract String getCode();
	//}}}
	//{{{ toString() method
	public String toString()
	{
		return name;
	} //}}}
	//{{{ Private members
	private String name;
	//}}}
	//{{{ Wrapper class
	/**
	 * 'Wrap' EditActions in this class to turn them into AWT
	 * ActionListeners, that can be attached to buttons, menu items, etc.
	 */
	public static class Wrapper implements ActionListener
	{
		/**
		 * Creates a new action listener wrapper.
		 * @since jEdit 4.2pre1
		 */
		public Wrapper(ActionContext context, String actionName)
		{
			this.context = context;
			this.actionName = actionName;
		}
		/**
		 * Called when the user selects this action from a menu.
		 * It passes the action through the
		 * {@link org.gjt.sp.jedit.gui.InputHandler#invokeAction(EditAction)}
		 * method, which performs any recording or repeating.
		 *
		 * @param evt The action event
		 */
		public void actionPerformed(ActionEvent evt)
		{
			EditAction action = context.getAction(actionName);
			if(action == null)
			{
				Log.log(Log.WARNING,this,""Unknown action: ""
					+ actionName);
			}
			else
				context.invokeAction(evt,action);
		}
		private ActionContext context;
		private String actionName;
	} //}}}
}
"
org.gjt.sp.jedit.EditBus,"/*
 * EditBus.java - The EditBus
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.*;
import org.gjt.sp.util.Log;
/**
 * jEdit's global event notification mechanism.<p>
 *
 * Plugins register with the EditBus to receive messages reflecting
 * changes in the application's state, including changes in buffers,
 * views and edit panes, changes in the set of properties maintained
 * by the application, and the closing of the application.<p>
 *
 * The EditBus maintains a list of objects that have requested to receive
 * messages. When a message is sent using this class, all registered
 * components receive it in turn. Classes for objects that subscribe to
 * the EditBus must implement the {@link EBComponent} interface, which
 * defines the single method {@link EBComponent#handleMessage(EBMessage)}.<p>
 *
 * A plugin core class that extends the
 * {@link EBPlugin} abstract class (and whose name ends with
 * <code>Plugin</code> for identification purposes) will automatically be
 * added to the EditBus during jEdit's startup routine.  Any other
 * class - for example, a dockable window that needs to receive
 * notification of buffer changes - must perform its own registration by calling
 * {@link #addToBus(EBComponent)} during its initialization.
 * A convenient place to register in a class derived from <code>JComponent</code>
 * would be in an implementation of the <code>JComponent</code> method
 * <code>addNotify()</code>.<p>
 *
 * Message types sent by jEdit can be found in the
 * {@link org.gjt.sp.jedit.msg} package.<p>
 *
 * Plugins can also send their own messages - any object can send a message to
 * the EditBus by calling the static method {@link #send(EBMessage)}.
 * Most plugins, however, only concern themselves with receiving, not
 * sending, messages.
 *
 * @see org.gjt.sp.jedit.EBComponent
 * @see org.gjt.sp.jedit.EBMessage
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: EditBus.java,v 1.11 2003/05/01 02:21:26 spestov Exp $
 *
 * @since jEdit 2.2pre6
 */
public class EditBus
{
	//{{{ addToBus() method
	/**
	 * Adds a component to the bus. It will receive all messages sent
	 * on the bus.
	 *
	 * @param comp The component to add
	 */
	public static void addToBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.add(comp);
			copyComponents = null;
		}
	} //}}}
	//{{{ removeFromBus() method
	/**
	 * Removes a component from the bus.
	 * @param comp The component to remove
	 */
	public static void removeFromBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.remove(comp);
			copyComponents = null;
		}
	} //}}}
	//{{{ getComponents() method
	/**
	 * Returns an array of all components connected to the bus.
	 */
	public static EBComponent[] getComponents()
	{
		synchronized(components)
		{
			if (copyComponents == null)
			{
				copyComponents = (EBComponent[])components.toArray(
					new EBComponent[components.size()]);
			}
			return copyComponents;
		}
	} //}}}
	//{{{ send() method
	/**
	 * Sends a message to all components on the bus in turn.
	 * @param message The message
	 */
	public static void send(EBMessage message)
	{
		Log.log(Log.DEBUG,EditBus.class,message.toString());
		// To avoid any problems if components are added or removed
		// while the message is being sent
		EBComponent[] comps = getComponents();
		for(int i = 0; i < comps.length; i++)
		{
			try
			{
				EBComponent comp = comps[i];
				if(Debug.EB_TIMER)
				{
					long start = System.currentTimeMillis();
					comp.handleMessage(message);
					long time = (System.currentTimeMillis() - start);
					if(time != 0)
					{
						Log.log(Log.DEBUG,EditBus.class,comp + "": "" + time + "" ms"");
					}
				}
				else
					comps[i].handleMessage(message);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,EditBus.class,""Exception""
					+ "" while sending message on EditBus:"");
				Log.log(Log.ERROR,EditBus.class,t);
			}
		}
	} //}}}
	//{{{ Private members
	private static ArrayList components = new ArrayList();
	private static EBComponent[] copyComponents;
	// can't create new instances
	private EditBus() {}
	//}}}
}
"
org.gjt.sp.jedit.EditPane,"/*
 * EditPane.java - Text area and buffer switcher
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.lang.reflect.Method;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.options.GlobalOptions;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * A panel containing a text area.<p>
 *
 * In a BeanShell script, you can obtain the current edit pane from the
 * <code>editPane</code> variable.<p>
 *
 * This class does not have a public constructor.
 * Edit panes can be created and destroyed using methods in the
 * {@link View} class.<p>
 *
 * Each edit pane can edit one buffer at a time.
 *
 * @see View#splitHorizontally()
 * @see View#splitVertically()
 * @see View#unsplitCurrent()
 * @see View#unsplit()
 * @see View#getEditPane()
 * @see View#getEditPanes()
 *
 * @author Slava Pestov
 * @version $Id: EditPane.java,v 1.51 2004/08/17 06:37:35 spestov Exp $
 */
public class EditPane extends JPanel implements EBComponent
{
	//{{{ getView() method
	/**
	 * Returns the view containing this edit pane.
	 * @since jEdit 2.5pre2
	 */
	public View getView()
	{
		return view;
	} //}}}
	//{{{ getBuffer() method
	/**
	 * Returns the current buffer.
	 * @since jEdit 2.5pre2
	 */
	public Buffer getBuffer()
	{
		return buffer;
	} //}}}
	//{{{ setBuffer() method
	/**
	 * Sets the current buffer.
	 * @param buffer The buffer to edit.
	 * @since jEdit 2.5pre2
	 */
	public void setBuffer(final Buffer buffer)
	{
		if(buffer == null)
			throw new NullPointerException();
		if(this.buffer == buffer)
			return;
		//if(buffer.insideCompoundEdit())
		//	buffer.endCompoundEdit();
		recentBuffer = this.buffer;
		if(recentBuffer != null)
			saveCaretInfo();
		this.buffer = buffer;
		textArea.setBuffer(buffer);
		if(!init)
		{
			view.updateTitle();
			if(bufferSwitcher != null)
			{
				if(bufferSwitcher.getSelectedItem() != buffer)
					bufferSwitcher.setSelectedItem(buffer);
			}
			EditBus.send(new EditPaneUpdate(this,EditPaneUpdate
				.BUFFER_CHANGED));
		}
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				// only do this if we are the current edit pane
				if(view.getEditPane() == EditPane.this
					&& (bufferSwitcher == null
					|| !bufferSwitcher.isPopupVisible()))
				{
					textArea.requestFocus();
				}
			}
		});
		// Only do this after all I/O requests are complete
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				// avoid a race condition
				// see bug #834338
				if(buffer == getBuffer())
					loadCaretInfo();
			}
		};
		if(buffer.isPerformingIO())
			VFSManager.runInAWTThread(runnable);
		else
			runnable.run();
	} //}}}
	//{{{ prevBuffer() method
	/**
	 * Selects the previous buffer.
	 * @since jEdit 2.7pre2
	 */
	public void prevBuffer()
	{
		Buffer buffer = this.buffer.getPrev();
		if(buffer == null)
			setBuffer(jEdit.getLastBuffer());
		else
			setBuffer(buffer);
	} //}}}
	//{{{ nextBuffer() method
	/**
	 * Selects the next buffer.
	 * @since jEdit 2.7pre2
	 */
	public void nextBuffer()
	{
		Buffer buffer = this.buffer.getNext();
		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);
	} //}}}
	//{{{ recentBuffer() method
	/**
	 * Selects the most recently edited buffer.
	 * @since jEdit 2.7pre2
	 */
	public void recentBuffer()
	{
		if(recentBuffer != null)
			setBuffer(recentBuffer);
		else
			getToolkit().beep();
	} //}}}
	//{{{ focusOnTextArea() method
	/**
	 * Sets the focus onto the text area.
	 * @since jEdit 2.5pre2
	 */
	public void focusOnTextArea()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				textArea.requestFocus();
			}
		});
	} //}}}
	//{{{ getTextArea() method
	/**
	 * Returns the view's text area.
	 * @since jEdit 2.5pre2
	 */
	public JEditTextArea getTextArea()
	{
		return textArea;
	} //}}}
	//{{{ getBufferSwitcher() method
	/**
	 * Returns the buffer switcher combo box instance.
	 * @since jEdit 4.1pre8
	 */
	public BufferSwitcher getBufferSwitcher()
	{
		return bufferSwitcher;
	} //}}}
	//{{{ showBufferSwitcher() method
	/**
	 * Shows the buffer switcher combo box.
	 * @since jEdit 4.1pre8
	 */
	public void showBufferSwitcher()
	{
		if(bufferSwitcher == null)
			getToolkit().beep();
		else
		{
			bufferSwitcher.requestFocus();
			bufferSwitcher.showPopup();
		}
	} //}}}
	//{{{ saveCaretInfo() method
	/**
	 * Saves the caret information to the current buffer.
	 * @since jEdit 2.5pre2
	 */
	public void saveCaretInfo()
	{
		if(!buffer.isLoaded())
			return;
		buffer.setIntegerProperty(Buffer.CARET,
			textArea.getCaretPosition());
		/*Selection[] selection = textArea.getSelection();
		if(selection != null)
			buffer.setProperty(Buffer.SELECTION,selection);*/
		buffer.setIntegerProperty(Buffer.SCROLL_VERT,
			textArea.getFirstPhysicalLine());
		buffer.setIntegerProperty(Buffer.SCROLL_HORIZ,
			textArea.getHorizontalOffset());
	} //}}}
	//{{{ loadCaretInfo() method
	/**
	 * Loads the caret information from the current buffer.
	 * @since jEdit 2.5pre2
	 */
	public void loadCaretInfo()
	{
		Integer caret = (Integer)buffer.getProperty(Buffer.CARET);
		//Selection[] selection = (Selection[])buffer.getProperty(Buffer.SELECTION);
		Integer firstLine = (Integer)buffer.getProperty(Buffer.SCROLL_VERT);
		Integer horizontalOffset = (Integer)buffer.getProperty(Buffer.SCROLL_HORIZ);
		if(caret != null)
		{
			textArea.setCaretPosition(Math.min(caret.intValue(),
				buffer.getLength()));
		}
		/*if(selection != null)
			textArea.setSelection(selection);*/
		if(firstLine != null)
			textArea.setFirstPhysicalLine(firstLine.intValue());
		if(horizontalOffset != null)
			textArea.setHorizontalOffset(horizontalOffset.intValue());
		/* Silly bug workaround #8694. If you look at the above code,
		 * note that we restore the saved caret position first, then
		 * scroll to the saved location. However, the caret changing
		 * can itself result in scrolling to a different location than
		 * what was saved; and since moveCaretPosition() calls
		 * updateBracketHighlight(), the bracket highlight's out of
		 * bounds calculation will rely on a different set of physical
		 * first/last lines than what we will end up with eventually.
		 * Instead of confusing the user with status messages that
		 * appear at random when switching buffers, we simply hide the
		 * message altogether. */
		view.getStatus().setMessage(null);
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
		{
			propertiesChanged();
			loadBufferSwitcher();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
	} //}}}
	//{{{ getMinimumSize() method
	/**
	 * Returns 0,0 for split pane compatibility.
	 */
	public final Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		return getClass().getName() + ""[""
			+ (view.getEditPane() == this
			? ""active"" : ""inactive"")
			+ ""]"";
	} //}}}
	//{{{ Package-private members
	//{{{ EditPane constructor
	EditPane(View view, Buffer buffer)
	{
		super(new BorderLayout());
		init = true;
		this.view = view;
		EditBus.addToBus(this);
		textArea = new JEditTextArea(view);
		add(BorderLayout.CENTER,textArea);
		propertiesChanged();
		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);
		loadBufferSwitcher();
		init = false;
	} //}}}
	//{{{ close() method
	void close()
	{
		saveCaretInfo();
		EditBus.send(new EditPaneUpdate(this,EditPaneUpdate.DESTROYED));
		EditBus.removeFromBus(this);
		textArea.dispose();
	} //}}}
	//}}}
	//{{{ Private members
	private static Method initBufferSwitcher;
	static
	{
		if(OperatingSystem.hasJava14())
		{
			try
			{
				initBufferSwitcher = Java14.class
					.getMethod(""initBufferSwitcher"",
					new Class[] { EditPane.class,
					BufferSwitcher.class });
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,EditPane.class,e);
			}
		}
	}
	//{{{ Instance variables
	private boolean init;
	private View view;
	private Buffer buffer;
	private Buffer recentBuffer;
	private BufferSwitcher bufferSwitcher;
	private JEditTextArea textArea;
	//}}}
	//{{{ propertiesChanged() method
	private void propertiesChanged()
	{
		TextAreaPainter painter = textArea.getPainter();
		painter.setFont(jEdit.getFontProperty(""view.font""));
		painter.setStructureHighlightEnabled(jEdit.getBooleanProperty(
			""view.structureHighlight""));
		painter.setStructureHighlightColor(
			jEdit.getColorProperty(""view.structureHighlightColor""));
		painter.setEOLMarkersPainted(jEdit.getBooleanProperty(
			""view.eolMarkers""));
		painter.setEOLMarkerColor(
			jEdit.getColorProperty(""view.eolMarkerColor""));
		painter.setWrapGuidePainted(jEdit.getBooleanProperty(
			""view.wrapGuide""));
		painter.setWrapGuideColor(
			jEdit.getColorProperty(""view.wrapGuideColor""));
		painter.setCaretColor(
			jEdit.getColorProperty(""view.caretColor""));
		painter.setSelectionColor(
			jEdit.getColorProperty(""view.selectionColor""));
		painter.setMultipleSelectionColor(
			jEdit.getColorProperty(""view.multipleSelectionColor""));
		painter.setBackground(
			jEdit.getColorProperty(""view.bgColor""));
		painter.setForeground(
			jEdit.getColorProperty(""view.fgColor""));
		painter.setBlockCaretEnabled(jEdit.getBooleanProperty(
			""view.blockCaret""));
		painter.setLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.lineHighlight""));
		painter.setLineHighlightColor(
			jEdit.getColorProperty(""view.lineHighlightColor""));
		painter.setAntiAliasEnabled(jEdit.getBooleanProperty(
			""view.antiAlias""));
		painter.setFractionalFontMetricsEnabled(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		String defaultFont = jEdit.getProperty(""view.font"");
		int defaultFontSize = jEdit.getIntegerProperty(""view.fontsize"",12);
		painter.setStyles(GUIUtilities.loadStyles(defaultFont,defaultFontSize));
		SyntaxStyle[] foldLineStyle = new SyntaxStyle[4];
		for(int i = 0; i <= 3; i++)
		{
			foldLineStyle[i] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.foldLine."" + i),
				defaultFont,defaultFontSize);
		}
		painter.setFoldLineStyle(foldLineStyle);
		Gutter gutter = textArea.getGutter();
		gutter.setExpanded(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		int interval = jEdit.getIntegerProperty(
			""view.gutter.highlightInterval"",5);
		gutter.setHighlightInterval(interval);
		gutter.setCurrentLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		gutter.setStructureHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.structureHighlight""));
		gutter.setStructureHighlightColor(
			jEdit.getColorProperty(""view.gutter.structureHighlightColor""));
		gutter.setBackground(
			jEdit.getColorProperty(""view.gutter.bgColor""));
		gutter.setForeground(
			jEdit.getColorProperty(""view.gutter.fgColor""));
		gutter.setHighlightedForeground(
			jEdit.getColorProperty(""view.gutter.highlightColor""));
		gutter.setFoldColor(
			jEdit.getColorProperty(""view.gutter.foldColor""));
		gutter.setMarkerHighlightColor(
			jEdit.getColorProperty(""view.gutter.markerColor""));
		gutter.setMarkerHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		gutter.setCurrentLineForeground(
			jEdit.getColorProperty(""view.gutter.currentLineColor""));
		String alignment = jEdit.getProperty(
			""view.gutter.numberAlignment"");
		if (""right"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.RIGHT);
		}
		else if (""center"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.CENTER);
		}
		else // left == default case
		{
			gutter.setLineNumberAlignment(Gutter.LEFT);
		}
		gutter.setFont(jEdit.getFontProperty(""view.gutter.font""));
		int width = jEdit.getIntegerProperty(
			""view.gutter.borderWidth"",3);
		gutter.setBorder(width,
			jEdit.getColorProperty(""view.gutter.focusBorderColor""),
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor""),
			textArea.getPainter().getBackground());
		textArea.setCaretBlinkEnabled(jEdit.getBooleanProperty(
			""view.caretBlink""));
		textArea.setElectricScroll(jEdit.getIntegerProperty(
			""view.electricBorders"",0));
		// Set up the right-click popup menu
		JPopupMenu popup = GUIUtilities.loadPopupMenu(""view.context"");
		JMenuItem customize = new JMenuItem(jEdit.getProperty(
			""view.context.customize""));
		customize.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				new GlobalOptions(view,""context"");
			}
		});
		popup.addSeparator();
		popup.add(customize);
		textArea.setRightClickPopup(popup);
		// use old property name for backwards compatibility
		textArea.setQuickCopyEnabled(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
		textArea.setDragEnabled(jEdit.getBooleanProperty(
			""view.dragAndDrop""));
		textArea.propertiesChanged();
	} //}}}
	//{{{ loadBufferSwitcher() method
	private void loadBufferSwitcher()
	{
		if(jEdit.getBooleanProperty(""view.showBufferSwitcher""))
		{
			if(bufferSwitcher == null)
			{
				bufferSwitcher = new BufferSwitcher(this);
				if(initBufferSwitcher != null)
				{
					try
					{
						initBufferSwitcher.invoke(
							null,new Object[] {
								EditPane.this,
								bufferSwitcher
							});
					}
					catch(Exception e)
					{
						Log.log(Log.ERROR,this,e);
					}
				}
				add(BorderLayout.NORTH,bufferSwitcher);
				bufferSwitcher.updateBufferList();
				revalidate();
			}
		}
		else if(bufferSwitcher != null)
		{
			remove(bufferSwitcher);
			revalidate();
			bufferSwitcher = null;
		}
	} //}}}
	//{{{ handleBufferUpdate() method
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer _buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.CREATED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();
			/* When closing the last buffer, the BufferUpdate.CLOSED
			 * handler doesn't call setBuffer(), because null buffers
			 * are not supported. Instead, it waits for the subsequent
			 * 'Untitled' file creation. */
			if(buffer.isClosed())
			{
				setBuffer(jEdit.getFirstBuffer());
				// since recentBuffer will be set to the one that
				// was closed
				recentBuffer = null;
			}
		}
		else if(msg.getWhat() == BufferUpdate.CLOSED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();
			if(_buffer == buffer)
			{
				Buffer newBuffer = (recentBuffer != null ?
					recentBuffer : _buffer.getPrev());
				if(newBuffer != null && !newBuffer.isClosed())
					setBuffer(newBuffer);
				else if(jEdit.getBufferCount() != 0)
					setBuffer(jEdit.getFirstBuffer());
				recentBuffer = null;
			}
			else if(_buffer == recentBuffer)
				recentBuffer = null;
		}
		else if(msg.getWhat() == BufferUpdate.LOAD_STARTED)
		{
			if(_buffer == buffer)
			{
				textArea.setCaretPosition(0);
				textArea.getPainter().repaint();
			}
		}
		else if(msg.getWhat() == BufferUpdate.LOADED)
		{
			if(_buffer == buffer)
			{
				textArea.repaint();
				if(bufferSwitcher != null)
					bufferSwitcher.updateBufferList();
				if(view.getEditPane() == this)
				{
					StatusBar status = view.getStatus();
					status.updateCaretStatus();
					status.updateBufferStatus();
					status.updateMiscStatus();
				}
				loadCaretInfo();
			}
		}
		else if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(_buffer == buffer)
			{
				if(bufferSwitcher != null)
				{
					if(buffer.isDirty())
						bufferSwitcher.repaint();
					else
						bufferSwitcher.updateBufferList();
				}
			}
		}
		else if(msg.getWhat() == BufferUpdate.MARKERS_CHANGED)
		{
			if(_buffer == buffer)
				textArea.getGutter().repaint();
		}
		else if(msg.getWhat() == BufferUpdate.PROPERTIES_CHANGED)
		{
			if(_buffer == buffer)
			{
				textArea.propertiesChanged();
				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.SAVED)
		{
			if(_buffer == buffer)
				textArea.propertiesChanged();
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.EditPlugin,"/*
 * EditPlugin.java - Abstract class all plugins must implement
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.JMenuItem;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.menu.EnhancedMenu;
/**
 * The abstract base class that every plugin must implement.
 * Alternatively, instead of extending this class, a plugin core class can
 * extend {@link EBPlugin} to automatically receive EditBus messages.
 *
 * <h3>Basic plugin information properties</h3>
 *
 * Note that in all cases above where a class name is needed, the fully
 * qualified class name, including the package name, if any, must be used.<p>
 *
 * The following properties are required for jEdit to load the plugin:
 *
 * <ul>
 * <li><code>plugin.<i>class name</i>.activate</code> - set this to
 * <code>defer</code> if your plugin only needs to be loaded when it is first
 * invoked; set it to <code>startup</code> if your plugin must be loaded at
 * startup regardless; set it to a whitespace-separated list of property names
 * if your plugin should be loaded if at least one of these properties is set.
 * Note that if this property is <b>not</b> set, the plugin is loaded like an
 * old-style jEdit 4.1 plugin.
 * </li>
 * <li><code>plugin.<i>class name</i>.name</code></li>
 * <li><code>plugin.<i>class name</i>.version</code></li>
 * <li><code>plugin.<i>class name</i>.jars</code> - only needed if your plugin
 * bundles external JAR files. Contains a whitespace-separated list of JAR
 * file names. Without this property, the plugin manager will leave behind the
 * external JAR files when removing the plugin.</li>
 * </ul>
 *
 * The following properties are optional but recommended:
 *
 * <ul>
 * <li><code>plugin.<i>class name</i>.author</code></li>
 * <li><code>plugin.<i>class name</i>.docs</code> - the path to plugin
 * documentation in HTML format within the JAR file.</li>
 * </ul>
 *
 * <h3>Plugin dependency properties</h3>
 *
 * Plugin dependencies are also specified using properties.
 * Each dependency is defined in a property named with
 * <code>plugin.<i>class name</i>.depend.</code> followed by a number.
 * Dependencies must be numbered in order, starting from zero.<p>
 *
 * The value of a dependency property has one of the following forms:
 *
 * <ul>
 * <li><code>jdk <i>minimum Java version</i></code></li>
 * <li><code>jedit <i>minimum jEdit version</i></code> - note that this must be
 * a version number in the form returned by {@link jEdit#getBuild()},
 * not {@link jEdit#getVersion()}. Note that the documentation here describes
 * the jEdit 4.2 plugin API, so this dependency must be set to at least
 * <code>04.02.01.00</code>.</li>
 * <li><code>plugin <i>plugin</i> <i>version</i></code> - the fully quailified
 * plugin class name must be specified.</li>
 * </ul>
 *
 * <h3>Plugin menu item properties</h3>
 *
 * To add your plugin to the view's <b>Plugins</b> menu, define one of these two
 * properties:
 *
 * <ul>
 * <li><code>plugin.<i>class name</i>.menu-item</code> - if this is defined,
 * the action named by this property is added to the <b>Plugins</b> menu.</li>
 * <li><code>plugin.<i>class name</i>.menu</code> - if this is defined,
 * a sub-menu is added to the <b>Plugins</b> menu whose content is the
 * whitespace-separated list of action names in this property. A separator may
 * be added to the sub-menu by listing <code>-</code> in the property.</li>
 * </ul>
 *
 * If you want the plugin's menu items to be determined at runtime, define a
 * property <code>plugin.<i>class name</i>.menu.code</code> to be BeanShell
 * code that evaluates to an implementation of
 * {@link org.gjt.sp.jedit.menu.DynamicMenuProvider}.<p>
 *
 * To add your plugin to the file system browser's <b>Plugins</b> menu, define
 * one of these two properties:
 *
 * <ul>
 * <li><code>plugin.<i>class name</i>.browser-menu-item</code> - if this is
 * defined, the action named by this property is added to the <b>Plugins</b>
 * menu.</li>
 * <li><code>plugin.<i>class name</i>.browser-menu</code> - if this is defined,
 * a sub-menu is added to the <b>Plugins</b> menu whose content is the
 * whitespace-separated list of action names in this property. A separator may
 * be added to the sub-menu by listing <code>-</code> in the property.</li>
 * </ul>
 *
 * In all cases, each action's
 * menu item label is taken from the <code><i>action name</i>.label</code>
 * property. View actions are defined in an <code>actions.xml</code>
 * file, file system browser actions are defined in a
 * <code>browser.actions.xml</code> file; see {@link ActionSet}.
 *
 * <h3>Plugin option pane properties</h3>
 *
 * To add your plugin to the <b>Plugin Options</b> dialog box, define one of
 * these two properties:
 *
 * <ul>
 * <li><code>plugin.<i>class name</i>.option-pane</code> - if this is defined,
 * the option pane named by this property is added to the <b>Plugin Options</b>
 * menu.</li>
 * <li><code>plugin.<i>class name</i>.option-group</code> - if this is defined,
 * a branch node is added to the <b>Plugin Options</b> dialog box whose content
 * is the whitespace-separated list of option pane names in this property.</li>
 * </ul>
 *
 * Then for each option pane name, define these two properties:
 *
 * <ul>
 * <li><code>options.<i>option pane name</i>.label</code> - the label to show
 * for the pane in the dialog box.</li>
 * <li><code>options.<i>option pane name</i>.code</code> - BeanShell code that
 * evaluates to an instance of the {@link OptionPane} class.</li>
 *
 * <h3>Example</h3>
 *
 * Here is an example set of plugin properties:
 *
 * <pre>plugin.QuickNotepadPlugin.activate=defer
 *plugin.QuickNotepadPlugin.name=QuickNotepad
 *plugin.QuickNotepadPlugin.author=John Gellene
 *plugin.QuickNotepadPlugin.version=4.2
 *plugin.QuickNotepadPlugin.docs=QuickNotepad.html
 *plugin.QuickNotepadPlugin.depend.0=jedit 04.02.01.00
 *plugin.QuickNotepadPlugin.menu=quicknotepad \
 *    - \
 *    quicknotepad.choose-file \
 *    quicknotepad.save-file \
 *    quicknotepad.copy-to-buffer
 *plugin.QuickNotepadPlugin.option-pane=quicknotepad</pre>
 *
 * Note that action and option pane labels are not shown in the above example.
 *
 * @see org.gjt.sp.jedit.jEdit#getProperty(String)
 * @see org.gjt.sp.jedit.jEdit#getPlugin(String)
 * @see org.gjt.sp.jedit.jEdit#getPlugins()
 * @see org.gjt.sp.jedit.jEdit#getPluginJAR(String)
 * @see org.gjt.sp.jedit.jEdit#getPluginJARs()
 * @see org.gjt.sp.jedit.jEdit#addPluginJAR(String)
 * @see org.gjt.sp.jedit.jEdit#removePluginJAR(PluginJAR,boolean)
 * @see org.gjt.sp.jedit.ActionSet
 * @see org.gjt.sp.jedit.gui.DockableWindowManager
 * @see org.gjt.sp.jedit.OptionPane
 * @see org.gjt.sp.jedit.PluginJAR
 * @see org.gjt.sp.jedit.ServiceManager
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: EditPlugin.java,v 1.31 2003/05/03 20:34:25 spestov Exp $
 * @since jEdit 2.1pre1
 */
public abstract class EditPlugin
{
	//{{{ start() method
	/**
	 * jEdit calls this method when the plugin is being activated, either
	 * during startup or at any other time. A plugin can get activated for
	 * a number of reasons:
	 *
	 * <ul>
	 * <li>The plugin is written for jEdit 4.1 or older, in which case it
	 * will always be loaded at startup.</li>
	 * <li>The plugin has its <code>activate</code> property set to
	 * <code>startup</code>, in which case it will always be loaded at
	 * startup.</li>
	 * <li>One of the properties listed in the plugin's
	 * <code>activate</code> property is set to <code>true</code>,
	 * in which case it will always be loaded at startup.</li>
	 * <li>One of the plugin's classes is being accessed by another plugin,
	 * a macro, or a BeanShell snippet in a plugin API XML file.</li>
	 * </ul>
	 *
	 * Note that this method is always called from the event dispatch
	 * thread, even if the activation resulted from a class being loaded
	 * from another thread. A side effect of this is that some of your
	 * plugin's code might get executed before this method finishes
	 * running.<p>
	 *
	 * When this method is being called for plugins written for jEdit 4.1
	 * and below, no views or buffers are open. However, this is not the
	 * case for plugins using the new API. For example, if your plugin adds
	 * tool bars to views, make sure you correctly handle the case where
	 * views are already open when the plugin is loaded.<p>
	 *
	 * If your plugin must be loaded on startup, take care to have this
	 * method return as quickly as possible.<p>
	 *
	 * The default implementation of this method does nothing.
	 *
	 * @since jEdit 2.1pre1
	 */
	public void start() {}
	//}}}
	//{{{ stop() method
	/**
	 * jEdit calls this method when the plugin is being unloaded. This can
	 * be when the program is exiting, or at any other time.<p>
	 *
	 * If a plugin uses state information or other persistent data
	 * that should be stored in a special format, this would be a good place
	 * to write the data to storage.  If the plugin uses jEdit's properties
	 * API to hold settings, no special processing is needed for them on
	 * exit, since they will be saved automatically.<p>
	 *
	 * With plugins written for jEdit 4.1 and below, this method is only
	 * called when the program is exiting. However, this is not the case
	 * for plugins using the new API. For example, if your plugin adds
	 * tool bars to views, make sure you correctly handle the case where
	 * views are still open when the plugin is unloaded.<p>
	 *
	 * To avoid memory leaks, this method should ensure that no references
	 * to any objects created by this plugin remain in the heap. In the
	 * case of actions, dockable windows and services, jEdit ensures this
	 * automatically. For other objects, your plugin must clean up maually.
	 * <p>
	 *
	 * The default implementation of this method does nothing.
	 *
	 * @since jEdit 2.1pre1
	 */
	public void stop() {} //}}}
	//{{{ getClassName() method
	/**
	 * Returns the plugin's class name. This might not be the same as
	 * the class of the actual <code>EditPlugin</code> instance, for
	 * example if the plugin is not loaded yet.
	 *
	 * @since jEdit 2.5pre3
	 */
	public String getClassName()
	{
		return getClass().getName();
	} //}}}
	//{{{ getPluginJAR() method
	/**
	 * Returns the JAR file containing this plugin.
	 * @since jEdit 4.2pre1
	 */
	public PluginJAR getPluginJAR()
	{
		return jar;
	} //}}}
	//{{{ createMenuItems() method
	/**
	 * Called by the view when constructing its <b>Plugins</b> menu.
	 * See the description of this class for details about how the
	 * menu items are constructed from plugin properties.
	 *
	 * @since jEdit 4.2pre1
	 */
	public final JMenuItem createMenuItems()
	{
		if(this instanceof Broken)
			return null;
		String menuItemName = jEdit.getProperty(""plugin."" +
			getClassName() + "".menu-item"");
		if(menuItemName != null)
			return GUIUtilities.loadMenuItem(menuItemName);
		String menuProperty = ""plugin."" + getClassName() + "".menu"";
		String codeProperty = ""plugin."" + getClassName() + "".menu.code"";
		if(jEdit.getProperty(menuProperty) != null
			|| jEdit.getProperty(codeProperty) != null)
		{
			String pluginName = jEdit.getProperty(""plugin."" +
				getClassName() + "".name"");
			return new EnhancedMenu(menuProperty,pluginName);
		}
		return null;
	} //}}}
	//{{{ createBrowserMenuItems() method
	/**
	 * Called by the filesystem browser when constructing its
	 * <b>Plugins</b> menu.
	 * See the description of this class for details about how the
	 * menu items are constructed from plugin properties.
	 *
	 * @since jEdit 4.2pre1
	 */
	public final JMenuItem createBrowserMenuItems()
	{
		if(this instanceof Broken)
			return null;
		String menuItemName = jEdit.getProperty(""plugin."" +
			getClassName() + "".browser-menu-item"");
		if(menuItemName != null)
		{
			return GUIUtilities.loadMenuItem(
				VFSBrowser.getActionContext(),
				menuItemName,
				false);
		}
		String menuProperty = ""plugin."" + getClassName() + "".browser-menu"";
		if(jEdit.getProperty(menuProperty) != null)
		{
			String pluginName = jEdit.getProperty(""plugin."" +
				getClassName() + "".name"");
			return new EnhancedMenu(menuProperty,pluginName,
				VFSBrowser.getActionContext());
		}
		return null;
	} //}}}
	//{{{ Deprecated methods
	//{{{ createMenuItems() method
	/**
	 * @deprecated Instead of overriding this method, define properties
	 * as specified in the description of this class.
	 */
	public void createMenuItems(Vector menuItems) {} //}}}
	//{{{ createOptionPanes() method
	/**
	 * @deprecated Instead of overriding this method, define properties
	 * as specified in the description of this class.
	 */
	public void createOptionPanes(OptionsDialog optionsDialog) {} //}}}
	//{{{ getJAR() method
	/**
	 * @deprecated Call <code>getPluginJAR()</code> instead.
	 */
	public EditPlugin.JAR getJAR()
	{
		return jar;
	} //}}}
	//}}}
	//{{{ Package-private members
	EditPlugin.JAR jar;
	//}}}
	//{{{ Broken class
	/**
	 * A placeholder for a plugin that didn't load.
	 * @see jEdit#getPlugin(String)
	 * @see PluginJAR#getPlugin()
	 * @see PluginJAR#activatePlugin()
	 */
	public static class Broken extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}
		// package-private members
		Broken(String clazz)
		{
			this.clazz = clazz;
		}
		// private members
		private String clazz;
	} //}}}
	//{{{ Deferred class
	/**
	 * A placeholder for a plugin that hasn't been loaded yet.
	 * @see jEdit#getPlugin(String)
	 * @see PluginJAR#getPlugin()
	 * @see PluginJAR#activatePlugin()
	 */
	public static class Deferred extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}
		// package-private members
		Deferred(String clazz)
		{
			this.clazz = clazz;
		}
		EditPlugin loadPluginClass()
		{
			return null;
		}
		public String toString()
		{
			return ""Deferred["" + clazz + ""]"";
		}
		// private members
		private String clazz;
	} //}}}
	//{{{ JAR class
	/**
	 * @deprecated Use <code>PluginJAR</code> instead.
	 */
	public static class JAR extends PluginJAR
	{
		JAR(java.io.File file)
		{
			super(file);
		}
	}
	//}}}
}
"
org.gjt.sp.jedit.EditServer,"/*
 * EditServer.java - jEdit server
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import bsh.NameSpace;
import javax.swing.SwingUtilities;
import java.io.*;
import java.net.*;
import java.util.Random;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.util.Log;
//}}}
/**
 * Inter-process communication.<p>
 *
 * The edit server protocol is very simple. <code>$HOME/.jedit/server</code>
 * is an ASCII file containing two lines, the first being the port number,
 * the second being the authorization key.<p>
 *
 * You connect to that port on the local machine, sending the authorization
 * key as four bytes in network byte order, followed by the length of the
 * BeanShell script as two bytes in network byte order, followed by the
 * script in UTF8 encoding. After the socked is closed, the BeanShell script
 * will be executed by jEdit.<p>
 *
 * The snippet is executed in the AWT thread. None of the usual BeanShell
 * variables (view, buffer, textArea, editPane) are set so the script has to
 * figure things out by itself.<p>
 *
 * In most cases, the script will call the static
 * {@link #handleClient(boolean,String,String[])} method, but of course more
 * complicated stuff can be done too.
 *
 * @author Slava Pestov
 * @version $Id: EditServer.java,v 1.23 2004/08/08 03:41:34 spestov Exp $
 */
public class EditServer extends Thread
{
	//{{{ EditServer constructor
	EditServer(String portFile)
	{
		super(""jEdit server daemon ["" + portFile + ""]"");
		setDaemon(true);
		this.portFile = portFile;
		try
		{
			// On Unix, set permissions of port file to rw-------,
			// so that on broken Unices which give everyone read
			// access to user home dirs, people can't see your
			// port file (and hence send arbitriary BeanShell code
			// your way. Nasty.)
			if(OperatingSystem.isUnix())
			{
				new File(portFile).createNewFile();
				FileVFS.setPermissions(portFile,0600);
			}
			// Bind to any port on localhost; accept 2 simultaneous
			// connection attempts before rejecting connections
			socket = new ServerSocket(0, 2,
				InetAddress.getByName(""127.0.0.1""));
			authKey = Math.abs(new Random().nextInt());
			int port = socket.getLocalPort();
			FileWriter out = new FileWriter(portFile);
			try
			{
				out.write(""b\n"");
				out.write(String.valueOf(port));
				out.write(""\n"");
				out.write(String.valueOf(authKey));
				out.write(""\n"");
			}
			finally
			{
				out.close();
			}
			ok = true;
			Log.log(Log.DEBUG,this,""jEdit server started on port ""
				+ socket.getLocalPort());
			Log.log(Log.DEBUG,this,""Authorization key is ""
				+ authKey);
		}
		catch(IOException io)
		{
			/* on some Windows versions, connections to localhost
			 * fail if the network is not running. To avoid
			 * confusing newbies with weird error messages, log
			 * errors that occur while starting the server
			 * as NOTICE, not ERROR */
			Log.log(Log.NOTICE,this,io);
		}
	} //}}}
	//{{{ run() method
	public void run()
	{
		for(;;)
		{
			if(abort)
				return;
			Socket client = null;
			try
			{
				client = socket.accept();
				// Stop script kiddies from opening the edit
				// server port and just leaving it open, as a
				// DoS
				client.setSoTimeout(1000);
				Log.log(Log.MESSAGE,this,client + "": connected"");
				DataInputStream in = new DataInputStream(
					client.getInputStream());
				if(!handleClient(client,in))
					abort = true;
			}
			catch(Exception e)
			{
				if(!abort)
					Log.log(Log.ERROR,this,e);
				abort = true;
			}
			finally
			{
				/* if(client != null)
				{
					try
					{
						client.close();
					}
					catch(Exception e)
					{
						Log.log(Log.ERROR,this,e);
					}
					client = null;
				} */
			}
		}
	} //}}}
	//{{{ handleClient() method
	/**
	 * @param restore Ignored unless no views are open
	 * @param parent The client's parent directory
	 * @param args A list of files. Null entries are ignored, for convinience
	 * @since jEdit 3.2pre7
	 */
	public static void handleClient(boolean restore, String parent,
		String[] args)
	{
		handleClient(restore,false,false,parent,args);
	} //}}}
	//{{{ handleClient() method
	/**
	 * @param restore Ignored unless no views are open
	 * @param newView Open a new view?
	 * @param newPlainView Open a new plain view?
	 * @param parent The client's parent directory
	 * @param args A list of files. Null entries are ignored, for convinience
	 * @since jEdit 4.2pre1
	 */
	public static Buffer handleClient(boolean restore,
		boolean newView, boolean newPlainView, String parent,
		String[] args)
	{
		// we have to deal with a huge range of possible border cases here.
		if(jEdit.getFirstView() == null)
		{
			// coming out of background mode.
			// no views open.
			// no buffers open if args empty.
			Buffer buffer = jEdit.openFiles(null,parent,args);
			if(jEdit.getBufferCount() == 0)
				jEdit.newFile(null);
			boolean restoreFiles = restore
				&& jEdit.getBooleanProperty(""restore"")
				&& (buffer == null
				|| jEdit.getBooleanProperty(""restore.cli""));
			View view = PerspectiveManager.loadPerspective(
				restoreFiles);
			if(view == null)
			{
				if(buffer == null)
					buffer = jEdit.getFirstBuffer();
				view = jEdit.newView(null,buffer);
			}
			else if(buffer != null)
				view.setBuffer(buffer);
			return buffer;
		}
		else if(newPlainView)
		{
			// no background mode, and opening a new view
			Buffer buffer = jEdit.openFiles(null,parent,args);
			if(buffer == null)
				buffer = jEdit.getFirstBuffer();
			jEdit.newView(null,buffer,true);
			return buffer;
		}
		else if(newView)
		{
			// no background mode, and opening a new view
			Buffer buffer = jEdit.openFiles(null,parent,args);
			if(buffer == null)
				buffer = jEdit.getFirstBuffer();
			jEdit.newView(jEdit.getActiveView(),buffer,false);
			return buffer;
		}
		else
		{
			// no background mode, and reusing existing view
			View view = jEdit.getActiveView();
			Buffer buffer = jEdit.openFiles(view,parent,args);
			// Hack done to fix bringing the window to the front.
			// At least on windows, Frame.toFront() doesn't cut it.
			// Remove the isWindows check if it's broken under other
			// OSes too.
			if (jEdit.getBooleanProperty(""server.brokenToFront""))
				view.setState(java.awt.Frame.ICONIFIED);
			// un-iconify using JDK 1.3 API
			view.setState(java.awt.Frame.NORMAL);
			view.requestFocus();
			view.toFront();
			return buffer;
		}
	} //}}}
	//{{{ isOK() method
	boolean isOK()
	{
		return ok;
	} //}}}
	//{{{ getPort method
	public int getPort()
	{
		return socket.getLocalPort();
	} //}}}
	//{{{ stopServer() method
	void stopServer()
	{
		abort = true;
		try
		{
			socket.close();
		}
		catch(IOException io)
		{
		}
		new File(portFile).delete();
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private String portFile;
	private ServerSocket socket;
	private int authKey;
	private boolean ok;
	private boolean abort;
	//}}}
	//{{{ handleClient() method
	private boolean handleClient(final Socket client, DataInputStream in)
		throws Exception
	{
		int key = in.readInt();
		if(key != authKey)
		{
			Log.log(Log.ERROR,this,client + "": wrong""
				+ "" authorization key (got "" + key
				+ "", expected "" + authKey + "")"");
			in.close();
			client.close();
			return false;
		}
		else
		{
			// Reset the timeout
			client.setSoTimeout(0);
			Log.log(Log.DEBUG,this,client + "": authenticated""
				+ "" successfully"");
			final String script = in.readUTF();
			Log.log(Log.DEBUG,this,script);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					try
					{
						NameSpace ns = new NameSpace(
							BeanShell.getNameSpace(),
							""EditServer namespace"");
						ns.setVariable(""socket"",client);
						BeanShell.eval(null,ns,script);
					}
					catch(bsh.UtilEvalError e)
					{
						Log.log(Log.ERROR,this,e);
					}
					finally
					{
						try
						{
							BeanShell.getNameSpace().setVariable(""socket"",null);
						}
						catch(bsh.UtilEvalError e)
						{
							Log.log(Log.ERROR,this,e);
						}
					}
				}
			});
			return true;
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.GUIUtilities,"/*
 * GUIUtilities.java - Various GUI utility functions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.menu.*;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.util.Log;
//}}}
/**
 * Various GUI functions.<p>
 *
 * The most frequently used members of this class are:
 *
 * <ul>
 * <li>{@link #loadIcon(String)}</li>
 * <li>{@link #confirm(Component,String,Object[],int,int)}</li>
 * <li>{@link #error(Component,String,Object[])}</li>
 * <li>{@link #message(Component,String,Object[])}</li>
 * <li>{@link #showPopupMenu(JPopupMenu,Component,int,int)}</li>
 * <li>{@link #showVFSFileDialog(View,String,int,boolean)}</li>
 * <li>{@link #loadGeometry(Window,String)}</li>
 * <li>{@link #saveGeometry(Window,String)}</li>
 * </ul>
 *
 * @author Slava Pestov
 * @version $Id: GUIUtilities.java,v 1.82 2004/06/04 00:18:34 spestov Exp $
 */
public class GUIUtilities
{
	//{{{ Some predefined icons
	/**
	 * @deprecated Use <code>GUIUtilities.loadIcon(""new.gif"");</code>
	 * instead.
	 */
	public static Icon NEW_BUFFER_ICON;
	/**
	 * @deprecated Use <code>GUIUtilities.loadIcon(""dirty.gif"");</code>
	 * instead.
	 */
	public static Icon DIRTY_BUFFER_ICON;
	/**
	 * @deprecated Use <code>GUIUtilities.loadIcon(""readonly.gif"");</code>
	 * instead.
	 */
	public static Icon READ_ONLY_BUFFER_ICON;
	/**
	 * @deprecated Use <code>GUIUtilities.loadIcon(""normal.gif"");</code>
	 * instead.
	 */
	public static Icon NORMAL_BUFFER_ICON;
	/**
	 * @deprecated Use <code>GUIUtilities.loadIcon(""jedit-icon.gif"");</code>
	 * instead.
	 */
	public static Icon WINDOW_ICON;
	//}}}
	//{{{ Icon methods
	//{{{ setIconPath() method
	/**
	 * Sets the path where jEdit looks for icons.
	 * @since jEdit 4.2pre5
	 */
	public static void setIconPath(String iconPath)
	{
		GUIUtilities.iconPath = iconPath;
		if(icons != null)
			icons.clear();
	} //}}}
	//{{{ loadIcon() method
	/**
	 * Loads an icon.
	 * @param iconName The icon name
	 * @since jEdit 2.6pre7
	 */
	public static Icon loadIcon(String iconName)
	{
		if(icons == null)
			icons = new Hashtable();
		// check if there is a cached version first
		Icon icon = (Icon)icons.get(iconName);
		if(icon != null)
			return icon;
		// get the icon
		if(MiscUtilities.isURL(iconName))
		{
			icon = new ImageIcon(iconName.substring(5));
		}
		else
		{
			try
			{
				URL url = new URL(iconPath + iconName);
				icon = new ImageIcon(url);
			}
			catch(Exception e)
			{
				try
				{
					URL url = new URL(defaultIconPath + iconName);
					icon = new ImageIcon(url);
				}
				catch(Exception ex)
				{
					Log.log(Log.ERROR,GUIUtilities.class,
						""Icon not found: "" + iconName);
					Log.log(Log.ERROR,GUIUtilities.class,ex);
					return null;
				}
			}
		}
		icons.put(iconName,icon);
		return icon;
	} //}}}
	//{{{ getEditorIcon() method
	/**
	 * Returns the default editor window image.
	 */
	public static Image getEditorIcon()
	{
		return ((ImageIcon)loadIcon(""jedit-icon.gif"")).getImage();
	} //}}}
	//{{{ getPluginIcon() method
	/**
	 * Returns the default plugin window image.
	 */
	public static Image getPluginIcon()
	{
		return getEditorIcon();
	} //}}}
	//}}}
	//{{{ Menus, tool bars
	//{{{ loadMenuBar() method
	/**
	 * Creates a menubar. Plugins should not need to call this method.
	 * @param name The menu bar name
	 * @since jEdit 3.2pre5
	 */
	public static JMenuBar loadMenuBar(String name)
	{
		return loadMenuBar(jEdit.getActionContext(),name);
	} //}}}
	//{{{ loadMenuBar() method
	/**
	 * Creates a menubar. Plugins should not need to call this method.
	 * @param context An action context
	 * @param name The menu bar name
	 * @since jEdit 4.2pre1
	 */
	public static JMenuBar loadMenuBar(ActionContext context, String name)
	{
		String menus = jEdit.getProperty(name);
		StringTokenizer st = new StringTokenizer(menus);
		JMenuBar mbar = new JMenuBar();
		while(st.hasMoreTokens())
		{
			mbar.add(loadMenu(context,st.nextToken()));
		}
		return mbar;
	} //}}}
	//{{{ loadMenu() method
	/**
	 * Creates a menu. The menu label is set from the
	 * <code><i>name</i>.label</code> property. The menu contents is taken
	 * from the <code><i>name</i></code> property, which is a whitespace
	 * separated list of action names. An action name of <code>-</code>
	 * inserts a separator in the menu.
	 * @param name The menu name
	 * @see #loadMenuItem(String)
	 * @since jEdit 2.6pre2
	 */
	public static JMenu loadMenu(String name)
	{
		return loadMenu(jEdit.getActionContext(),name);
	} //}}}
	//{{{ loadMenu() method
	/**
	 * Creates a menu. The menu label is set from the
	 * <code><i>name</i>.label</code> property. The menu contents is taken
	 * from the <code><i>name</i></code> property, which is a whitespace
	 * separated list of action names. An action name of <code>-</code>
	 * inserts a separator in the menu.
	 * @param context An action context; either
	 * <code>jEdit.getActionContext()</code> or
	 * <code>VFSBrowser.getActionContext()</code>.
	 * @param name The menu name
	 * @see #loadMenuItem(String)
	 * @since jEdit 4.2pre1
	 */
	public static JMenu loadMenu(ActionContext context, String name)
	{
		return new EnhancedMenu(name,
			jEdit.getProperty(name.concat("".label"")),
			context);
	} //}}}
	//{{{ loadPopupMenu() method
	/**
	 * Creates a popup menu.
	 * @param name The menu name
	 * @since jEdit 2.6pre2
	 */
	public static JPopupMenu loadPopupMenu(String name)
	{
		return loadPopupMenu(jEdit.getActionContext(),name);
	} //}}}
	//{{{ loadPopupMenu() method
	/**
	 * Creates a popup menu.
	 * @param context An action context; either
	 * <code>jEdit.getActionContext()</code> or
	 * <code>VFSBrowser.getActionContext()</code>.
	 * @param name The menu name
	 * @since jEdit 4.2pre1
	 */
	public static JPopupMenu loadPopupMenu(ActionContext context, String name)
	{
		JPopupMenu menu = new JPopupMenu();
		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					menu.addSeparator();
				else
					menu.add(loadMenuItem(context,menuItemName,false));
			}
		}
		return menu;
	} //}}}
	//{{{ loadMenuItem() method
	/**
	 * Creates a menu item. The menu item is bound to the action named by
	 * <code>name</code> with label taken from the return value of the
	 * {@link EditAction#getLabel()} method.
	 *
	 * @param name The menu item name
	 * @see #loadMenu(String)
	 * @since jEdit 2.6pre1
	 */
	public static JMenuItem loadMenuItem(String name)
	{
		return loadMenuItem(jEdit.getActionContext(),name,true);
	} //}}}
	//{{{ loadMenuItem() method
	/**
	 * Creates a menu item.
	 * @param name The menu item name
	 * @param setMnemonic True if the menu item should have a mnemonic
	 * @since jEdit 3.1pre1
	 */
	public static JMenuItem loadMenuItem(String name, boolean setMnemonic)
	{
		return loadMenuItem(jEdit.getActionContext(),name,setMnemonic);
	} //}}}
	//{{{ loadMenuItem() method
	/**
	 * Creates a menu item.
	 * @param context An action context; either
	 * <code>jEdit.getActionContext()</code> or
	 * <code>VFSBrowser.getActionContext()</code>.
	 * @param name The menu item name
	 * @param setMnemonic True if the menu item should have a mnemonic
	 * @since jEdit 4.2pre1
	 */
	public static JMenuItem loadMenuItem(ActionContext context, String name,
		boolean setMnemonic)
	{
		if(name.startsWith(""%""))
			return loadMenu(context,name.substring(1));
		String label = jEdit.getProperty(name + "".label"");
		if(label == null)
			label = name;
		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';
		JMenuItem mi;
		if(jEdit.getBooleanProperty(name + "".toggle""))
			mi = new EnhancedCheckBoxMenuItem(label,name,context);
		else
			mi = new EnhancedMenuItem(label,name,context);
		if(!OperatingSystem.isMacOS() && setMnemonic && mnemonic != '\0')
			mi.setMnemonic(mnemonic);
		return mi;
	} //}}}
	//{{{ loadToolBar() method
	/**
	 * Creates a toolbar.
	 * @param name The toolbar name
	 * @since jEdit 4.2pre2
	 */
	public static Box loadToolBar(String name)
	{
		return loadToolBar(jEdit.getActionContext(),name);
	} //}}}
	//{{{ loadToolBar() method
	/**
	 * Creates a toolbar.
	 * @param context An action context; either
	 * <code>jEdit.getActionContext()</code> or
	 * <code>VFSBrowser.getActionContext()</code>.
	 * @param name The toolbar name
	 * @since jEdit 4.2pre2
	 */
	public static Box loadToolBar(ActionContext context, String name)
	{
		Box toolBar = new Box(BoxLayout.X_AXIS);
		String buttons = jEdit.getProperty(name);
		if(buttons != null)
		{
			StringTokenizer st = new StringTokenizer(buttons);
			while(st.hasMoreTokens())
			{
				String button = st.nextToken();
				if(button.equals(""-""))
					toolBar.add(Box.createHorizontalStrut(12));
				else
				{
					JButton b = loadToolButton(context,button);
					if(b != null)
						toolBar.add(b);
				}
			}
		}
		toolBar.add(Box.createGlue());
		return toolBar;
	} //}}}
	//{{{ loadToolButton() method
	/**
	 * Loads a tool bar button. The tooltip is constructed from
	 * the <code><i>name</i>.label</code> and
	 * <code><i>name</i>.shortcut</code> properties and the icon is loaded
	 * from the resource named '/org/gjt/sp/jedit/icons/' suffixed
	 * with the value of the <code><i>name</i>.icon</code> property.
	 * @param name The name of the button
	 */
	public static EnhancedButton loadToolButton(String name)
	{
		return loadToolButton(jEdit.getActionContext(),name);
	} //}}}
	//{{{ loadToolButton() method
	/**
	 * Loads a tool bar button. The tooltip is constructed from
	 * the <code><i>name</i>.label</code> and
	 * <code><i>name</i>.shortcut</code> properties and the icon is loaded
	 * from the resource named '/org/gjt/sp/jedit/icons/' suffixed
	 * with the value of the <code><i>name</i>.icon</code> property.
	 * @param context An action context; either
	 * <code>jEdit.getActionContext()</code> or
	 * <code>VFSBrowser.getActionContext()</code>.
	 * @param name The name of the button
	 * @since jEdit 4.2pre1
	 */
	public static EnhancedButton loadToolButton(ActionContext context,
		String name)
	{
		String label = jEdit.getProperty(name + "".label"");
		if(label == null)
			label = name;
		Icon icon;
		String iconName = jEdit.getProperty(name + "".icon"");
		if(iconName == null)
			icon = loadIcon(""BrokenImage.png"");
		else
		{
			icon = loadIcon(iconName);
			if(icon == null)
				icon = loadIcon(""BrokenImage.png"");
		}
		String toolTip = prettifyMenuLabel(label);
		String shortcut1 = jEdit.getProperty(name + "".shortcut"");
		String shortcut2 = jEdit.getProperty(name + "".shortcut2"");
		if(shortcut1 != null || shortcut2 != null)
		{
			toolTip = toolTip + "" (""
				+ (shortcut1 != null
				? shortcut1 : """")
				+ ((shortcut1 != null && shortcut2 != null)
				? "" or "" : """")
				+ (shortcut2 != null
				? shortcut2
				: """") + "")"";
		}
		return new EnhancedButton(icon,toolTip,name,context);
	} //}}}
	//{{{ prettifyMenuLabel() method
	/**
	 * `Prettifies' a menu item label by removing the `$' sign. This
	 * can be used to process the contents of an <i>action</i>.label
	 * property.
	 */
	public static String prettifyMenuLabel(String label)
	{
		int index = label.indexOf('$');
		if(index != -1)
		{
			label = label.substring(0,index)
				.concat(label.substring(index + 1));
		}
		return label;
	} //}}}
	//}}}
	//{{{ Canned dialog boxes
	//{{{ message() method
	/**
	 * Displays a dialog box.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property. The message
	 * is formatted by the property manager with <code>args</code> as
	 * positional parameters.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 */
	public static void message(Component comp, String name, Object[] args)
	{
		hideSplashScreen();
		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.INFORMATION_MESSAGE);
	} //}}}
	//{{{ error() method
	/**
	 * Displays an error dialog box.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property. The message
	 * is formatted by the property manager with <code>args</code> as
	 * positional parameters.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 */
	public static void error(Component comp, String name, Object[] args)
	{
		hideSplashScreen();
		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.ERROR_MESSAGE);
	} //}}}
	//{{{ input() method
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param def The text to display by default in the input field
	 */
	public static String input(Component comp, String name, Object def)
	{
		return input(comp,name,null,def);
	} //}}}
	//{{{ inputProperty() method
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param def The property whose text to display in the input field
	 */
	public static String inputProperty(Component comp, String name,
		String def)
	{
		return inputProperty(comp,name,null,def);
	} //}}}
	//{{{ input() method
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param def The text to display by default in the input field
	 * @param args Positional parameters to be substituted into the
	 * message text
	 * @since jEdit 3.1pre3
	 */
	public static String input(Component comp, String name,
		Object[] args, Object def)
	{
		hideSplashScreen();
		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,null,null,def);
		return retVal;
	} //}}}
	//{{{ inputProperty() method
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 * @param def The property whose text to display in the input field
	 * @since jEdit 3.1pre3
	 */
	public static String inputProperty(Component comp, String name,
		Object[] args, String def)
	{
		hideSplashScreen();
		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,
			null,null,jEdit.getProperty(def));
		if(retVal != null)
			jEdit.setProperty(def,retVal);
		return retVal;
	} //}}}
	//{{{ confirm() method
	/**
	 * Displays a confirm dialog box and returns the button pushed by the
	 * user. The title of the dialog is fetched from the
	 * <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 * @param buttons The buttons to display - for example,
	 * JOptionPane.YES_NO_CANCEL_OPTION
	 * @param type The dialog type - for example,
	 * JOptionPane.WARNING_MESSAGE
	 * @since jEdit 3.1pre3
	 */
	public static int confirm(Component comp, String name,
		Object[] args, int buttons, int type)
	{
		hideSplashScreen();
		return JOptionPane.showConfirmDialog(comp,
			jEdit.getProperty(name + "".message"",args),
			jEdit.getProperty(name + "".title""),buttons,type);
	} //}}}
	//{{{ showVFSFileDialog() method
	/**
	 * Displays a VFS file selection dialog box.
	 * @param view The view, should be non-null
	 * @param path The initial directory to display. May be null
	 * @param type The dialog type. One of
	 * {@link org.gjt.sp.jedit.browser.VFSBrowser#OPEN_DIALOG},
	 * {@link org.gjt.sp.jedit.browser.VFSBrowser#SAVE_DIALOG}, or
	 * {@link org.gjt.sp.jedit.browser.VFSBrowser#CHOOSE_DIRECTORY_DIALOG}.
	 * @param multipleSelection True if multiple selection should be allowed
	 * @return The selected file(s)
	 * @since jEdit 2.6pre2
	 */
	public static String[] showVFSFileDialog(View view, String path,
		int type, boolean multipleSelection)
	{
		// the view should not be null, but some plugins might do this
		if(view == null)
		{
			Log.log(Log.WARNING,GUIUtilities.class,
			""showVFSFileDialog(): given null view, assuming jEdit.getActiveView()"");
			view = jEdit.getActiveView();
		}
		hideSplashScreen();
		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			view,path,type,multipleSelection);
		String[] selectedFiles = fileChooser.getSelectedFiles();
		if(selectedFiles == null)
			return null;
		return selectedFiles;
	} //}}}
	//}}}
	//{{{ Colors and styles
	//{{{ parseColor() method
	/**
	 * Converts a color name to a color object. The name must either be
	 * a known string, such as `red', `green', etc (complete list is in
	 * the <code>java.awt.Color</code> class) or a hex color value
	 * prefixed with `#', for example `#ff0088'.
	 * @param name The color name
	 */
	public static Color parseColor(String name)
	{
		return parseColor(name, Color.black);
	} //}}}
	//{{{ parseColor() method
	public static Color parseColor(String name, Color defaultColor)
	{
		if(name == null)
			return defaultColor;
		else if(name.startsWith(""#""))
		{
			try
			{
				return Color.decode(name);
			}
			catch(NumberFormatException nf)
			{
				return defaultColor;
			}
		}
		else if(""red"".equals(name))
			return Color.red;
		else if(""green"".equals(name))
			return Color.green;
		else if(""blue"".equals(name))
			return Color.blue;
		else if(""yellow"".equals(name))
			return Color.yellow;
		else if(""orange"".equals(name))
			return Color.orange;
		else if(""white"".equals(name))
			return Color.white;
		else if(""lightGray"".equals(name))
			return Color.lightGray;
		else if(""gray"".equals(name))
			return Color.gray;
		else if(""darkGray"".equals(name))
			return Color.darkGray;
		else if(""black"".equals(name))
			return Color.black;
		else if(""cyan"".equals(name))
			return Color.cyan;
		else if(""magenta"".equals(name))
			return Color.magenta;
		else if(""pink"".equals(name))
			return Color.pink;
		else
			return defaultColor;
	} //}}}
	//{{{ getColorHexString() method
	/**
	 * Converts a color object to its hex value. The hex value
	 * prefixed is with `#', for example `#ff0088'.
	 * @param c The color object
	 */
	public static String getColorHexString(Color c)
	{
		String colString = Integer.toHexString(c.getRGB() & 0xffffff);
		return ""#000000"".substring(0,7 - colString.length()).concat(colString);
	} //}}}
	//{{{ parseStyle() method
	/**
	 * Converts a style string to a style object.
	 * @param str The style string
	 * @param family Style strings only specify font style, not font family
	 * @param size Style strings only specify font style, not font family
	 * @exception IllegalArgumentException if the style is invalid
	 * @since jEdit 3.2pre6
	 */
	public static SyntaxStyle parseStyle(String str, String family, int size)
		throws IllegalArgumentException
	{
		return parseStyle(str,family,size,true);
	} //}}}
	//{{{ parseStyle() method
	/**
	 * Converts a style string to a style object.
	 * @param str The style string
	 * @param family Style strings only specify font style, not font family
	 * @param size Style strings only specify font style, not font family
	 * @param color If false, the styles will be monochrome
	 * @exception IllegalArgumentException if the style is invalid
	 * @since jEdit 4.0pre4
	 */
	public static SyntaxStyle parseStyle(String str, String family, int size,
		boolean color)
		throws IllegalArgumentException
	{
		Color fgColor = Color.black;
		Color bgColor = null;
		boolean italic = false;
		boolean bold = false;
		StringTokenizer st = new StringTokenizer(str);
		while(st.hasMoreTokens())
		{
			String s = st.nextToken();
			if(s.startsWith(""color:""))
			{
				if(color)
					fgColor = GUIUtilities.parseColor(s.substring(6), Color.black);
			}
			else if(s.startsWith(""bgColor:""))
			{
				if(color)
					bgColor = GUIUtilities.parseColor(s.substring(8), null);
			}
			else if(s.startsWith(""style:""))
			{
				for(int i = 6; i < s.length(); i++)
				{
					if(s.charAt(i) == 'i')
						italic = true;
					else if(s.charAt(i) == 'b')
						bold = true;
					else
						throw new IllegalArgumentException(
							""Invalid style: "" + s);
				}
			}
			else
				throw new IllegalArgumentException(
					""Invalid directive: "" + s);
		}
		return new SyntaxStyle(fgColor,bgColor,
			new Font(family,
			(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0),
			size));
	} //}}}
	//{{{ getStyleString() method
	/**
	 * Converts a style into it's string representation.
	 * @param style The style
	 */
	public static String getStyleString(SyntaxStyle style)
	{
		StringBuffer buf = new StringBuffer();
		if(style.getForegroundColor() != null)
		{
			buf.append(""color:"" + getColorHexString(style.getForegroundColor()));
		}
		if(style.getBackgroundColor() != null) 
		{
			buf.append("" bgColor:"" + getColorHexString(style.getBackgroundColor()));
		}
		if(!style.getFont().isPlain())
		{
			buf.append("" style:"" + (style.getFont().isItalic() ? ""i"" : """")
				+ (style.getFont().isBold() ? ""b"" : """"));
		}
		return buf.toString();
	} //}}}
	//{{{ loadStyles() method
	/**
	 * Loads the syntax styles from the properties, giving them the specified
	 * base font family and size.
	 * @param family The font family
	 * @param size The font size
	 * @since jEdit 3.2pre6
	 */
	public static SyntaxStyle[] loadStyles(String family, int size)
	{
		return loadStyles(family,size,true);
	} //}}}
	//{{{ loadStyles() method
	/**
	 * Loads the syntax styles from the properties, giving them the specified
	 * base font family and size.
	 * @param family The font family
	 * @param size The font size
	 * @param color If false, the styles will be monochrome
	 * @since jEdit 4.0pre4
	 */
	public static SyntaxStyle[] loadStyles(String family, int size, boolean color)
	{
		SyntaxStyle[] styles = new SyntaxStyle[Token.ID_COUNT];
		// start at 1 not 0 to skip Token.NULL
		for(int i = 1; i < styles.length; i++)
		{
			try
			{
				String styleName = ""view.style.""
					+ Token.tokenToString((byte)i)
					.toLowerCase();
				styles[i] = GUIUtilities.parseStyle(
					jEdit.getProperty(styleName),
					family,size,color);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,GUIUtilities.class,e);
			}
		}
		return styles;
	} //}}}
	//}}}
	//{{{ Loading, saving window geometry
	//{{{ loadGeometry() method
	/**
	 * Loads a windows's geometry from the properties.
	 * The geometry is loaded from the <code><i>name</i>.x</code>,
	 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and
	 * <code><i>name</i>.height</code> properties.
	 *
	 * @param win The window
	 * @param name The window name
	 */
	public static void loadGeometry(Window win, String name)
	{
		int x, y, width, height;
		Dimension size = win.getSize();
		GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
		Rectangle gcbounds = gd.getDefaultConfiguration().getBounds();
		x = gcbounds.x;
		y = gcbounds.y;
		width = jEdit.getIntegerProperty(name + "".width"",size.width);
		height = jEdit.getIntegerProperty(name + "".height"",size.height);
		Component parent = win.getParent();
		if(parent == null)
		{
			x += (gcbounds.width - width) / 2;
			y += (gcbounds.height - height) / 2;
		}
		else
		{
			Rectangle bounds = parent.getBounds();
			x += bounds.x + (bounds.width - width) / 2;
			y += bounds.y + (bounds.height - height) / 2;
		}
		x = jEdit.getIntegerProperty(name + "".x"",x);
		y = jEdit.getIntegerProperty(name + "".y"",y);
		int extState = jEdit.getIntegerProperty(name + "".extendedState"", 0);
		Rectangle desired = new Rectangle(x,y,width,height);
		adjustForScreenBounds(desired);
		if(OperatingSystem.isX11() && Debug.GEOMETRY_WORKAROUND)
			new UnixWorkaround(win,name,desired,extState);
		else
		{
			win.setBounds(desired);
			if(win instanceof Frame)
				setExtendedState((Frame)win,extState);
		}
	} //}}}
	//{{{ adjustForScreenBounds() method
	/**
	 * Gives a rectangle the specified bounds, ensuring it is within the
	 * screen bounds.
	 * @since jEdit 4.2pre3
	 */
	public static void adjustForScreenBounds(Rectangle desired)
	{
		// Make sure the window is displayed in visible region
		Rectangle osbounds = OperatingSystem.getScreenBounds(desired);
		if(desired.x < osbounds.x || desired.x+desired.width
			> desired.x + osbounds.width)
		{
			if (desired.width > osbounds.width)
				desired.width = osbounds.width;
			desired.x = (osbounds.width - desired.width) / 2;
		}
		if(desired.y < osbounds.y || desired.y+desired.height
			> osbounds.y + osbounds.height)
		{
			if (desired.height >= osbounds.height)
				desired.height = osbounds.height;
			desired.y = (osbounds.height - desired.height) / 2;
		}
	} //}}}
	//{{{ UnixWorkaround class
	static class UnixWorkaround
	{
		Window win;
		String name;
		Rectangle desired;
		Rectangle required;
		long start;
		boolean windowOpened;
		//{{{ UnixWorkaround constructor
		UnixWorkaround(Window win, String name, Rectangle desired,
			int extState)
		{
			this.win = win;
			this.name = name;
			this.desired = desired;
			int adjust_x, adjust_y, adjust_width, adjust_height;
			adjust_x = jEdit.getIntegerProperty(name + "".dx"",0);
			adjust_y = jEdit.getIntegerProperty(name + "".dy"",0);
			adjust_width = jEdit.getIntegerProperty(name + "".d-width"",0);
			adjust_height = jEdit.getIntegerProperty(name + "".d-height"",0);
			required = new Rectangle(
				desired.x - adjust_x,
				desired.y - adjust_y,
				desired.width - adjust_width,
				desired.height - adjust_height);
			Log.log(Log.DEBUG,GUIUtilities.class,""Window "" + name
				+ "": desired geometry is "" + desired);
			Log.log(Log.DEBUG,GUIUtilities.class,""Window "" + name
				+ "": setting geometry to "" + required);
			start = System.currentTimeMillis();
			win.setBounds(required);
			if(win instanceof Frame)
				setExtendedState((Frame)win,extState);
			win.addComponentListener(new ComponentHandler());
			win.addWindowListener(new WindowHandler());
		} //}}}
		//{{{ ComponentHandler class
		class ComponentHandler extends ComponentAdapter
		{
			//{{{ componentMoved() method
			public void componentMoved(ComponentEvent evt)
			{
				if(System.currentTimeMillis() - start < 1000)
				{
					Rectangle r = win.getBounds();
					if(!windowOpened && r.equals(required))
						return;
					if(!r.equals(desired))
					{
						Log.log(Log.DEBUG,GUIUtilities.class,
							""Window resize blocked: "" + win.getBounds());
						win.setBounds(desired);
					}
				}
				win.removeComponentListener(this);
			} //}}}
			//{{{ componentResized() method
			public void componentResized(ComponentEvent evt)
			{
				if(System.currentTimeMillis() - start < 1000)
				{
					Rectangle r = win.getBounds();
					if(!windowOpened && r.equals(required))
						return;
					if(!r.equals(desired))
					{
 						Log.log(Log.DEBUG,GUIUtilities.class,
 							""Window resize blocked: "" + win.getBounds());
						win.setBounds(desired);
					}
				}
				win.removeComponentListener(this);
			} //}}}
		} //}}}
		//{{{ WindowHandler class
		class WindowHandler extends WindowAdapter
		{
			//{{{ windowOpened() method
			public void windowOpened(WindowEvent evt)
			{
				windowOpened = true;
				Rectangle r = win.getBounds();
 				Log.log(Log.DEBUG,GUIUtilities.class,""Window ""
 					+ name + "": bounds after opening: "" + r);
				jEdit.setIntegerProperty(name + "".dx"",
					r.x - required.x);
				jEdit.setIntegerProperty(name + "".dy"",
					r.y - required.y);
				jEdit.setIntegerProperty(name + "".d-width"",
					r.width - required.width);
				jEdit.setIntegerProperty(name + "".d-height"",
					r.height - required.height);
				win.removeWindowListener(this);
			} //}}}
		} //}}}
	} //}}}
	//{{{ saveGeometry() method
	/**
	 * Saves a window's geometry to the properties.
	 * The geometry is saved to the <code><i>name</i>.x</code>,
	 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and
	 * <code><i>name</i>.height</code> properties.
	 * @param win The window
	 * @param name The window name
	 */
	public static void saveGeometry(Window win, String name)
	{
		if(win instanceof Frame)
		{
			jEdit.setIntegerProperty(name + "".extendedState"",
				getExtendedState((Frame)win));
		}
		Rectangle bounds = win.getBounds();
		jEdit.setIntegerProperty(name + "".x"",bounds.x);
		jEdit.setIntegerProperty(name + "".y"",bounds.y);
		jEdit.setIntegerProperty(name + "".width"",bounds.width);
		jEdit.setIntegerProperty(name + "".height"",bounds.height);
	} //}}}
	//{{{ getExtendedState() method
	/**
	 * On Java 1.4, calls <code>Frame.getExtendedState()</code>.
	 * On Java 1.3, returns 0.
	 * @since jEdit 4.2pre1
	 */
	public static int getExtendedState(Frame frame)
	{
		if(OperatingSystem.hasJava14())
		{
			try
			{
				java.lang.reflect.Method meth =
					Frame.class.getMethod(""getExtendedState"",
					new Class[0]);
				Integer extState = (Integer)meth.invoke(frame,
					new Object[0]);
				return extState.intValue();
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,GUIUtilities.class,e);
			}
		}
		return 0;
	} //}}}
	//{{{ setExtendedState() method
	/**
	 * On Java 1.4, calls <code>Frame.setExtendedState()</code>.
	 * On Java 1.3, does nothing.
	 * @since jEdit 4.2pre1
	 */
	public static void setExtendedState(Frame frame, int extState)
	{
		if(OperatingSystem.hasJava14())
		{
			try
			{
				java.lang.reflect.Method meth =
					Frame.class.getMethod(""setExtendedState"",
					new Class[] {int.class});
				meth.invoke(frame, new Object[] {
					new Integer(extState)});
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,GUIUtilities.class,e);
			}
		}
	} //}}}
	//{{{ centerOnScreen() method
	/**
	 * Centers the given window on the screen. This method is needed because
	 * JDK 1.3 does not have a <code>JWindow.setLocationRelativeTo()</code>
	 * method.
	 * @since jEdit 4.2pre3
	 */
	public static void centerOnScreen(Window win)
	{
		GraphicsDevice gd = GraphicsEnvironment
			.getLocalGraphicsEnvironment()
			.getDefaultScreenDevice();
		Rectangle gcbounds = gd.getDefaultConfiguration().getBounds();
		int x = gcbounds.x + (gcbounds.width - win.getWidth()) / 2;
		int y = gcbounds.y + (gcbounds.height - win.getHeight()) / 2;
		win.setLocation(x,y);
	} //}}}
	//}}}
	//{{{ hideSplashScreen() method
	/**
	 * Ensures that the splash screen is not visible. This should be
	 * called before displaying any dialog boxes or windows at
	 * startup.
	 */
	public static void hideSplashScreen()
	{
		if(splash != null)
		{
			splash.dispose();
			splash = null;
		}
	} //}}}
	//{{{ createMultilineLabel() method
	/**
	 * Creates a component that displays a multiple line message. This
	 * is implemented by assembling a number of <code>JLabels</code> in
	 * a <code>JPanel</code>.
	 * @param str The string, with lines delimited by newline
	 * (<code>\n</code>) characters.
	 * @since jEdit 4.1pre3
	 */
	public static JComponent createMultilineLabel(String str)
	{
		JPanel panel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1,1,1));
		int lastOffset = 0;
		for(;;)
		{
			int index = str.indexOf('\n',lastOffset);
			if(index == -1)
				break;
			else
			{
				panel.add(new JLabel(str.substring(lastOffset,index)));
				lastOffset = index + 1;
			}
		}
		if(lastOffset != str.length())
			panel.add(new JLabel(str.substring(lastOffset)));
		return panel;
	} //}}}
	//{{{ requestFocus() method
	/**
	 * Focuses on the specified component as soon as the window becomes
	 * active.
	 * @param win The window
	 * @param comp The component
	 */
	public static void requestFocus(final Window win, final Component comp)
	{
		win.addWindowListener(new WindowAdapter()
		{
			public void windowActivated(WindowEvent evt)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						comp.requestFocus();
					}
				});
				win.removeWindowListener(this);
			}
		});
	} //}}}
	//{{{ isPopupTrigger() method
	/**
	 * Returns if the specified event is the popup trigger event.
	 * This implements precisely defined behavior, as opposed to
	 * MouseEvent.isPopupTrigger().
	 * @param evt The event
	 * @since jEdit 3.2pre8
	 */
	public static boolean isPopupTrigger(MouseEvent evt)
	{
		return isRightButton(evt.getModifiers());
	} //}}}
	//{{{ isMiddleButton() method
	/**
	 * @param modifiers The modifiers flag from a mouse event
	 * @since jEdit 4.1pre9
	 */
	public static boolean isMiddleButton(int modifiers)
	{
		if (OperatingSystem.isMacOS())
		{
			if((modifiers & MouseEvent.BUTTON1_MASK) != 0)
				return ((modifiers & MouseEvent.ALT_MASK) != 0);
			if(!OperatingSystem.hasJava14())
				return ((modifiers & MouseEvent.BUTTON3_MASK) != 0);
			else
				return ((modifiers & MouseEvent.BUTTON2_MASK) != 0);
		}
		else
			return ((modifiers & MouseEvent.BUTTON2_MASK) != 0);
	} //}}}
	//{{{ isRightButton() method
	/**
	 * @param modifiers The modifiers flag from a mouse event
	 * @since jEdit 4.1pre9
	 */
	public static boolean isRightButton(int modifiers)
	{
		if (OperatingSystem.isMacOS())
		{
			if((modifiers & MouseEvent.BUTTON1_MASK) != 0)
				return ((modifiers & MouseEvent.CTRL_MASK) != 0);
			if(!OperatingSystem.hasJava14())
				return ((modifiers & MouseEvent.BUTTON2_MASK) != 0);
			else
				return ((modifiers & MouseEvent.BUTTON3_MASK) != 0);
		}
		else
			return ((modifiers & MouseEvent.BUTTON3_MASK) != 0);
	} //}}}
	//{{{ showPopupMenu() method
	/**
	 * Shows the specified popup menu, ensuring it is displayed within
	 * the bounds of the screen.
	 * @param popup The popup menu
	 * @param comp The component to show it for
	 * @param x The x co-ordinate
	 * @param y The y co-ordinate
	 * @since jEdit 4.0pre1
	 */
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y)
	{
		showPopupMenu(popup,comp,x,y,true);
	} //}}}
	//{{{ showPopupMenu() method
	/**
	 * Shows the specified popup menu, ensuring it is displayed within
	 * the bounds of the screen.
	 * @param popup The popup menu
	 * @param comp The component to show it for
	 * @param x The x co-ordinate
	 * @param y The y co-ordinate
	 * @param point If true, then the popup originates from a single point;
	 * otherwise it will originate from the component itself. This affects
	 * positioning in the case where the popup does not fit onscreen.
	 *
	 * @since jEdit 4.1pre1
	 */
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y, boolean point)
	{
		int offsetX = 0;
		int offsetY = 0;
		int extraOffset = (point ? 1 : 0);
		Component win = comp;
		while(!(win instanceof Window || win == null))
		{
			offsetX += win.getX();
			offsetY += win.getY();
			win = win.getParent();
		}
		if(win != null)
		{
			Dimension size = popup.getPreferredSize();
			Rectangle screenSize = win.getGraphicsConfiguration()
				.getBounds();
			if(x + offsetX + size.width + win.getX() > screenSize.width
				&& x + offsetX + win.getX() >= size.width)
			{
				//System.err.println(""x overflow"");
				if(point)
					x -= (size.width + extraOffset);
				else
					x = (win.getWidth() - size.width - offsetX + extraOffset);
			}
			else
			{
				x += extraOffset;
			}
			//System.err.println(""y="" + y + "",offsetY="" + offsetY
			//	+ "",size.height="" + size.height
			//	+ "",win.height="" + win.getHeight());
			if(y + offsetY + size.height + win.getY() > screenSize.height
				&& y + offsetY + win.getY() >= size.height)
			{
				if(point)
					y = (win.getHeight() - size.height - offsetY + extraOffset);
				else
					y = -size.height - 1;
			}
			else
			{
				y += extraOffset;
			}
			popup.show(comp,x,y);
		}
		else
			popup.show(comp,x + extraOffset,y + extraOffset);
	} //}}}
	//{{{ isAncestorOf() method
	/**
	 * Returns if the first component is an ancestor of the
	 * second by traversing up the component hierarchy.
	 *
	 * @param comp1 The ancestor
	 * @param comp2 The component to check
	 * @since jEdit 4.1pre5
	 */
	public static boolean isAncestorOf(Component comp1, Component comp2)
	{
		while(comp2 != null)
		{
			if(comp1 == comp2)
				return true;
			else
				comp2 = comp2.getParent();
		}
		return false;
	} //}}}
	//{{{ getParentDialog() method
	/**
	 * Traverses the given component's parent tree looking for an
	 * instance of JDialog, and return it. If not found, return null.
	 * @param c The component
	 */
	public static JDialog getParentDialog(Component c)
	{
		Component p = c.getParent();
		while (p != null && !(p instanceof JDialog))
			p = p.getParent();
		return (p instanceof JDialog) ? (JDialog) p : null;
	} //}}}
	//{{{ getComponentParent() method
	/**
	 * Finds a parent of the specified component.
	 * @param comp The component
	 * @param clazz Looks for a parent with this class (exact match, not
	 * derived).
	 * @since jEdit 4.2pre1
	 */
	public static Component getComponentParent(Component comp, Class clazz)
	{
		for(;;)
		{
			if(comp == null)
				break;
			if(comp instanceof JComponent)
			{
				Component real = (Component)((JComponent)comp)
					.getClientProperty(""KORTE_REAL_FRAME"");
				if(real != null)
					comp = real;
			}
			if(comp.getClass().equals(clazz))
				return comp;
			else if(comp instanceof JPopupMenu)
				comp = ((JPopupMenu)comp).getInvoker();
			else if(comp instanceof FloatingWindowContainer)
			{
				comp = ((FloatingWindowContainer)comp)
					.getDockableWindowManager();
			}
			else
				comp = comp.getParent();
		}
		return null;
	} //}}}
	//{{{ getView() method
	/**
	 * Finds the view parent of the specified component.
	 * @since jEdit 4.0pre2
	 */
	public static View getView(Component comp)
	{
		return (View)getComponentParent(comp,View.class);
	} //}}}
	//{{{ Package-private members
	//{{{ init() method
	static void init()
	{
		// don't do this in static{} since we need jEdit.initMisc()
		// run first so we have the jeditresource: protocol
		NEW_BUFFER_ICON = loadIcon(""new.gif"");
		DIRTY_BUFFER_ICON = loadIcon(""dirty.gif"");
		READ_ONLY_BUFFER_ICON = loadIcon(""readonly.gif"");
		NORMAL_BUFFER_ICON = loadIcon(""normal.gif"");
		WINDOW_ICON = loadIcon(""jedit-icon.gif"");
	} //}}}
	//{{{ showSplashScreen() method
	static void showSplashScreen()
	{
		splash = new SplashScreen();
	} //}}}
	//{{{ advanceSplashProgress() method
	static void advanceSplashProgress()
	{
		if(splash != null)
			splash.advance();
	} //}}}
	//}}}
	//{{{ Private members
	private static SplashScreen splash;
	private static Hashtable icons;
	private static String iconPath = ""jeditresource:/org/gjt/sp/jedit/icons/"";
	private static String defaultIconPath = ""jeditresource:/org/gjt/sp/jedit/icons/"";
	private GUIUtilities() {}
	//}}}
}
"
org.gjt.sp.jedit.JARClassLoader,"/*
 * JARClassLoader.java - Loads classes from JAR files
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.gjt.sp.util.Log;
//}}}
/**
 * A class loader implementation that loads classes from JAR files. All
 * instances share the same set of classes.
 * @author Slava Pestov
 * @version $Id: JARClassLoader.java,v 1.34 2004/03/11 05:21:00 spestov Exp $
 */
public class JARClassLoader extends ClassLoader
{
	//{{{ JARClassLoader constructor
	/**
	 * This constructor creates a class loader for loading classes from all
	 * plugins. For example BeanShell uses one of these so that scripts can
	 * use plugin classes.
	 */
	public JARClassLoader()
	{
		// for debugging
		id = INDEX++;
		live++;
	} //}}}
	//{{{ loadClass() method
	/**
	 * @exception ClassNotFoundException if the class could not be found
	 */
	public Class loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		// see what JARClassLoader this class is in
		Object obj = classHash.get(clazz);
		if(obj == NO_CLASS)
		{
			// we remember which classes we don't exist
			// because BeanShell tries loading all possible
			// <imported prefix>.<class name> combinations
			throw new ClassNotFoundException(clazz);
		}
		else if(obj instanceof JARClassLoader)
		{
			JARClassLoader classLoader = (JARClassLoader)obj;
			return classLoader._loadClass(clazz,resolveIt);
		}
		// if it's not in the class hash, and not marked as
		// non-existent, try loading it from the CLASSPATH
		try
		{
			Class cls;
			/* Defer to whoever loaded us (such as JShell,
			 * Echidna, etc) */
			ClassLoader parentLoader = getClass().getClassLoader();
			if (parentLoader != null)
				cls = parentLoader.loadClass(clazz);
			else
				cls = findSystemClass(clazz);
			return cls;
		}
		catch(ClassNotFoundException cnf)
		{
			// remember that this class doesn't exist for
			// future reference
			classHash.put(clazz,NO_CLASS);
			throw cnf;
		}
	} //}}}
	//{{{ getResourceAsStream() method
	public InputStream getResourceAsStream(String name)
	{
		if(jar == null)
			return null;
		try
		{
			ZipFile zipFile = jar.getZipFile();
			ZipEntry entry = zipFile.getEntry(name);
			if(entry == null)
				return getSystemResourceAsStream(name);
			else
				return zipFile.getInputStream(entry);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			return null;
		}
	} //}}}
	//{{{ getResource() method
	public URL getResource(String name)
	{
		if(jar == null)
			return null;
		try
		{
			ZipFile zipFile = jar.getZipFile();
			ZipEntry entry = zipFile.getEntry(name);
			if(entry == null)
				return getSystemResource(name);
			else
				return new URL(getResourceAsPath(name));
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			return null;
		}
	} //}}}
	//{{{ getResourceAsPath() method
	public String getResourceAsPath(String name)
	{
		if(jar == null)
			return null;
		if(!name.startsWith(""/""))
			name = ""/"" + name;
		return ""jeditresource:/"" + MiscUtilities.getFileName(
			jar.getPath()) + ""!"" + name;
	} //}}}
	//{{{ getZipFile() method
	/**
	 * @deprecated Call <code>PluginJAR.getZipFile()</code> instead.
	 */
	public ZipFile getZipFile()
	{
		try
		{
			return jar.getZipFile();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			return null;
		}
	} //}}}
	//{{{ dump() method
	/**
	 * For debugging.
	 */
	public static void dump()
	{
		Log.log(Log.DEBUG,JARClassLoader.class,
			""Total instances created: "" + INDEX);
		Log.log(Log.DEBUG,JARClassLoader.class,
			""Live instances: "" + live);
		synchronized(classHash)
		{
			Iterator entries = classHash.entrySet().iterator();
			while(entries.hasNext())
			{
				Map.Entry entry = (Map.Entry)entries.next();
				if(entry.getValue() != NO_CLASS)
				{
					Log.log(Log.DEBUG,JARClassLoader.class,
						entry.getKey() + "" ==> ""
						+ entry.getValue());
				}
			}
		}
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		if(jar == null)
			return ""<anonymous>("" + id + "")"";
		else
			return jar.getPath() + "" ("" + id + "")"";
	} //}}}
	//{{{ finalize() method
	protected void finalize()
	{
		live--;
	} //}}}
	//{{{ Package-private members
	//{{{ JARClassLoader constructor
	/**
	 * @since jEdit 4.2pre1
	 */
	JARClassLoader(PluginJAR jar)
	{
		this();
		this.jar = jar;
	} //}}}
	//{{{ activate() method
	void activate()
	{
		String[] classes = jar.getClasses();
		if(classes != null)
		{
			for(int i = 0; i < classes.length; i++)
			{
				classHash.put(classes[i],this);
			}
		}
	} //}}}
	//{{{ deactivate() method
	void deactivate()
	{
		String[] classes = jar.getClasses();
		if(classes == null)
			return;
		for(int i = 0; i < classes.length; i++)
		{
			Object loader = classHash.get(classes[i]);
			if(loader == this)
				classHash.remove(classes[i]);
			else
				/* two plugins provide same class! */;
		}
	} //}}}
	//}}}
	//{{{ Private members
	// used to mark non-existent classes in class hash
	private static final Object NO_CLASS = new Object();
	private static int INDEX;
	private static int live;
	private static Hashtable classHash = new Hashtable();
	private int id;
	private PluginJAR jar;
	//{{{ _loadClass() method
	/**
	 * Load class from this JAR only.
	 */
	private synchronized Class _loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		jar.activatePlugin();
		synchronized(this)
		{
			Class cls = findLoadedClass(clazz);
			if(cls != null)
			{
				if(resolveIt)
					resolveClass(cls);
				return cls;
			}
			String name = MiscUtilities.classToFile(clazz);
			try
			{
				ZipFile zipFile = jar.getZipFile();
				ZipEntry entry = zipFile.getEntry(name);
				if(entry == null)
					throw new ClassNotFoundException(clazz);
				InputStream in = zipFile.getInputStream(entry);
				int len = (int)entry.getSize();
				byte[] data = new byte[len];
				int success = 0;
				int offset = 0;
				while(success < len)
				{
					len -= success;
					offset += success;
					success = in.read(data,offset,len);
					if(success == -1)
					{
						Log.log(Log.ERROR,this,""Failed to load class ""
							+ clazz + "" from "" + zipFile.getName());
						throw new ClassNotFoundException(clazz);
					}
				}
				cls = defineClass(clazz,data,0,data.length);
				if(resolveIt)
					resolveClass(cls);
				return cls;
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				throw new ClassNotFoundException(clazz);
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.Java14,"/*
 * Java14.java - Java 2 version 1.4 API calls
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.*;
import java.awt.datatransfer.*;
import java.awt.dnd.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Iterator;
import java.util.List;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * This file must be compiled with a JDK 1.4 or higher javac. If you are using
 * an older Java version and wish to compile from source, you can safely leave
 * this file out.
 * @since jEdit 4.0pre4
 * @author Slava Pestov
 * @version $Id: Java14.java,v 1.36 2004/07/12 19:25:07 spestov Exp $
 */
public class Java14
{
	//{{{ init() method
	public static void init()
	{
		JFrame.setDefaultLookAndFeelDecorated(
			jEdit.getBooleanProperty(""decorate.frames""));
		JDialog.setDefaultLookAndFeelDecorated(
			jEdit.getBooleanProperty(""decorate.dialogs""));
		KeyboardFocusManager.setCurrentKeyboardFocusManager(
			new MyFocusManager());
		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof ViewUpdate)
				{
					ViewUpdate vu = (ViewUpdate)msg;
					if(vu.getWhat() == ViewUpdate.CREATED)
					{
						vu.getView().setFocusTraversalPolicy(
							new MyFocusTraversalPolicy());
					}
				}
				else if(msg instanceof EditPaneUpdate)
				{
					EditPaneUpdate eu = (EditPaneUpdate)msg;
					if(eu.getWhat() == EditPaneUpdate.CREATED)
					{
						initTextArea(eu.getEditPane()
							.getTextArea());
					}
				}
			}
		});
		Clipboard selection = Toolkit.getDefaultToolkit().getSystemSelection();
		if(selection != null)
		{
			Log.log(Log.DEBUG,Java14.class,""Setting % register""
				+ "" to system selection"");
			Registers.setRegister('%',new Registers.ClipboardRegister(selection));
		}
	} //}}}
	//{{{ dragAndDropCallback() method
	/**
	 * Called by the text area via reflection to initiate a text drag and
	 * drop operation using the JDK 1.4 API.
	 * @since jEdit 4.2pre5
	 */
	public static void dragAndDropCallback(JEditTextArea textArea,
		InputEvent evt, boolean copy)
	{
		Log.log(Log.DEBUG,Java14.class,""Drag and drop callback"");
		TransferHandler handler = textArea.getTransferHandler();
		handler.exportAsDrag(textArea,evt,
			copy ? TransferHandler.COPY
			: TransferHandler.MOVE);
	} //}}}
	//{{{ initTextArea() method
	static void initTextArea(JEditTextArea textArea)
	{
		textArea.addMouseWheelListener(new MouseWheelHandler());
		// drag and drop support
		// I'd just move the code to
		// JEditTextArea but it
		// depends on JDK 1.4 APIs
		textArea.setTransferHandler(new TextAreaTransferHandler());
		try
		{
			textArea.getDropTarget().addDropTargetListener(
				new DropHandler(textArea));
			textArea.setDragAndDropCallback(
				Java14.class.getMethod(""dragAndDropCallback"",
				new Class[] { JEditTextArea.class,
				InputEvent.class, boolean.class }));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,Java14.class,e);
		}
	} //}}}
	//{{{ initBufferSwitcher() method
	public static void initBufferSwitcher(final EditPane pane,
		BufferSwitcher switcher)
	{
		switcher.addPopupMenuListener(new PopupMenuListener()
		{
			public void popupMenuWillBecomeVisible(
				PopupMenuEvent e) {}
			public void popupMenuWillBecomeInvisible(
				PopupMenuEvent e)
			{
				pane.getTextArea().requestFocus();
			}
			public void popupMenuCanceled(PopupMenuEvent e)
			{
				pane.getTextArea().requestFocus();
			}
		});
	} //}}}
	//{{{ MyFocusManager class
	static class MyFocusManager extends DefaultKeyboardFocusManager
	{
		MyFocusManager()
		{
			setDefaultFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		}
		public boolean postProcessKeyEvent(KeyEvent evt)
		{
			if(!evt.isConsumed())
			{
				Component comp = (Component)evt.getSource();
				if(!comp.isShowing())
					return true;
				for(;;)
				{
					if(comp instanceof View)
					{
						((View)comp).processKeyEvent(evt,
							View.VIEW);
						return true;
					}
					else if(comp == null || comp instanceof Window
						|| comp instanceof JEditTextArea)
					{
						break;
					}
					else
						comp = comp.getParent();
				}
			}
			return super.postProcessKeyEvent(evt);
		}
	} //}}}
	//{{{ MyFocusTraversalPolicy class
	static class MyFocusTraversalPolicy extends LayoutFocusTraversalPolicy
	{
		public Component getDefaultComponent(Container focusCycleRoot)
		{
			return GUIUtilities.getView(focusCycleRoot).getTextArea();
		}
	} //}}}
	//{{{ MouseWheelHandler class
	static class MouseWheelHandler implements MouseWheelListener
	{
		public void mouseWheelMoved(MouseWheelEvent e)
		{
			JEditTextArea textArea = (JEditTextArea)e.getSource();
			/****************************************************
			 * move caret depending on pressed control-keys:
			 * - Alt: move cursor, do not select
			 * - Alt+(shift or control): move cursor, select
			 * - shift: scroll page
			 * - control: scroll single line
			 * - <else>: scroll 3 lines
			 ****************************************************/
			if(e.isAltDown())
			{
				moveCaret(textArea,e.getWheelRotation(),
					e.isShiftDown() || e.isControlDown());
			}
			else if(e.isShiftDown())
				scrollPage(textArea,e.getWheelRotation());
			else if(e.isControlDown())
				scrollLine(textArea,e.getWheelRotation());
			else if(e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL)
				scrollLine(textArea,e.getUnitsToScroll());
			else
				scrollLine(textArea,3 * e.getWheelRotation());
		}
		private void scrollLine(JEditTextArea textArea, int amt)
		{
			textArea.setFirstLine(textArea.getFirstLine() + amt);
		}
		private void scrollPage(JEditTextArea textArea, int amt)
		{
			if(amt > 0)
				textArea.scrollDownPage();
			else
				textArea.scrollUpPage();
		}
		private void moveCaret(JEditTextArea textArea, int amt, boolean select)
		{
			if (amt < 0)
				textArea.goToPrevLine(select);
			else
				textArea.goToNextLine(select);
		}
	} //}}}
	//{{{ TextAreaTransferHandler class
	static class TextAreaTransferHandler extends TransferHandler
	{
		/* I assume that there can be only one drag operation at the time */
		private static JEditTextArea dragSource;
		private static boolean compoundEdit;
		protected Transferable createTransferable(JComponent c)
		{
			Log.log(Log.DEBUG,this,""createTransferable()"");
			JEditTextArea textArea = (JEditTextArea)c;
			if(textArea.getSelectionCount() == 0)
				return null;
			else
			{
				dragSource = textArea;
				return new TextAreaSelection(textArea);
			}
		}
		public int getSourceActions(JComponent c)
		{
			return COPY_OR_MOVE;
		}
		public boolean importData(JComponent c, Transferable t)
		{
			Log.log(Log.DEBUG,this,""Import data"");
			if(!canImport(c,t.getTransferDataFlavors()))
				return false;
			boolean returnValue;
			try
			{
				if(t.isDataFlavorSupported(
					DataFlavor.javaFileListFlavor))
				{
					returnValue = importFile(c,t);
				}
				else
				{
					returnValue = importText(c,t);
				}
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				returnValue = false;
			}
			GUIUtilities.getView(c).toFront();
			GUIUtilities.getView(c).requestFocus();
			c.requestFocus();
			return returnValue;
		}
		private boolean importFile(JComponent c, Transferable t)
			throws Exception
		{
			Log.log(Log.DEBUG,this,""=> File list"");
			EditPane editPane = (EditPane)
				GUIUtilities.getComponentParent(
				c,EditPane.class);
			Buffer buffer = null;
			Object data = t.getTransferData(
				DataFlavor.javaFileListFlavor);
			Iterator iterator = ((List)data)
				.iterator();
			while(iterator.hasNext())
			{
				File file = (File)
					iterator.next();
				Buffer _buffer = jEdit.openFile(null,
					file.getPath());
				if(_buffer != null)
					buffer = _buffer;
			}
			if(buffer != null)
				editPane.setBuffer(buffer);
			editPane.getView().toFront();
			editPane.getView().requestFocus();
			editPane.requestFocus();
			return true;
		}
		private boolean importText(JComponent c, Transferable t)
			throws Exception
		{
			Log.log(Log.DEBUG,this,""=> String"");
			String str = (String)t.getTransferData(
				DataFlavor.stringFlavor);
			JEditTextArea textArea = (JEditTextArea)c;
			if(dragSource != null
				&& textArea.getBuffer()
				== dragSource.getBuffer())
			{
				compoundEdit = true;
				textArea.getBuffer().beginCompoundEdit();
			}
			int caret = textArea.getCaretPosition();
			Selection s = textArea.getSelectionAtOffset(caret);
			/* if user drops into the same
			selection where they started, do
			nothing. */
			if(s != null)
			{
				if(textArea == dragSource)
					return false;
				/* if user drops into a selection,
				replace selection */
				textArea.setSelectedText(s,str);
			}
			/* otherwise just insert the text */
			else
				textArea.getBuffer().insert(caret,str);
			textArea.scrollToCaret(true);
			return true;
		}
		protected void exportDone(JComponent c, Transferable t,
			int action)
		{
			Log.log(Log.DEBUG,this,""Export done"");
			JEditTextArea textArea = (JEditTextArea)c;
			try
			{
				if(t == null)
				{
					Log.log(Log.DEBUG,this,""=> Null transferrable"");
					textArea.selectNone();
				}
				else if(t.isDataFlavorSupported(
					DataFlavor.stringFlavor))
				{
					Log.log(Log.DEBUG,this,""=> String"");
					if(action == MOVE)
						textArea.setSelectedText(null,false);
					else
						textArea.selectNone();
				}
			}
			finally
			{
				if(compoundEdit)
				{
					compoundEdit = false;
					textArea.getBuffer().endCompoundEdit();
				}
			}
			dragSource = null;
		}
		public boolean canImport(JComponent c, DataFlavor[] flavors)
		{
			JEditTextArea textArea = (JEditTextArea)c;
			// correctly handle text flavor + file list flavor
			// + text area read only, do an or of all flags
			boolean returnValue = false;
			for(int i = 0; i < flavors.length; i++)
			{
				if(flavors[i].equals(
					DataFlavor.javaFileListFlavor))
				{
					returnValue = true;
				}
				else if(flavors[i].equals(
					DataFlavor.stringFlavor))
				{
					if(textArea.isEditable())
						returnValue = true;
				}
			}
			Log.log(Log.DEBUG,this,""canImport() returning ""
				+ returnValue);
			return returnValue;
		}
	} //}}}
	//{{{ DropHandler class
	static class DropHandler extends DropTargetAdapter
	{
		JEditTextArea textArea;
		Buffer savedBuffer;
		int savedCaret;
		DropHandler(JEditTextArea textArea)
		{
			this.textArea = textArea;
		}
		public void dragEnter(DropTargetDragEvent dtde)
		{
			Log.log(Log.DEBUG,this,""Drag enter"");
			savedBuffer = textArea.getBuffer();
			textArea.setDragInProgress(true);
			//textArea.getBuffer().beginCompoundEdit();
			savedCaret = textArea.getCaretPosition();
		}
		public void dragOver(DropTargetDragEvent dtde)
		{
			Point p = dtde.getLocation();
			p = SwingUtilities.convertPoint(textArea,p,
				textArea.getPainter());
			int pos = textArea.xyToOffset(p.x,p.y,
				!(textArea.getPainter().isBlockCaretEnabled()
				|| textArea.isOverwriteEnabled()));
			if(pos != -1)
			{
				textArea.moveCaretPosition(pos,
					JEditTextArea.ELECTRIC_SCROLL);
			}
		}
		public void dragExit(DropTargetEvent dtde)
		{
			Log.log(Log.DEBUG,this,""Drag exit"");
			textArea.setDragInProgress(false);
			//textArea.getBuffer().endCompoundEdit();
			if(textArea.getBuffer() == savedBuffer)
			{
				textArea.moveCaretPosition(savedCaret,
					JEditTextArea.ELECTRIC_SCROLL);
			}
			savedBuffer = null;
		}
		public void drop(DropTargetDropEvent dtde)
		{
			Log.log(Log.DEBUG,this,""Drop"");
			textArea.setDragInProgress(false);
			//textArea.getBuffer().endCompoundEdit();
		}
	} //}}}
	//{{{ TextAreaSelection class
	static class TextAreaSelection extends StringSelection
	{
		JEditTextArea textArea;
		TextAreaSelection(JEditTextArea textArea)
		{
			super(textArea.getSelectedText());
			this.textArea = textArea;
		}
	} //}}}
}
"
org.gjt.sp.jedit.jEdit,"/*
 * jEdit.java - Main class of the jEdit editor
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import bsh.UtilEvalError;
import com.microstar.xml.*;
import javax.swing.plaf.metal.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.net.*;
import java.text.MessageFormat;
import java.util.*;
import org.gjt.sp.jedit.buffer.BufferIORequest;
import org.gjt.sp.jedit.buffer.KillRing;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.help.HelpViewer;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.pluginmgr.PluginManager;
import org.gjt.sp.jedit.search.SearchAndReplace;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * The main class of the jEdit text editor.
 * @author Slava Pestov
 * @version $Id: jEdit.java,v 1.238 2004/08/29 02:58:43 spestov Exp $
 */
public class jEdit
{
	//{{{ getVersion() method
	/**
	 * Returns the jEdit version as a human-readable string.
	 */
	public static String getVersion()
	{
		return MiscUtilities.buildToVersion(getBuild());
	} //}}}
	//{{{ getBuild() method
	/**
	 * Returns the internal version. MiscUtilities.compareStrings() can be used
	 * to compare different internal versions.
	 */
	public static String getBuild()
	{
		// (major).(minor).(<99 = preX, 99 = final).(bug fix)
		return ""04.02.99.00"";
	} //}}}
	//{{{ main() method
	/**
	 * The main method of the jEdit application.
	 * This should never be invoked directly.
	 * @param args The command line arguments
	 */
	public static void main(String[] args)
	{
		//{{{ Check for Java 1.3 or later
		String javaVersion = System.getProperty(""java.version"");
		if(javaVersion.compareTo(""1.3"") < 0)
		{
			System.err.println(""You are running Java version ""
				+ javaVersion + ""."");
			System.err.println(""jEdit requires Java 1.3 or later."");
			System.exit(1);
		} //}}}
		// later on we need to know if certain code is called from
		// the main thread
		mainThread = Thread.currentThread();
		settingsDirectory = "".jedit"";
		// MacOS users expect the app to keep running after all windows
		// are closed
		background = OperatingSystem.isMacOS();
		//{{{ Parse command line
		boolean endOpts = false;
		int level = Log.WARNING;
		String portFile = ""server"";
		boolean restore = true;
		boolean newView = true;
		boolean newPlainView = false;
		boolean gui = true; // open initial view?
		boolean loadPlugins = true;
		boolean runStartupScripts = true;
		boolean quit = false;
		boolean wait = false;
		String userDir = System.getProperty(""user.dir"");
		// script to run
		String scriptFile = null;
		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.length() == 0)
				args[i] = null;
			else if(arg.startsWith(""-"") && !endOpts)
			{
				if(arg.equals(""--""))
					endOpts = true;
				else if(arg.equals(""-usage""))
				{
					version();
					System.err.println();
					usage();
					System.exit(1);
				}
				else if(arg.equals(""-version""))
				{
					version();
					System.exit(1);
				}
				else if(arg.startsWith(""-log=""))
				{
					try
					{
						level = Integer.parseInt(arg.substring(""-log="".length()));
					}
					catch(NumberFormatException nf)
					{
						System.err.println(""Malformed option: "" + arg);
					}
				}
				else if(arg.equals(""-nosettings""))
					settingsDirectory = null;
				else if(arg.startsWith(""-settings=""))
					settingsDirectory = arg.substring(10);
				else if(arg.startsWith(""-noserver""))
					portFile = null;
				else if(arg.equals(""-server""))
					portFile = ""server"";
				else if(arg.startsWith(""-server=""))
					portFile = arg.substring(8);
				else if(arg.startsWith(""-background""))
					background = true;
				else if(arg.startsWith(""-nobackground""))
					background = false;
				else if(arg.equals(""-gui""))
					gui = true;
				else if(arg.equals(""-nogui""))
					gui = false;
				else if(arg.equals(""-newview""))
					newView = true;
				else if(arg.equals(""-newplainview""))
					newPlainView = true;
				else if(arg.equals(""-reuseview""))
					newPlainView = newView = false;
				else if(arg.equals(""-restore""))
					restore = true;
				else if(arg.equals(""-norestore""))
					restore = false;
				else if(arg.equals(""-plugins""))
					loadPlugins = true;
				else if(arg.equals(""-noplugins""))
					loadPlugins = false;
				else if(arg.equals(""-startupscripts""))
					runStartupScripts = true;
				else if(arg.equals(""-nostartupscripts""))
					runStartupScripts = false;
				else if(arg.startsWith(""-run=""))
					scriptFile = arg.substring(5);
				else if(arg.equals(""-wait""))
					wait = true;
				else if(arg.equals(""-quit""))
					quit = true;
				else
				{
					System.err.println(""Unknown option: ""
						+ arg);
					usage();
					System.exit(1);
				}
				args[i] = null;
			}
		} //}}}
		//{{{ We need these initializations very early on
		if(settingsDirectory != null)
		{
			settingsDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),
				settingsDirectory);
			settingsDirectory = MiscUtilities.resolveSymlinks(
				settingsDirectory);
		}
		if(settingsDirectory != null && portFile != null)
			portFile = MiscUtilities.constructPath(settingsDirectory,portFile);
		else
			portFile = null;
		Log.init(true,level);
		//}}}
		//{{{ Try connecting to another running jEdit instance
		if(portFile != null && new File(portFile).exists())
		{
			int port, key;
			try
			{
				BufferedReader in = new BufferedReader(new FileReader(portFile));
				String check = in.readLine();
				if(!check.equals(""b""))
					throw new Exception(""Wrong port file format"");
				port = Integer.parseInt(in.readLine());
				key = Integer.parseInt(in.readLine());
				Socket socket = new Socket(InetAddress.getByName(""127.0.0.1""),port);
				DataOutputStream out = new DataOutputStream(
					socket.getOutputStream());
				out.writeInt(key);
				String script;
				if(quit)
				{
					script = ""socket.close();\n""
						+ ""jEdit.exit(null,true);\n"";
				}
				else
				{
					script = makeServerScript(wait,restore,
						newView,newPlainView,args,
						scriptFile);
				}
				out.writeUTF(script);
				Log.log(Log.DEBUG,jEdit.class,""Waiting for server"");
				// block until its closed
				try
				{
					socket.getInputStream().read();
				}
				catch(Exception e)
				{
				}
				in.close();
				out.close();
				System.exit(0);
			}
			catch(Exception e)
			{
				// ok, this one seems to confuse newbies
				// endlessly, so log it as NOTICE, not
				// ERROR
				Log.log(Log.NOTICE,jEdit.class,""An error occurred""
					+ "" while connecting to the jEdit server instance."");
				Log.log(Log.NOTICE,jEdit.class,""This probably means that""
					+ "" jEdit crashed and/or exited abnormally"");
				Log.log(Log.NOTICE,jEdit.class,""the last time it was run."");
				Log.log(Log.NOTICE,jEdit.class,""If you don't""
					+ "" know what this means, don't worry."");
				Log.log(Log.NOTICE,jEdit.class,e);
			}
		}
		if(quit)
		{
			// if no server running and user runs jedit -quit,
			// just exit
			System.exit(0);
		} //}}}
		// don't show splash screen if there is a file named
		// 'nosplash' in the settings directory
		if(!new File(settingsDirectory,""nosplash"").exists())
			GUIUtilities.showSplashScreen();
		//{{{ Initialize settings directory
		Writer stream;
		if(settingsDirectory != null)
		{
			File _settingsDirectory = new File(settingsDirectory);
			if(!_settingsDirectory.exists())
				_settingsDirectory.mkdirs();
			File _macrosDirectory = new File(settingsDirectory,""macros"");
			if(!_macrosDirectory.exists())
				_macrosDirectory.mkdir();
			String logPath = MiscUtilities.constructPath(
				settingsDirectory,""activity.log"");
			backupSettingsFile(new File(logPath));
			try
			{
				stream = new BufferedWriter(new FileWriter(logPath));
				// Write a warning message:
				String lineSep = System.getProperty(""line.separator"");
				stream.write(""Log file created on "" + new Date());
				stream.write(lineSep);
				stream.write(""IMPORTANT:"");
				stream.write(lineSep);
				stream.write(""Because updating this file after ""
					+ ""every log message would kill"");
				stream.write(lineSep);
				stream.write(""performance, it will be *incomplete* ""
					+ ""unless you invoke the"");
				stream.write(lineSep);
				stream.write(""Utilities->Troubleshooting->Update ""
					+ ""Activity Log on Disk command!"");
				stream.write(lineSep);
			}
			catch(Exception e)
			{
				e.printStackTrace();
				stream = null;
			}
		}
		else
		{
			stream = null;
		} //}}}
		Log.setLogWriter(stream);
		Log.log(Log.NOTICE,jEdit.class,""jEdit version "" + getVersion());
		Log.log(Log.MESSAGE,jEdit.class,""Settings directory is ""
			+ settingsDirectory);
		//{{{ Get things rolling
		initMisc();
		initSystemProperties();
		GUIUtilities.advanceSplashProgress();
		GUIUtilities.init();
		BeanShell.init();
		if(jEditHome != null)
			initSiteProperties();
		initUserProperties();
		//}}}
		//{{{ Initialize server
		if(portFile != null)
		{
			server = new EditServer(portFile);
			if(!server.isOK())
				server = null;
		}
		else
		{
			if(background)
			{
				background = false;
				Log.log(Log.WARNING,jEdit.class,""You cannot specify both the""
					+ "" -background and -noserver switches"");
			}
		} //}}}
		//{{{ Do more stuff
		initPLAF();
		VFSManager.init();
		initResources();
		SearchAndReplace.load();
		GUIUtilities.advanceSplashProgress();
		if(loadPlugins)
			initPlugins();
		HistoryModel.loadHistory();
		BufferHistory.load();
		KillRing.load();
		propertiesChanged();
		GUIUtilities.advanceSplashProgress();
		// Buffer sort
		sortBuffers = getBooleanProperty(""sortBuffers"");
		sortByName = getBooleanProperty(""sortByName"");
		reloadModes();
		GUIUtilities.advanceSplashProgress();
		//}}}
		//{{{ Initialize Java 1.4-specific code
		if(OperatingSystem.hasJava14())
		{
			try
			{
				ClassLoader loader = jEdit.class.getClassLoader();
				Class clazz;
				if(loader != null)
					clazz = loader.loadClass(""org.gjt.sp.jedit.Java14"");
				else
					clazz = Class.forName(""org.gjt.sp.jedit.Java14"");
				java.lang.reflect.Method meth = clazz
					.getMethod(""init"",new Class[0]);
				meth.invoke(null,new Object[0]);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
				System.exit(1);
			}
		} //}}}
		//{{{ Activate plugins that must be activated at startup
		for(int i = 0; i < jars.size(); i++)
		{
			((PluginJAR)jars.elementAt(i)).activatePluginIfNecessary();
		} //}}}
		//{{{ Load macros and run startup scripts, after plugins and settings are loaded
		Macros.loadMacros();
		Macros.getMacroActionSet().initKeyBindings();
		if(runStartupScripts && jEditHome != null)
		{
			String path = MiscUtilities.constructPath(jEditHome,""startup"");
			File file = new File(path);
			if(file.exists())
				runStartupScripts(file);
		}
		if(runStartupScripts && settingsDirectory != null)
		{
			String path = MiscUtilities.constructPath(settingsDirectory,""startup"");
			File file = new File(path);
			if(!file.exists())
				file.mkdirs();
			else
				runStartupScripts(file);
		} //}}}
		//{{{ Run script specified with -run= parameter
		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			try
			{
				BeanShell.getNameSpace().setVariable(""args"",args);
			}
			catch(UtilEvalError e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
			BeanShell.runScript(null,scriptFile,null,false);
		} //}}}
		GUIUtilities.advanceSplashProgress();
		// Open files, create the view and hide the splash screen.
		finishStartup(gui,restore,userDir,args);
	} //}}}
	//{{{ Property methods
	//{{{ getProperties() method
	/**
	 * Returns the properties object which contains all known
	 * jEdit properties. Note that as of jEdit 4.2pre10, this returns a
	 * new collection, not the existing properties instance.
	 * @since jEdit 3.1pre4
	 */
	public static final Properties getProperties()
	{
		return propMgr.getProperties();
	} //}}}
	//{{{ getProperty() method
	/**
	 * Fetches a property, returning null if it's not defined.
	 * @param name The property
	 */
	public static final String getProperty(String name)
	{
		return propMgr.getProperty(name);
	} //}}}
	//{{{ getProperty() method
	/**
	 * Fetches a property, returning the default value if it's not
	 * defined.
	 * @param name The property
	 * @param def The default value
	 */
	public static final String getProperty(String name, String def)
	{
		String value = propMgr.getProperty(name);
		if(value == null)
			return def;
		else
			return value;
	} //}}}
	//{{{ getProperty() method
	/**
	 * Returns the property with the specified name.<p>
	 *
	 * The elements of the <code>args</code> array are substituted
	 * into the value of the property in place of strings of the
	 * form <code>{<i>n</i>}</code>, where <code><i>n</i></code> is an index
	 * in the array.<p>
	 *
	 * You can find out more about this feature by reading the
	 * documentation for the <code>format</code> method of the
	 * <code>java.text.MessageFormat</code> class.
	 *
	 * @param name The property
	 * @param args The positional parameters
	 */
	public static final String getProperty(String name, Object[] args)
	{
		if(name == null)
			return null;
		if(args == null)
			return getProperty(name);
		else
		{
			String value = getProperty(name);
			if(value == null)
				return null;
			else
				return MessageFormat.format(value,args);
		}
	} //}}}
	//{{{ getBooleanProperty() method
	/**
	 * Returns the value of a boolean property.
	 * @param name The property
	 */
	public static final boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name,false);
	} //}}}
	//{{{ getBooleanProperty() method
	/**
	 * Returns the value of a boolean property.
	 * @param name The property
	 * @param def The default value
	 */
	public static final boolean getBooleanProperty(String name, boolean def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else if(value.equals(""true"") || value.equals(""yes"")
			|| value.equals(""on""))
			return true;
		else if(value.equals(""false"") || value.equals(""no"")
			|| value.equals(""off""))
			return false;
		else
			return def;
	} //}}}
	//{{{ getIntegerProperty() method
	/**
	 * Returns the value of an integer property.
	 * @param name The property
	 * @param def The default value
	 * @since jEdit 4.0pre1
	 */
	public static final int getIntegerProperty(String name, int def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Integer.parseInt(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	} //}}}
	//{{{ getDoubleProperty() method
	public static double getDoubleProperty(String name, double def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Double.parseDouble(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	}
	//}}}
	//{{{ getFontProperty() method
	/**
	 * Returns the value of a font property. The family is stored
	 * in the <code><i>name</i></code> property, the font size is stored
	 * in the <code><i>name</i>size</code> property, and the font style is
	 * stored in <code><i>name</i>style</code>. For example, if
	 * <code><i>name</i></code> is <code>view.gutter.font</code>, the
	 * properties will be named <code>view.gutter.font</code>,
	 * <code>view.gutter.fontsize</code>, and
	 * <code>view.gutter.fontstyle</code>.
	 *
	 * @param name The property
	 * @since jEdit 4.0pre1
	 */
	public static final Font getFontProperty(String name)
	{
		return getFontProperty(name,null);
	} //}}}
	//{{{ getFontProperty() method
	/**
	 * Returns the value of a font property. The family is stored
	 * in the <code><i>name</i></code> property, the font size is stored
	 * in the <code><i>name</i>size</code> property, and the font style is
	 * stored in <code><i>name</i>style</code>. For example, if
	 * <code><i>name</i></code> is <code>view.gutter.font</code>, the
	 * properties will be named <code>view.gutter.font</code>,
	 * <code>view.gutter.fontsize</code>, and
	 * <code>view.gutter.fontstyle</code>.
	 *
	 * @param name The property
	 * @param def The default value
	 * @since jEdit 4.0pre1
	 */
	public static final Font getFontProperty(String name, Font def)
	{
		String family = getProperty(name);
		String sizeString = getProperty(name + ""size"");
		String styleString = getProperty(name + ""style"");
		if(family == null || sizeString == null || styleString == null)
			return def;
		else
		{
			int size, style;
			try
			{
				size = Integer.parseInt(sizeString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
			try
			{
				style = Integer.parseInt(styleString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
			return new Font(family,style,size);
		}
	} //}}}
	//{{{ getColorProperty() method
	/**
	 * Returns the value of a color property.
	 * @param name The property name
	 * @since jEdit 4.0pre1
	 */
	public static Color getColorProperty(String name)
	{
		return getColorProperty(name,Color.black);
	} //}}}
	//{{{ getColorProperty() method
	/**
	 * Returns the value of a color property.
	 * @param name The property name
	 * @param def The default value
	 * @since jEdit 4.0pre1
	 */
	public static Color getColorProperty(String name, Color def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
			return GUIUtilities.parseColor(value,def);
	} //}}}
	//{{{ setColorProperty() method
	/**
	 * Sets the value of a color property.
	 * @param name The property name
	 * @param value The value
	 * @since jEdit 4.0pre1
	 */
	public static void setColorProperty(String name, Color value)
	{
		setProperty(name,GUIUtilities.getColorHexString(value));
	} //}}}
	//{{{ setProperty() method
	/**
	 * Sets a property to a new value.
	 * @param name The property
	 * @param value The new value
	 */
	public static final void setProperty(String name, String value)
	{
		propMgr.setProperty(name,value);
	} //}}}
	//{{{ setTemporaryProperty() method
	/**
	 * Sets a property to a new value. Properties set using this
	 * method are not saved to the user properties list.
	 * @param name The property
	 * @param value The new value
	 * @since jEdit 2.3final
	 */
	public static final void setTemporaryProperty(String name, String value)
	{
		propMgr.setTemporaryProperty(name,value);
	} //}}}
	//{{{ setBooleanProperty() method
	/**
	 * Sets a boolean property.
	 * @param name The property
	 * @param value The value
	 */
	public static final void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? ""true"" : ""false"");
	} //}}}
	//{{{ setIntegerProperty() method
	/**
	 * Sets the value of an integer property.
	 * @param name The property
	 * @param value The value
	 * @since jEdit 4.0pre1
	 */
	public static final void setIntegerProperty(String name, int value)
	{
		setProperty(name,String.valueOf(value));
	} //}}}
	//{{{ setDoubleProperty() method
	public static final void setDoubleProperty(String name, double value)
	{
		setProperty(name,String.valueOf(value));
	}
	//}}}
	//{{{ setFontProperty() method
	/**
	 * Sets the value of a font property. The family is stored
	 * in the <code><i>name</i></code> property, the font size is stored
	 * in the <code><i>name</i>size</code> property, and the font style is
	 * stored in <code><i>name</i>style</code>. For example, if
	 * <code><i>name</i></code> is <code>view.gutter.font</code>, the
	 * properties will be named <code>view.gutter.font</code>,
	 * <code>view.gutter.fontsize</code>, and
	 * <code>view.gutter.fontstyle</code>.
	 *
	 * @param name The property
	 * @param value The value
	 * @since jEdit 4.0pre1
	 */
	public static final void setFontProperty(String name, Font value)
	{
		setProperty(name,value.getFamily());
		setIntegerProperty(name + ""size"",value.getSize());
		setIntegerProperty(name + ""style"",value.getStyle());
	} //}}}
	//{{{ unsetProperty() method
	/**
	 * Unsets (clears) a property.
	 * @param name The property
	 */
	public static final void unsetProperty(String name)
	{
		propMgr.unsetProperty(name);
	} //}}}
	//{{{ resetProperty() method
	/**
	 * Resets a property to its default value.
	 * @param name The property
	 *
	 * @since jEdit 2.5pre3
	 */
	public static final void resetProperty(String name)
	{
		propMgr.resetProperty(name);
	} //}}}
	//{{{ propertiesChanged() method
	/**
	 * Reloads various settings from the properties.
	 */
	public static void propertiesChanged()
	{
		initKeyBindings();
		Autosave.setInterval(getIntegerProperty(""autosave"",30));
		saveCaret = getBooleanProperty(""saveCaret"");
		UIDefaults defaults = UIManager.getDefaults();
		// give all text areas the same font
		Font font = getFontProperty(""view.font"");
		//defaults.put(""TextField.font"",font);
		defaults.put(""TextArea.font"",font);
		defaults.put(""TextPane.font"",font);
		// Enable/Disable tooltips
		ToolTipManager.sharedInstance().setEnabled(
			jEdit.getBooleanProperty(""showTooltips""));
		initProxy();
		// we do this here instead of adding buffers to the bus.
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			buffer.resetCachedProperties();
			buffer.propertiesChanged();
			buffer = buffer.next;
		}
		HistoryModel.propertiesChanged();
		KillRing.propertiesChanged();
		EditBus.send(new PropertiesChanged(null));
	} //}}}
	//}}}
	//{{{ Plugin management methods
	//{{{ getNotLoadedPluginJARs() method
	/**
	 * Returns a list of plugin JARs that are not currently loaded
	 * by examining the user and system plugin directories.
	 * @since jEdit 3.2pre1
	 */
	public static String[] getNotLoadedPluginJARs()
	{
		Vector returnValue = new Vector();
		if(jEditHome != null)
		{
			String systemPluginDir = MiscUtilities
				.constructPath(jEditHome,""jars"");
			String[] list = new File(systemPluginDir).list();
			if(list != null)
				getNotLoadedPluginJARs(returnValue,systemPluginDir,list);
		}
		if(settingsDirectory != null)
		{
			String userPluginDir = MiscUtilities
				.constructPath(settingsDirectory,""jars"");
			String[] list = new File(userPluginDir).list();
			if(list != null)
			{
				getNotLoadedPluginJARs(returnValue,
					userPluginDir,list);
			}
		}
		String[] _returnValue = new String[returnValue.size()];
		returnValue.copyInto(_returnValue);
		return _returnValue;
	} //}}}
	//{{{ getPlugin() method
	/**
	 * Returns the plugin with the specified class name.
	 */
	public static EditPlugin getPlugin(String name)
	{
		return getPlugin(name, false);
	} //}}}
	//{{{ getPlugin(String, boolean) method
	/**
	 * Returns the plugin with the specified class name. If
	 * <code>loadIfNecessary</code> is true, the plugin will be activated in
	 * case it has not yet been started.
	 * @since jEdit 4.2pre4
	 */
	public static EditPlugin getPlugin(String name, boolean loadIfNecessary)
	{
		EditPlugin[] plugins = getPlugins();
		EditPlugin plugin = null;
		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClassName().equals(name))
				plugin = plugins[i];
			if(loadIfNecessary)
			{
				if(plugin instanceof EditPlugin.Deferred)
				{
					plugin.getPluginJAR().activatePlugin();
					plugin = plugin.getPluginJAR().getPlugin();
					break;
				}
			}
		}
		return plugin;
	} //}}}
	//{{{ getPlugins() method
	/**
	 * Returns an array of installed plugins.
	 */
	public static EditPlugin[] getPlugins()
	{
		Vector vector = new Vector();
		for(int i = 0; i < jars.size(); i++)
		{
			EditPlugin plugin = ((PluginJAR)jars.elementAt(i))
				.getPlugin();
			if(plugin != null)
				vector.add(plugin);
		}
		EditPlugin[] array = new EditPlugin[vector.size()];
		vector.copyInto(array);
		return array;
	} //}}}
	//{{{ getPluginJARs() method
	/**
	 * Returns an array of installed plugins.
	 * @since jEdit 4.2pre1
	 */
	public static PluginJAR[] getPluginJARs()
	{
		PluginJAR[] array = new PluginJAR[jars.size()];
		jars.copyInto(array);
		return array;
	} //}}}
	//{{{ getPluginJAR() method
	/**
	 * Returns the JAR with the specified path name.
	 * @param path The path name
	 * @since jEdit 4.2pre1
	 */
	public static PluginJAR getPluginJAR(String path)
	{
		for(int i = 0; i < jars.size(); i++)
		{
			PluginJAR jar = (PluginJAR)jars.elementAt(i);
			if(jar.getPath().equals(path))
				return jar;
		}
		return null;
	} //}}}
	//{{{ addPluginJAR() method
	/**
	 * Loads the plugin JAR with the specified path. Some notes about this
	 * method:
	 *
	 * <ul>
	 * <li>Calling this at a time other than jEdit startup can have
	 * unpredictable results if the plugin has not been updated for the
	 * jEdit 4.2 plugin API.
	 * <li>You must make sure yourself the plugin is not already loaded.
	 * <li>After loading, you just make sure all the plugin's dependencies
	 * are satisified before activating the plugin, using the
	 * {@link PluginJAR#checkDependencies()} method.
	 * </ul>
	 *
	 * @param path The JAR file path
	 * @since jEdit 4.2pre1
	 */
	public static void addPluginJAR(String path)
	{
		// backwards compatibility...
		PluginJAR jar = new EditPlugin.JAR(new File(path));
		jars.addElement(jar);
		jar.init();
		EditBus.send(new PluginUpdate(jar,PluginUpdate.LOADED,false));
		if(!isMainThread())
		{
			EditBus.send(new DynamicMenuChanged(""plugins""));
			initKeyBindings();
		}
	} //}}}
	//{{{ addPluginJARsFromDirectory() method
	/**
	 * Loads all plugins in a directory.
	 * @param directory The directory
	 * @since jEdit 4.2pre1
	 */
	private static void addPluginJARsFromDirectory(String directory)
	{
		Log.log(Log.NOTICE,jEdit.class,""Loading plugins from ""
			+ directory);
		File file = new File(directory);
		if(!(file.exists() && file.isDirectory()))
			return;
		String[] plugins = file.list();
		if(plugins == null)
			return;
		for(int i = 0; i < plugins.length; i++)
		{
			String plugin = plugins[i];
			if(!plugin.toLowerCase().endsWith("".jar""))
				continue;
			String path = MiscUtilities.constructPath(directory,plugin);
			// remove this when 4.1 plugin API is deprecated
			if(plugin.equals(""EditBuddy.jar"")
				|| plugin.equals(""PluginManager.jar"")
				|| plugin.equals(""Firewall.jar"")
				|| plugin.equals(""Tidy.jar"")
				|| plugin.equals(""DragAndDrop.jar""))
			{
				pluginError(path,""plugin-error.obsolete"",null);
				continue;
			}
			addPluginJAR(path);
		}
	} //}}}
	//{{{ removePluginJAR() method
	/**
	 * Unloads the given plugin JAR with the specified path. Note that
	 * calling this at a time other than jEdit shutdown can have
	 * unpredictable results if the plugin has not been updated for the
	 * jEdit 4.2 plugin API.
	 *
	 * @param jar The <code>PluginJAR</code> instance
	 * @param exit Set to true if jEdit is exiting; enables some
	 * shortcuts so the editor can close faster.
	 * @since jEdit 4.2pre1
	 */
	public static void removePluginJAR(PluginJAR jar, boolean exit)
	{
		if(exit)
		{
			jar.uninit(true);
		}
		else
		{
			jar.uninit(false);
			jars.removeElement(jar);
			initKeyBindings();
		}
		EditBus.send(new PluginUpdate(jar,PluginUpdate.UNLOADED,exit));
		if(!isMainThread() && !exit)
			EditBus.send(new DynamicMenuChanged(""plugins""));
	} //}}}
	//}}}
	//{{{ Action methods
	//{{{ getActionContext() method
	/**
	 * Returns the action context used to store editor actions.
	 * @since jEdit 4.2pre1
	 */
	public static ActionContext getActionContext()
	{
		return actionContext;
	} //}}}
	//{{{ addActionSet() method
	/**
	 * Adds a new action set to jEdit's list. Plugins probably won't
	 * need to call this method.
	 * @since jEdit 4.0pre1
	 */
	public static void addActionSet(ActionSet actionSet)
	{
		actionContext.addActionSet(actionSet);
	} //}}}
	//{{{ removeActionSet() method
	/**
	 * Removes an action set from jEdit's list. Plugins probably won't
	 * need to call this method.
	 * @since jEdit 4.2pre1
	 */
	public static void removeActionSet(ActionSet actionSet)
	{
		actionContext.removeActionSet(actionSet);
	} //}}}
	//{{{ getBuiltInActionSet() method
	/**
	 * Returns the set of commands built into jEdit.
	 * @since jEdit 4.2pre1
	 */
	public static ActionSet getBuiltInActionSet()
	{
		return builtInActionSet;
	} //}}}
	//{{{ getActionSets() method
	/**
	 * Returns all registered action sets.
	 * @since jEdit 4.0pre1
	 */
	public static ActionSet[] getActionSets()
	{
		return actionContext.getActionSets();
	} //}}}
	//{{{ getAction() method
	/**
	 * Returns the specified action.
	 * @param name The action name
	 */
	public static EditAction getAction(String name)
	{
		return actionContext.getAction(name);
	} //}}}
	//{{{ getActionSetForAction() method
	/**
	 * Returns the action set that contains the specified action.
	 *
	 * @param action The action
	 * @since jEdit 4.2pre1
	 */
	public static ActionSet getActionSetForAction(String action)
	{
		return actionContext.getActionSetForAction(action);
	} //}}}
	//{{{ getActionSetForAction() method
	/**
	 * @deprecated Use the form that takes a String instead
	 */
	public static ActionSet getActionSetForAction(EditAction action)
	{
		return actionContext.getActionSetForAction(action.getName());
	} //}}}
	//{{{ getActions() method
	/**
	 * @deprecated Call getActionNames() instead
	 */
	public static EditAction[] getActions()
	{
		String[] names = actionContext.getActionNames();
		EditAction[] actions = new EditAction[names.length];
		for(int i = 0; i < actions.length; i++)
		{
			actions[i] = actionContext.getAction(names[i]);
			if(actions[i] == null)
				Log.log(Log.ERROR,jEdit.class,""wtf: "" + names[i]);
		}
		return actions;
	} //}}}
	//{{{ getActionNames() method
	/**
	 * Returns all registered action names.
	 */
	public static String[] getActionNames()
	{
		return actionContext.getActionNames();
	} //}}}
	//}}}
	//{{{ Edit mode methods
	//{{{ reloadModes() method
	/**
	 * Reloads all edit modes.
	 * @since jEdit 3.2pre2
	 */
	public static void reloadModes()
	{
		/* Try to guess the eventual size to avoid unnecessary
		 * copying */
		modes = new Vector(50);
		//{{{ Load the global catalog
		if(jEditHome == null)
			loadModeCatalog(""/modes/catalog"",true);
		else
		{
			loadModeCatalog(MiscUtilities.constructPath(jEditHome,
				""modes"",""catalog""),false);
		} //}}}
		//{{{ Load user catalog
		if(settingsDirectory != null)
		{
			File userModeDir = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes""));
			if(!userModeDir.exists())
				userModeDir.mkdirs();
			File userCatalog = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes"",""catalog""));
			if(!userCatalog.exists())
			{
				// create dummy catalog
				FileWriter out = null;
				try
				{
					out = new FileWriter(userCatalog);
					out.write(jEdit.getProperty(""defaultCatalog""));
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}
				finally
				{
					try
					{
						if(out != null)
							out.close();
					}
					catch(IOException e)
					{
					}
				}
			}
			loadModeCatalog(userCatalog.getPath(),false);
		} //}}}
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			// This reloads the token marker and sends a message
			// which causes edit panes to repaint their text areas
			buffer.setMode();
			buffer = buffer.next;
		}
	} //}}}
	//{{{ getMode() method
	/**
	 * Returns the edit mode with the specified name.
	 * @param name The edit mode
	 */
	public static Mode getMode(String name)
	{
		for(int i = 0; i < modes.size(); i++)
		{
			Mode mode = (Mode)modes.elementAt(i);
			if(mode.getName().equals(name))
				return mode;
		}
		return null;
	} //}}}
	//{{{ getModes() method
	/**
	 * Returns an array of installed edit modes.
	 */
	public static Mode[] getModes()
	{
		Mode[] array = new Mode[modes.size()];
		modes.copyInto(array);
		return array;
	} //}}}
	//}}}
	//{{{ Buffer creation methods
	//{{{ openFiles() method
	/**
	 * Opens the file names specified in the argument array. This
	 * handles +line and +marker arguments just like the command
	 * line parser.
	 * @param parent The parent directory
	 * @param args The file names to open
	 * @since jEdit 3.2pre4
	 */
	public static Buffer openFiles(View view, String parent, String[] args)
	{
		Buffer retVal = null;
		Buffer lastBuffer = null;
		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.startsWith(""+line:"") || arg.startsWith(""+marker:""))
			{
				if(lastBuffer != null)
					gotoMarker(view,lastBuffer,arg);
				continue;
			}
			lastBuffer = openFile(null,parent,arg,false,null);
			if(retVal == null && lastBuffer != null)
				retVal = lastBuffer;
		}
		if(view != null && retVal != null)
			view.setBuffer(retVal);
		return retVal;
	} //}}}
	//{{{ openFile() method
	/**
	 * Opens a file. Note that as of jEdit 2.5pre1, this may return
	 * null if the buffer could not be opened.
	 * @param view The view to open the file in
	 * @param path The file path
	 *
	 * @since jEdit 2.4pre1
	 */
	public static Buffer openFile(View view, String path)
	{
		return openFile(view,null,path,false,new Hashtable());
	} //}}}
	//{{{ openFile() method
	/**
	 * @deprecated The openFile() forms with the readOnly parameter
	 * should not be used. The readOnly prameter is no longer supported.
	 */
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile)
	{
		return openFile(view,parent,path,newFile,new Hashtable());
	} //}}}
	//{{{ openFile() method
	/**
	 * @deprecated The openFile() forms with the readOnly parameter
	 * should not be used. The readOnly prameter is no longer supported.
	 */
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile,
		Hashtable props)
	{
		return openFile(view,parent,path,newFile,props);
	} //}}}
	//{{{ openFile() method
	/**
	 * Opens a file. This may return null if the buffer could not be
	 * opened for some reason.
	 * @param view The view to open the file in
	 * @param parent The parent directory of the file
	 * @param path The path name of the file
	 * @param newFile True if the file should not be loaded from disk
	 * be prompted if it should be reloaded
	 * @param props Buffer-local properties to set in the buffer
	 *
	 * @since jEdit 3.2pre10
	 */
	public static Buffer openFile(View view, String parent,
		String path, boolean newFile, Hashtable props)
	{
		PerspectiveManager.setPerspectiveDirty(true);
		if(view != null && parent == null)
			parent = view.getBuffer().getDirectory();
		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}
		path = MiscUtilities.constructPath(parent,path);
		Buffer newBuffer;
		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
			{
				if(view != null)
					view.setBuffer(buffer);
				return buffer;
			}
			if(props == null)
				props = new Hashtable();
			BufferHistory.Entry entry = BufferHistory.getEntry(path);
			if(entry != null && saveCaret && props.get(Buffer.CARET) == null)
			{
				props.put(Buffer.CARET,new Integer(entry.caret));
				/* if(entry.selection != null)
				{
					// getSelection() converts from string to
					// Selection[]
					props.put(Buffer.SELECTION,entry.getSelection());
				} */
			}
			if(entry != null && props.get(Buffer.ENCODING) == null)
			{
				if(entry.encoding != null)
					props.put(Buffer.ENCODING,entry.encoding);
			}
			newBuffer = new Buffer(path,newFile,false,props);
			if(!newBuffer.load(view,false))
				return null;
			addBufferToList(newBuffer);
		}
		EditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));
		if(view != null)
			view.setBuffer(newBuffer);
		return newBuffer;
	} //}}}
	//{{{ openTemporary() method
	/**
	 * Opens a temporary buffer. A temporary buffer is like a normal
	 * buffer, except that an event is not fired, the the buffer is
	 * not added to the buffers list.
	 *
	 * @param view The view to open the file in
	 * @param parent The parent directory of the file
	 * @param path The path name of the file
	 * @param newFile True if the file should not be loaded from disk
	 *
	 * @since jEdit 3.2pre10
	 */
	public static Buffer openTemporary(View view, String parent,
		String path, boolean newFile)
	{
		if(view != null && parent == null)
			parent = view.getBuffer().getDirectory();
		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}
		path = MiscUtilities.constructPath(parent,path);
		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
				return buffer;
			buffer = new Buffer(path,newFile,true,new Hashtable());
			if(!buffer.load(view,false))
				return null;
			else
				return buffer;
		}
	} //}}}
	//{{{ commitTemporary() method
	/**
	 * Adds a temporary buffer to the buffer list. This must be done
	 * before allowing the user to interact with the buffer in any
	 * way.
	 * @param buffer The buffer
	 */
	public static void commitTemporary(Buffer buffer)
	{
		if(!buffer.isTemporary())
			return;
		PerspectiveManager.setPerspectiveDirty(true);
		addBufferToList(buffer);
		buffer.commitTemporary();
		// send full range of events to avoid breaking plugins
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOAD_STARTED));
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOADED));
	} //}}}
	//{{{ newFile() method
	/**
	 * Creates a new `untitled' file.
	 * @param view The view to create the file in
	 */
	public static Buffer newFile(View view)
	{
		String path;
		if(view != null && view.getBuffer() != null)
		{
			path = view.getBuffer().getDirectory();
			VFS vfs = VFSManager.getVFSForPath(path);
			// don't want 'New File' to create a read only buffer
			// if current file is on SQL VFS or something
			if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
				path = System.getProperty(""user.home"");
		}
		else
			path = null;
		return newFile(view,path);
	} //}}}
	//{{{ newFile() method
	/**
	 * Creates a new `untitled' file.
	 * @param view The view to create the file in
	 * @param dir The directory to create the file in
	 * @since jEdit 3.1pre2
	 */
	public static Buffer newFile(View view, String dir)
	{
		// If only one new file is open which is clean, just close
		// it, which will create an 'Untitled-1'
		if(dir != null
			&& buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			closeBuffer(view,buffersFirst);
			// return the newly created 'untitled-1'
			return buffersFirst;
		}
		// Find the highest Untitled-n file
		int untitledCount = 0;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.getName().startsWith(""Untitled-""))
			{
				try
				{
					untitledCount = Math.max(untitledCount,
						Integer.parseInt(buffer.getName()
						.substring(9)));
				}
				catch(NumberFormatException nf)
				{
				}
			}
			buffer = buffer.next;
		}
		return openFile(view,dir,""Untitled-"" + (untitledCount+1),true,null);
	} //}}}
	//}}}
	//{{{ Buffer management methods
	//{{{ closeBuffer() method
	/**
	 * Closes a buffer. If there are unsaved changes, the user is
	 * prompted if they should be saved first.
	 * @param view The view
	 * @param buffer The buffer
	 * @return True if the buffer was really closed, false otherwise
	 */
	public static boolean closeBuffer(View view, Buffer buffer)
	{
		// Wait for pending I/O requests
		if(buffer.isPerformingIO())
		{
			VFSManager.waitForRequests();
			if(VFSManager.errorOccurred())
				return false;
		}
		if(buffer.isDirty())
		{
			Object[] args = { buffer.getName() };
			int result = GUIUtilities.confirm(view,""notsaved"",args,
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				if(!buffer.save(view,null,true))
					return false;
				VFSManager.waitForRequests();
				if(buffer.getBooleanProperty(BufferIORequest
					.ERROR_OCCURRED))
				{
					return false;
				}
			}
			else if(result != JOptionPane.NO_OPTION)
				return false;
		}
		_closeBuffer(view,buffer);
		return true;
	} //}}}
	//{{{ _closeBuffer() method
	/**
	 * Closes the buffer, even if it has unsaved changes.
	 * @param view The view, may be null
	 * @param buffer The buffer
	 *
	 * @exception NullPointerException if the buffer is null
	 *
	 * @since jEdit 2.2pre1
	 */
	public static void _closeBuffer(View view, Buffer buffer)
	{
		if(buffer.isClosed())
		{
			// can happen if the user presses C+w twice real
			// quick and the buffer has unsaved changes
			return;
		}
		PerspectiveManager.setPerspectiveDirty(true);
		if(!buffer.isNewFile())
		{
			if(view != null)
				view.getEditPane().saveCaretInfo();
			Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
			int caret = (_caret == null ? 0 : _caret.intValue());
			BufferHistory.setEntry(buffer.getPath(),caret,
				(Selection[])buffer.getProperty(Buffer.SELECTION),
				buffer.getStringProperty(Buffer.ENCODING));
		}
		String path = buffer.getSymlinkPath();
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
		}
		bufferHash.remove(path);
		removeBufferFromList(buffer);
		buffer.close();
		DisplayManager.bufferClosed(buffer);
		EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));
		// Create a new file when the last is closed
		if(buffersFirst == null && buffersLast == null)
			newFile(view);
	} //}}}
	//{{{ closeAllBuffers() method
	/**
	 * Closes all open buffers.
	 * @param view The view
	 */
	public static boolean closeAllBuffers(View view)
	{
		return closeAllBuffers(view,false);
	} //}}}
	//{{{ closeAllBuffers() method
	/**
	 * Closes all open buffers.
	 * @param view The view
	 * @param isExiting This must be false unless this method is
	 * being called by the exit() method
	 */
	public static boolean closeAllBuffers(View view, boolean isExiting)
	{
		if(view != null)
			view.getEditPane().saveCaretInfo();
		boolean dirty = false;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				dirty = true;
				break;
			}
			buffer = buffer.next;
		}
		if(dirty)
		{
			boolean ok = new CloseDialog(view).isOK();
			if(!ok)
				return false;
		}
		// Wait for pending I/O requests
		VFSManager.waitForRequests();
		if(VFSManager.errorOccurred())
			return false;
		// close remaining buffers (the close dialog only deals with
		// dirty ones)
		buffer = buffersFirst;
		// zero it here so that BufferTabs doesn't have any problems
		buffersFirst = buffersLast = null;
		bufferHash.clear();
		bufferCount = 0;
		while(buffer != null)
		{
			if(!buffer.isNewFile())
			{
				Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
				int caret = (_caret == null ? 0 : _caret.intValue());
				BufferHistory.setEntry(buffer.getPath(),caret,
					(Selection[])buffer.getProperty(Buffer.SELECTION),
					buffer.getStringProperty(Buffer.ENCODING));
			}
			buffer.close();
			DisplayManager.bufferClosed(buffer);
			if(!isExiting)
			{
				EditBus.send(new BufferUpdate(buffer,view,
					BufferUpdate.CLOSED));
			}
			buffer = buffer.next;
		}
		if(!isExiting)
			newFile(view);
		PerspectiveManager.setPerspectiveDirty(true);
		return true;
	} //}}}
	//{{{ saveAllBuffers() method
	/**
	 * Saves all open buffers.
	 * @param view The view
	 * @since jEdit 4.2pre1
	 */
	public static void saveAllBuffers(View view)
	{
		saveAllBuffers(view,jEdit.getBooleanProperty(""confirmSaveAll""));
	} //}}}
	//{{{ saveAllBuffers() method
	/**
	 * Saves all open buffers.
	 * @param view The view
	 * @param confirm If true, a confirmation dialog will be shown first
	 * @since jEdit 2.7pre2
	 */
	public static void saveAllBuffers(View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""saveall"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		Buffer current = view.getBuffer();
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				if(buffer.isNewFile())
					view.setBuffer(buffer);
				buffer.save(view,null,true);
			}
			buffer = buffer.next;
		}
		view.setBuffer(current);
	} //}}}
	//{{{ reloadAllBuffers() method
	/**
	 * Reloads all open buffers.
	 * @param view The view
	 * @param confirm If true, a confirmation dialog will be shown first
	 *	if any buffers are dirty
	 * @since jEdit 2.7pre2
	 */
	public static void reloadAllBuffers(final View view, boolean confirm)
	{
		boolean hasDirty = false;
		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length && hasDirty == false; i++)
			hasDirty = buffers[i].isDirty();
		if(confirm && hasDirty)
		{
			int result = GUIUtilities.confirm(view,""reload-all"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		// save caret info. Buffer.load() will load it.
		View _view = viewsFirst;
		while(_view != null)
		{
			EditPane[] panes = _view.getEditPanes();
			for(int i = 0; i < panes.length; i++)
			{
				panes[i].saveCaretInfo();
			}
			_view = _view.next;
		}
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			buffer.load(view,true);
		}
	} //}}}
	//{{{ _getBuffer() method
	/**
	 * Returns the buffer with the specified path name. The path name
	 * must be an absolute, canonical, path.
	 *
	 * @param path The path name
	 * @see MiscUtilities#constructPath(String,String)
	 * @see MiscUtilities#resolveSymlinks(String)
	 * @see #getBuffer(String)
	 *
	 * @since jEdit 4.2pre7
	 */
	public static Buffer _getBuffer(String path)
	{
		// paths on case-insensitive filesystems are stored as lower
		// case in the hash.
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
		}
		synchronized(bufferListLock)
		{
			return (Buffer)bufferHash.get(path);
		}
	} //}}}
	//{{{ getBuffer() method
	/**
	 * Returns the buffer with the specified path name. The path name
	 * must be an absolute path. This method automatically resolves
	 * symbolic links. If performance is critical, cache the canonical
	 * path and call {@link #_getBuffer(String)} instead.
	 *
	 * @param path The path name
	 * @see MiscUtilities#constructPath(String,String)
	 * @see MiscUtilities#resolveSymlinks(String)
	 */
	public static Buffer getBuffer(String path)
	{
		return _getBuffer(MiscUtilities.resolveSymlinks(path));
	} //}}}
	//{{{ getBuffers() method
	/**
	 * Returns an array of open buffers.
	 */
	public static Buffer[] getBuffers()
	{
		synchronized(bufferListLock)
		{
			Buffer[] buffers = new Buffer[bufferCount];
			Buffer buffer = buffersFirst;
			for(int i = 0; i < bufferCount; i++)
			{
				buffers[i] = buffer;
				buffer = buffer.next;
			}
			return buffers;
		}
	} //}}}
	//{{{ getBufferCount() method
	/**
	 * Returns the number of open buffers.
	 */
	public static int getBufferCount()
	{
		return bufferCount;
	} //}}}
	//{{{ getFirstBuffer() method
	/**
	 * Returns the first buffer.
	 */
	public static Buffer getFirstBuffer()
	{
		return buffersFirst;
	} //}}}
	//{{{ getLastBuffer() method
	/**
	 * Returns the last buffer.
	 */
	public static Buffer getLastBuffer()
	{
		return buffersLast;
	} //}}}
	//{{{ checkBufferStatus() method
	/**
	 * Checks each buffer's status on disk and shows the dialog box
	 * informing the user that buffers changed on disk, if necessary.
	 * @param view The view
	 * @since jEdit 4.2pre1
	 */
	public static void checkBufferStatus(View view)
	{
		// still need to call the status check even if the option is
		// off, so that the write protection is updated if it changes
		// on disk
		boolean showDialogSetting = getBooleanProperty(
			""autoReloadDialog"");
		// auto reload changed buffers?
		boolean autoReloadSetting = getBooleanProperty(
			""autoReload"");
		// the problem with this is that if we have two edit panes
		// looking at the same buffer and the file is reloaded both
		// will jump to the same location
		View _view = viewsFirst;
		while(_view != null)
		{
			EditPane[] editPanes = _view.getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				editPanes[i].saveCaretInfo();
			}
			_view = _view.next;
		}
		Buffer buffer = buffersFirst;
		int[] states = new int[bufferCount];
		int i = 0;
		boolean show = false;
		while(buffer != null)
		{
			states[i] = buffer.checkFileStatus(view);
			switch(states[i])
			{
			case Buffer.FILE_CHANGED:
				if(autoReloadSetting
					&& showDialogSetting
					&& !buffer.isDirty())
				{
					buffer.load(view,true);
				}
				/* fall through */
			case Buffer.FILE_DELETED:
				show = true;
				break;
			}
			buffer = buffer.next;
			i++;
		}
		if(show && showDialogSetting)
			new FilesChangedDialog(view,states,autoReloadSetting);
	} //}}}
	//}}}
	//{{{ View methods
	//{{{ getInputHandler() method
	/**
	 * Returns the current input handler (key binding to action mapping)
	 * @see org.gjt.sp.jedit.gui.InputHandler
	 */
	public static InputHandler getInputHandler()
	{
		return inputHandler;
	} //}}}
	/* public static void newViewTest()
	{
		long time = System.currentTimeMillis();
		for(int i = 0; i < 30; i++)
		{
			Buffer b = newFile(null);
			b.insert(0,""x"");
			new View(b,null,false);
		}
		System.err.println(System.currentTimeMillis() - time);
	} */
	//{{{ newView() method
	/**
	 * Creates a new view.
	 * @param view An existing view
	 * @since jEdit 3.2pre2
	 */
	public static View newView(View view)
	{
		return newView(view,null,false);
	} //}}}
	//{{{ newView() method
	/**
	 * Creates a new view of a buffer.
	 * @param view An existing view
	 * @param buffer The buffer
	 */
	public static View newView(View view, Buffer buffer)
	{
		return newView(view,buffer,false);
	} //}}}
	//{{{ newView() method
	/**
	 * Creates a new view of a buffer.
	 * @param view An existing view
	 * @param buffer The buffer
	 * @param plainView If true, the view will not have dockable windows or
	 * tool bars.
	 *
	 * @since 4.1pre2
	 */
	public static View newView(View view, Buffer buffer, boolean plainView)
	{
		View.ViewConfig config;
		if(view != null && (plainView == view.isPlainView()))
			config = view.getViewConfig();
		else
			config = new View.ViewConfig(plainView);
		return newView(view,buffer,config);
	} //}}}
	//{{{ newView() method
	/**
	 * Creates a new view.
	 * @param view An existing view
	 * @param buffer A buffer to display, or null
	 * @param config Encapsulates the view geometry, split configuration
	 * and if the view is a plain view
	 * @since jEdit 4.2pre1
	 */
	public static View newView(View view, Buffer buffer, View.ViewConfig config)
	{
		PerspectiveManager.setPerspectiveDirty(true);
		try
		{
			if(view != null)
			{
				view.showWaitCursor();
				view.getEditPane().saveCaretInfo();
			}
			View newView = new View(buffer,config);
			addViewToList(newView);
			if(!config.plainView)
			{
				DockableWindowManager wm = newView.getDockableWindowManager();
				if(config.top != null
					&& config.top.length() != 0)
					wm.showDockableWindow(config.top);
				if(config.left != null
					&& config.left.length() != 0)
					wm.showDockableWindow(config.left);
				if(config.bottom != null
					&& config.bottom.length() != 0)
					wm.showDockableWindow(config.bottom);
				if(config.right != null
					&& config.right.length() != 0)
					wm.showDockableWindow(config.right);
			}
			newView.pack();
			if(config.width != 0 && config.height != 0)
			{
				Rectangle desired = new Rectangle(
					config.x,config.y,config.width,
					config.height);
				if(OperatingSystem.isX11() && Debug.GEOMETRY_WORKAROUND)
				{
					new GUIUtilities.UnixWorkaround(newView,
						""view"",desired,config.extState);
				}
				else
				{
					newView.setBounds(desired);
					GUIUtilities.setExtendedState(newView,
						config.extState);
				}
			}
			else
				GUIUtilities.centerOnScreen(newView);
			EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));
			newView.setVisible(true);
			// show tip of the day
			if(newView == viewsFirst)
			{
				newView.getTextArea().requestFocus();
				// Don't show the welcome message if jEdit was started
				// with the -nosettings switch
				if(settingsDirectory != null && getBooleanProperty(""firstTime""))
					new HelpViewer();
				else if(jEdit.getBooleanProperty(""tip.show""))
					new TipOfTheDay(newView);
				setBooleanProperty(""firstTime"",false);
			}
			else
				GUIUtilities.requestFocus(newView,newView.getTextArea());
			return newView;
		}
		finally
		{
			if(view != null)
				view.hideWaitCursor();
		}
	} //}}}
	//{{{ closeView() method
	/**
	 * Closes a view.
	 *
	 * jEdit will exit if this was the last open view.
	 */
	public static void closeView(View view)
	{
		closeView(view,true);
	} //}}}
	//{{{ getViews() method
	/**
	 * Returns an array of all open views.
	 */
	public static View[] getViews()
	{
		View[] views = new View[viewCount];
		View view = viewsFirst;
		for(int i = 0; i < viewCount; i++)
		{
			views[i] = view;
			view = view.next;
		}
		return views;
	} //}}}
	//{{{ getViewCount() method
	/**
	 * Returns the number of open views.
	 */
	public static int getViewCount()
	{
		return viewCount;
	} //}}}
	//{{{ getFirstView() method
	/**
	 * Returns the first view.
	 */
	public static View getFirstView()
	{
		return viewsFirst;
	} //}}}
	//{{{ getLastView() method
	/**
	 * Returns the last view.
	 */
	public static View getLastView()
	{
		return viewsLast;
	} //}}}
	//{{{ getActiveView() method
	/**
	 * Returns the currently focused view.
	 * @since jEdit 4.1pre1
	 */
	public static View getActiveView()
	{
		if(activeView == null)
		{
			// eg user just closed a view and didn't focus another
			return viewsFirst;
		}
		else
			return activeView;
	} //}}}
	//}}}
	//{{{ Miscellaneous methods
	//{{{ isMainThread() method
	/**
	 * Returns true if the currently running thread is the main thread.
	 * @since jEdit 4.2pre1
	 */
	public static boolean isMainThread()
	{
		return (Thread.currentThread() == mainThread);
	} //}}}
	//{{{ isBackgroundMode() method
	/**
	 * Returns true if jEdit was started with the <code>-background</code>
	 * command-line switch.
	 * @since jEdit 4.0pre4
	 */
	public static boolean isBackgroundModeEnabled()
	{
		return background;
	} //}}}
	//{{{ showMemoryStatusDialog() method
	/**
	 * Performs garbage collection and displays a dialog box showing
	 * memory status.
	 * @param view The view
	 * @since jEdit 4.0pre1
	 */
	public static void showMemoryDialog(View view)
	{
		Runtime rt = Runtime.getRuntime();
		int before = (int) (rt.freeMemory() / 1024);
		System.gc();
		int after = (int) (rt.freeMemory() / 1024);
		int total = (int) (rt.totalMemory() / 1024);
		JProgressBar progress = new JProgressBar(0,total);
		progress.setValue(total - after);
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""memory-status.use"",
			new Object[] { new Integer(total - after),
			new Integer(total) }));
		Object[] message = new Object[4];
		message[0] = getProperty(""memory-status.gc"",
			new Object[] { new Integer(after - before) });
		message[1] = Box.createVerticalStrut(12);
		message[2] = progress;
		message[3] = Box.createVerticalStrut(6);
		JOptionPane.showMessageDialog(view,message,
			jEdit.getProperty(""memory-status.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} //}}}
	//{{{ getJEditHome() method
	/**
	 * Returns the jEdit install directory.
	 */
	public static String getJEditHome()
	{
		return jEditHome;
	} //}}}
	//{{{ getSettingsDirectory() method
	/**
	 * Returns the path of the directory where user-specific settings
	 * are stored. This will be <code>null</code> if jEdit was
	 * started with the <code>-nosettings</code> command-line switch; do not
	 * blindly use this method without checking for a <code>null</code>
	 * return value first.
	 */
	public static String getSettingsDirectory()
	{
		return settingsDirectory;
	} //}}}
	//{{{ getJARCacheDirectory() method
	/**
	 * Returns the directory where plugin cache files are stored.
	 * @since jEdit 4.2pre1
	 */
	public static String getJARCacheDirectory()
	{
		return jarCacheDirectory;
	} //}}}
	//{{{ backupSettingsFile() method
	/**
	 * Backs up the specified file in the settings directory.
	 * You should call this on any settings files your plugin
	 * writes.
	 * @param file The file
	 * @since jEdit 4.0pre1
	 */
	public static void backupSettingsFile(File file)
	{
		if(settingsDirectory == null)
			return;
		String backupDir = MiscUtilities.constructPath(
			settingsDirectory,""settings-backup"");
		File dir = new File(backupDir);
		if(!dir.exists())
			dir.mkdirs();
		// ... sweet. saveBackup() will create backupDir if it
		// doesn't exist.
		MiscUtilities.saveBackup(file,5,null,""~"",backupDir);
	} //}}}
	//{{{ saveSettings() method
	/**
	 * Saves all user preferences to disk.
	 */
	public static void saveSettings()
	{
		if(settingsDirectory == null)
			return;
		Abbrevs.save();
		FavoritesVFS.saveFavorites();
		HistoryModel.saveHistory();
		Registers.saveRegisters();
		SearchAndReplace.save();
		BufferHistory.save();
		KillRing.save();
		File file1 = new File(MiscUtilities.constructPath(
			settingsDirectory,""#properties#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			settingsDirectory,""properties""));
		if(file2.exists() && file2.lastModified() != propsModTime)
		{
			Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
				+ "" on disk; will not save user properties"");
		}
		else
		{
			backupSettingsFile(file2);
			try
			{
				OutputStream out = new FileOutputStream(file1);
				propMgr.saveUserProps(out);
				file2.delete();
				file1.renameTo(file2);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,io);
			}
			propsModTime = file2.lastModified();
		}
	} //}}}
	//{{{ exit() method
	/**
	 * Exits cleanly from jEdit, prompting the user if any unsaved files
	 * should be saved first.
	 * @param view The view from which this exit was called
	 * @param reallyExit If background mode is enabled and this parameter
	 * is true, then jEdit will close all open views instead of exiting
	 * entirely.
	 */
	public static void exit(View view, boolean reallyExit)
	{
		// Close dialog, view.close() call need a view...
		if(view == null)
			view = activeView;
		// Wait for pending I/O requests
		VFSManager.waitForRequests();
		// Send EditorExitRequested
		EditBus.send(new EditorExitRequested(view));
		// Even if reallyExit is false, we still exit properly
		// if background mode is off
		reallyExit |= !background;
		PerspectiveManager.savePerspective(false);
		// Close all buffers
		if(!closeAllBuffers(view,reallyExit))
			return;
		// If we are running in background mode and
		// reallyExit was not specified, then return here.
		if(!reallyExit)
		{
			// in this case, we can't directly call
			// view.close(); we have to call closeView()
			// for all open views
			view = viewsFirst;
			while(view != null)
			{
				closeView(view,false);
				view = view.next;
			}
			// Save settings in case user kills the backgrounded
			// jEdit process
			saveSettings();
		}
		else
		{
			// Save view properties here
			if(view != null)
				view.close();
			// Stop autosave timer
			Autosave.stop();
			// Stop server
			if(server != null)
				server.stopServer();
			// Stop all plugins
			PluginJAR[] plugins = getPluginJARs();
			for(int i = 0; i < plugins.length; i++)
			{
				removePluginJAR(plugins[i],true);
			}
			// Send EditorExiting
			EditBus.send(new EditorExiting(null));
			// Save settings
			saveSettings();
			// Close activity log stream
			Log.closeStream();
			// Byebye...
			System.exit(0);
		}
	} //}}}
	//{{{ getEditServer() method
	/**
	 * Returns the edit server instance. You can use this to find out the
	 * port number jEdit is listening on.
	 * @since jEdit 4.2pre10
	 */
	public static EditServer getEditServer()
	{
		return server;
	} //}}}
	//}}}
	//{{{ Package-private members
	//{{{ updatePosition() method
	/**
	 * If buffer sorting is enabled, this repositions the buffer.
	 */
	static void updatePosition(String oldPath, Buffer buffer)
	{
		if((VFSManager.getVFSForPath(oldPath).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			oldPath = oldPath.toLowerCase();
		}
		bufferHash.remove(oldPath);
		String path = buffer.getSymlinkPath();
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
		}
		bufferHash.put(path,buffer);
		if(sortBuffers)
		{
			removeBufferFromList(buffer);
			addBufferToList(buffer);
		}
	} //}}}
	//{{{ addMode() method
	/**
	 * Do not call this method. It is only public so that classes
	 * in the org.gjt.sp.jedit.syntax package can access it.
	 * @param mode The edit mode
	 */
	public static void addMode(Mode mode)
	{
		//Log.log(Log.DEBUG,jEdit.class,""Adding edit mode ""
		//	+ mode.getName());
		modes.addElement(mode);
	} //}}}
	//{{{ loadMode() method
	/**
	 * Loads an XML-defined edit mode from the specified reader.
	 * @param mode The edit mode
	 */
	/* package-private */ static void loadMode(Mode mode)
	{
		final String fileName = (String)mode.getProperty(""file"");
		Log.log(Log.NOTICE,jEdit.class,""Loading edit mode "" + fileName);
		final XmlParser parser = new XmlParser();
		XModeHandler xmh = new XModeHandler(mode.getName())
		{
			public void error(String what, Object subst)
			{
				int line = parser.getLineNumber();
				int column = parser.getColumnNumber();
				String msg;
				if(subst == null)
					msg = jEdit.getProperty(""xmode-error."" + what);
				else
				{
					msg = jEdit.getProperty(""xmode-error."" + what,
						new String[] { subst.toString() });
					if(subst instanceof Throwable)
						Log.log(Log.ERROR,this,subst);
				}
				Object[] args = { fileName, new Integer(line),
					new Integer(column), msg };
				GUIUtilities.error(null,""xmode-error"",args);
			}
			public TokenMarker getTokenMarker(String modeName)
			{
				Mode mode = getMode(modeName);
				if(mode == null)
					return null;
				else
					return mode.getTokenMarker();
			}
		};
		mode.setTokenMarker(xmh.getTokenMarker());
		Reader grammar = null;
		parser.setHandler(xmh);
		try
		{
			grammar = new BufferedReader(new FileReader(fileName));
			parser.parse(null, null, grammar);
			mode.setProperties(xmh.getModeProperties());
		}
		catch (Throwable e)
		{
			Log.log(Log.ERROR, jEdit.class, e);
			if (e instanceof XmlException)
			{
				XmlException xe = (XmlException) e;
				int line = xe.getLine();
				String message = xe.getMessage();
				Object[] args = { fileName, new Integer(line), null,
					message };
				GUIUtilities.error(null,""xmode-error"",args);
			}
		}
		finally
		{
			try
			{
				if(grammar != null)
					grammar.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,io);
			}
		}
	} //}}}
	//{{{ addPluginProps() method
	static void addPluginProps(Properties map)
	{
		propMgr.addPluginProps(map);
	} //}}}
	//{{{ removePluginProps() method
	static void removePluginProps(Properties map)
	{
		propMgr.removePluginProps(map);
	} //}}}
	//{{{ pluginError() method
	static void pluginError(String path, String messageProp,
		Object[] args)
	{
		synchronized(pluginErrorLock)
		{
			if(pluginErrors == null)
				pluginErrors = new Vector();
			ErrorListDialog.ErrorEntry newEntry =
				new ErrorListDialog.ErrorEntry(
				path,messageProp,args);
			for(int i = 0; i < pluginErrors.size(); i++)
			{
				if(pluginErrors.get(i).equals(newEntry))
					return;
			}
			pluginErrors.addElement(newEntry);
			if(startupDone)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						showPluginErrorDialog();
					}
				});
			}
		}
	} //}}}
	//{{{ setActiveView() method
	static void setActiveView(View view)
	{
		jEdit.activeView = view;
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Static variables
	private static String jEditHome;
	private static String settingsDirectory;
	private static String jarCacheDirectory;
	private static long propsModTime;
	private static PropertyManager propMgr;
	private static EditServer server;
	private static boolean background;
	private static ActionContext actionContext;
	private static ActionSet builtInActionSet;
	private static Vector pluginErrors;
	private static Object pluginErrorLock = new Object();
	private static Vector jars;
	private static Vector modes;
	private static boolean saveCaret;
	private static InputHandler inputHandler;
	// buffer link list
	private static boolean sortBuffers;
	private static boolean sortByName;
	private static int bufferCount;
	private static Buffer buffersFirst;
	private static Buffer buffersLast;
	private static Map bufferHash;
	// makes openTemporary() thread-safe
	private static Object bufferListLock = new Object();
	// view link list
	private static int viewCount;
	private static View viewsFirst;
	private static View viewsLast;
	private static View activeView;
	private static boolean startupDone;
	private static Thread mainThread;
	//}}}
	private jEdit() {}
	//{{{ usage() method
	private static void usage()
	{
		System.out.println(""Usage: jedit [<options>] [<files>]"");
		System.out.println(""	<file> +marker:<marker>: Positions caret""
			+ "" at marker <marker>"");
		System.out.println(""	<file> +line:<line>: Positions caret""
			+ "" at line number <line>"");
		System.out.println(""	--: End of options"");
		System.out.println(""	-background: Run in background mode"");
		System.out.println(""	-nobackground: Disable background mode (default)"");
		System.out.println(""	-gui: Only if running in background mode; open initial view (default)"");
		System.out.println(""	-nogui: Only if running in background mode; don't open initial view"");
		System.out.println(""	-log=<level>: Log messages with level equal to or higher than this to"");
		System.out.println(""	 standard error. <level> must be between 1 and 9. Default is 7."");
		System.out.println(""	-newplainview: Client instance opens a new plain view"");
		System.out.println(""	-newview: Client instance opens a new view (default)"");
		System.out.println(""	-plugins: Load plugins (default)"");
		System.out.println(""	-noplugins: Don't load any plugins"");
		System.out.println(""	-restore: Restore previously open files (default)"");
		System.out.println(""	-norestore: Don't restore previously open files"");
		System.out.println(""	-reuseview: Client instance reuses existing view"");
		System.out.println(""	-quit: Quit a running instance"");
		System.out.println(""	-run=<script>: Run the specified BeanShell script"");
		System.out.println(""	-server: Read/write server info from/to $HOME/.jedit/server (default)"");
		System.out.println(""	-server=<name>: Read/write server info from/to $HOME/.jedit/<name>"");
		System.out.println(""	-noserver: Don't start edit server"");
		System.out.println(""	-settings=<path>: Load user-specific settings from <path>"");
		System.out.println(""	-nosettings: Don't load user-specific settings"");
		System.out.println(""	-startupscripts: Run startup scripts (default)"");
		System.out.println(""	-nostartupscripts: Don't run startup scripts"");
		System.out.println(""	-usage: Print this message and exit"");
		System.out.println(""	-version: Print jEdit version and exit"");
		System.out.println(""	-wait: Wait until the user closes the specified buffer in the server"");
		System.out.println(""	 instance. Does nothing if passed to the initial jEdit instance."");
		System.out.println();
		System.out.println(""Report bugs to Slava Pestov <slava@jedit.org>."");
	} //}}}
	//{{{ version() method
	private static void version()
	{
		System.out.println(""jEdit "" + getVersion());
	} //}}}
	//{{{ makeServerScript() method
	/**
	 * Creates a BeanShell script that can be sent to a running edit server.
	 */
	private static String makeServerScript(boolean wait,
		boolean restore, boolean newView,
		boolean newPlainView, String[] args,
		String scriptFile)
	{
		StringBuffer script = new StringBuffer();
		String userDir = System.getProperty(""user.dir"");
		script.append(""parent = \"""");
		script.append(MiscUtilities.charsToEscapes(userDir));
		script.append(""\"";\n"");
		script.append(""args = new String["");
		script.append(args.length);
		script.append(""];\n"");
		for(int i = 0; i < args.length; i++)
		{
			script.append(""args["");
			script.append(i);
			script.append(""] = "");
			if(args[i] == null)
				script.append(""null"");
			else
			{
				script.append('""');
				script.append(MiscUtilities.charsToEscapes(args[i]));
				script.append('""');
			}
			script.append("";\n"");
		}
		script.append(""view = jEdit.getLastView();\n"");
		script.append(""buffer = EditServer.handleClient(""
			+ restore + "","" + newView + "","" + newPlainView +
			"",parent,args);\n"");
		script.append(""if(buffer != null && "" + wait + "") {\n"");
		script.append(""\tbuffer.setWaitSocket(socket);\n"");
		script.append(""\tdoNotCloseSocket = true;\n"");
		script.append(""}\n"");
		script.append(""if(view != jEdit.getLastView() && "" + wait + "") {\n"");
		script.append(""\tjEdit.getLastView().setWaitSocket(socket);\n"");
		script.append(""\tdoNotCloseSocket = true;\n"");
		script.append(""}\n"");
		script.append(""if(doNotCloseSocket == void)\n"");
		script.append(""\tsocket.close();\n"");
		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			script.append(""BeanShell.runScript(view,\""""
				+ MiscUtilities.charsToEscapes(scriptFile)
				+ ""\"",null,this.namespace);\n"");
		}
		return script.toString();
	} //}}}
	//{{{ initMisc() method
	/**
	 * Initialise various objects, register protocol handlers.
	 */
	private static void initMisc()
	{
		jars = new Vector();
		actionContext = new ActionContext()
		{
			public void invokeAction(EventObject evt,
				EditAction action)
			{
				View view = GUIUtilities.getView(
					(Component)evt.getSource());
				boolean actionBarVisible;
				if(view.getActionBar() == null
					|| !view.getActionBar().isShowing())
					actionBarVisible = false;
				else
				{
					actionBarVisible = view.getActionBar()
						.isVisible();
				}
				view.getInputHandler().invokeAction(action);
				if(actionBarVisible)
				{
					// XXX: action bar might not be 'temp'
					ActionBar actionBar = view
						.getActionBar();
					if(actionBar != null)
						view.removeToolBar(actionBar);
				}
			}
		};
		bufferHash = new HashMap();
		inputHandler = new DefaultInputHandler(null);
		// Add our protocols to java.net.URL's list
		System.getProperties().put(""java.protocol.handler.pkgs"",
			""org.gjt.sp.jedit.proto|"" +
			System.getProperty(""java.protocol.handler.pkgs"",""""));
		// Set the User-Agent string used by the java.net HTTP handler
		String userAgent = ""jEdit/"" + getVersion()
			+ "" (Java "" + System.getProperty(""java.version"")
			+ "". "" + System.getProperty(""java.vendor"")
			+ ""; "" + System.getProperty(""os.arch"") + "")"";
		System.getProperties().put(""http.agent"",userAgent);
		/* Determine installation directory.
		 * If the jedit.home property is set, use that.
		 * Then, look for jedit.jar in the classpath.
		 * If that fails, assume this is the web start version. */
		jEditHome = System.getProperty(""jedit.home"");
		if(jEditHome == null)
		{
			String classpath = System
				.getProperty(""java.class.path"");
			int index = classpath.toLowerCase()
				.indexOf(""jedit.jar"");
			int start = classpath.lastIndexOf(File
				.pathSeparator,index) + 1;
			// if started with java -jar jedit.jar
			 if(classpath.equalsIgnoreCase(""jedit.jar""))
			{
				jEditHome = System.getProperty(""user.dir"");
			}
			else if(index > start)
			{
				jEditHome = classpath.substring(start,
					index - 1);
			}
			else
			{
				// check if web start
				/* if(jEdit.class.getResource(""/modes/catalog"") != null)
				{
					// modes bundled in; hence web start
					jEditHome = null;
				}
				else */
				{
					// use user.dir as last resort
					jEditHome = System.getProperty(""user.dir"");
					Log.log(Log.WARNING,jEdit.class,""jedit.jar not in class path!"");
					Log.log(Log.WARNING,jEdit.class,""Assuming jEdit is installed in ""
						+ jEditHome + ""."");
					Log.log(Log.WARNING,jEdit.class,""Override with jedit.home ""
						+ ""system property."");
				}
			}
		}
		jEditHome = MiscUtilities.resolveSymlinks(jEditHome);
		Log.log(Log.MESSAGE,jEdit.class,""jEdit home directory is "" + jEditHome);
		if(settingsDirectory != null)
		{
			jarCacheDirectory = MiscUtilities.constructPath(
				settingsDirectory,""jars-cache"");
			new File(jarCacheDirectory).mkdirs();
		}
		//if(jEditHome == null)
		//	Log.log(Log.DEBUG,jEdit.class,""Web start mode"");
		// Add an EditBus component that will reload edit modes and
		// macros if they are changed from within the editor
		EditBus.addToBus(new SettingsReloader());
		// Perhaps if Xerces wasn't slightly brain-damaged, we would
		// not need this
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				Thread.currentThread().setContextClassLoader(
					new JARClassLoader());
			}
		});
	} //}}}
	//{{{ initSystemProperties() method
	/**
	 * Load system properties.
	 */
	private static void initSystemProperties()
	{
		propMgr = new PropertyManager();
		try
		{
			propMgr.loadSystemProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit.props""));
			propMgr.loadSystemProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_gui.props""));
			propMgr.loadSystemProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_keys.props""));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,
				""Error while loading system properties!"");
			Log.log(Log.ERROR,jEdit.class,
				""One of the following property files could not be loaded:\n""
				+ ""- jedit.props\n""
				+ ""- jedit_gui.props\n""
				+ ""- jedit_keys.props\n""
				+ ""jedit.jar is probably corrupt."");
			Log.log(Log.ERROR,jEdit.class,e);
			System.exit(1);
		}
	} //}}}
	//{{{ initSiteProperties() method
	/**
	 * Load site properties.
	 */
	private static void initSiteProperties()
	{
		// site properties are loaded as default properties, overwriting
		// jEdit's system properties
		String siteSettingsDirectory = MiscUtilities.constructPath(
			jEditHome, ""properties"");
		File siteSettings = new File(siteSettingsDirectory);
		if (!(siteSettings.exists() && siteSettings.isDirectory()))
			return;
		String[] snippets = siteSettings.list();
		if (snippets == null)
			return;
		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());
		for (int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".props""))
				continue;
			try
			{
				String path = MiscUtilities.constructPath(
					siteSettingsDirectory,snippet);
				Log.log(Log.DEBUG,jEdit.class,
					""Loading site snippet: "" + path);
				propMgr.loadSiteProps(new FileInputStream(new File(path)));
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load site snippet ""
					+ snippet);
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} //}}}
	//{{{ initResources() method
	private static void initResources()
	{
		builtInActionSet = new ActionSet(null,null,null,
			jEdit.class.getResource(""actions.xml""));
		builtInActionSet.setLabel(getProperty(""action-set.jEdit""));
		builtInActionSet.load();
		actionContext.addActionSet(builtInActionSet);
		DockableWindowManager.loadDockableWindows(null,
			jEdit.class.getResource(""dockables.xml""),
			null);
		ServiceManager.loadServices(null,
			jEdit.class.getResource(""services.xml""),
			null);
	} //}}}
	//{{{ initPlugins() method
	/**
	 * Loads plugins.
	 */
	private static void initPlugins()
	{
		if(jEditHome != null)
		{
			addPluginJARsFromDirectory(MiscUtilities.constructPath(
				jEditHome,""jars""));
		}
		if(settingsDirectory != null)
		{
			File jarsDirectory = new File(settingsDirectory,""jars"");
			if(!jarsDirectory.exists())
				jarsDirectory.mkdir();
			addPluginJARsFromDirectory(jarsDirectory.getPath());
		}
		PluginJAR[] jars = getPluginJARs();
		for(int i = 0; i < jars.length; i++)
		{
			jars[i].checkDependencies();
		}
	} //}}}
	//{{{ initUserProperties() method
	/**
	 * Loads user properties.
	 */
	private static void initUserProperties()
	{
		if(settingsDirectory != null)
		{
			File file = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			propsModTime = file.lastModified();
			try
			{
				propMgr.loadUserProps(
					new FileInputStream(file));
			}
			catch(FileNotFoundException fnf)
			{
				//Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} //}}}
	//{{{ fontStyleToString() method
	private static String fontStyleToString(int style)
	{
		if(style == 0)
			return ""PLAIN"";
		else if(style == Font.BOLD)
			return ""BOLD"";
		else if(style == Font.ITALIC)
			return ""ITALIC"";
		else if(style == (Font.BOLD | Font.ITALIC))
			return ""BOLDITALIC"";
		else
			throw new RuntimeException(""Invalid style: "" + style);
	} //}}}
	//{{{ fontToString() method
	private static String fontToString(Font font)
	{
		return font.getFamily()
			+ ""-""
			+ fontStyleToString(font.getStyle())
			+ ""-""
			+ font.getSize();
	} //}}}
	//{{{ initPLAF() method
	/**
	 * Sets the Swing look and feel.
	 */
	private static void initPLAF()
	{
		Font primaryFont = jEdit.getFontProperty(
			""metal.primary.font"");
		if(primaryFont != null)
		{
			String primaryFontString =
				fontToString(primaryFont);
			System.getProperties().put(
				""swing.plaf.metal.controlFont"",
				primaryFontString);
			System.getProperties().put(
				""swing.plaf.metal.menuFont"",
				primaryFontString);
		}
		Font secondaryFont = jEdit.getFontProperty(
			""metal.secondary.font"");
		if(secondaryFont != null)
		{
			String secondaryFontString =
				fontToString(secondaryFont);
			System.getProperties().put(
				""swing.plaf.metal.systemFont"",
				secondaryFontString);
			System.getProperties().put(
				""swing.plaf.metal.userFont"",
				secondaryFontString);
		}
		try
		{
			String lf = getProperty(""lookAndFeel"");
			if(lf != null && lf.length() != 0)
				UIManager.setLookAndFeel(lf);
			else if(OperatingSystem.isMacOS())
			{
				UIManager.setLookAndFeel(UIManager
					.getSystemLookAndFeelClassName());
			}
			else
			{
				UIManager.setLookAndFeel(UIManager
					.getCrossPlatformLookAndFeelClassName());
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
		UIDefaults defaults = UIManager.getDefaults();
		// give all Swing components our colors
		if(jEdit.getBooleanProperty(""textColors""))
		{
			Color background = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.bgColor""));
			Color foreground = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.fgColor""));
			Color caretColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.caretColor""));
			Color selectionColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.selectionColor""));
			String[] prefixes = { ""TextField"", ""TextArea"", ""List"", ""Table"" };
			for(int i = 0; i < prefixes.length; i++)
			{
				String prefix = prefixes[i];
				defaults.put(prefix + "".disabledBackground"",background);
				defaults.put(prefix + "".background"",background);
				defaults.put(prefix + "".disabledForeground"",foreground);
				defaults.put(prefix + "".foreground"",foreground);
				defaults.put(prefix + "".caretForeground"",caretColor);
				defaults.put(prefix + "".selectionForeground"",foreground);
				defaults.put(prefix + "".selectionBackground"",selectionColor);
				//defaults.put(prefix + "".inactiveForeground"",foreground);
			}
			defaults.put(""Tree.background"",background);
			defaults.put(""Tree.foreground"",foreground);
			defaults.put(""Tree.textBackground"",background);
			defaults.put(""Tree.textForeground"",foreground);
			defaults.put(""Tree.selectionForeground"",foreground);
			defaults.put(""Tree.selectionBackground"",selectionColor);
		}
		defaults.remove(""SplitPane.border"");
		defaults.remove(""SplitPaneDivider.border"");
	} //}}}
	//{{{ runStartupScripts() method
	/**
	 * Runs scripts in a directory.
	 */
	private static void runStartupScripts(File directory)
	{
		if (!directory.isDirectory())
			return;
		File[] snippets = directory.listFiles();
		if (snippets == null)
			return;
		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < snippets.length; ++i)
		{
			File snippet = snippets[i];
			Macros.Handler handler = Macros.getHandlerForPathName(
				snippet.getPath());
			if(handler == null)
				continue;
			try
			{
				Macros.Macro newMacro = handler.createMacro(
					snippet.getName(),
					snippet.getPath());
				handler.runMacro(null,newMacro,false);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} //}}}
	//{{{ initProxy() method
	private static void initProxy()
	{
		boolean socksEnabled = jEdit.getBooleanProperty(""socks.enabled"");
		if(!socksEnabled)
		{
			Log.log(Log.DEBUG,jEdit.class,""SOCKS proxy disabled"");
                        System.getProperties().remove(""socksProxyHost"");
                        System.getProperties().remove(""socksProxyPort"");
		}
		else
		{
			String socksHost = jEdit.getProperty(""firewall.socks.host"");
			if( socksHost != null )
			{
				System.setProperty(""socksProxyHost"", socksHost);
				Log.log(Log.DEBUG, jEdit.class,
					""SOCKS proxy enabled: "" + socksHost);
                        }
			String socksPort =  jEdit.getProperty(""firewall.socks.port"");
			if(socksPort != null)
				System.setProperty(""socksProxyPort"", socksPort);
		}
		boolean httpEnabled = jEdit.getBooleanProperty(""firewall.enabled"");
		if (!httpEnabled)
		{
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy disabled"");
			System.getProperties().remove(""proxySet"");
			System.getProperties().remove(""proxyHost"");
			System.getProperties().remove(""proxyPort"");
			System.getProperties().remove(""http.proxyHost"");
			System.getProperties().remove(""http.proxyPort"");
			System.getProperties().remove(""http.nonProxyHosts"");
			Authenticator.setDefault(null);
		}
		else
		{
			// set proxy host
			String host = jEdit.getProperty(""firewall.host"");
			if (host == null)
				return;
			System.setProperty(""http.proxyHost"", host);
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy enabled: "" + host);
			// set proxy port
			String port = jEdit.getProperty(""firewall.port"");
			if (port != null)
				System.setProperty(""http.proxyPort"", port);
			// set non proxy hosts list
			String nonProxyHosts = jEdit.getProperty(""firewall.nonProxyHosts"");
			if (nonProxyHosts != null)
				System.setProperty(""http.nonProxyHosts"", nonProxyHosts);
			// set proxy authentication
			String username = jEdit.getProperty(""firewall.user"");
			String password = jEdit.getProperty(""firewall.password"");
			// null not supported?
			if(password == null)
				password = """";
			if(username == null || username.length()==0)
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy without user"");
				Authenticator.setDefault(new FirewallAuthenticator(null));
			}
			else
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy user: "" + username);
				PasswordAuthentication pw = new PasswordAuthentication(
					username,password.toCharArray()
				);
				Authenticator.setDefault(new FirewallAuthenticator(pw));
			}
		}
	} //}}}
	//{{{ FirewallAuthenticator class
	static class FirewallAuthenticator extends Authenticator
	{
		PasswordAuthentication pw;
		public FirewallAuthenticator(PasswordAuthentication pw)
		{
			this.pw = pw;
		}
		protected PasswordAuthentication getPasswordAuthentication()
		{
			return pw;
		}
	} //}}}
	//{{{ finishStartup() method
	private static void finishStartup(final boolean gui, final boolean restore,
		final String userDir, final String[] args)
	{
		SwingUtilities.invokeLater(new Runnable() {
			public void run()
			{
				Buffer buffer = openFiles(null,userDir,args);
				int count = getBufferCount();
				if(count == 0)
					newFile(null);
				View view = null;
				boolean restoreFiles = restore
					&& jEdit.getBooleanProperty(""restore"")
					&& (getBufferCount() == 0 ||
					jEdit.getBooleanProperty(""restore.cli""));
				if(gui || count != 0)
				{
					view = PerspectiveManager
						.loadPerspective(
						restoreFiles);
					if(view == null)
						view = newView(null,buffer);
					else if(buffer != null)
						view.setBuffer(buffer);
				}
				// Start I/O threads
				EditBus.send(new EditorStarted(null));
				VFSManager.start();
				// Start edit server
				if(server != null)
					server.start();
				GUIUtilities.hideSplashScreen();
				Log.log(Log.MESSAGE,jEdit.class,""Startup ""
					+ ""complete"");
				//{{{ Report any plugin errors
				if(pluginErrors != null)
				{
					showPluginErrorDialog();
				} //}}}
				startupDone = true;
				// in one case not a single AWT class will
				// have been touched (splash screen off +
				// -nogui -nobackground switches on command
				// line)
				Toolkit.getDefaultToolkit();
			}
		});
	} //}}}
	//{{{ showPluginErrorDialog() method
	private static void showPluginErrorDialog()
	{
		if(pluginErrors == null)
			return;
		String caption = getProperty(
			""plugin-error.caption"" + (pluginErrors.size() == 1
			? ""-1"" : """"));
		Frame frame = (PluginManager.getInstance() == null
			? (Frame)viewsFirst
			: (Frame)PluginManager.getInstance());
		new ErrorListDialog(frame,
			getProperty(""plugin-error.title""),
			caption,pluginErrors,true);
		pluginErrors = null;
	} //}}}
	//{{{ getNotLoadedPluginJARs() method
	private static void getNotLoadedPluginJARs(Vector returnValue,
		String dir, String[] list)
	{
loop:		for(int i = 0; i < list.length; i++)
		{
			String name = list[i];
			if(!name.toLowerCase().endsWith("".jar""))
				continue loop;
			String path = MiscUtilities.constructPath(dir,name);
			for(int j = 0; j < jars.size(); j++)
			{
				PluginJAR jar = (PluginJAR)
					jars.elementAt(j);
				String jarPath = jar.getPath();
				String jarName = MiscUtilities.getFileName(jarPath);
				if(path.equals(jarPath))
					continue loop;
				else if(!new File(jarPath).exists()
					&& name.equals(jarName))
					continue loop;
			}
			returnValue.addElement(path);
		}
	} //}}}
	//{{{ gotoMarker() method
	private static void gotoMarker(final View view, final Buffer buffer,
		final String marker)
	{
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				int pos;
				// Handle line number
				if(marker.startsWith(""+line:""))
				{
					try
					{
						int line = Integer.parseInt(marker.substring(6));
						pos = buffer.getLineStartOffset(line - 1);
					}
					catch(Exception e)
					{
						return;
					}
				}
				// Handle marker
				else if(marker.startsWith(""+marker:""))
				{
					if(marker.length() != 9)
						return;
					Marker m = buffer.getMarker(marker.charAt(8));
					if(m == null)
						return;
					pos = m.getPosition();
				}
				// Can't happen
				else
					throw new InternalError();
				if(view != null && view.getBuffer() == buffer)
					view.getTextArea().setCaretPosition(pos);
				else
				{
					buffer.setIntegerProperty(Buffer.CARET,pos);
					buffer.unsetProperty(Buffer.SCROLL_VERT);
				}
			}
		});
	} //}}}
	//{{{ addBufferToList() method
	private static void addBufferToList(Buffer buffer)
	{
		synchronized(bufferListLock)
		{
			String symlinkPath = buffer.getSymlinkPath();
			if((VFSManager.getVFSForPath(symlinkPath).getCapabilities()
				& VFS.CASE_INSENSITIVE_CAP) != 0)
			{
				symlinkPath = symlinkPath.toLowerCase();
			}
			// if only one, clean, 'untitled' buffer is open, we
			// replace it
			if(viewCount <= 1 && buffersFirst != null
				&& buffersFirst == buffersLast
				&& buffersFirst.isUntitled()
				&& !buffersFirst.isDirty())
			{
				Buffer oldBuffersFirst = buffersFirst;
				buffersFirst = buffersLast = buffer;
				DisplayManager.bufferClosed(oldBuffersFirst);
				EditBus.send(new BufferUpdate(oldBuffersFirst,
					null,BufferUpdate.CLOSED));
				bufferHash.clear();
				bufferHash.put(symlinkPath,buffer);
				return;
			}
			bufferCount++;
			bufferHash.put(symlinkPath,buffer);
			if(buffersFirst == null)
			{
				buffersFirst = buffersLast = buffer;
				return;
			}
			//{{{ Sort buffer list
			else if(sortBuffers)
			{
				String str11, str12;
				if(sortByName)
				{
					str11 = buffer.getName();
					str12 = buffer.getDirectory();
				}
				else
				{
					str11 = buffer.getDirectory();
					str12 = buffer.getName();
				}
				Buffer _buffer = buffersFirst;
				while(_buffer != null)
				{
					String str21, str22;
					if(sortByName)
					{
						str21 = _buffer.getName();
						str22 = _buffer.getDirectory();
					}
					else
					{
						str21 = _buffer.getDirectory();
						str22 = _buffer.getName();
					}
					int comp = MiscUtilities.compareStrings(str11,str21,true);
					if(comp < 0 || (comp == 0 && MiscUtilities.compareStrings(str12,str22,true) < 0))
					{
						buffer.next = _buffer;
						buffer.prev = _buffer.prev;
						_buffer.prev = buffer;
						if(_buffer != buffersFirst)
							buffer.prev.next = buffer;
						else
							buffersFirst = buffer;
						return;
					}
					_buffer = _buffer.next;
				}
			} //}}}
			buffer.prev = buffersLast;
			// fixes the hang that can occur if we 'save as' to a
			// new filename which requires re-sorting
			buffer.next = null;
			buffersLast.next = buffer;
			buffersLast = buffer;
		}
	} //}}}
	//{{{ removeBufferFromList() method
	private static void removeBufferFromList(Buffer buffer)
	{
		synchronized(bufferListLock)
		{
			bufferCount--;
			boolean caseInsensitiveFilesystem =
				OperatingSystem.isDOSDerived()
				|| OperatingSystem.isMacOS();
			String path = buffer.getPath();
			if(caseInsensitiveFilesystem)
				path = path.toLowerCase();
			bufferHash.remove(path);
			if(buffer == buffersFirst && buffer == buffersLast)
			{
				buffersFirst = buffersLast = null;
				return;
			}
			if(buffer == buffersFirst)
			{
				buffersFirst = buffer.next;
				buffer.next.prev = null;
			}
			else
			{
				buffer.prev.next = buffer.next;
			}
			if(buffer == buffersLast)
			{
				buffersLast = buffersLast.prev;
				buffer.prev.next = null;
			}
			else
			{
				buffer.next.prev = buffer.prev;
			}
			// fixes the hang that can occur if we 'save as' to a new
			// filename which requires re-sorting
			buffer.next = buffer.prev = null;
		}
	} //}}}
	//{{{ addViewToList() method
	private static void addViewToList(View view)
	{
		viewCount++;
		if(viewsFirst == null)
			viewsFirst = viewsLast = view;
		else
		{
			view.prev = viewsLast;
			viewsLast.next = view;
			viewsLast = view;
		}
	} //}}}
	//{{{ removeViewFromList() method
	private static void removeViewFromList(View view)
	{
		viewCount--;
		if(viewsFirst == viewsLast)
		{
			viewsFirst = viewsLast = null;
			return;
		}
		if(view == viewsFirst)
		{
			viewsFirst = view.next;
			view.next.prev = null;
		}
		else
		{
			view.prev.next = view.next;
		}
		if(view == viewsLast)
		{
			viewsLast = viewsLast.prev;
			view.prev.next = null;
		}
		else
		{
			view.next.prev = view.prev;
		}
	} //}}}
	//{{{ closeView() method
	/**
	 * closeView() used by exit().
	 */
	private static void closeView(View view, boolean callExit)
	{
		PerspectiveManager.setPerspectiveDirty(true);
		if(viewsFirst == viewsLast && callExit)
			exit(view,false); /* exit does editor event & save */
		else
		{
			EditBus.send(new ViewUpdate(view,ViewUpdate.CLOSED));
			view.close();
			removeViewFromList(view);
			if(view == activeView)
				activeView = null;
		}
	} //}}}
	//{{{ loadModeCatalog() method
	/**
	 * Loads a mode catalog file.
	 * @since jEdit 3.2pre2
	 */
	private static void loadModeCatalog(String path, boolean resource)
	{
		Log.log(Log.MESSAGE,jEdit.class,""Loading mode catalog file "" + path);
		ModeCatalogHandler handler = new ModeCatalogHandler(
			MiscUtilities.getParentOfPath(path),resource);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		Reader in = null;
		try
		{
			InputStream _in;
			if(resource)
				_in = jEdit.class.getResourceAsStream(path);
			else
				_in = new FileInputStream(path);
			in = new BufferedReader(new InputStreamReader(_in));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,io);
			}
		}
	} //}}}
	//{{{ initKeyBindings() method
	/**
	 * Loads all key bindings from the properties.
	 * @since 3.1pre1
	 */
	private static void initKeyBindings()
	{
		inputHandler.removeAllKeyBindings();
		ActionSet[] actionSets = getActionSets();
		for(int i = 0; i < actionSets.length; i++)
		{
			actionSets[i].initKeyBindings();
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.Macros,"/*
 * Macros.java - Macro manager
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 * Portions copyright (C) 2002 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import gnu.regexp.RE;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * This class records and runs macros.<p>
 *
 * It also contains a few methods useful for displaying output messages
 * or obtaining input from a macro:
 *
 * <ul>
 * <li>{@link #confirm(Component,String,int)}</li>
 * <li>{@link #confirm(Component,String,int,int)}</li>
 * <li>{@link #error(Component,String)}</li>
 * <li>{@link #input(Component,String)}</li>
 * <li>{@link #input(Component,String,String)}</li>
 * <li>{@link #message(Component,String)}</li>
 * </ul>
 *
 * Note that plugins should not use the above methods. Call
 * the methods in the {@link GUIUtilities} class instead.
 *
 * @author Slava Pestov
 * @version $Id: Macros.java,v 1.40 2004/07/12 19:25:07 spestov Exp $
 */
public class Macros
{
	//{{{ showRunScriptDialog() method
	/**
	 * Prompts for one or more files to run as macros
	 * @param view The view
	 * @since jEdit 4.0pre7
	 */
	public static void showRunScriptDialog(View view)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,true);
		if(paths != null)
		{
			Buffer buffer = view.getBuffer();
			try
			{
				buffer.beginCompoundEdit();
file_loop:			for(int i = 0; i < paths.length; i++)
					runScript(view,paths[i],false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} //}}}
	//{{{ runScript() method
	/**
	 * Runs the specified script.
	 * Unlike the {@link BeanShell#runScript(View,String,Reader,boolean)}
	 * method, this method can run scripts supported
	 * by any registered macro handler.
	 * @param view The view
	 * @param path The VFS path of the script
	 * @param ignoreUnknown If true, then unknown file types will be
	 * ignored; otherwise, a warning message will be printed and they will
	 * be evaluated as BeanShell scripts.
	 *
	 * @since jEdit 4.1pre2
	 */
	public static void runScript(View view, String path, boolean ignoreUnknown)
	{
		Handler handler = getHandlerForPathName(path);
		if(handler != null)
		{
			try
			{
				Macro newMacro = handler.createMacro(
					MiscUtilities.getFileName(path), path);
				newMacro.invoke(view);
			}
			catch (Exception e)
			{
				Log.log(Log.ERROR, Macros.class, e);
				return;
			}
			return;
		}
		// only executed if above loop falls
		// through, ie there is no handler for
		// this file
		if(ignoreUnknown)
		{
			Log.log(Log.NOTICE,Macros.class,path +
				"": Cannot find a suitable macro handler"");
		}
		else
		{
			Log.log(Log.ERROR,Macros.class,path +
				"": Cannot find a suitable macro handler, ""
				+ ""assuming BeanShell"");
			getHandler(""beanshell"").createMacro(
				path,path).invoke(view);
		}
	} //}}}
	//{{{ message() method
	/**
	 * Utility method that can be used to display a message dialog in a macro.
	 * @param comp The component to show the dialog on behalf of, this
	 * will usually be a view instance
	 * @param message The message
	 * @since jEdit 2.7pre2
	 */
	public static void message(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();
		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} //}}}
	//{{{ error() method
	/**
	 * Utility method that can be used to display an error dialog in a macro.
	 * @param comp The component to show the dialog on behalf of, this
	 * will usually be a view instance
	 * @param message The message
	 * @since jEdit 2.7pre2
	 */
	public static void error(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();
		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.ERROR_MESSAGE);
	} //}}}
	//{{{ input() method
	/**
	 * Utility method that can be used to prompt for input in a macro.
	 * @param comp The component to show the dialog on behalf of, this
	 * will usually be a view instance
	 * @param prompt The prompt string
	 * @since jEdit 2.7pre2
	 */
	public static String input(Component comp, String prompt)
	{
		GUIUtilities.hideSplashScreen();
		return input(comp,prompt,null);
	} //}}}
	//{{{ input() method
	/**
	 * Utility method that can be used to prompt for input in a macro.
	 * @param comp The component to show the dialog on behalf of, this
	 * will usually be a view instance
	 * @param prompt The prompt string
	 * @since jEdit 3.1final
	 */
	public static String input(Component comp, String prompt, String defaultValue)
	{
		GUIUtilities.hideSplashScreen();
		return (String)JOptionPane.showInputDialog(comp,prompt,
			jEdit.getProperty(""macro-input.title""),
			JOptionPane.QUESTION_MESSAGE,null,null,defaultValue);
	} //}}}
	//{{{ confirm() method
	/**
	 * Utility method that can be used to ask for confirmation in a macro.
	 * @param comp The component to show the dialog on behalf of, this
	 * will usually be a view instance
	 * @param prompt The prompt string
	 * @param buttons The buttons to display - for example,
	 * JOptionPane.YES_NO_CANCEL_OPTION
	 * @since jEdit 4.0pre2
	 */
	public static int confirm(Component comp, String prompt, int buttons)
	{
		GUIUtilities.hideSplashScreen();
		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,
			JOptionPane.QUESTION_MESSAGE);
	} //}}}
	//{{{ confirm() method
	/**
	 * Utility method that can be used to ask for confirmation in a macro.
	 * @param comp The component to show the dialog on behalf of, this
	 * will usually be a view instance
	 * @param prompt The prompt string
	 * @param buttons The buttons to display - for example,
	 * JOptionPane.YES_NO_CANCEL_OPTION
	 * @param type The dialog type - for example,
	 * JOptionPane.WARNING_MESSAGE
	 */
	public static int confirm(Component comp, String prompt, int buttons, int type)
	{
		GUIUtilities.hideSplashScreen();
		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,type);
	} //}}}
	//{{{ loadMacros() method
	/**
	 * Rebuilds the macros list, and sends a MacrosChanged message
	 * (views update their Macros menu upon receiving it)
	 * @since jEdit 2.2pre4
	 */
	public static void loadMacros()
	{
		macroActionSet.removeAllActions();
		macroHierarchy.removeAllElements();
		macroHash.clear();
		// since subsequent macros with the same name are ignored,
		// load user macros first so that they override the system
		// macros.
		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			userMacroPath = MiscUtilities.constructPath(
				settings,""macros"");
			loadMacros(macroHierarchy,"""",new File(userMacroPath));
		}
		if(jEdit.getJEditHome() != null)
		{
			systemMacroPath = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""macros"");
			loadMacros(macroHierarchy,"""",new File(systemMacroPath));
		}
		EditBus.send(new DynamicMenuChanged(""macros""));
	} //}}}
	//{{{ registerHandler() method
	/**
	 * Adds a macro handler to the handlers list
	 * @since jEdit 4.0pre6
	 */
	public static void registerHandler(Handler handler)
	{
		if (getHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, Macros.class, ""Cannot register more than one macro handler with the same name"");
			return;
		}
		Log.log(Log.DEBUG,Macros.class,""Registered "" + handler.getName()
			+ "" macro handler"");
		macroHandlers.add(handler);
	} //}}}
	//{{{ getHandlers() method
	/**
	 * Returns an array containing the list of registered macro handlers
	 * @since jEdit 4.0pre6
	 */
	public static Handler[] getHandlers()
	{
		Handler[] handlers = new Handler[macroHandlers.size()];
		return (Handler[])macroHandlers.toArray(handlers);
	} //}}}
	//{{{ getHandlerForFileName() method
	/**
	 * Returns the macro handler suitable for running the specified file
	 * name, or null if there is no suitable handler.
	 * @since jEdit 4.1pre3
	 */
	public static Handler getHandlerForPathName(String pathName)
	{
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			Handler handler = (Handler)macroHandlers.get(i);
			if (handler.accept(pathName))
				return handler;
		}
		return null;
	} //}}}
	//{{{ getHandler() method
	/**
	 * Returns the macro handler with the specified name, or null if
	 * there is no registered handler with that name.
	 * @since jEdit 4.0pre6
	 */
	public static Handler getHandler(String name)
	{
		Handler handler = null;
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			handler = (Handler)macroHandlers.get(i);
			if (handler.getName().equals(name)) return handler;
		}
		return null;
	}
	//}}}
	//{{{ getMacroHierarchy() method
	/**
	 * Returns a vector hierarchy with all known macros in it.
	 * Each element of this vector is either a macro name string,
	 * or another vector. If it is a vector, the first element is a
	 * string label, the rest are again, either macro name strings
	 * or vectors.
	 * @since jEdit 2.6pre1
	 */
	public static Vector getMacroHierarchy()
	{
		return macroHierarchy;
	} //}}}
	//{{{ getMacroActionSet() method
	/**
	 * Returns an action set with all known macros in it.
	 * @since jEdit 4.0pre1
	 */
	public static ActionSet getMacroActionSet()
	{
		return macroActionSet;
	} //}}}
	//{{{ getMacro() method
	/**
	 * Returns the macro with the specified name.
	 * @param macro The macro's name
	 * @since jEdit 2.6pre1
	 */
	public static Macro getMacro(String macro)
	{
		return (Macro)macroHash.get(macro);
	} //}}}
	//{{{ Macro class
	/**
	 * Encapsulates the macro's label, name and path.
	 * @since jEdit 2.2pre4
	 */
	public static class Macro extends EditAction
	{
		//{{{ Macro constructor
		public Macro(Handler handler, String name, String label, String path)
		{
			super(name);
			this.handler = handler;
			this.label = label;
			this.path = path;
		} //}}}
		//{{{ getHandler() method
		public Handler getHandler()
		{
			return handler;
		}
		//}}}
		//{{{ getPath() method
		public String getPath()
		{
			return path;
		} //}}}
		//{{{ invoke() method
		public void invoke(View view)
		{
			if(view == null)
				handler.runMacro(null,this);
			else
			{
				Buffer buffer = view.getBuffer();
				try
				{
					buffer.beginCompoundEdit();
					handler.runMacro(view,this);
				}
				finally
				{
					buffer.endCompoundEdit();
				}
			}
		} //}}}
		//{{{ getCode() method
		public String getCode()
		{
			return ""Macros.getMacro(\"""" + getName() + ""\"").invoke(view);"";
		} //}}}
		//{{{ macroNameToLabel() method
		public static String macroNameToLabel(String macroName)
		{
			int index = macroName.lastIndexOf('/');
			return macroName.substring(index + 1).replace('_', ' ');
		}
		//}}}
		//{{{ Private members
		private Handler handler;
		private String path;
		String label;
		//}}}
	} //}}}
	//{{{ recordTemporaryMacro() method
	/**
	 * Starts recording a temporary macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void recordTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}
		Buffer buffer = jEdit.openFile(null,settings + File.separator
			+ ""macros"",""Temporary_Macro.bsh"",true,null);
		if(buffer == null)
			return;
		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.temp.header""));
		recordMacro(view,buffer,true);
	} //}}}
	//{{{ recordMacro() method
	/**
	 * Starts recording a macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void recordMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}
		String name = GUIUtilities.input(view,""record"",null);
		if(name == null)
			return;
		name = name.replace(' ','_');
		Buffer buffer = jEdit.openFile(null,null,
			MiscUtilities.constructPath(settings,""macros"",
			name + "".bsh""),true,null);
		if(buffer == null)
			return;
		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.header""));
		recordMacro(view,buffer,false);
	} //}}}
	//{{{ stopRecording() method
	/**
	 * Stops a recording currently in progress.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void stopRecording(View view)
	{
		Recorder recorder = view.getMacroRecorder();
		if(recorder == null)
			GUIUtilities.error(view,""macro-not-recording"",null);
		else
		{
			view.setMacroRecorder(null);
			if(!recorder.temporary)
				view.setBuffer(recorder.buffer);
			recorder.dispose();
		}
	} //}}}
	//{{{ runTemporaryMacro() method
	/**
	 * Runs the temporary macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void runTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",null);
			return;
		}
		String path = MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(),""macros"",
			""Temporary_Macro.bsh"");
		if(jEdit.getBuffer(path) == null)
		{
			GUIUtilities.error(view,""no-temp-macro"",null);
			return;
		}
		Handler handler = getHandler(""beanshell"");
		Macro temp = handler.createMacro(path,path);
		Buffer buffer = view.getBuffer();
		try
		{
			buffer.beginCompoundEdit();
			temp.invoke(view);
		}
		finally
		{
			/* I already wrote a comment expaining this in
			 * Macro.invoke(). */
			if(buffer.insideCompoundEdit())
				buffer.endCompoundEdit();
		}
	} //}}}
	//{{{ Private members
	//{{{ Static variables
	private static String systemMacroPath;
	private static String userMacroPath;
	private static ArrayList macroHandlers;
	private static ActionSet macroActionSet;
	private static Vector macroHierarchy;
	private static Hashtable macroHash;
	//}}}
	//{{{ Class initializer
	static
	{
		macroHandlers = new ArrayList();
		registerHandler(new BeanShellHandler());
		macroActionSet = new ActionSet(jEdit.getProperty(""action-set.macros""));
		jEdit.addActionSet(macroActionSet);
		macroHierarchy = new Vector();
		macroHash = new Hashtable();
	} //}}}
	//{{{ loadMacros() method
	private static void loadMacros(Vector vector, String path, File directory)
	{
		File[] macroFiles = directory.listFiles();
		if(macroFiles == null || macroFiles.length == 0)
			return;
		for(int i = 0; i < macroFiles.length; i++)
		{
			File file = macroFiles[i];
			String fileName = file.getName();
			if(file.isHidden())
			{
				/* do nothing! */
				continue;
			}
			else if(file.isDirectory())
			{
				String submenuName = fileName.replace('_',' ');
				Vector submenu = null;
				//{{{ try to merge with an existing menu first
				for(int j = 0; j < vector.size(); j++)
				{
					Object obj = vector.get(j);
					if(obj instanceof Vector)
					{
						Vector vec = (Vector)obj;
						if(((String)vec.get(0)).equals(submenuName))
						{
							submenu = vec;
							break;
						}
					}
				} //}}}
				if(submenu == null)
				{
					submenu = new Vector();
					submenu.addElement(submenuName);
					vector.addElement(submenu);
				}
				loadMacros(submenu,path + fileName + '/',file);
			}
			else
			{
				addMacro(file,path,vector);
			}
		}
	} //}}}
	//{{{ addMacro() method
	private static void addMacro(File file, String path, Vector vector)
	{
		String fileName = file.getName();
		Handler handler = getHandlerForPathName(file.getPath());
		if(handler == null)
			return;
		try
		{
			// in case macro file name has a space in it.
			// spaces break the view.toolBar property, for instance,
			// since it uses spaces to delimit action names.
			String macroName = (path + fileName).replace(' ','_');
			Macro newMacro = handler.createMacro(macroName,
				file.getPath());
			// ignore if already added.
			// see comment in loadMacros().
			if(macroHash.get(newMacro.getName()) != null)
				return;
			vector.addElement(newMacro.getName());
			jEdit.setTemporaryProperty(newMacro.getName()
				+ "".label"",
				newMacro.label);
			jEdit.setTemporaryProperty(newMacro.getName()
				+ "".mouse-over"",
				handler.getLabel() + "" - "" + file.getPath());
			macroActionSet.addAction(newMacro);
			macroHash.put(newMacro.getName(),newMacro);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, Macros.class, e);
			macroHandlers.remove(handler);
		}
	} //}}}
	//{{{ recordMacro() method
	/**
	 * Starts recording a macro.
	 * @param view The view
	 * @param buffer The buffer to record to
	 * @param temporary True if this is a temporary macro
	 * @since jEdit 3.0pre5
	 */
	private static void recordMacro(View view, Buffer buffer, boolean temporary)
	{
		view.setMacroRecorder(new Recorder(view,buffer,temporary));
		// setting the message to 'null' causes the status bar to check
		// if a recording is in progress
		view.getStatus().setMessage(null);
	} //}}}
	//}}}
	//{{{ Recorder class
	/**
	 * Handles macro recording.
	 */
	public static class Recorder implements EBComponent
	{
		View view;
		Buffer buffer;
		boolean temporary;
		boolean lastWasInput;
		boolean lastWasOverwrite;
		int overwriteCount;
		//{{{ Recorder constructor
		public Recorder(View view, Buffer buffer, boolean temporary)
		{
			this.view = view;
			this.buffer = buffer;
			this.temporary = temporary;
			EditBus.addToBus(this);
		} //}}}
		//{{{ record() method
		public void record(String code)
		{
			flushInput();
			append(""\n"");
			append(code);
		} //}}}
		//{{{ record() method
		public void record(int repeat, String code)
		{
			if(repeat == 1)
				record(code);
			else
			{
				record(""for(int i = 1; i <= "" + repeat + ""; i++)\n""
					+ ""{\n""
					+ code + ""\n""
					+ ""}"");
			}
		} //}}}
		//{{{ recordInput() method
		/**
		 * @since jEdit 4.2pre5
		 */
		public void recordInput(int repeat, char ch, boolean overwrite)
		{
			// record \n and \t on lines specially so that auto indent
			// can take place
			if(ch == '\n')
				record(repeat,""textArea.userInput(\'\\n\');"");
			else if(ch == '\t')
				record(repeat,""textArea.userInput(\'\\t\');"");
			else
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < repeat; i++)
					buf.append(ch);
				recordInput(buf.toString(),overwrite);
			}
		} //}}}
		//{{{ recordInput() method
		/**
		 * @since jEdit 4.2pre5
		 */
		public void recordInput(String str, boolean overwrite)
		{
			String charStr = MiscUtilities.charsToEscapes(str);
			if(overwrite)
			{
				if(lastWasOverwrite)
				{
					overwriteCount++;
					append(charStr);
				}
				else
				{
					flushInput();
					overwriteCount = 1;
					lastWasOverwrite = true;
					append(""\ntextArea.setSelectedText(\"""" + charStr);
				}
			}
			else
			{
				if(lastWasInput)
					append(charStr);
				else
				{
					flushInput();
					lastWasInput = true;
					append(""\ntextArea.setSelectedText(\"""" + charStr);
				}
			}
		} //}}}
		//{{{ handleMessage() method
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof BufferUpdate)
			{
				BufferUpdate bmsg = (BufferUpdate)msg;
				if(bmsg.getWhat() == BufferUpdate.CLOSED)
				{
					if(bmsg.getBuffer() == buffer)
						stopRecording(view);
				}
			}
		} //}}}
		//{{{ append() method
		private void append(String str)
		{
			buffer.insert(buffer.getLength(),str);
		} //}}}
		//{{{ dispose() method
		private void dispose()
		{
			flushInput();
			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				buffer.indentLine(i,true);
			}
			EditBus.removeFromBus(this);
			// setting the message to 'null' causes the status bar to
			// check if a recording is in progress
			view.getStatus().setMessage(null);
		} //}}}
		//{{{ flushInput() method
		/**
		 * We try to merge consecutive inputs. This helper method is
		 * called when something other than input is to be recorded.
		 */
		private void flushInput()
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}
			if(lastWasOverwrite)
			{
				lastWasOverwrite = false;
				append(""\"");\n"");
				append(""offset = buffer.getLineEndOffset(""
					+ ""textArea.getCaretLine()) - 1;\n"");
				append(""buffer.remove(textArea.getCaretPosition(),""
					+ ""Math.min("" + overwriteCount
					+ "",offset - ""
					+ ""textArea.getCaretPosition()));"");
			}
		} //}}}
	} //}}}
	//{{{ Handler class
	/**
	 * Encapsulates creating and invoking macros in arbitrary scripting languages
	 * @since jEdit 4.0pre6
	 */
	public static abstract class Handler
	{
		//{{{ getName() method
		public String getName()
		{
			return name;
		} //}}}
		//{{{ getLabel() method
		public String getLabel()
		{
			return label;
		} //}}}
		//{{{ accept() method
		public boolean accept(String path)
		{
			return filter.isMatch(MiscUtilities.getFileName(path));
		} //}}}
		//{{{ createMacro() method
		public abstract Macro createMacro(String macroName, String path);
		//}}}
		//{{{ runMacro() method
		/**
		 * Runs the specified macro.
		 * @param view The view - may be null.
		 * @param macro The macro.
		 */
		public abstract void runMacro(View view, Macro macro);
		//}}}
		//{{{ runMacro() method
		/**
		 * Runs the specified macro. This method is optional; it is
		 * called if the specified macro is a startup script. The
		 * default behavior is to simply call {@link #runMacro(View,Macros.Macro)}.
		 *
		 * @param view The view - may be null.
		 * @param macro The macro.
		 * @param ownNamespace  A hint indicating whenever functions and
		 * variables defined in the script are to be self-contained, or
		 * made available to other scripts. The macro handler may ignore
		 * this parameter.
		 * @since jEdit 4.1pre3
		 */
		public void runMacro(View view, Macro macro, boolean ownNamespace)
		{
			runMacro(view,macro);
		} //}}}
		//{{{ Handler constructor
		protected Handler(String name)
		{
			this.name = name;
			label = jEdit.getProperty(""macro-handler.""
				+ name + "".label"", name);
			try
			{
				filter = new RE(MiscUtilities.globToRE(
					jEdit.getProperty(
					""macro-handler."" + name + "".glob"")));
			}
			catch (Exception e)
			{
				throw new InternalError(""Missing or invalid glob for handler "" + name);
			}
		} //}}}
		//{{{ Private members
		private String name;
		private String label;
		private RE filter;
		//}}}
	} //}}}
	//{{{ BeanShellHandler class
	static class BeanShellHandler extends Handler
	{
		//{{{ BeanShellHandler constructor
		BeanShellHandler()
		{
			super(""beanshell"");
		} //}}}
		//{{{ createMacro() method
		public Macro createMacro(String macroName, String path)
		{
			// Remove '.bsh'
			macroName = macroName.substring(0, macroName.length() - 4);
			return new Macro(this, macroName,
				Macro.macroNameToLabel(macroName), path);
		} //}}}
		//{{{ runMacro() method
		public void runMacro(View view, Macro macro)
		{
			BeanShell.runScript(view,macro.getPath(),null,true);
		} //}}}
		//{{{ runMacro() method
		public void runMacro(View view, Macro macro, boolean ownNamespace)
		{
			BeanShell.runScript(view,macro.getPath(),null,ownNamespace);
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.Marker,"/*
 * Marker.java - Named location in a buffer
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.text.Position;
/**
 * Buffers may contain one or more <i>markers</i> which serve
 * as textual bookmarks.<p>
 *
 * A <code>Marker</code> has three key attributes: the
 * <code>Buffer</code> to which it relates, the line number to which
 * the marker refers, and an optional shortcut character. The shortcut
 * identifies the the key that can be pressed with the
 * <b>Markers</b>&gt;<b>Go To Marker</b> command.
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: Marker.java,v 1.6 2003/02/08 18:53:02 spestov Exp $
 */
public class Marker
{
	//{{{ getShortcut() method
	/**
	 * Returns the marker's shortcut character.
	 * @since jEdit 3.2pre1
	 */
	public char getShortcut()
	{
		return shortcut;
	} //}}}
	//{{{ getPosition() method
	/**
	 * Returns the position of this marker.
	 * @since jEdit 3.2pre1
	 */
	public int getPosition()
	{
		return (position == null ? pos : position.getOffset());
	} //}}}
	//{{{ Package-private members
	//{{{ Marker constructor
	Marker(Buffer buffer, char shortcut, int position)
	{
		this.buffer = buffer;
		this.shortcut = shortcut;
		this.pos = position;
	} //}}}
	//{{{ setShortcut() method
	/**
	 * Sets the marker's shortcut.
	 * @param shortcut The new shortcut
	 * @since jEdit 3.2pre1
	 */
	void setShortcut(char shortcut)
	{
		this.shortcut = shortcut;
	} //}}}
	//{{{ createPosition() method
	void createPosition()
	{
		position = buffer.createPosition(pos);
	} //}}}
	//{{{ removePosition() method
	void removePosition()
	{
		// forget the cached Position instance
		if(position != null)
		{
			pos = position.getOffset();
			position = null;
		}
	} //}}}
	//{{{ setPosition() method
	/**
	 * Sets the position of this marker.
	 * @since jEdit 4.0pre5
	 */
	void setPosition(int pos)
	{
		this.pos = pos;
	} //}}}
	//}}}
	//{{{ Private members
	private Buffer buffer;
	private char shortcut;
	private int pos;
	private Position position;
	//}}}
}
"
org.gjt.sp.jedit.MiscUtilities,"/*
 * MiscUtilities.java - Various miscallaneous utility functions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 * Portions copyright (C) 2000 Richard S. Hall
 * Portions copyright (C) 2001 Dirk Moebius
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.text.Segment;
import javax.swing.JMenuItem;
import java.lang.reflect.Method;
import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Path name manipulation, string manipulation, and more.<p>
 *
 * The most frequently used members of this class are:<p>
 *
 * <b>Some path name methods:</b><p>
 * <ul>
 * <li>{@link #getFileName(String)}</li>
 * <li>{@link #getParentOfPath(String)}</li>
 * <li>{@link #constructPath(String,String)}</li>
 * </ul>
 * <b>String comparison:</b><p>
 * A {@link #compareStrings(String,String,boolean)} method that unlike
 * <function>String.compareTo()</function>, correctly recognizes and handles
 * embedded numbers.<p>
 *
 * This class also defines several inner classes for use with the
 * sorting features of the Java collections API:
 *
 * <ul>
 * <li>{@link MiscUtilities.StringCompare}</li>
 * <li>{@link MiscUtilities.StringICaseCompare}</li>
 * <li>{@link MiscUtilities.MenuItemCompare}</li>
 * </ul>
 *
 * For example, you might call:<p>
 *
 * <code>Arrays.sort(myListOfStrings,
 *     new MiscUtilities.StringICaseCompare());</code>
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: MiscUtilities.java,v 1.77 2004/08/21 01:49:05 spestov Exp $
 */
public class MiscUtilities
{
	/**
	 * This encoding is not supported by Java, yet it is useful.
	 * A UTF-8 file that begins with 0xEFBBBF.
	 */
	public static final String UTF_8_Y = ""UTF-8Y"";
	//{{{ Path name methods
	//{{{ canonPath() method
	/**
	 * Returns the canonical form of the specified path name. Currently
	 * only expands a leading <code>~</code>. <b>For local path names
	 * only.</b>
	 * @param path The path name
	 * @since jEdit 4.0pre2
	 */
	public static String canonPath(String path)
	{
		if(path.length() == 0)
			return path;
		if(path.startsWith(""file://""))
			path = path.substring(""file://"".length());
		else if(path.startsWith(""file:""))
			path = path.substring(""file:"".length());
		else if(isURL(path))
			return path;
		if(File.separatorChar == '\\')
		{
			// get rid of mixed paths on Windows
			path = path.replace('/','\\');
			// also get rid of trailing spaces on Windows
			int trim = path.length();
			while(path.charAt(trim - 1) == ' ')
				trim--;
			path = path.substring(0,trim);
		}
		else if(OperatingSystem.isMacOS())
		{
			// do the same on OS X
			path = path.replace(':','/');
		}
		if(path.startsWith(""~"" + File.separator))
		{
			path = path.substring(2);
			String home = System.getProperty(""user.home"");
			if(home.endsWith(File.separator))
				return home + path;
			else
				return home + File.separator + path;
		}
		else if(path.equals(""~""))
			return System.getProperty(""user.home"");
		else
			return path;
	} //}}}
	//{{{ resolveSymlinks() method
	/**
	 * Resolves any symbolic links in the path name specified
	 * using <code>File.getCanonicalPath()</code>. <b>For local path
	 * names only.</b>
	 * @since jEdit 4.2pre1
	 */
	public static String resolveSymlinks(String path)
	{
		if(isURL(path))
			return path;
		// 2 aug 2003: OS/2 Java has a broken getCanonicalPath()
		if(OperatingSystem.isOS2())
			return path;
		// 18 nov 2003: calling this on a drive letter on Windows causes
		// drive access
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 || path.length() == 3)
			{
				if(path.charAt(1) == ':')
					return path;
			}
		}
		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(IOException io)
		{
			return path;
		}
	} //}}}
	//{{{ isAbsolutePath() method
	/**
	 * Returns if the specified path name is an absolute path or URL.
	 * @since jEdit 4.1pre11
	 */
	public static boolean isAbsolutePath(String path)
	{
		if(isURL(path))
			return true;
		else if(path.startsWith(""~/"") || path.startsWith(""~"" + File.separator) || path.equals(""~""))
			return true;
		else if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return true;
			if(path.length() > 2 && path.charAt(1) == ':'
				&& (path.charAt(2) == '\\'
				|| path.charAt(2) == '/'))
				return true;
			if(path.startsWith(""\\\\"")
				|| path.startsWith(""//""))
				return true;
		}
		// not sure if this is correct for OpenVMS.
		else if(OperatingSystem.isUnix()
			|| OperatingSystem.isVMS())
		{
			// nice and simple
			if(path.length() > 0 && path.charAt(0) == '/')
				return true;
		}
		return false;
	} //}}}
	//{{{ constructPath() method
	/**
	 * Constructs an absolute path name from a directory and another
	 * path name. This method is VFS-aware.
	 * @param parent The directory
	 * @param path The path name
	 */
	public static String constructPath(String parent, String path)
	{
		if(isAbsolutePath(path))
			return canonPath(path);
		// have to handle this case specially on windows.
		// insert \ between, eg A: and myfile.txt.
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return path;
			else if(path.length() > 2 && path.charAt(1) == ':'
				&& path.charAt(2) != '\\')
			{
				path = path.substring(0,2) + '\\'
					+ path.substring(2);
				return canonPath(path);
			}
		}
		String dd = "".."" + File.separator;
		String d = ""."" + File.separator;
		if(parent == null)
			parent = System.getProperty(""user.dir"");
		for(;;)
		{
			if(path.equals("".""))
				return parent;
			else if(path.equals(""..""))
				return getParentOfPath(parent);
			else if(path.startsWith(dd) || path.startsWith(""../""))
			{
				parent = getParentOfPath(parent);
				path = path.substring(3);
			}
			else if(path.startsWith(d) || path.startsWith(""./""))
				path = path.substring(2);
			else
				break;
		}
		if(OperatingSystem.isDOSDerived()
			&& !isURL(parent)
			&& path.startsWith(""\\""))
			parent = parent.substring(0,2);
		VFS vfs = VFSManager.getVFSForPath(parent);
		return canonPath(vfs.constructPath(parent,path));
	} //}}}
	//{{{ constructPath() method
	/**
	 * Constructs an absolute path name from three path components.
	 * This method is VFS-aware.
	 * @param parent The parent directory
	 * @param path1 The first path
	 * @param path2 The second path
	 */
	public static String constructPath(String parent,
		String path1, String path2)
	{
		return constructPath(constructPath(parent,path1),path2);
	} //}}}
	//{{{ concatPath() method
	/**
	 * Like {@link #constructPath}, except <code>path</code> will be
	 * appended to <code>parent</code> even if it is absolute.
	 * <b>For local path names only.</b>.
	 *
	 * @param path
	 * @param parent
	 */
	public static String concatPath(String parent, String path)
	{
		parent = canonPath(parent);
		path = canonPath(path);
		// Make all child paths relative.
		if (path.startsWith(File.separator))
			path = path.substring(1);
		else if ((path.length() >= 3) && (path.charAt(1) == ':'))
			path = path.replace(':', File.separatorChar);
		if (parent == null)
			parent = System.getProperty(""user.dir"");
		if (parent.endsWith(File.separator))
			return parent + path;
		else
			return parent + File.separator + path;
	} //}}}
	//{{{ getFileExtension() method
	/**
	 * Returns the extension of the specified filename, or an empty
	 * string if there is none.
	 * @param name The file name or path
	 */
	public static String getFileExtension(String name)
	{
		int fsIndex = Math.max(name.indexOf('/'),
			name.indexOf(File.separatorChar));
		int index = name.indexOf('.',fsIndex);
		if(index == -1)
			return """";
		else
			return name.substring(index);
	} //}}}
	//{{{ getFileName() method
	/**
	 * Returns the last component of the specified path.
	 * This method is VFS-aware.
	 * @param path The path name
	 */
	public static String getFileName(String path)
	{
		return VFSManager.getVFSForPath(path).getFileName(path);
	} //}}}
	//{{{ getFileNameNoExtension() method
	/**
	 * Returns the last component of the specified path name without the
	 * trailing extension (if there is one).
	 * @param path The path name
	 * @since jEdit 4.0pre8
	 */
	public static String getFileNameNoExtension(String path)
	{
		String name = getFileName(path);
		int index = name.indexOf('.');
		if(index == -1)
			return name;
		else
			return name.substring(0,index);
	} //}}}
	//{{{ getFileParent() method
	/**
	 * @deprecated Call getParentOfPath() instead
	 */
	public static String getFileParent(String path)
	{
		return getParentOfPath(path);
	} //}}}
	//{{{ getParentOfPath() method
	/**
	 * Returns the parent of the specified path. This method is VFS-aware.
	 * @param path The path name
	 * @since jEdit 2.6pre5
	 */
	public static String getParentOfPath(String path)
	{
		return VFSManager.getVFSForPath(path).getParentOfPath(path);
	} //}}}
	//{{{ getFileProtocol() method
	/**
	 * @deprecated Call getProtocolOfURL() instead
	 */
	public static String getFileProtocol(String url)
	{
		return getProtocolOfURL(url);
	} //}}}
	//{{{ getProtocolOfURL() method
	/**
	 * Returns the protocol specified by a URL.
	 * @param url The URL
	 * @since jEdit 2.6pre5
	 */
	public static String getProtocolOfURL(String url)
	{
		return url.substring(0,url.indexOf(':'));
	} //}}}
	//{{{ isURL() method
	/**
	 * Checks if the specified string is a URL.
	 * @param str The string to check
	 * @return True if the string is a URL, false otherwise
	 */
	public static boolean isURL(String str)
	{
		int fsIndex = Math.max(str.indexOf(File.separatorChar),
			str.indexOf('/'));
		if(fsIndex == 0) // /etc/passwd
			return false;
		else if(fsIndex == 2) // C:\AUTOEXEC.BAT
			return false;
		int cIndex = str.indexOf(':');
		if(cIndex <= 1) // D:\WINDOWS, or doesn't contain : at all
			return false;
		String protocol = str.substring(0,cIndex);
		VFS vfs = VFSManager.getVFSForProtocol(protocol);
		if(vfs != null && !(vfs instanceof UrlVFS))
			return true;
		try
		{
			new URL(str);
			return true;
		}
		catch(MalformedURLException mf)
		{
			return false;
		}
	} //}}}
	//{{{ saveBackup() method
	/**
	 * Saves a backup (optionally numbered) of a file.
	 * @param file A local file
	 * @param backups The number of backups. Must be >= 1. If > 1, backup
	 * files will be numbered.
	 * @param backupPrefix The backup file name prefix
	 * @param backupSuffix The backup file name suffix
	 * @param backupDirectory The directory where to save backups; if null,
	 * they will be saved in the same directory as the file itself.
	 * @since jEdit 4.0pre1
	 */
	public static void saveBackup(File file, int backups,
		String backupPrefix, String backupSuffix,
		String backupDirectory)
	{
		saveBackup(file,backups,backupPrefix,backupSuffix,backupDirectory,0);
	} //}}}
	//{{{ saveBackup() method
	/**
	 * Saves a backup (optionally numbered) of a file.
	 * @param file A local file
	 * @param backups The number of backups. Must be >= 1. If > 1, backup
	 * files will be numbered.
	 * @param backupPrefix The backup file name prefix
	 * @param backupSuffix The backup file name suffix
	 * @param backupDirectory The directory where to save backups; if null,
	 * they will be saved in the same directory as the file itself.
	 * @param backupTimeDistance The minimum time in minutes when a backup
	 * version 1 shall be moved into version 2; if 0, backups are always
	 * moved.
	 * @since jEdit 4.2pre5
	 */
	public static void saveBackup(File file, int backups,
		String backupPrefix, String backupSuffix,
		String backupDirectory, int backupTimeDistance)
	{
		if(backupPrefix == null)
			backupPrefix = """";
		if(backupSuffix == null)
			backupSuffix = """";
		String name = file.getName();
		// If backups is 1, create ~ file
		if(backups == 1)
		{
			File backupFile = new File(backupDirectory,
				backupPrefix + name + backupSuffix);
			long modTime = backupFile.lastModified();
			/* if backup file was created less than
			 * 'backupTimeDistance' ago, we do not
			 * create the backup */
			if(System.currentTimeMillis() - modTime
				>= backupTimeDistance)
			{
				backupFile.delete();
				file.renameTo(backupFile);
			}
		}
		// If backups > 1, move old ~n~ files, create ~1~ file
		else
		{
			/* delete a backup created using above method */
			new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ backups + backupSuffix).delete();
			File firstBackup = new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ ""1"" + backupSuffix);
			long modTime = firstBackup.lastModified();
			/* if backup file was created less than
			 * 'backupTimeDistance' ago, we do not
			 * create the backup */
			if(System.currentTimeMillis() - modTime
				>= backupTimeDistance)
			{
				for(int i = backups - 1; i > 0; i--)
				{
					File backup = new File(backupDirectory,
						backupPrefix + name
						+ backupSuffix + i
						+ backupSuffix);
					backup.renameTo(
						new File(backupDirectory,
						backupPrefix + name
						+ backupSuffix + (i+1)
						+ backupSuffix));
				}
				file.renameTo(new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ ""1"" + backupSuffix));
			}
		}
	} //}}}
	//{{{ fileToClass() method
	/**
	 * Converts a file name to a class name. All slash characters are
	 * replaced with periods and the trailing '.class' is removed.
	 * @param name The file name
	 */
	public static String fileToClass(String name)
	{
		char[] clsName = name.toCharArray();
		for(int i = clsName.length - 6; i >= 0; i--)
			if(clsName[i] == '/')
				clsName[i] = '.';
		return new String(clsName,0,clsName.length - 6);
	} //}}}
	//{{{ classToFile() method
	/**
	 * Converts a class name to a file name. All periods are replaced
	 * with slashes and the '.class' extension is added.
	 * @param name The class name
	 */
	public static String classToFile(String name)
	{
		return name.replace('.','/').concat("".class"");
	} //}}}
	//}}}
	//{{{ Text methods
	//{{{ getLeadingWhiteSpace() method
	/**
	 * Returns the number of leading white space characters in the
	 * specified string.
	 * @param str The string
	 */
	public static int getLeadingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(;whitespace < str.length();)
		{
			switch(str.charAt(whitespace))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} //}}}
	//{{{ getTrailingWhiteSpace() method
	/**
	 * Returns the number of trailing whitespace characters in the
	 * specified string.
	 * @param str The string
	 * @since jEdit 2.5pre5
	 */
	public static int getTrailingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(int i = str.length() - 1; i >= 0; i--)
		{
			switch(str.charAt(i))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} //}}}
	//{{{ getLeadingWhiteSpaceWidth() method
	/**
	 * Returns the width of the leading white space in the specified
	 * string.
	 * @param str The string
	 * @param tabSize The tab size
	 */
	public static int getLeadingWhiteSpaceWidth(String str, int tabSize)
	{
		int whitespace = 0;
loop:		for(int i = 0; i < str.length(); i++)
		{
			switch(str.charAt(i))
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} //}}}
	//{{{ getVirtualWidth() method
	/**
	 * Returns the virtual column number (taking tabs into account) of the
	 * specified offset in the segment.
	 *
	 * @param seg The segment
	 * @param tabSize The tab size
	 * @since jEdit 4.1pre1
	 */
	public static int getVirtualWidth(Segment seg, int tabSize)
	{
		int virtualPosition = 0;
		for (int i = 0; i < seg.count; i++)
		{
			char ch = seg.array[seg.offset + i];
			if (ch == '\t')
			{
				virtualPosition += tabSize
					- (virtualPosition % tabSize);
			}
			else
			{
				++virtualPosition;
			}
		}
		return virtualPosition;
	} //}}}
	//{{{ getOffsetOfVirtualColumn() method
	/**
	 * Returns the array offset of a virtual column number (taking tabs
	 * into account) in the segment.
	 *
	 * @param seg The segment
	 * @param tabSize The tab size
	 * @param column The virtual column number
	 * @param totalVirtualWidth If this array is non-null, the total
	 * virtual width will be stored in its first location if this method
	 * returns -1.
	 *
	 * @return -1 if the column is out of bounds
	 *
	 * @since jEdit 4.1pre1
	 */
	public static int getOffsetOfVirtualColumn(Segment seg, int tabSize,
		int column, int[] totalVirtualWidth)
	{
		int virtualPosition = 0;
		for (int i = 0; i < seg.count; i++)
		{
			char ch = seg.array[seg.offset + i];
			if (ch == '\t')
			{
				int tabWidth = tabSize
					- (virtualPosition % tabSize);
				if(virtualPosition >= column)
					return i;
				else
					virtualPosition += tabWidth;
			}
			else
			{
				if(virtualPosition >= column)
					return i;
				else
					++virtualPosition;
			}
		}
		if(totalVirtualWidth != null)
			totalVirtualWidth[0] = virtualPosition;
		return -1;
	} //}}}
	//{{{ createWhiteSpace() method
	/**
	 * Creates a string of white space with the specified length.<p>
	 *
	 * To get a whitespace string tuned to the current buffer's
	 * settings, call this method as follows:
	 *
	 * <pre>myWhitespace = MiscUtilities.createWhiteSpace(myLength,
	 *     (buffer.getBooleanProperty(""noTabs"") ? 0
	 *     : buffer.getTabSize()));</pre>
	 *
	 * @param len The length
	 * @param tabSize The tab size, or 0 if tabs are not to be used
	 */
	public static String createWhiteSpace(int len, int tabSize)
	{
		return createWhiteSpace(len,tabSize,0);
	} //}}}
	//{{{ createWhiteSpace() method
	/**
	 * Creates a string of white space with the specified length.<p>
	 *
	 * To get a whitespace string tuned to the current buffer's
	 * settings, call this method as follows:
	 *
	 * <pre>myWhitespace = MiscUtilities.createWhiteSpace(myLength,
	 *     (buffer.getBooleanProperty(""noTabs"") ? 0
	 *     : buffer.getTabSize()));</pre>
	 *
	 * @param len The length
	 * @param tabSize The tab size, or 0 if tabs are not to be used
	 * @param start The start offset, for tab alignment
	 * @since jEdit 4.2pre1
	 */
	public static String createWhiteSpace(int len, int tabSize, int start)
	{
		StringBuffer buf = new StringBuffer();
		if(tabSize == 0)
		{
			while(len-- > 0)
				buf.append(' ');
		}
		else if(len == 1)
			buf.append(' ');
		else
		{
			int count = (len + start % tabSize) / tabSize;
			if(count != 0)
				len += start;
			while(count-- > 0)
				buf.append('\t');
			count = len % tabSize;
			while(count-- > 0)
				buf.append(' ');
		}
		return buf.toString();
	} //}}}
	//{{{ globToRE() method
	/**
	 * Converts a Unix-style glob to a regular expression.<p>
	 *
	 * ? becomes ., * becomes .*, {aa,bb} becomes (aa|bb).
	 * @param glob The glob pattern
	 */
	public static String globToRE(String glob)
	{
		final Object NEG = new Object();
		final Object GROUP = new Object();
		Stack state = new Stack();
		StringBuffer buf = new StringBuffer();
		boolean backslash = false;
		for(int i = 0; i < glob.length(); i++)
		{
			char c = glob.charAt(i);
			if(backslash)
			{
				buf.append('\\');
				buf.append(c);
				backslash = false;
				continue;
			}
			switch(c)
			{
			case '\\':
				backslash = true;
				break;
			case '?':
				buf.append('.');
				break;
			case '.':
			case '+':
			case '(':
			case ')':
				buf.append('\\');
				buf.append(c);
				break;
			case '*':
				buf.append("".*"");
				break;
			case '|':
				if(backslash)
					buf.append(""\\|"");
				else
					buf.append('|');
				break;
			case '{':
				buf.append('(');
				if(i + 1 != glob.length() && glob.charAt(i + 1) == '!')
				{
					buf.append('?');
					state.push(NEG);
				}
				else
					state.push(GROUP);
				break;
			case ',':
				if(!state.isEmpty() && state.peek() == GROUP)
					buf.append('|');
				else
					buf.append(',');
				break;
			case '}':
				if(!state.isEmpty())
				{
					buf.append("")"");
					if(state.pop() == NEG)
						buf.append("".*"");
				}
				else
					buf.append('}');
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	} //}}}
	//{{{ escapesToChars() method
	/**
	 * Converts ""\n"" and ""\t"" escapes in the specified string to
	 * newlines and tabs.
	 * @param str The string
	 * @since jEdit 2.3pre1
	 */
	public static String escapesToChars(String str)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\\':
				if(i == str.length() - 1)
				{
					buf.append('\\');
					break;
				}
				c = str.charAt(++i);
				switch(c)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(c);
					break;
				}
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	} //}}}
	//{{{ charsToEscapes() method
	/**
	 * Escapes newlines, tabs, backslashes, and quotes in the specified
	 * string.
	 * @param str The string
	 * @since jEdit 2.3pre1
	 */
	public static String charsToEscapes(String str)
	{
		return charsToEscapes(str,""\n\t\\\""'"");
	} //}}}
	//{{{ charsToEscapes() method
	/**
	 * Escapes the specified characters in the specified string.
	 * @param str The string
	 * @param toEscape Any characters that require escaping
	 * @since jEdit 4.1pre3
	 */
	public static String charsToEscapes(String str, String toEscape)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			if(toEscape.indexOf(c) != -1)
			{
				if(c == '\n')
					buf.append(""\\n"");
				else if(c == '\t')
					buf.append(""\\t"");
				else
				{
					buf.append('\\');
					buf.append(c);
				}
			}
			else
				buf.append(c);
		}
		return buf.toString();
	} //}}}
	//{{{ compareVersions() method
	/**
	 * @deprecated Call <code>compareStrings()</code> instead
	 */
	public static int compareVersions(String v1, String v2)
	{
		return compareStrings(v1,v2,false);
	} //}}}
	//{{{ compareStrings() method
	/**
	 * Compares two strings.<p>
	 *
	 * Unlike <function>String.compareTo()</function>,
	 * this method correctly recognizes and handles embedded numbers.
	 * For example, it places ""My file 2"" before ""My file 10"".<p>
	 *
	 * @param str1 The first string
	 * @param str2 The second string
	 * @param ignoreCase If true, case will be ignored
	 * @return negative If str1 &lt; str2, 0 if both are the same,
	 * positive if str1 &gt; str2
	 * @since jEdit 4.0pre1
	 */
	public static int compareStrings(String str1, String str2, boolean ignoreCase)
	{
		char[] char1 = str1.toCharArray();
		char[] char2 = str2.toCharArray();
		int len = Math.min(char1.length,char2.length);
		for(int i = 0, j = 0; i < len && j < len; i++, j++)
		{
			char ch1 = char1[i];
			char ch2 = char2[j];
			if(Character.isDigit(ch1) && Character.isDigit(ch2)
				&& ch1 != '0' && ch2 != '0')
			{
				int _i = i + 1;
				int _j = j + 1;
				for(; _i < char1.length; _i++)
				{
					if(!Character.isDigit(char1[_i]))
					{
						//_i--;
						break;
					}
				}
				for(; _j < char2.length; _j++)
				{
					if(!Character.isDigit(char2[_j]))
					{
						//_j--;
						break;
					}
				}
				int len1 = _i - i;
				int len2 = _j - j;
				if(len1 > len2)
					return 1;
				else if(len1 < len2)
					return -1;
				else
				{
					for(int k = 0; k < len1; k++)
					{
						ch1 = char1[i + k];
						ch2 = char2[j + k];
						if(ch1 != ch2)
							return ch1 - ch2;
					}
				}
				i = _i - 1;
				j = _j - 1;
			}
			else
			{
				if(ignoreCase)
				{
					ch1 = Character.toLowerCase(ch1);
					ch2 = Character.toLowerCase(ch2);
				}
				if(ch1 != ch2)
					return ch1 - ch2;
			}
		}
		return char1.length - char2.length;
	} //}}}
	//{{{ stringsEqual() method
	/**
	 * @deprecated Call <code>objectsEqual()</code> instead.
	 */
	public static boolean stringsEqual(String s1, String s2)
	{
		return objectsEqual(s1,s2);
	} //}}}
	//{{{ objectsEqual() method
	/**
	 * Returns if two strings are equal. This correctly handles null pointers,
	 * as opposed to calling <code>o1.equals(o2)</code>.
	 * @since jEdit 4.2pre1
	 */
	public static boolean objectsEqual(Object o1, Object o2)
	{
		if(o1 == null)
		{
			if(o2 == null)
				return true;
			else
				return false;
		}
		else if(o2 == null)
			return false;
		else
			return o1.equals(o2);
	} //}}}
	//{{{ charsToEntities() method
	/**
	 * Converts &lt;, &gt;, &amp; in the string to their HTML entity
	 * equivalents.
	 * @param str The string
	 * @since jEdit 4.2pre1
	 */
	public static String charsToEntities(String str)
	{
		StringBuffer buf = new StringBuffer(str.length());
		for(int i = 0; i < str.length(); i++)
		{
			char ch = str.charAt(i);
			switch(ch)
			{
			case '<':
				buf.append(""&lt;"");
				break;
			case '>':
				buf.append(""&gt;"");
				break;
			case '&':
				buf.append(""&amp;"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}
		return buf.toString();
	} //}}}
	//{{{ formatFileSize() method
	public static final DecimalFormat KB_FORMAT = new DecimalFormat(""#.# KB"");
	public static final DecimalFormat MB_FORMAT = new DecimalFormat(""#.# MB"");
	/**
	 * Formats the given file size into a nice string (123 bytes, 10.6 KB,
	 * 1.2 MB).
	 * @param length The size
	 * @since jEdit 4.2pre1
	 */
	public static String formatFileSize(long length)
	{
		if(length < 1024)
			return length + "" bytes"";
		else if(length < 1024*1024)
			return KB_FORMAT.format((double)length / 1024);
		else
			return MB_FORMAT.format((double)length / 1024 / 1024);
	} //}}}
	//{{{ getLongestPrefix() method
	/**
	 * Returns the longest common prefix in the given set of strings.
	 * @param str The strings
	 * @param ignoreCase If true, case insensitive
	 * @since jEdit 4.2pre2
	 */
	public static String getLongestPrefix(List str, boolean ignoreCase)
	{
		if(str.size() == 0)
			return """";
		int prefixLength = 0;
loop:		for(;;)
		{
			String s = str.get(0).toString();
			if(prefixLength >= s.length())
				break loop;
			char ch = s.charAt(prefixLength);
			for(int i = 1; i < str.size(); i++)
			{
				s = str.get(i).toString();
				if(prefixLength >= s.length())
					break loop;
				if(!compareChars(s.charAt(prefixLength),ch,ignoreCase))
					break loop;
			}
			prefixLength++;
		}
		return str.get(0).toString().substring(0,prefixLength);
	} //}}}
	//{{{ getLongestPrefix() method
	/**
	 * Returns the longest common prefix in the given set of strings.
	 * @param str The strings
	 * @param ignoreCase If true, case insensitive
	 * @since jEdit 4.2pre2
	 */
	public static String getLongestPrefix(String[] str, boolean ignoreCase)
	{
		return getLongestPrefix((Object[])str,ignoreCase);
	} //}}}
	//{{{ getLongestPrefix() method
	/**
	 * Returns the longest common prefix in the given set of strings.
	 * @param str The strings (calls <code>toString()</code> on each object)
	 * @param ignoreCase If true, case insensitive
	 * @since jEdit 4.2pre6
	 */
	public static String getLongestPrefix(Object[] str, boolean ignoreCase)
	{
		if(str.length == 0)
			return """";
		int prefixLength = 0;
		String first = str[0].toString();
loop:		for(;;)
		{
			if(prefixLength >= first.length())
				break loop;
			char ch = first.charAt(prefixLength);
			for(int i = 1; i < str.length; i++)
			{
				String s = str[i].toString();
				if(prefixLength >= s.length())
					break loop;
				if(!compareChars(s.charAt(prefixLength),ch,ignoreCase))
					break loop;
			}
			prefixLength++;
		}
		return first.substring(0,prefixLength);
	} //}}}
	//}}}
	//{{{ Sorting methods
	//{{{ quicksort() method
	/**
	 * Sorts the specified array. Equivalent to calling
	 * <code>Arrays.sort()</code>.
	 * @param obj The array
	 * @param compare Compares the objects
	 * @since jEdit 4.0pre4
	 */
	public static void quicksort(Object[] obj, Comparator compare)
	{
		Arrays.sort(obj,compare);
	} //}}}
	//{{{ quicksort() method
	/**
	 * Sorts the specified vector.
	 * @param vector The vector
	 * @param compare Compares the objects
	 * @since jEdit 4.0pre4
	 */
	public static void quicksort(Vector vector, Comparator compare)
	{
		Collections.sort(vector,compare);
	} //}}}
	//{{{ quicksort() method
	/**
	 * Sorts the specified list.
	 * @param list The list
	 * @param compare Compares the objects
	 * @since jEdit 4.0pre4
	 */
	public static void quicksort(List list, Comparator compare)
	{
		Collections.sort(list,compare);
	} //}}}
	//{{{ quicksort() method
	/**
	 * Sorts the specified array. Equivalent to calling
	 * <code>Arrays.sort()</code>.
	 * @param obj The array
	 * @param compare Compares the objects
	 */
	public static void quicksort(Object[] obj, Compare compare)
	{
		Arrays.sort(obj,compare);
	} //}}}
	//{{{ quicksort() method
	/**
	 * Sorts the specified vector.
	 * @param vector The vector
	 * @param compare Compares the objects
	 */
	public static void quicksort(Vector vector, Compare compare)
	{
		Collections.sort(vector,compare);
	} //}}}
	//{{{ Compare interface
	/**
	 * An interface for comparing objects. This is a hold-over from
	 * they days when jEdit had its own sorting API due to JDK 1.1
	 * compatibility requirements. Use <code>java.util.Comparable</code>
	 * instead.
	 */
	public interface Compare extends Comparator
	{
		int compare(Object obj1, Object obj2);
	} //}}}
	//{{{ StringCompare class
	/**
	 * Compares strings.
	 */
	public static class StringCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),false);
		}
	} //}}}
	//{{{ StringICaseCompare class
	/**
	 * Compares strings ignoring case.
	 */
	public static class StringICaseCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),true);
		}
	} //}}}
	//{{{ MenuItemCompare class
	/**
	 * Compares menu item labels.
	 */
	public static class MenuItemCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(((JMenuItem)obj1).getText(),
				((JMenuItem)obj2).getText(),true);
		}
	} //}}}
	//}}}
	//{{{ buildToVersion() method
	/**
	 * Converts an internal version number (build) into a
	 * `human-readable' form.
	 * @param build The build
	 */
	public static String buildToVersion(String build)
	{
		if(build.length() != 11)
			return ""<unknown version: "" + build + "">"";
		// First 2 chars are the major version number
		int major = Integer.parseInt(build.substring(0,2));
		// Second 2 are the minor number
		int minor = Integer.parseInt(build.substring(3,5));
		// Then the pre-release status
		int beta = Integer.parseInt(build.substring(6,8));
		// Finally the bug fix release
		int bugfix = Integer.parseInt(build.substring(9,11));
		return major + ""."" + minor
			+ (beta != 99 ? ""pre"" + beta :
			(bugfix != 0 ? ""."" + bugfix : ""final""));
	} //}}}
	//{{{ isToolsJarAvailable() method
	/**
	 * If on JDK 1.2 or higher, make sure that tools.jar is available.
	 * This method should be called by plugins requiring the classes
	 * in this library.
	 * <p>
	 * tools.jar is searched for in the following places:
	 * <ol>
	 *   <li>the classpath that was used when jEdit was started,
	 *   <li>jEdit's jars folder in the user's home,
	 *   <li>jEdit's system jars folder,
	 *   <li><i>java.home</i>/lib/. In this case, tools.jar is added to
	 *       jEdit's list of known jars using jEdit.addPluginJAR(),
	 *       so that it gets loaded through JARClassLoader.
	 * </ol><p>
	 *
	 * On older JDK's this method does not perform any checks, and returns
	 * <code>true</code> (even though there is no tools.jar).
	 *
	 * @return <code>false</code> if and only if on JDK 1.2 and tools.jar
	 *    could not be found. In this case it prints some warnings on Log,
	 *    too, about the places where it was searched for.
	 * @since jEdit 3.2.2
	 */
	public static boolean isToolsJarAvailable()
	{
		Log.log(Log.DEBUG, MiscUtilities.class,""Searching for tools.jar..."");
		Vector paths = new Vector();
		//{{{ 1. Check whether tools.jar is in the system classpath:
		paths.addElement(""System classpath: ""
			+ System.getProperty(""java.class.path""));
		try
		{
			// Either class sun.tools.javac.Main or
			// com.sun.tools.javac.Main must be there:
			try
			{
				Class.forName(""sun.tools.javac.Main"");
			}
			catch(ClassNotFoundException e1)
			{
				Class.forName(""com.sun.tools.javac.Main"");
			}
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- is in classpath. Fine."");
			return true;
		}
		catch(ClassNotFoundException e)
		{
			//Log.log(Log.DEBUG, MiscUtilities.class,
			//	""- is not in system classpath."");
		} //}}}
		//{{{ 2. Check whether it is in the jEdit user settings jars folder:
		String settingsDir = jEdit.getSettingsDirectory();
		if(settingsDir != null)
		{
			String toolsPath = constructPath(settingsDir, ""jars"",
				""tools.jar"");
			paths.addElement(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in the user's jars folder. Fine."");
				// jEdit will load it automatically
				return true;
			}
		} //}}}
		//{{{ 3. Check whether it is in jEdit's system jars folder:
		String jEditDir = jEdit.getJEditHome();
		if(jEditDir != null)
		{
			String toolsPath = constructPath(jEditDir, ""jars"", ""tools.jar"");
			paths.addElement(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in jEdit's system jars folder. Fine."");
				// jEdit will load it automatically
				return true;
			}
		} //}}}
		//{{{ 4. Check whether it is in <java.home>/lib:
		String toolsPath = System.getProperty(""java.home"");
		if(toolsPath.toLowerCase().endsWith(File.separator + ""jre""))
			toolsPath = toolsPath.substring(0, toolsPath.length() - 4);
		toolsPath = constructPath(toolsPath, ""lib"", ""tools.jar"");
		paths.addElement(toolsPath);
		if(!(new File(toolsPath).exists()))
		{
			Log.log(Log.WARNING, MiscUtilities.class,
				""Could not find tools.jar.\n""
				+ ""I checked the following locations:\n""
				+ paths.toString());
			return false;
		} //}}}
		//{{{ Load it, if not yet done:
		PluginJAR jar = jEdit.getPluginJAR(toolsPath);
		if(jar == null)
		{
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- adding "" + toolsPath + "" to jEdit plugins."");
			jEdit.addPluginJAR(toolsPath);
		}
		else
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- has been loaded before."");
		//}}}
		return true;
	} //}}}
	//{{{ parsePermissions() method
	/**
	 * Parse a Unix-style permission string (rwxrwxrwx).
	 * @param s The string (must be 9 characters long).
	 * @since jEdit 4.1pre8
	 */
	public static int parsePermissions(String s)
	{
		int permissions = 0;
		if(s.length() == 9)
		{
			if(s.charAt(0) == 'r')
				permissions += 0400;
			if(s.charAt(1) == 'w')
				permissions += 0200;
			if(s.charAt(2) == 'x')
				permissions += 0100;
			else if(s.charAt(2) == 's')
				permissions += 04100;
			else if(s.charAt(2) == 'S')
				permissions += 04000;
			if(s.charAt(3) == 'r')
				permissions += 040;
			if(s.charAt(4) == 'w')
				permissions += 020;
			if(s.charAt(5) == 'x')
				permissions += 010;
			else if(s.charAt(5) == 's')
				permissions += 02010;
			else if(s.charAt(5) == 'S')
				permissions += 02000;
			if(s.charAt(6) == 'r')
				permissions += 04;
			if(s.charAt(7) == 'w')
				permissions += 02;
			if(s.charAt(8) == 'x')
				permissions += 01;
			else if(s.charAt(8) == 't')
				permissions += 01001;
			else if(s.charAt(8) == 'T')
				permissions += 01000;
		}
		return permissions;
	} //}}}
	//{{{ getEncodings() method
	/**
	 * Returns a list of supported character encodings.
	 * On Java 1.3, returns a fixed list.
	 * On Java 1.4, uses reflection to call an NIO API.
	 * @since jEdit 4.2pre5
	 */
	public static String[] getEncodings()
	{
		List returnValue = new ArrayList();
		if(OperatingSystem.hasJava14())
		{
			try
			{
				Class clazz = Class.forName(
					""java.nio.charset.Charset"");
				Method method = clazz.getMethod(
					""availableCharsets"",
					new Class[0]);
				Map map = (Map)method.invoke(null,
					new Object[0]);
				Iterator iter = map.keySet().iterator();
				returnValue.add(UTF_8_Y);
				while(iter.hasNext())
				{
					returnValue.add(iter.next());
				}
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,MiscUtilities.class,e);
			}
		}
		else
		{
			StringTokenizer st = new StringTokenizer(
				jEdit.getProperty(""encodings""));
			while(st.hasMoreTokens())
			{
				returnValue.add(st.nextToken());
			}
		}
		return (String[])returnValue.toArray(
			new String[returnValue.size()]);
	} //}}}
	//{{{ isSupportedEncoding() method
	/**
	 * Returns if the given character encoding is supported.
	 * Uses reflection to call a Java 1.4 API on Java 1.4, and always
	 * returns true on Java 1.3.
	 * @since jEdit 4.2pre7
	 */
	public static boolean isSupportedEncoding(String encoding)
	{
		if(OperatingSystem.hasJava14())
		{
			try
			{
				Class clazz = Class.forName(
					""java.nio.charset.Charset"");
				Method method = clazz.getMethod(
					""isSupported"",
					new Class[] { String.class });
				return ((Boolean)method.invoke(null,
					new Object[] { encoding }))
					.booleanValue();
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,MiscUtilities.class,e);
			}
		}
		return true;
	} //}}}
	//{{{ throwableToString() method
	/**
	 * Returns a string containing the stack trace of the given throwable.
	 * @since jEdit 4.2pre6
	 */
	public static String throwableToString(Throwable t)
	{
		StringWriter s = new StringWriter();
		t.printStackTrace(new PrintWriter(s));
		return s.toString();
	} //}}}
	//{{{ Private members
	private MiscUtilities() {}
	//{{{ compareChars()
	/** should this be public? */
	private static boolean compareChars(char ch1, char ch2, boolean ignoreCase)
	{
		if(ignoreCase)
			return Character.toUpperCase(ch1) == Character.toUpperCase(ch2);
		else
			return ch1 == ch2;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.Mode,"/*
 * Mode.java - jEdit editing mode
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 * Copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import gnu.regexp.*;
import java.util.Hashtable;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.util.Log;
//}}}
/**
 * An edit mode defines specific settings for editing some type of file.
 * One instance of this class is created for each supported edit mode.
 *
 * @author Slava Pestov
 * @version $Id: Mode.java,v 1.9 2003/04/28 01:35:23 spestov Exp $
 */
public class Mode
{
	//{{{ Mode constructor
	/**
	 * Creates a new edit mode.
	 *
	 * @param name The name used in mode listings and to query mode
	 * properties
	 * @see #getProperty(String)
	 */
	public Mode(String name)
	{
		this.name = name;
		props = new Hashtable();
	} //}}}
	//{{{ init() method
	/**
	 * Initializes the edit mode. Should be called after all properties
	 * are loaded and set.
	 */
	public void init()
	{
		try
		{
			String filenameGlob = (String)getProperty(""filenameGlob"");
			if(filenameGlob != null && filenameGlob.length() != 0)
			{
				filenameRE = new RE(MiscUtilities.globToRE(
					filenameGlob),RE.REG_ICASE);
			}
			String firstlineGlob = (String)getProperty(""firstlineGlob"");
			if(firstlineGlob != null && firstlineGlob.length() != 0)
			{
				firstlineRE = new RE(MiscUtilities.globToRE(
					firstlineGlob),RE.REG_ICASE);
			}
		}
		catch(REException re)
		{
			Log.log(Log.ERROR,this,""Invalid filename/firstline""
				+ "" globs in mode "" + name);
			Log.log(Log.ERROR,this,re);
		}
		// Fix for this bug:
		// -- Put a mode into the user dir with the same name as one
		//    on the system dir.
		// -- Reload edit modes.
		// -- Old mode from system dir still used for highlighting
		//    until jEdit restart.
		marker = null;
	} //}}}
	//{{{ getTokenMarker() method
	/**
	 * Returns the token marker for this mode.
	 */
	public TokenMarker getTokenMarker()
	{
		loadIfNecessary();
		return marker;
	} //}}}
	//{{{ setTokenMarker() method
	/**
	 * Sets the token marker for this mode.
	 * @param marker The new token marker
	 */
	public void setTokenMarker(TokenMarker marker)
	{
		this.marker = marker;
	} //}}}
	//{{{ loadIfNecessary() method
	/**
	 * Loads the mode from disk if it hasn't been loaded already.
	 * @since jEdit 2.5pre3
	 */
	public void loadIfNecessary()
	{
		if(marker == null)
			jEdit.loadMode(this);
	} //}}}
	//{{{ getProperty() method
	/**
	 * Returns a mode property.
	 * @param key The property name
	 *
	 * @since jEdit 2.2pre1
	 */
	public Object getProperty(String key)
	{
		String prefix = ""mode."" + name + ""."";
		//if(jEdit.getBooleanProperty(prefix + ""customSettings""))
		//{
			String property = jEdit.getProperty(prefix + key);
			if(property != null)
			{
				Object value;
				try
				{
					value = new Integer(property);
				}
				catch(NumberFormatException nf)
				{
					value = property;
				}
				return value;
			}
		//}
		Object value = props.get(key);
		if(value != null)
			return value;
		String global = jEdit.getProperty(""buffer."" + key);
		if(global != null)
		{
			try
			{
				return new Integer(global);
			}
			catch(NumberFormatException nf)
			{
				return global;
			}
		}
		else
			return null;
	} //}}}
	//{{{ getBooleanProperty() method
	/**
	 * Returns the value of a boolean property.
	 * @param key The property name
	 *
	 * @since jEdit 2.5pre3
	 */
	public boolean getBooleanProperty(String key)
	{
		Object value = getProperty(key);
		if(""true"".equals(value) || ""on"".equals(value) || ""yes"".equals(value))
			return true;
		else
			return false;
	} //}}}
	//{{{ setProperty() method
	/**
	 * Sets a mode property.
	 * @param key The property name
	 * @param value The property value
	 */
	public void setProperty(String key, Object value)
	{
		props.put(key,value);
	} //}}}
	//{{{ unsetProperty() method
	/**
	 * Unsets a mode property.
	 * @param key The property name
	 * @since jEdit 3.2pre3
	 */
	public void unsetProperty(String key)
	{
		props.remove(key);
	} //}}}
	//{{{ setProperties() method
	/**
	 * Should only be called by <code>XModeHandler</code>.
	 * @since jEdit 4.0pre3
	 */
	public void setProperties(Hashtable props)
	{
		if(props == null)
			props = new Hashtable();
		// need to carry over file name and first line globs because they are
		// not given to us by the XMode handler, but instead are filled in by
		// the catalog loader.
		String filenameGlob = (String)this.props.get(""filenameGlob"");
		String firstlineGlob = (String)this.props.get(""firstlineGlob"");
		String filename = (String)this.props.get(""file"");
		this.props = props;
		if(filenameGlob != null)
			props.put(""filenameGlob"",filenameGlob);
		if(firstlineGlob != null)
			props.put(""firstlineGlob"",firstlineGlob);
		if(filename != null)
			props.put(""file"",filename);
	} //}}}
	//{{{ accept() method
	/**
	 * Returns if the edit mode is suitable for editing the specified
	 * file. The buffer name and first line is checked against the
	 * file name and first line globs, respectively.
	 * @param fileName The buffer's name
	 * @param firstLine The first line of the buffer
	 *
	 * @since jEdit 3.2pre3
	 */
	public boolean accept(String fileName, String firstLine)
	{
		if(filenameRE != null && filenameRE.isMatch(fileName))
			return true;
		if(firstlineRE != null && firstlineRE.isMatch(firstLine))
			return true;
		return false;
	} //}}}
	//{{{ getName() method
	/**
	 * Returns the internal name of this edit mode.
	 */
	public String getName()
	{
		return name;
	} //}}}
	//{{{ toString() method
	/**
	 * Returns a string representation of this edit mode.
	 */
	public String toString()
	{
		return name;
	} //}}}
	//{{{ Private members
	private String name;
	private Hashtable props;
	private RE firstlineRE;
	private RE filenameRE;
	private TokenMarker marker;
	//}}}
}
"
org.gjt.sp.jedit.ModeCatalogHandler,"/*
 * ModeCatalogHandler.java - XML handler for mode catalog files
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import org.gjt.sp.util.Log;
class ModeCatalogHandler extends HandlerBase
{
	ModeCatalogHandler(String directory, boolean resource)
	{
		this.directory = directory;
		this.resource = resource;
	}
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""catalog.dtd"".equals(systemId))
		{
			// this will result in a slight speed up, since we
			// don't need to read the DTD anyway, as AElfred is
			// non-validating
			return new StringReader(""<!-- -->"");
			/* try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(""catalog.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" catalog.dtd:"");
				Log.log(Log.ERROR,this,e);
			} */
		}
		return null;
	}
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		if(aname == ""NAME"")
			modeName = value;
		else if(aname == ""FILE"")
		{
			if(value == null)
			{
				Log.log(Log.ERROR,this,directory + ""catalog:""
					+ "" mode "" + modeName + "" doesn't have""
					+ "" a FILE attribute"");
			}
			else
				file = value;
		}
		else if(aname == ""FILE_NAME_GLOB"")
			filenameGlob = value;
		else if(aname == ""FIRST_LINE_GLOB"")
			firstlineGlob = value;
	}
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		// older jEdit versions used a DOCTYPE of CATALOG, which
		// is incorrect since the DOCTYPE must be the name of the
		// root element, which is MODES.
		// so you the avid code reader should use MODES as the
		// DOCTYPE instead, but we still let old catalogs through
		// to avoid annoying users.
		if(""CATALOG"".equals(name) || ""MODES"".equals(name))
			return;
		Log.log(Log.ERROR,this,directory + ""catalog: DOCTYPE must be CATALOG"");
	}
	public void endElement(String name)
	{
		if(name.equals(""MODE""))
		{
			Mode mode = jEdit.getMode(modeName);
			if(mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}
			Object path;
			if(resource)
				path = jEdit.class.getResource(directory + file);
			else
				path = MiscUtilities.constructPath(directory,file);
			mode.setProperty(""file"",path);
			if(filenameGlob != null)
				mode.setProperty(""filenameGlob"",filenameGlob);
			else
				mode.unsetProperty(""filenameGlob"");
			if(firstlineGlob != null)
				mode.setProperty(""firstlineGlob"",firstlineGlob);
			else
				mode.unsetProperty(""firstlineGlob"");
			mode.init();
			modeName = file = filenameGlob = firstlineGlob = null;
		}
	}
	// end HandlerBase implementation
	// private members
	private String directory;
	private boolean resource;
	private String modeName;
	private String file;
	private String filenameGlob;
	private String firstlineGlob;
}
"
org.gjt.sp.jedit.OperatingSystem,"/*
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * OperatingSystem.java - OS detection
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.Toolkit;
import javax.swing.UIManager;
import java.io.File;
import java.util.Enumeration;
import java.util.Vector;
import org.gjt.sp.util.Log;
/**
 * Operating system detection routines.
 * @author Slava Pestov
 * @version $Id: OperatingSystem.java,v 1.16 2003/12/25 00:09:42 spestov Exp $
 * @since jEdit 4.0pre4
 */
public class OperatingSystem
{
	//{{{ getScreenBounds() method
	/**
	 * Returns the bounds of the default screen.
	 */
	public static final Rectangle getScreenBounds()
	{
		int screenX = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();
		int screenY = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();
		int x, y, w, h;
		if (isMacOS())
		{
			x = 0;
			y = 22;
			w = screenX;
			h = screenY - y - 4;//shadow size
		}
		else if (isWindows())
		{
			x = -4;
			y = -4;
			w = screenX - 2*x;
			h = screenY - 2*y;
		}
		else
		{
			x = 0;
			y = 0;
			w = screenX;
			h = screenY;
		}
		return new Rectangle(x,y,w,h);
	} //}}}
	//{{{ getScreenBounds() method
	/**
	 * Returns the bounds of the (virtual) screen that the window should be in
	 * @param window The bounds of the window to get the screen for
	 */
	public static final Rectangle getScreenBounds(Rectangle window)
	{
		GraphicsDevice[] gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();
		Vector intersects = new Vector();
		// Get available screens
		// O(n^3), this is nasty, but since we aren't dealling with
		// many items it should be fine
		for (int i=0; i < gd.length; i++)
		{
			GraphicsConfiguration gc = gd[i]
				.getDefaultConfiguration();
			// Don't add duplicates
			if (window.intersects(gc.getBounds()))
			{
				for (Enumeration e = intersects.elements(); e.hasMoreElements();)
				{
					GraphicsConfiguration gcc = (GraphicsConfiguration)e.nextElement();
					if (gcc.getBounds().equals(gc.getBounds()))
						break;
				}
				intersects.add(gc);
			}
		}
		GraphicsConfiguration choice = null;
		if (intersects.size() > 0)
		{
			// Pick screen with largest intersection
			for (Enumeration e = intersects.elements(); e.hasMoreElements();)
			{
				GraphicsConfiguration gcc = (GraphicsConfiguration)e.nextElement();
				if (choice == null)
					choice = gcc;
				else
				{
					Rectangle int1 = choice.getBounds().intersection(window);
					Rectangle int2 = gcc.getBounds().intersection(window);
					int area1 = int1.width * int1.height;
					int area2 = int2.width * int2.height;
					if (area2 > area1)
						choice = gcc;
				}
			}
		}
		else
			choice = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();
		// Make adjustments for some OS's
		int screenX = (int)choice.getBounds().x;
		int screenY = (int)choice.getBounds().y;
		int screenW = (int)choice.getBounds().width;
		int screenH = (int)choice.getBounds().height;
		int x, y, w, h;
		if (isMacOS())
		{
			x = screenX;
			y = screenY + 22;
			w = screenW;
			h = screenH - y - 4;//shadow size
		}
		else if (isWindows())
		{
			x = screenX - 4;
			y = screenY - 4;
			w = screenW - 2*x;
			h = screenH - 2*y;
		}
		else
		{
			x = screenX;
			y = screenY;
			w = screenW;
			h = screenH;
		}
		// Yay, we're finally there
		return new Rectangle(x,y,w,h);
	} //}}}
	//{{{ isDOSDerived() method
	/**
	 * Returns if we're running Windows 95/98/ME/NT/2000/XP, or OS/2.
	 */
	public static final boolean isDOSDerived()
	{
		return isWindows() || isOS2();
	} //}}}
	//{{{ isWindows() method
	/**
	 * Returns if we're running Windows 95/98/ME/NT/2000/XP.
	 */
	public static final boolean isWindows()
	{
		return os == WINDOWS_9x || os == WINDOWS_NT;
	} //}}}
	//{{{ isWindows9x() method
	/**
	 * Returns if we're running Windows 95/98/ME.
	 */
	public static final boolean isWindows9x()
	{
		return os == WINDOWS_9x;
	} //}}}
	//{{{ isWindowsNT() method
	/**
	 * Returns if we're running Windows NT/2000/XP.
	 */
	public static final boolean isWindowsNT()
	{
		return os == WINDOWS_NT;
	} //}}}
	//{{{ isOS2() method
	/**
	 * Returns if we're running OS/2.
	 */
	public static final boolean isOS2()
	{
		return os == OS2;
	} //}}}
	//{{{ isUnix() method
	/**
	 * Returns if we're running Unix (this includes MacOS X).
	 */
	public static final boolean isUnix()
	{
		return os == UNIX || os == MAC_OS_X;
	} //}}}
	//{{{ isMacOS() method
	/**
	 * Returns if we're running MacOS X.
	 */
	public static final boolean isMacOS()
	{
		return os == MAC_OS_X;
	} //}}}
	//{{{ isX11() method
	/**
	 * Returns if this OS is likely to be using X11 as the graphics
	 * system.
	 * @since jEdit 4.2pre3
	 */
	public static boolean isX11()
	{
		return os == UNIX;
	} //}}}
	//{{{ isVMS() method
	/**
	 * Returns if we're running VMS.
	 */
	public static final boolean isVMS()
	{
		return os == VMS;
	} //}}}
	//{{{ isMacOSLF() method
	/**
	* Returns if we're running MacOS X and using the native look and feel.
	*/
	public static final boolean isMacOSLF()
	{
		return (isMacOS() && UIManager.getLookAndFeel().isNativeLookAndFeel());
	} //}}}
	//{{{ hasScreenMenuBar
	/**
	 * Returns whether the screen menu bar on Mac OS X is in use.
	 * @since jEdit 4.2pre1
	*/
	public static final boolean hasScreenMenuBar()
	{
		if(!isMacOS())
			return false;
		else if(hasScreenMenuBar == -1)
		{
			String result = System.getProperty(""apple.laf.useScreenMenuBar"");
			if (result == null)
				result = System.getProperty(""com.apple.macos.useScreenMenuBar"");
			hasScreenMenuBar = (""true"".equals(result)) ? 1 : 0;
		}
		return (hasScreenMenuBar == 1);
	} //}}}
	//{{{ isJava14() method
	/**
	 * Returns if Java 2 version 1.4, or Java 2 version 1.5 is in use.
	 */
	public static final boolean hasJava14()
	{
		return java14;
	} //}}}
	//{{{ isJava15() method
	/**
	 * Returns if Java 2 version 1.5 is in use.
	 */
	public static final boolean hasJava15()
	{
		return java15;
	} //}}}
	//{{{ Private members
	private static final int UNIX = 0x31337;
	private static final int WINDOWS_9x = 0x640;
	private static final int WINDOWS_NT = 0x666;
	private static final int OS2 = 0xDEAD;
	private static final int MAC_OS_X = 0xABC;
	private static final int VMS = 0xDEAD2;
	private static final int UNKNOWN = 0xBAD;
	private static int os;
	private static boolean java14;
	private static boolean java15;
	private static int hasScreenMenuBar = -1;
	//{{{ Class initializer
	static
	{
		if(System.getProperty(""mrj.version"") != null)
		{
			os = MAC_OS_X;
		}
		else
		{
			String osName = System.getProperty(""os.name"");
			if(osName.indexOf(""Windows 9"") != -1
				|| osName.indexOf(""Windows M"") != -1)
			{
				os = WINDOWS_9x;
			}
			else if(osName.indexOf(""Windows"") != -1)
			{
				os = WINDOWS_NT;
			}
			else if(osName.indexOf(""OS/2"") != -1)
			{
				os = OS2;
			}
			else if(osName.indexOf(""VMS"") != -1)
			{
				os = VMS;
			}
			else if(File.separatorChar == '/')
			{
				os = UNIX;
			}
			else
			{
				os = UNKNOWN;
				Log.log(Log.WARNING,OperatingSystem.class,
					""Unknown operating system: "" + osName);
			}
		}
		// for debugging, make jEdit think its using a different
		// version of Java than it really is.
		String javaVersion = System.getProperty(""jedit.force.java.version"");
		if(javaVersion == null || javaVersion.equals(""""))
			javaVersion = System.getProperty(""java.version"");
		java14 = (javaVersion.compareTo(""1.4"") >= 0);
		java15 = (javaVersion.compareTo(""1.5"") >= 0);
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.OptionGroup,"/*
 * OptionGroup.java - Option pane group
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000 mike dillon
 * Portions copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.*;
import org.gjt.sp.util.Log;
/**
 * A set of option panes shown in one branch in the options dialog.<p>
 *
 * Plugins should not create instances of this class anymore. See
 * {@link EditPlugin} for information on how jEdit obtains and constructs
 * option pane instances.
 *
 * @author Mike Dillon
 * @version $Id: OptionGroup.java,v 1.10 2003/06/27 20:02:05 spestov Exp $
 */
public class OptionGroup
{
	//{{{ OptionGroup constructor
	/**
	 * Creates an option group.
	 * @param name The internal name of the option group, used to key a
	 * property <code>options.<i>name</i>.label</code> which is the
	 * label displayed in the options dialog.
	 * @see jEdit#getProperty(String)
	 */
	public OptionGroup(String name)
	{
		this.name = name;
		label = jEdit.getProperty(""options."" + name + "".label"");
		members = new Vector();
	} //}}}
	//{{{ OptionGroup constructor
	/**
	 * Creates an option group.
	 * @param label The label
	 * @param options A whitespace-separated list of option pane names
	 * @since jEdit 4.2pre2
	 */
	public OptionGroup(String name, String label, String options)
	{
		this.name = name;
		this.label = label;
		members = new Vector();
		StringTokenizer st = new StringTokenizer(options);
		while(st.hasMoreTokens())
		{
			String pane = st.nextToken();
			addOptionPane(pane);
		}
	} //}}}
	//{{{ getName() method
	public String getName()
	{
		return name;
	} //}}}
	//{{{ getLabel() method
	/**
	 * Returns the option group's human-readable label.
	 * @since jEdit 4.2pre1
	 */
	public String getLabel()
	{
		return label;
	} //}}}
	//{{{ addOptionGroup() method
	public void addOptionGroup(OptionGroup group)
	{
		insertionSort(group.getLabel(),group);
	} //}}}
	//{{{ addOptionPane() method
	public void addOptionPane(OptionPane pane)
	{
		String label = jEdit.getProperty(""options.""
			+ pane.getName() + "".label"",""NO LABEL PROPERTY: ""
			+ pane.getName());
		insertionSort(label,pane);
	} //}}}
	//{{{ addOptionPane() method
	public void addOptionPane(String pane)
	{
		String label = jEdit.getProperty(""options.""
			+ pane + "".label"",""NO LABEL PROPERTY: ""
			+ pane);
		insertionSort(label,pane);
	} //}}}
	//{{{ getMembers() method
	public Enumeration getMembers()
	{
		return members.elements();
	} //}}}
	//{{{ getMember() method
	public Object getMember(int index)
	{
		return (index >= 0 && index < members.size())
			? members.elementAt(index) : null;
	} //}}}
	//{{{ getMemberIndex() method
	public int getMemberIndex(Object member)
	{
		return members.indexOf(member);
	} //}}}
	//{{{ getMemberCount() method
	public int getMemberCount()
	{
		return members.size();
	} //}}}
	//{{{ setSort() method
	/**
	 * Sets if the members of this group should be sorted.
	 * @since jEdit 4.2pre3
	 */
	public void setSort(boolean sort)
	{
		this.sort = sort;
	} //}}}
	//{{{ Private members
	private String name;
	private String label;
	private Vector members;
	private boolean sort;
	//{{{ insertionSort() method
	private void insertionSort(String newLabel, Object newObj)
	{
		if(sort)
		{
			for(int i = 0; i < members.size(); i++)
			{
				Object obj = members.elementAt(i);
				String label;
				if(obj instanceof OptionPane)
				{
					String name = ((OptionPane)obj).getName();
					label = jEdit.getProperty(""options.""
						+ name + "".label"",""NO LABEL PROPERTY: ""
						+ name);
				}
				else if(obj instanceof String)
				{
					label = jEdit.getProperty(""options.""
						+ obj + "".label"",""NO LABEL PROPERTY: ""
						+ obj);
				}
				else if(obj instanceof OptionGroup)
					label = ((OptionGroup)obj).getLabel();
				else
					throw new InternalError();
				if(newLabel.compareTo(label) < 0)
				{
					members.insertElementAt(newObj,i);
					return;
				}
			}
		}
		members.addElement(newObj);
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.OptionPane,"/*
 * OptionPane.java - Option pane interface
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.awt.Component;
/**
 * The interface all option panes must implement.<p>
 *
 * See {@link EditPlugin} for information on how jEdit obtains and constructs
 * option pane instances.<p>
 *
 * Note that in most cases it is much easier to extend
 * {@link AbstractOptionPane} instead.
 *
 * @author Slava Pestov
 * @version $Id: OptionPane.java,v 1.6 2003/05/01 02:21:26 spestov Exp $
 */
public interface OptionPane
{
	/**
	 * Returns the internal name of this option pane. The option pane's label
	 * is set to the value of the property named
	 * <code>options.<i>name</i>.label</code>.
	 * @see jEdit#getProperty(String)
	 */
	String getName();
	/**
	 * Returns the component that should be displayed for this option pane.
	 */
	Component getComponent();
	/**
	 * This method is called every time the option pane is displayed.
	 */
	void init();
	/**
	 * Called when the options dialog's ""ok"" button is clicked.
	 * This should save any properties being edited in this option
	 * pane.
	 */
	void save();
}
"
org.gjt.sp.jedit.PerspectiveManager,"/*
 * PerspectiveManager.java - Saves view configuration
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import org.gjt.sp.util.Log;
/**
 * Manages persistence of open buffers and views across jEdit sessions.
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: PerspectiveManager.java,v 1.12 2004/08/17 06:37:36 spestov Exp $
 */
public class PerspectiveManager
{
	//{{{ isPerspectiveDirty() method
	/**
	 * We only autosave the perspective if it has changed, to avoid spinning
	 * up the disk on laptops.
	 * @since jEdit 4.2pre13
	 */
	public static boolean isPerspectiveDirty()
	{
		return dirty;
	} //}}}
	//{{{ setPerspectiveDirty() method
	/**
	 * We only autosave the perspective if it has changed, to avoid spinning
	 * up the disk on laptops.
	 * @since jEdit 4.2pre13
	 */
	public static void setPerspectiveDirty(boolean dirty)
	{
		PerspectiveManager.dirty = dirty;
	} //}}}
	//{{{ loadPerspective() method
	public static View loadPerspective(boolean restoreFiles)
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return null;
		File perspective = new File(MiscUtilities.constructPath(
			settingsDirectory,""perspective.xml""));
		if(!perspective.exists())
			return null;
		Log.log(Log.MESSAGE,PerspectiveManager.class,""Loading "" + perspective);
		PerspectiveHandler handler = new PerspectiveHandler(restoreFiles);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		Reader in = null;
		try
		{
			in = new BufferedReader(new FileReader(perspective));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,PerspectiveManager.class,perspective
				+ "":"" + line + "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,PerspectiveManager.class,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,PerspectiveManager.class,io);
			}
		}
		return handler.view;
	} //}}}
	//{{{ savePerspective() method
	public static void savePerspective(boolean autosave)
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		// backgrounded
		if(jEdit.getBufferCount() == 0)
			return;
		if(!autosave)
			Log.log(Log.MESSAGE,PerspectiveManager.class,""Saving perspective.xml"");
		File file1 = new File(MiscUtilities.constructPath(
			settingsDirectory,""#perspective.xml#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			settingsDirectory,""perspective.xml""));
		String lineSep = System.getProperty(""line.separator"");
		BufferedWriter out = null;
		try
		{
			out = new BufferedWriter(new FileWriter(file1));
			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE PERSPECTIVE SYSTEM \""perspective.dtd\"">"");
			out.write(lineSep);
			out.write(""<PERSPECTIVE>"");
			out.write(lineSep);
			Buffer[] buffers = jEdit.getBuffers();
			for(int i = 0; i < buffers.length; i++)
			{
				Buffer buffer = buffers[i];
				if(buffer.isNewFile())
					continue;
				out.write(""<BUFFER>"");
				out.write(MiscUtilities.charsToEntities(buffer.getPath()));
				out.write(""</BUFFER>"");
				out.write(lineSep);
			}
			View[] views = jEdit.getViews();
			for(int i = 0; i < views.length; i++)
			{
				View view = views[i];
				// ensures that active view is saved last,
				// ie created last on next load, ie in front
				// on next load
				if(view == jEdit.getActiveView()
					&& i != views.length - 1)
				{
					View last = views[views.length - 1];
					views[i] = last;
					views[views.length - 1] = view;
					view = last;
				}
				View.ViewConfig config = views[i].getViewConfig();
				out.write(""<VIEW PLAIN=\"""");
				out.write(config.plainView ? ""TRUE"" : ""FALSE"");
				out.write(""\"">"");
				out.write(""<PANES>"");
				out.write(lineSep);
				out.write(MiscUtilities.charsToEntities(
					config.splitConfig));
				out.write(lineSep);
				out.write(""</PANES>"");
				out.write(lineSep);
				out.write(""<GEOMETRY X=\"""");
				out.write(String.valueOf(config.x));
				out.write(""\"" Y=\"""");
				out.write(String.valueOf(config.y));
				out.write(""\"" WIDTH=\"""");
				out.write(String.valueOf(config.width));
				out.write(""\"" HEIGHT=\"""");
				out.write(String.valueOf(config.height));
				out.write(""\"" EXT_STATE=\"""");
				out.write(String.valueOf(config.extState));
				out.write(""\"" />"");
				out.write(lineSep);
				out.write(""<DOCKING LEFT=\"""");
				out.write(config.left == null ? """" : config.left);
				out.write(""\"" TOP=\"""");
				out.write(config.top == null ? """" : config.top);
				out.write(""\"" RIGHT=\"""");
				out.write(config.right == null ? """" : config.right);
				out.write(""\"" BOTTOM=\"""");
				out.write(config.bottom == null ? """" : config.bottom);
				out.write(""\"" LEFT_POS=\"""");
				out.write(String.valueOf(config.leftPos));
				out.write(""\"" TOP_POS=\"""");
				out.write(String.valueOf(config.topPos));
				out.write(""\"" RIGHT_POS=\"""");
				out.write(String.valueOf(config.rightPos));
				out.write(""\"" BOTTOM_POS=\"""");
				out.write(String.valueOf(config.bottomPos));
				out.write(""\"" />"");
				out.write(lineSep);
				out.write(""</VIEW>"");
				out.write(lineSep);
			}
			out.write(""</PERSPECTIVE>"");
			out.write(lineSep);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,PerspectiveManager.class,""Error saving "" + file1);
			Log.log(Log.ERROR,PerspectiveManager.class,io);
		}
		finally
		{
			try
			{
				if(out != null)
					out.close();
			}
			catch(IOException e)
			{
			}
		}
		file2.delete();
		file1.renameTo(file2);
	} //}}}
	private static boolean dirty;
	//{{{ PerspectiveHandler class
	static class PerspectiveHandler extends HandlerBase
	{
		View view;
		String charData;
		View.ViewConfig config;
		boolean restoreFiles;
		PerspectiveHandler(boolean restoreFiles)
		{
			this.restoreFiles = restoreFiles;
			config = new View.ViewConfig();
		}
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""perspective.dtd"".equals(systemId))
			{
				// this will result in a slight speed up, since we
				// don't need to read the DTD anyway, as AElfred is
				// non-validating
				return new StringReader(""<!-- -->"");
				/* try
				{
					return new BufferedReader(new InputStreamReader(
						getClass().getResourceAsStream(""recent.dtd"")));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,""Error while opening""
						+ "" recent.dtd:"");
					Log.log(Log.ERROR,this,e);
				} */
			}
			return null;
		}
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""PERSPECTIVE"".equals(name))
				return;
			Log.log(Log.ERROR,this,""perspective.xml: DOCTYPE must be PERSPECTIVE"");
		}
		public void attribute(String aname, String value, boolean specified)
		{
			if(!specified)
				return;
			if(aname.equals(""X""))
				config.x = Integer.parseInt(value);
			else if(aname.equals(""Y""))
				config.y = Integer.parseInt(value);
			else if(aname.equals(""WIDTH""))
				config.width = Integer.parseInt(value);
			else if(aname.equals(""HEIGHT""))
				config.height = Integer.parseInt(value);
			else if(aname.equals(""EXT_STATE""))
				config.extState = Integer.parseInt(value);
			else if(aname.equals(""PLAIN""))
				config.plainView = (""TRUE"".equals(value));
			else if(aname.equals(""TOP""))
				config.top = value;
			else if(aname.equals(""LEFT""))
				config.left = value;
			else if(aname.equals(""BOTTOM""))
				config.bottom = value;
			else if(aname.equals(""RIGHT""))
				config.right = value;
			else if(aname.equals(""TOP_POS""))
				config.topPos = Integer.parseInt(value);
			else if(aname.equals(""LEFT_POS""))
				config.leftPos = Integer.parseInt(value);
			else if(aname.equals(""BOTTOM_POS""))
				config.bottomPos = Integer.parseInt(value);
			else if(aname.equals(""RIGHT_POS""))
				config.rightPos = Integer.parseInt(value);
		}
		public void endElement(String name)
		{
			if(name.equals(""BUFFER""))
			{
				if(restoreFiles)
					jEdit.openFile(null,charData);
			}
			else if(name.equals(""PANES""))
				config.splitConfig = charData;
			else if(name.equals(""VIEW""))
			{
				view = jEdit.newView(view,null,config);
				config = new View.ViewConfig();
			}
		}
		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		}
	} //}}}
}
"
org.gjt.sp.jedit.PluginJAR,"/*
 * PluginJAR.java - Controls JAR loading and unloading
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.SwingUtilities;
import java.io.*;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.*;
import java.util.zip.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Loads and unloads plugins.<p>
 *
 * <h3>JAR file contents</h3>
 *
 * When loading a plugin, jEdit looks for the following resources:
 *
 * <ul>
 * <li>A file named <code>actions.xml</code> defining plugin actions.
 * Only one such file per plugin is allowed. See {@link ActionSet} for
 * syntax.</li>
 * <li>A file named <code>browser.actions.xml</code> defining file system
 * browser actions.
 * Only one such file per plugin is allowed. See {@link ActionSet} for
 * syntax.</li>
 * <li>A file named <code>dockables.xml</code> defining dockable windows.
 * Only one such file per plugin is allowed. See {@link
 * org.gjt.sp.jedit.gui.DockableWindowManager} for
 * syntax.</li>
 * <li>A file named <code>services.xml</code> defining additional services
 * offered by the plugin, such as virtual file systems.
 * Only one such file per plugin is allowed. See {@link
 * org.gjt.sp.jedit.ServiceManager} for
 * syntax.</li>
 * <li>File with extension <code>.props</code> containing name/value pairs
 * separated by an equals sign.
 * A plugin can supply any number of property files. Property files are used
 * to define plugin men items, plugin option panes, as well as arbitriary
 * settings and strings used by the plugin. See {@link EditPlugin} for
 * information about properties used by jEdit. See
 * <code>java.util.Properties</code> for property file syntax.</li>
 * </ul>
 *
 * For a plugin to actually do something once it is resident in memory,
 * it must contain a class whose name ends with <code>Plugin</code>.
 * This class, known as the <i>plugin core class</i> must extend
 * {@link EditPlugin} and define a few required properties, otherwise it is
 * ignored.
 *
 * <h3>Dynamic and deferred loading</h3>
 *
 * Unlike in prior jEdit versions, jEdit 4.2 and later allow
 * plugins to be added and removed to the resident set at any time using
 * the {@link jEdit#addPluginJAR(String)} and
 * {@link jEdit#removePluginJAR(PluginJAR,boolean)} methods. Furthermore, the
 *  plugin core class might not be loaded until the plugin is first used. See
 * {@link EditPlugin#start()} for a full description.
 *
 * @see org.gjt.sp.jedit.jEdit#getProperty(String)
 * @see org.gjt.sp.jedit.jEdit#getPlugin(String)
 * @see org.gjt.sp.jedit.jEdit#getPlugins()
 * @see org.gjt.sp.jedit.jEdit#getPluginJAR(String)
 * @see org.gjt.sp.jedit.jEdit#getPluginJARs()
 * @see org.gjt.sp.jedit.jEdit#addPluginJAR(String)
 * @see org.gjt.sp.jedit.jEdit#removePluginJAR(PluginJAR,boolean)
 * @see org.gjt.sp.jedit.ActionSet
 * @see org.gjt.sp.jedit.gui.DockableWindowManager
 * @see org.gjt.sp.jedit.OptionPane
 * @see org.gjt.sp.jedit.PluginJAR
 * @see org.gjt.sp.jedit.ServiceManager
 *
 * @author Slava Pestov
 * @version $Id: PluginJAR.java,v 1.47 2004/04/20 19:58:39 spestov Exp $
 * @since jEdit 4.2pre1
 */
public class PluginJAR
{
	//{{{ getPath() method
	/**
	 * Returns the full path name of this plugin's JAR file.
	 */
	public String getPath()
	{
		return path;
	} //}}}
	//{{{ getCachePath() method
	/**
	 * Returns the full path name of this plugin's summary file.
	 * The summary file is used to store certain information which allows
	 * loading of the plugin's resources and core class to be deferred
	 * until the plugin is first used. As long as a plugin is using the
	 * jEdit 4.2 plugin API, no extra effort is required to take advantage
	 * of the summary cache.
	 */
	public String getCachePath()
	{
		return cachePath;
	} //}}}
	//{{{ getFile() method
	/**
	 * Returns a file pointing to the plugin JAR.
	 */
	public File getFile()
	{
		return file;
	} //}}}
	//{{{ getClassLoader() method
	/**
	 * Returns the plugin's class loader.
	 */
	public JARClassLoader getClassLoader()
	{
		return classLoader;
	} //}}}
	//{{{ getZipFile() method
	/**
	 * Returns the plugin's JAR file, opening it if necessary.
	 * @since jEdit 4.2pre1
	 */
	public synchronized ZipFile getZipFile() throws IOException
	{
		if(zipFile == null)
		{
			Log.log(Log.DEBUG,this,""Opening "" + path);
			zipFile = new ZipFile(path);
		}
		return zipFile;
	} //}}}
	//{{{ getActions() method
	/**
	 * @deprecated Call getActionSet() instead
	 */
	public ActionSet getActions()
	{
		return getActionSet();
	} //}}}
	//{{{ getActionSet() method
	/**
	 * Returns the plugin's action set for the jEdit action context
	 * {@link jEdit#getActionContext()}. These actions are loaded from
	 * the <code>actions.xml</code> file; see {@link ActionSet}.
	 *.
	 * @since jEdit 4.2pre1
	 */
	public ActionSet getActionSet()
	{
		return actions;
	} //}}}
	//{{{ getBrowserActionSet() method
	/**
	 * Returns the plugin's action set for the file system browser action
	 * context {@link
	 * org.gjt.sp.jedit.browser.VFSBrowser#getActionContext()}.
	 * These actions are loaded from
	 * the <code>browser.actions.xml</code> file; see {@link ActionSet}.
	 *.
	 * @since jEdit 4.2pre1
	 */
	public ActionSet getBrowserActionSet()
	{
		return browserActions;
	} //}}}
	//{{{ checkDependencies() method
	/**
	 * Returns true if all dependencies are satisified, false otherwise.
	 * Also if dependencies are not satisfied, the plugin is marked as
	 * ""broken"".
	 */
	public boolean checkDependencies()
	{
		if(plugin == null)
			return true;
		int i = 0;
		boolean ok = true;
		boolean optional = false;
		String name = plugin.getClassName();
		String dep;
		while((dep = jEdit.getProperty(""plugin."" + name + "".depend."" + i++)) != null)
		{
			if(dep.startsWith(""optional ""))
			{
				optional = true;
				dep = dep.substring(""optional "".length());
			}
			int index = dep.indexOf(' ');
			if(index == -1)
			{
				Log.log(Log.ERROR,this,name + "" has an invalid""
					+ "" dependency: "" + dep);
				ok = false;
				continue;
			}
			String what = dep.substring(0,index);
			String arg = dep.substring(index + 1);
			if(what.equals(""jdk""))
			{
				if(!optional && MiscUtilities.compareStrings(
					System.getProperty(""java.version""),
					arg,false) < 0)
				{
					String[] args = { arg,
						System.getProperty(""java.version"") };
					jEdit.pluginError(path,""plugin-error.dep-jdk"",args);
					ok = false;
				}
			}
			else if(what.equals(""jedit""))
			{
				if(arg.length() != 11)
				{
					Log.log(Log.ERROR,this,""Invalid jEdit version""
						+ "" number: "" + arg);
					ok = false;
				}
				if(!optional && MiscUtilities.compareStrings(
					jEdit.getBuild(),arg,false) < 0)
				{
					String needs = MiscUtilities.buildToVersion(arg);
					String[] args = { needs,
						jEdit.getVersion() };
					jEdit.pluginError(path,
						""plugin-error.dep-jedit"",args);
					ok = false;
				}
			}
			else if(what.equals(""plugin""))
			{
				int index2 = arg.indexOf(' ');
				if(index2 == -1)
				{
					Log.log(Log.ERROR,this,name 
						+ "" has an invalid dependency: ""
						+ dep + "" (version is missing)"");
					ok = false;
					continue;
				}
				String pluginName = arg.substring(0,index2);
				String needVersion = arg.substring(index2 + 1);
				String currVersion = jEdit.getProperty(""plugin."" 
					+ pluginName + "".version"");
				EditPlugin plugin = jEdit.getPlugin(pluginName);
				if(plugin == null)
				{
					if(!optional)
					{
						String[] args = { needVersion,
							pluginName };
						jEdit.pluginError(path,
							""plugin-error.dep-plugin.no-version"",
							args);
						ok = false;
					}
				}
				else if(MiscUtilities.compareStrings(
					currVersion,needVersion,false) < 0)
				{
					if(!optional)
					{
						String[] args = { needVersion,
							pluginName, currVersion };
						jEdit.pluginError(path,
							""plugin-error.dep-plugin"",args);
						ok = false;
					}
				}
				else if(plugin instanceof EditPlugin.Broken)
				{
					if(!optional)
					{
						String[] args = { pluginName };
						jEdit.pluginError(path,
							""plugin-error.dep-plugin.broken"",args);
						ok = false;
					}
				}
				else
				{
					PluginJAR jar = plugin.getPluginJAR();
					jar.theseRequireMe.add(path);
					weRequireThese.add(jar.getPath());
				}
			}
			else if(what.equals(""class""))
			{
				if(!optional)
				{
					try
					{
						classLoader.loadClass(arg,false);
					}
					catch(Exception e)
					{
						String[] args = { arg };
						jEdit.pluginError(path,
							""plugin-error.dep-class"",args);
						ok = false;
					}
				}
			}
			else
			{
				Log.log(Log.ERROR,this,name + "" has unknown""
					+ "" dependency: "" + dep);
				ok = false;
			}
		}
		// each JAR file listed in the plugin's jars property
		// needs to know that we need them
		String jars = jEdit.getProperty(""plugin.""
			+ plugin.getClassName() + "".jars"");
		if(jars != null)
		{
			String dir = MiscUtilities.getParentOfPath(path);
			StringTokenizer st = new StringTokenizer(jars);
			while(st.hasMoreTokens())
			{
				String jarPath = MiscUtilities.constructPath(
					dir,st.nextToken());
				PluginJAR jar = jEdit.getPluginJAR(jarPath);
				if(jar == null)
				{
					String[] args = { jarPath };
					jEdit.pluginError(path,
						""plugin-error.missing-jar"",args);
					ok = false;
				}
				else
				{
					weRequireThese.add(jarPath);
					jar.theseRequireMe.add(path);
				}
			}
		}
		if(!ok)
			breakPlugin();
		return ok;
	} //}}}
	//{{{ getDependentPlugins() method
	/**
	 * Returns an array of all plugins that depend on this one.
	 * @since jEdit 4.2pre2
	 */
	public String[] getDependentPlugins()
	{
		return (String[])theseRequireMe.toArray(
			new String[theseRequireMe.size()]);
	} //}}}
	//{{{ getPlugin() method
	/**
	 * Returns the plugin core class for this JAR file. Note that if the
	 * plugin has not been activated, this will return an instance of
	 * {@link EditPlugin.Deferred}. If you need the actual plugin core
	 * class instance, call {@link #activatePlugin()} first.
	 *
	 * @since jEdit 4.2pre1
	 */
	public EditPlugin getPlugin()
	{
		return plugin;
	} //}}}
	//{{{ activatePlugin() method
	/**
	 * Loads the plugin core class. Does nothing if the plugin core class
	 * has already been loaded. This method might be called on startup,
	 * depending on what properties are set. See {@link EditPlugin#start()}.
	 * This method is thread-safe.
	 *
	 * @since jEdit 4.2pre1
	 */
	public void activatePlugin()
	{
		synchronized(this)
		{
			if(activated)
			{
				// recursive call
				return;
			}
			activated = true;
		}
		if(!(plugin instanceof EditPlugin.Deferred))
			return;
		String className = plugin.getClassName();
		try
		{
			Class clazz = classLoader.loadClass(className,false);
			int modifiers = clazz.getModifiers();
			if(Modifier.isInterface(modifiers)
				|| Modifier.isAbstract(modifiers)
				|| !EditPlugin.class.isAssignableFrom(clazz))
			{
				Log.log(Log.ERROR,this,""Plugin has properties but does not extend EditPlugin: ""
					+ className);
				breakPlugin();
				return;
			}
			plugin = (EditPlugin)clazz.newInstance();
			plugin.jar = (EditPlugin.JAR)this;
		}
		catch(Throwable t)
		{
			breakPlugin();
			Log.log(Log.ERROR,this,""Error while starting plugin "" + className);
			Log.log(Log.ERROR,this,t);
			String[] args = { t.toString() };
			jEdit.pluginError(path,""plugin-error.start-error"",args);
			return;
		}
		if(jEdit.isMainThread()
			|| SwingUtilities.isEventDispatchThread())
		{
			startPlugin();
		}
		else
		{
			// for thread safety
			startPluginLater();
		}
		EditBus.send(new PluginUpdate(this,PluginUpdate.ACTIVATED,false));
	} //}}}
	//{{{ activateIfNecessary() method
	/**
	 * Should be called after a new plugin is installed.
	 * @since jEdit 4.2pre2
	 */
	public void activatePluginIfNecessary()
	{
		if(!(plugin instanceof EditPlugin.Deferred && plugin != null))
			return;
		String className = plugin.getClassName();
		// default for plugins that don't specify this property (ie,
		// 4.1-style plugins) is to load them on startup
		String activate = jEdit.getProperty(""plugin.""
			+ className + "".activate"");
		if(activate == null)
		{
			// 4.1 plugin
			if(!jEdit.isMainThread())
			{
				breakPlugin();
				jEdit.pluginError(path,""plugin-error.not-42"",null);
			}
			else
				activatePlugin();
		}
		else
		{
			// 4.2 plugin
			// if at least one property listed here is true,
			// load the plugin
			boolean load = false;
			StringTokenizer st = new StringTokenizer(activate);
			while(st.hasMoreTokens())
			{
				String prop = st.nextToken();
				boolean value = jEdit.getBooleanProperty(prop);
				if(value)
				{
					Log.log(Log.DEBUG,this,""Activating ""
						+ className + "" because of "" + prop);
					load = true;
					break;
				}
			}
			if(load)
				activatePlugin();
		}
	} //}}}
	//{{{ deactivatePlugin() method
	/**
	 * Unloads the plugin core class. Does nothing if the plugin core class
	 * has not been loaded.
	 * This method can only be called from the AWT event dispatch thread!
	 * @see EditPlugin#stop()
	 *
	 * @since jEdit 4.2pre3
	 */
	public void deactivatePlugin(boolean exit)
	{
		if(!activated)
			return;
		if(!exit)
		{
			// buffers retain a reference to the fold handler in
			// question... and the easiest way to handle fold
			// handler unloading is this...
			Buffer buffer = jEdit.getFirstBuffer();
			while(buffer != null)
			{
				if(buffer.getFoldHandler() != null
					&& buffer.getFoldHandler().getClass()
					.getClassLoader() == classLoader)
				{
					buffer.setFoldHandler(
						new DummyFoldHandler());
				}
				buffer = buffer.getNext();
			}
		}
		if(plugin != null && !(plugin instanceof EditPlugin.Broken))
		{
			if(plugin instanceof EBPlugin)
				EditBus.removeFromBus((EBPlugin)plugin);
			try
			{
				plugin.stop();
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error while ""
					+ ""stopping plugin:"");
				Log.log(Log.ERROR,this,t);
			}
			plugin = new EditPlugin.Deferred(
				plugin.getClassName());
			plugin.jar = (EditPlugin.JAR)this;
			EditBus.send(new PluginUpdate(this,
				PluginUpdate.DEACTIVATED,exit));
			if(!exit)
			{
				// see if this is a 4.1-style plugin
				String activate = jEdit.getProperty(""plugin.""
					+ plugin.getClassName() + "".activate"");
				if(activate == null)
				{
					breakPlugin();
					jEdit.pluginError(path,""plugin-error.not-42"",null);
				}
			}
		}
		activated = false;
	} //}}}
	//{{{ getDockablesURI() method
	/**
	 * Returns the location of the plugin's
	 * <code>dockables.xml</code> file.
	 * @since jEdit 4.2pre1
	 */
	public URL getDockablesURI()
	{
		return dockablesURI;
	} //}}}
	//{{{ getServicesURI() method
	/**
	 * Returns the location of the plugin's
	 * <code>services.xml</code> file.
	 * @since jEdit 4.2pre1
	 */
	public URL getServicesURI()
	{
		return servicesURI;
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		if(plugin == null)
			return path;
		else
			return path + "",class="" + plugin.getClassName();
	} //}}}
	//{{{ Package-private members
	//{{{ Static methods
	//{{{ getPluginCache() method
	static PluginCacheEntry getPluginCache(PluginJAR plugin)
	{
		String jarCachePath = plugin.getCachePath();
		if(jarCachePath == null)
			return null;
		DataInputStream din = null;
		try
		{
			PluginCacheEntry cache = new PluginCacheEntry();
			cache.plugin = plugin;
			cache.modTime = plugin.getFile().lastModified();
			din = new DataInputStream(
				new BufferedInputStream(
				new FileInputStream(jarCachePath)));
			if(cache.read(din))
				return cache;
			else
			{
				// returns false with outdated cache
				return null;
			}
		}
		catch(FileNotFoundException fnf)
		{
			return null;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,PluginJAR.class,io);
			return null;
		}
		finally
		{
			try
			{
				if(din != null)
					din.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,PluginJAR.class,io);
			}
		}
	} //}}}
	//{{{ setPluginCache() method
	static void setPluginCache(PluginJAR plugin, PluginCacheEntry cache)
	{
		String jarCachePath = plugin.getCachePath();
		if(jarCachePath == null)
			return;
		Log.log(Log.DEBUG,PluginJAR.class,""Writing "" + jarCachePath);
		DataOutputStream dout = null;
		try
		{
			dout = new DataOutputStream(
				new BufferedOutputStream(
				new FileOutputStream(jarCachePath)));
			cache.write(dout);
			dout.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,PluginJAR.class,io);
			try
			{
				if(dout != null)
					dout.close();
			}
			catch(IOException io2)
			{
				Log.log(Log.ERROR,PluginJAR.class,io2);
			}
			new File(jarCachePath).delete();
		}
	} //}}}
	//}}}
	//{{{ PluginJAR constructor
	PluginJAR(File file)
	{
		this.path = file.getPath();
		String jarCacheDir = jEdit.getJARCacheDirectory();
		if(jarCacheDir != null)
		{
			cachePath = MiscUtilities.constructPath(
				jarCacheDir,file.getName() + "".summary"");
		}
		this.file = file;
		classLoader = new JARClassLoader(this);
		actions = new ActionSet();
	} //}}}
	//{{{ init() method
	void init()
	{
		boolean initialized = false;
		PluginCacheEntry cache = getPluginCache(this);
		if(cache != null)
		{
			loadCache(cache);
			classLoader.activate();
			initialized = true;
		}
		else
		{
			try
			{
				cache = generateCache();
				if(cache != null)
				{
					setPluginCache(this,cache);
					classLoader.activate();
					initialized = true;
				}
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,""Cannot load""
					+ "" plugin "" + path);
				Log.log(Log.ERROR,this,io);
				String[] args = { io.toString() };
				jEdit.pluginError(path,""plugin-error.load-error"",args);
				uninit(false);
			}
		}
	} //}}}
	//{{{ uninit() method
	void uninit(boolean exit)
	{
		deactivatePlugin(exit);
		if(!exit)
		{
			Iterator iter = weRequireThese.iterator();
			while(iter.hasNext())
			{
				String path = (String)iter.next();
				PluginJAR jar = jEdit.getPluginJAR(path);
				if(jar != null)
					jar.theseRequireMe.remove(this.path);
			}
			classLoader.deactivate();
			BeanShell.resetClassManager();
			if(actions != null)
				jEdit.getActionContext().removeActionSet(actions);
			if(browserActions != null)
				VFSBrowser.getActionContext().removeActionSet(browserActions);
			DockableWindowManager.unloadDockableWindows(this);
			ServiceManager.unloadServices(this);
			jEdit.removePluginProps(properties);
			try
			{
				if(zipFile != null)
				{
					zipFile.close();
					zipFile = null;
				}
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
			}
		}
	} //}}}
	//{{{ getClasses() method
	String[] getClasses()
	{
		return classes;
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private String path;
	private String cachePath;
	private File file;
	private JARClassLoader classLoader;
	private ZipFile zipFile;
	private Properties properties;
	private String[] classes;
	private ActionSet actions;
	private ActionSet browserActions;
	private EditPlugin plugin;
	private URL dockablesURI;
	private URL servicesURI;
	private boolean activated;
	private List theseRequireMe = new LinkedList();
	private List weRequireThese = new LinkedList();
	//}}}
	//{{{ actionsPresentButNotCoreClass() method
	private void actionsPresentButNotCoreClass()
	{
		Log.log(Log.WARNING,this,getPath() + "" has an actions.xml but no plugin core class"");
		actions.setLabel(""MISSING PLUGIN CORE CLASS"");
	} //}}}
	//{{{ loadCache() method
	private void loadCache(PluginCacheEntry cache)
	{
		classes = cache.classes;
		/* this should be before dockables are initialized */
		if(cache.cachedProperties != null)
		{
			properties = cache.cachedProperties;
			jEdit.addPluginProps(cache.cachedProperties);
		}
		if(cache.actionsURI != null
			&& cache.cachedActionNames != null)
		{
			actions = new ActionSet(this,
				cache.cachedActionNames,
				cache.cachedActionToggleFlags,
				cache.actionsURI);
		}
		if(cache.browserActionsURI != null
			&& cache.cachedBrowserActionNames != null)
		{
			browserActions = new ActionSet(this,
				cache.cachedBrowserActionNames,
				cache.cachedBrowserActionToggleFlags,
				cache.browserActionsURI);
			VFSBrowser.getActionContext().addActionSet(browserActions);
		}
		if(cache.dockablesURI != null
			&& cache.cachedDockableNames != null
			&& cache.cachedDockableActionFlags != null)
		{
			dockablesURI = cache.dockablesURI;
			DockableWindowManager.cacheDockableWindows(this,
				cache.cachedDockableNames,
				cache.cachedDockableActionFlags);
		}
		if(actions.size() != 0)
			jEdit.addActionSet(actions);
		if(cache.servicesURI != null
			&& cache.cachedServices != null)
		{
			servicesURI = cache.servicesURI;
			for(int i = 0; i < cache.cachedServices.length;
				i++)
			{
				ServiceManager.Descriptor d
					= cache.cachedServices[i];
				ServiceManager.registerService(d);
			}
		}
		if(cache.pluginClass != null)
		{
			// Check if a plugin with the same name
			// is already loaded
			if(jEdit.getPlugin(cache.pluginClass) != null)
			{
				jEdit.pluginError(path,
					""plugin-error.already-loaded"",
					null);
				uninit(false);
			}
			else
			{
				String label = jEdit.getProperty(
					""plugin."" + cache.pluginClass
					+ "".name"");
				actions.setLabel(jEdit.getProperty(
					""action-set.plugin"",
					new String[] { label }));
				plugin = new EditPlugin.Deferred(
					cache.pluginClass);
				plugin.jar = (EditPlugin.JAR)this;
			}
		}
		else
		{
			if(actions.size() != 0)
				actionsPresentButNotCoreClass();
		}
	} //}}}
	//{{{ generateCache() method
	private PluginCacheEntry generateCache() throws IOException
	{
		properties = new Properties();
		LinkedList classes = new LinkedList();
		ZipFile zipFile = getZipFile();
		List plugins = new LinkedList();
		PluginCacheEntry cache = new PluginCacheEntry();
		cache.modTime = file.lastModified();
		cache.cachedProperties = new Properties();
		Enumeration entries = zipFile.entries();
		while(entries.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)
				entries.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.equals(""actions.xml""))
			{
				cache.actionsURI = classLoader.getResource(name);
			}
			else if(lname.equals(""browser.actions.xml""))
			{
				cache.browserActionsURI = classLoader.getResource(name);
			}
			else if(lname.equals(""dockables.xml""))
			{
				dockablesURI = classLoader.getResource(name);
				cache.dockablesURI = dockablesURI;
			}
			else if(lname.equals(""services.xml""))
			{
				servicesURI = classLoader.getResource(name);
				cache.servicesURI = servicesURI;
			}
			else if(lname.endsWith("".props""))
			{
				InputStream in = classLoader.getResourceAsStream(name);
				properties.load(in);
				in.close();
			}
			else if(name.endsWith("".class""))
			{
				String className = MiscUtilities
					.fileToClass(name);
				if(className.endsWith(""Plugin""))
				{
					plugins.add(className);
				}
				classes.add(className);
			}
		}
		cache.cachedProperties = properties;
		jEdit.addPluginProps(properties);
		this.classes = cache.classes =
			(String[])classes.toArray(
			new String[classes.size()]);
		String label = null;
		Iterator iter = plugins.iterator();
		while(iter.hasNext())
		{
			String className = (String)iter.next();
			String _label = jEdit.getProperty(""plugin.""
				+ className + "".name"");
			String version = jEdit.getProperty(""plugin.""
				+ className + "".version"");
			if(_label == null || version == null)
			{
				Log.log(Log.WARNING,this,""Ignoring: ""
					+ className);
			}
			else
			{
				cache.pluginClass = className;
				// Check if a plugin with the same name
				// is already loaded
				if(jEdit.getPlugin(className) != null)
				{
					jEdit.pluginError(path,
						""plugin-error.already-loaded"",
						null);
					return null;
				}
				else
				{
					plugin = new EditPlugin.Deferred(
						className);
					plugin.jar = (EditPlugin.JAR)this;
					label = _label;
				}
				break;
			}
		}
		if(cache.actionsURI != null)
		{
			actions = new ActionSet(this,null,null,
				cache.actionsURI);
			actions.load();
			cache.cachedActionNames =
				actions.getCacheableActionNames();
			cache.cachedActionToggleFlags = new boolean[
				cache.cachedActionNames.length];
			for(int i = 0; i < cache.cachedActionNames.length; i++)
			{
				 cache.cachedActionToggleFlags[i]
				 	= jEdit.getBooleanProperty(
					cache.cachedActionNames[i]
					+ "".toggle"");
			}
		}
		if(cache.browserActionsURI != null)
		{
			browserActions = new ActionSet(this,null,null,
				cache.browserActionsURI);
			browserActions.load();
			VFSBrowser.getActionContext().addActionSet(browserActions);
			cache.cachedBrowserActionNames =
				browserActions.getCacheableActionNames();
			cache.cachedBrowserActionToggleFlags = new boolean[
				cache.cachedBrowserActionNames.length];
			for(int i = 0;
				i < cache.cachedBrowserActionNames.length;
				i++)
			{
				 cache.cachedBrowserActionToggleFlags[i]
				 	= jEdit.getBooleanProperty(
					cache.cachedBrowserActionNames[i]
					+ "".toggle"");
			}
		}
		if(dockablesURI != null)
		{
			DockableWindowManager.loadDockableWindows(this,
				dockablesURI,cache);
		}
		if(actions.size() != 0)
		{
			if(label != null)
			{
				actions.setLabel(jEdit.getProperty(
					""action-set.plugin"",
					new String[] { label }));
			}
			else
				actionsPresentButNotCoreClass();
			jEdit.addActionSet(actions);
		}
		if(servicesURI != null)
		{
			ServiceManager.loadServices(this,servicesURI,cache);
		}
		return cache;
	} //}}}
	//{{{ startPlugin() method
	private void startPlugin()
	{
		try
		{
			plugin.start();
		}
		catch(Throwable t)
		{
			breakPlugin();
			Log.log(Log.ERROR,PluginJAR.this,
				""Error while starting plugin "" + plugin.getClassName());
			Log.log(Log.ERROR,PluginJAR.this,t);
			String[] args = { t.toString() };
			jEdit.pluginError(path,""plugin-error.start-error"",args);
		}
		if(plugin instanceof EBPlugin)
		{
			if(jEdit.getProperty(""plugin.""
				+ plugin.getClassName() + "".activate"")
				== null)
			{
				// old plugins expected jEdit 4.1-style
				// behavior, where a PropertiesChanged
				// was sent after plugins were started
				((EBComponent)plugin).handleMessage(
					new org.gjt.sp.jedit.msg.PropertiesChanged(null));
			}
			EditBus.addToBus((EBPlugin)plugin);
		}
		// buffers retain a reference to the fold handler in
		// question... and the easiest way to handle fold
		// handler loading is this...
		Buffer buffer = jEdit.getFirstBuffer();
		while(buffer != null)
		{
			FoldHandler handler =
				FoldHandler.getFoldHandler(
				buffer.getStringProperty(""folding""));
			// == null before loaded
			if(buffer.getFoldHandler() != null
				&& handler != null
				&& handler != buffer.getFoldHandler())
			{
				buffer.setFoldHandler(handler);
			}
			buffer = buffer.getNext();
		}
	} //}}}
	//{{{ startPluginLater() method
	private void startPluginLater()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(!activated)
					return;
				startPlugin();
			}
		});
	} //}}}
	//{{{ breakPlugin() method
	private void breakPlugin()
	{
		plugin = new EditPlugin.Broken(plugin.getClassName());
		plugin.jar = (EditPlugin.JAR)this;
		// remove action sets, dockables, etc so that user doesn't
		// see the broken plugin
		uninit(false);
		// but we want properties to hang around
		jEdit.addPluginProps(properties);
	} //}}}
	//}}}
	//{{{ PluginCacheEntry class
	/**
	 * Used by the <code>DockableWindowManager</code> and
	 * <code>ServiceManager</code> to handle caching.
	 * @since jEdit 4.2pre1
	 */
	public static class PluginCacheEntry
	{
		public static final int MAGIC = 0xB7A2E420;
		//{{{ Instance variables
		public PluginJAR plugin;
		public long modTime;
		public String[] classes;
		public URL actionsURI;
		public String[] cachedActionNames;
		public boolean[] cachedActionToggleFlags;
		public URL browserActionsURI;
		public String[] cachedBrowserActionNames;
		public boolean[] cachedBrowserActionToggleFlags;
		public URL dockablesURI;
		public String[] cachedDockableNames;
		public boolean[] cachedDockableActionFlags;
		public URL servicesURI;
		public ServiceManager.Descriptor[] cachedServices;
		public Properties cachedProperties;
		public String pluginClass;
		//}}}
		/* read() and write() must be kept perfectly in sync...
		 * its a very simple file format. doing it this way is
		 * faster than serializing since serialization calls
		 * reflection, etc. */
		//{{{ read() method
		public boolean read(DataInputStream din) throws IOException
		{
			int cacheMagic = din.readInt();
			if(cacheMagic != MAGIC)
				return false;
			String cacheBuild = readString(din);
			if(!cacheBuild.equals(jEdit.getBuild()))
				return false;
			long cacheModTime = din.readLong();
			if(cacheModTime != modTime)
				return false;
			actionsURI = readURI(din);
			cachedActionNames = readStringArray(din);
			cachedActionToggleFlags = readBooleanArray(din);
			browserActionsURI = readURI(din);
			cachedBrowserActionNames = readStringArray(din);
			cachedBrowserActionToggleFlags = readBooleanArray(din);
			dockablesURI = readURI(din);
			cachedDockableNames = readStringArray(din);
			cachedDockableActionFlags = readBooleanArray(din);
			servicesURI = readURI(din);
			int len = din.readInt();
			if(len == 0)
				cachedServices = null;
			else
			{
				cachedServices = new ServiceManager.Descriptor[len];
				for(int i = 0; i < len; i++)
				{
					ServiceManager.Descriptor d = new
						ServiceManager.Descriptor(
						readString(din),
						readString(din),
						null,
						plugin);
					cachedServices[i] = d;
				}
			}
			classes = readStringArray(din);
			cachedProperties = readMap(din);
			pluginClass = readString(din);
			return true;
		} //}}}
		//{{{ write() method
		public void write(DataOutputStream dout) throws IOException
		{
			dout.writeInt(MAGIC);
			writeString(dout,jEdit.getBuild());
			dout.writeLong(modTime);
			writeString(dout,actionsURI);
			writeStringArray(dout,cachedActionNames);
			writeBooleanArray(dout,cachedActionToggleFlags);
			writeString(dout,browserActionsURI);
			writeStringArray(dout,cachedBrowserActionNames);
			writeBooleanArray(dout,cachedBrowserActionToggleFlags);
			writeString(dout,dockablesURI);
			writeStringArray(dout,cachedDockableNames);
			writeBooleanArray(dout,cachedDockableActionFlags);
			writeString(dout,servicesURI);
			if(cachedServices == null)
				dout.writeInt(0);
			else
			{
				dout.writeInt(cachedServices.length);
				for(int i = 0; i < cachedServices.length; i++)
				{
					writeString(dout,cachedServices[i].clazz);
					writeString(dout,cachedServices[i].name);
				}
			}
			writeStringArray(dout,classes);
			writeMap(dout,cachedProperties);
			writeString(dout,pluginClass);
		} //}}}
		//{{{ Private members
		//{{{ readString() method
		private String readString(DataInputStream din)
			throws IOException
		{
			int len = din.readInt();
			if(len == 0)
				return null;
			char[] str = new char[len];
			for(int i = 0; i < len; i++)
				str[i] = din.readChar();
			return new String(str);
		} //}}}
		//{{{ readURI() method
		private URL readURI(DataInputStream din)
			throws IOException
		{
			String str = readString(din);
			if(str == null)
				return null;
			else
				return new URL(str);
		} //}}}
		//{{{ readStringArray() method
		private String[] readStringArray(DataInputStream din)
			throws IOException
		{
			int len = din.readInt();
			if(len == 0)
				return null;
			String[] str = new String[len];
			for(int i = 0; i < len; i++)
			{
				str[i] = readString(din);
			}
			return str;
		} //}}}
		//{{{ readBooleanArray() method
		private boolean[] readBooleanArray(DataInputStream din)
			throws IOException
		{
			int len = din.readInt();
			if(len == 0)
				return null;
			boolean[] bools = new boolean[len];
			for(int i = 0; i < len; i++)
			{
				bools[i] = din.readBoolean();
			}
			return bools;
		} //}}}
		//{{{ readMap() method
		private Properties readMap(DataInputStream din)
			throws IOException
		{
			Properties returnValue = new Properties();
			int count = din.readInt();
			for(int i = 0; i < count; i++)
			{
				String key = readString(din);
				String value = readString(din);
				if(value == null)
					value = """";
				returnValue.put(key,value);
			}
			return returnValue;
		} //}}}
		//{{{ writeString() method
		private void writeString(DataOutputStream dout,
			Object obj) throws IOException
		{
			if(obj == null)
			{
				dout.writeInt(0);
			}
			else
			{
				String str = obj.toString();
				dout.writeInt(str.length());
				dout.writeChars(str);
			}
		} //}}}
		//{{{ writeStringArray() method
		private void writeStringArray(DataOutputStream dout,
			String[] str) throws IOException
		{
			if(str == null)
			{
				dout.writeInt(0);
			}
			else
			{
				dout.writeInt(str.length);
				for(int i = 0; i < str.length; i++)
				{
					writeString(dout,str[i]);
				}
			}
		} //}}}
		//{{{ writeBooleanArray() method
		private void writeBooleanArray(DataOutputStream dout,
			boolean[] bools) throws IOException
		{
			if(bools == null)
			{
				dout.writeInt(0);
			}
			else
			{
				dout.writeInt(bools.length);
				for(int i = 0; i < bools.length; i++)
				{
					dout.writeBoolean(bools[i]);
				}
			}
		} //}}}
		//{{{ writeMap() method
		private void writeMap(DataOutputStream dout, Map map)
			throws IOException
		{
			dout.writeInt(map.size());
			Iterator iter = map.keySet().iterator();
			while(iter.hasNext())
			{
				String key = (String)iter.next();
				writeString(dout,key);
				writeString(dout,map.get(key));
			}
		} //}}}
		//}}}
	} //}}}
}
"
org.gjt.sp.jedit.PropertyManager,"/*
 * PropertyManager.java - Manages property files
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.io.*;
import java.util.*;
class PropertyManager
{
	//{{{ getProperties() method
	Properties getProperties()
	{
		Properties total = new Properties();
		total.putAll(system);
		Iterator iter = plugins.iterator();
		while(iter.hasNext())
			total.putAll((Properties)iter.next());
		total.putAll(site);
		total.putAll(user);
		return total;
	} //}}}
	//{{{ loadSystemProps() method
	void loadSystemProps(InputStream in)
		throws IOException
	{
		loadProps(system,in);
	} //}}}
	//{{{ loadSiteProps() method
	void loadSiteProps(InputStream in)
		throws IOException
	{
		loadProps(site,in);
	} //}}}
	//{{{ loadUserProps() method
	void loadUserProps(InputStream in)
		throws IOException
	{
		loadProps(user,in);
	} //}}}
	//{{{ saveUserProps() method
	void saveUserProps(OutputStream out)
		throws IOException
	{
		user.store(out,""jEdit properties"");
		out.close();
	} //}}}
	//{{{ loadPluginProps() method
	Properties loadPluginProps(InputStream in)
		throws IOException
	{
		Properties plugin = new Properties();
		loadProps(plugin,in);
		plugins.add(plugin);
		return plugin;
	} //}}}
	//{{{ addPluginProps() method
	void addPluginProps(Properties props)
	{
		plugins.add(props);
	} //}}}
	//{{{ removePluginProps() method
	void removePluginProps(Properties props)
	{
		plugins.remove(props);
	} //}}}
	//{{{ getProperty() method
	String getProperty(String name)
	{
		String value = user.getProperty(name);
		if(value != null)
			return value;
		else
			return getDefaultProperty(name);
	} //}}}
	//{{{ setProperty() method
	void setProperty(String name, String value)
	{
		String prop = getDefaultProperty(name);
		/* if value is null:
		 * - if default is null, unset user prop
		 * - else set user prop to """"
		 * else
		 * - if default equals value, ignore
		 * - if default doesn't equal value, set user
		 */
		if(value == null)
		{
			if(prop == null || prop.length() == 0)
				user.remove(name);
			else
				user.put(name,"""");
		}
		else
		{
			if(value.equals(prop))
				user.remove(name);
			else
				user.put(name,value);
		}
	} //}}}
	//{{{ setTemporaryProperty() method
	public void setTemporaryProperty(String name, String value)
	{
		user.remove(name);
		system.put(name,value);
	} //}}}
	//{{{ unsetProperty() method
	void unsetProperty(String name)
	{
		if(getDefaultProperty(name) != null)
			user.put(name,"""");
		else
			user.remove(name);
	} //}}}
	//{{{ resetProperty() method
	public void resetProperty(String name)
	{
		user.remove(name);
	} //}}}
	//{{{ Private members
	private Properties system = new Properties();
	private List plugins = new LinkedList();
	private Properties site = new Properties();
	private Properties user = new Properties();
	//{{{ getDefaultProperty() method
	private String getDefaultProperty(String name)
	{
		String value = site.getProperty(name);
		if(value != null)
			return value;
		Iterator iter = plugins.iterator();
		while(iter.hasNext())
		{
			value = ((Properties)iter.next()).getProperty(name);
			if(value != null)
				return value;
		}
		return system.getProperty(name);
	} //}}}
	//{{{ loadProps() method
	private void loadProps(Properties into, InputStream in)
		throws IOException
	{
		try
		{
			into.load(in);
		}
		finally
		{
			in.close();
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.Registers,"/*
 * Registers.java - Register manager
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import com.microstar.xml.*;
import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * jEdit's registers are an extension of the clipboard metaphor.<p>
 *
 * A {@link Registers.Register} is string of text indexed by a
 * single character. Typically the text is taken from selected buffer text
 * and the index character is a keyboard character selected by the user.<p>
 *
 * This class defines a number of static methods
 * that give each register the properties of a virtual clipboard.<p>
 *
 * Two classes implement the {@link Registers.Register} interface. A
 * {@link Registers.ClipboardRegister} is tied to the contents of the
 * system clipboard. jEdit assigns a
 * {@link Registers.ClipboardRegister} to the register indexed under
 * the character <code>$</code>. A
 * {@link Registers.StringRegister} is created for registers assigned
 * by the user. In addition, jEdit assigns <code>%</code> to
 * the last text segment selected in the text area. On Windows this is a
 * {@link Registers.StringRegister}, on Unix under Java 2 version 1.4, a
 * {@link Registers.ClipboardRegister}.
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: Registers.java,v 1.21 2004/05/29 01:55:24 spestov Exp $
 */
public class Registers
{
	//{{{ copy() method
	/**
	 * Copies the text selected in the text area into the specified register.
	 * This will replace the existing contents of the designated register.
	 *
	 * @param textArea The text area
	 * @param register The register
	 * @since jEdit 2.7pre2
	 */
	public static void copy(JEditTextArea textArea, char register)
	{
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;
		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);
	} //}}}
	//{{{ cut() method
	/**
	 * Copies the text selected in the text area into the specified
	 * register, and then removes it from the buffer.
	 *
	 * @param textArea The text area
	 * @param register The register
	 * @since jEdit 2.7pre2
	 */
	public static void cut(JEditTextArea textArea, char register)
	{
		if(textArea.isEditable())
		{
			String selection = textArea.getSelectedText();
			if(selection == null)
				return;
			setRegister(register,selection);
			HistoryModel.getModel(""clipboard"").addItem(selection);
			textArea.setSelectedText("""");
		}
		else
			textArea.getToolkit().beep();
	} //}}}
	//{{{ append() method
	/**
	 * Appends the text selected in the text area to the specified register,
	 * with a newline between the old and new text.
	 * @param textArea The text area
	 * @param register The register
	 */
	public static void append(JEditTextArea textArea, char register)
	{
		append(textArea,register,""\n"",false);
	} //}}}
	//{{{ append() method
	/**
	 * Appends the text selected in the text area to the specified register.
	 * @param textArea The text area
	 * @param register The register
	 * @param separator The separator to insert between the old and new text
	 */
	public static void append(JEditTextArea textArea, char register,
		String separator)
	{
		append(textArea,register,separator,false);
	} //}}}
	//{{{ append() method
	/**
	 * Appends the text selected in the  text area to the specified register.
	 * @param textArea The text area
	 * @param register The register
	 * @param separator The text to insert between the old and new text
	 * @param cut Should the current selection be removed?
	 * @since jEdit 3.2pre1
	 */
	public static void append(JEditTextArea textArea, char register,
		String separator, boolean cut)
	{
		if(cut && !textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;
		Register reg = getRegister(register);
		if(reg != null)
		{
			String registerContents = reg.toString();
			if(registerContents != null)
			{
				if(registerContents.endsWith(separator))
					selection = registerContents + selection;
				else
					selection = registerContents + separator + selection;
			}
		}
		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);
		if(cut)
			textArea.setSelectedText("""");
	} //}}}
	//{{{ paste() method
	/**
	 * Insets the contents of the specified register into the text area.
	 * @param textArea The text area
	 * @param register The register
	 * @since jEdit 2.7pre2
	 */
	public static void paste(JEditTextArea textArea, char register)
	{
		paste(textArea,register,false);
	} //}}}
	//{{{ paste() method
	/**
	 * Inserts the contents of the specified register into the text area.
	 * @param textArea The text area
	 * @param register The register
	 * @param vertical Vertical (columnar) paste
	 * @since jEdit 4.1pre1
	 */
	public static void paste(JEditTextArea textArea, char register,
		boolean vertical)
	{
		if(!textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}
		Register reg = getRegister(register);
		if(reg == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		else
		{
			String selection = reg.toString();
			if(selection == null)
			{
				textArea.getToolkit().beep();
				return;
			}
			if(vertical && textArea.getSelectionCount() == 0)
			{
				Buffer buffer = textArea.getBuffer();
				try
				{
					buffer.beginCompoundEdit();
					int caret = textArea.getCaretPosition();
					int caretLine = textArea.getCaretLine();
					Selection.Rect rect = new Selection.Rect(
						caretLine,caret,caretLine,caret);
					textArea.setSelectedText(rect,selection);
					caretLine = textArea.getCaretLine();
					if(caretLine != textArea.getLineCount() - 1)
					{
						int startColumn = rect.getStartColumn(
							buffer);
						int offset = buffer
							.getOffsetOfVirtualColumn(
							caretLine + 1,startColumn,null);
						if(offset == -1)
						{
							buffer.insertAtColumn(caretLine + 1,startColumn,"""");
							textArea.setCaretPosition(
								buffer.getLineEndOffset(
								caretLine + 1) - 1);
						}
						else
						{
							textArea.setCaretPosition(
								buffer.getLineStartOffset(
								caretLine + 1) + offset);
						}
					}
				}
				finally
				{
					buffer.endCompoundEdit();
				}
			}
			else
				textArea.setSelectedText(selection);
			HistoryModel.getModel(""clipboard"").addItem(selection);
		}
	} //}}}
	//{{{ getRegister() method
	/**
	 * Returns the specified register.
	 * @param name The name
	 */
	public static Register getRegister(char name)
	{
		if(name != '$' && name != '%')
		{
			if(!loaded)
				loadRegisters();
		}
		if(registers == null || name >= registers.length)
			return null;
		else
			return registers[name];
	} //}}}
	//{{{ setRegister() method
	/**
	 * Sets the specified register.
	 * @param name The name
	 * @param newRegister The new value
	 */
	public static void setRegister(char name, Register newRegister)
	{
		if(name != '%' && name != '$')
		{
			if(!loaded)
				loadRegisters();
			if(!loading)
				modified = true;
		}
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
		}
		registers[name] = newRegister;
	} //}}}
	//{{{ setRegister() method
	/**
	 * Sets the specified register.
	 * @param name The name
	 * @param value The new value
	 */
	public static void setRegister(char name, String value)
	{
		Register register = getRegister(name);
		if(register != null)
			register.setValue(value);
		else
			setRegister(name,new StringRegister(value));
	} //}}}
	//{{{ clearRegister() method
	/**
	 * Sets the value of the specified register to <code>null</code>.
	 * @param name The register name
	 */
	public static void clearRegister(char name)
	{
		if(name >= registers.length)
			return;
		Register register = registers[name];
		if(name == '$' || name == '%')
			register.setValue("""");
		else
			registers[name] = null;
	} //}}}
	//{{{ getRegisters() method
	/**
	 * Returns an array of all available registers. Some of the elements
	 * of this array might be <code>null</code>.
	 */
	public static Register[] getRegisters()
	{
		if(!loaded)
			loadRegisters();
		return registers;
	} //}}}
	//{{{ getRegisterStatusPrompt() method
	/**
	 * Returns the status prompt for the given register action. Only
	 * intended to be called from <code>actions.xml</code>.
	 * @since jEdit 4.2pre2
	 */
	public static String getRegisterStatusPrompt(String action)
	{
		return jEdit.getProperty(""view.status."" + action,
			new String[] { getRegisterNameString() });
	} //}}}
	//{{{ getRegisterNameString() method
	/**
	 * Returns a string of all defined registers, used by the status bar
	 * (eg, ""a b $ % ^"").
	 * @since jEdit 4.2pre2
	 */
	public static String getRegisterNameString()
	{
		if(!loaded)
			loadRegisters();
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < registers.length; i++)
		{
			if(registers[i] != null)
			{
				if(buf.length() != 0)
					buf.append(' ');
				buf.append((char)i);
			}
		}
		if(buf.length() == 0)
			return jEdit.getProperty(""view.status.no-registers"");
		else
			return buf.toString();
	} //}}}
	//{{{ saveRegisters() method
	public static void saveRegisters()
	{
		if(!loaded || !modified)
			return;
		Log.log(Log.MESSAGE,Registers.class,""Saving registers.xml"");
		File file1 = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(), ""#registers.xml#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(), ""registers.xml""));
		if(file2.exists() && file2.lastModified() != registersModTime)
		{
			Log.log(Log.WARNING,Registers.class,file2 + "" changed""
				+ "" on disk; will not save registers"");
			return;
		}
		jEdit.backupSettingsFile(file2);
		String lineSep = System.getProperty(""line.separator"");
		BufferedWriter out = null;
		boolean ok = false;
		try
		{
			out = new BufferedWriter(new FileWriter(file1));
			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE REGISTERS SYSTEM \""registers.dtd\"">"");
			out.write(lineSep);
			out.write(""<REGISTERS>"");
			out.write(lineSep);
			Register[] registers = getRegisters();
			for(int i = 0; i < registers.length; i++)
			{
				Register register = registers[i];
				if(register == null || i == '$' || i == '%')
					continue;
				out.write(""<REGISTER NAME=\"""");
				if(i == '""')
					out.write(""&quot;"");
				else
					out.write((char)i);
				out.write(""\"">"");
				out.write(MiscUtilities.charsToEntities(
					register.toString()));
				out.write(""</REGISTER>"");
				out.write(lineSep);
			}
			out.write(""</REGISTERS>"");
			out.write(lineSep);
			ok = true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,Registers.class,e);
		}
		finally
		{
			try
			{
				if(out != null)
					out.close();
			}
			catch(IOException e)
			{
			}
		}
		if(ok)
		{
			/* to avoid data loss, only do this if the above
			 * completed successfully */
			file2.delete();
			file1.renameTo(file2);
		}
		registersModTime = file2.lastModified();
		modified = false;
	} //}}}
	//{{{ Private members
	private static Register[] registers;
	private static long registersModTime;
	private static boolean loaded, loading, modified;
	private Registers() {}
	static
	{
		registers = new Register[256];
		registers['$'] = new ClipboardRegister(Toolkit
			.getDefaultToolkit().getSystemClipboard());
	}
	//{{{ loadRegisters() method
	private static void loadRegisters()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		File registerFile = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(),""registers.xml""));
		if(!registerFile.exists())
			return;
		registersModTime = registerFile.lastModified();
		loaded = true;
		Log.log(Log.MESSAGE,jEdit.class,""Loading registers.xml"");
		RegistersHandler handler = new RegistersHandler();
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		Reader in = null;
		try
		{
			loading = true;
			in = new BufferedReader(new FileReader(registerFile));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,Registers.class,registerFile + "":""
				+ line + "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
			//Log.log(Log.DEBUG,Registers.class,fnf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,Registers.class,e);
		}
		finally
		{
			loading = false;
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,Registers.class,io);
			}
		}
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ Register interface
	/**
	 * A register.
	 */
	public interface Register
	{
		/**
		 * Converts to a string.
		 */
		String toString();
		/**
		 * Sets the register contents.
		 */
		void setValue(String value);
	} //}}}
	//{{{ ClipboardRegister class
	/**
	 * A clipboard register. Register ""$"" should always be an
	 * instance of this.
	 */
	public static class ClipboardRegister implements Register
	{
		Clipboard clipboard;
		public ClipboardRegister(Clipboard clipboard)
		{
			this.clipboard = clipboard;
		}
		/**
		 * Sets the clipboard contents.
		 */
		public void setValue(String value)
		{
			StringSelection selection = new StringSelection(value);
			clipboard.setContents(selection,null);
		}
		/**
		 * Returns the clipboard contents.
		 */
		public String toString()
		{
			try
			{
				String selection = (String)(clipboard
					.getContents(this).getTransferData(
					DataFlavor.stringFlavor));
				boolean trailingEOL = (selection.endsWith(""\n"")
					|| selection.endsWith(System.getProperty(
					""line.separator"")));
				// Some Java versions return the clipboard
				// contents using the native line separator,
				// so have to convert it here
				BufferedReader in = new BufferedReader(
					new StringReader(selection));
				StringBuffer buf = new StringBuffer();
				String line;
				while((line = in.readLine()) != null)
				{
					// broken Eclipse workaround!
					// 24 Febuary 2004
					if(line.endsWith(""\0""))
					{
						line = line.substring(0,
							line.length() - 1);
					}
					buf.append(line);
					buf.append('\n');
				}
				// remove trailing \n
				if(!trailingEOL && buf.length() != 0)
					buf.setLength(buf.length() - 1);
				return buf.toString();
			}
			catch(Exception e)
			{
				Log.log(Log.NOTICE,this,e);
				return null;
			}
		}
	} //}}}
	//{{{ StringRegister class
	/**
	 * Register that stores a string.
	 */
	public static class StringRegister implements Register
	{
		private String value;
		/**
		 * Creates a new string register.
		 * @param value The contents
		 */
		public StringRegister(String value)
		{
			this.value = value;
		}
		/**
		 * Sets the register contents.
		 */
		public void setValue(String value)
		{
			this.value = value;
		}
		/**
		 * Converts to a string.
		 */
		public String toString()
		{
			return value;
		}
		/**
		 * Called when this register is no longer available. This
		 * implementation does nothing.
		 */
		public void dispose() {}
	} //}}}
	//{{{ RegistersHandler class
	static class RegistersHandler extends HandlerBase
	{
		//{{{ resolveEntity() method
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""registers.dtd"".equals(systemId))
			{
				// this will result in a slight speed up, since we
				// don't need to read the DTD anyway, as AElfred is
				// non-validating
				return new StringReader(""<!-- -->"");
				/* try
				{
					return new BufferedReader(new InputStreamReader(
						getClass().getResourceAsStream(""registers.dtd"")));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,""Error while opening""
						+ "" recent.dtd:"");
					Log.log(Log.ERROR,this,e);
				} */
			}
			return null;
		} //}}}
		//{{{ attribute() method
		public void attribute(String aname, String value, boolean isSpecified)
		{
			if(aname.equals(""NAME""))
				registerName = value;
		} //}}}
		//{{{ doctypeDecl() method
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""REGISTERS"".equals(name))
				return;
			Log.log(Log.ERROR,this,""registers.xml: DOCTYPE must be REGISTERS"");
		} //}}}
		//{{{ endElement() method
		public void endElement(String name)
		{
			if(name.equals(""REGISTER""))
			{
				if(registerName == null || registerName.length() != 1)
					Log.log(Log.ERROR,this,""Malformed NAME: "" + registerName);
				else
					setRegister(registerName.charAt(0),charData);
			}
		} //}}}
		//{{{ charData() method
		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		} //}}}
		//{{{ Private members
		private String registerName;
		private String charData;
		//}}}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.ServiceListHandler,"/*
 * ServiceManager.java - Handles services.xml files in plugins
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: ServiceListHandler.java,v 1.3 2003/04/30 21:22:37 spestov Exp $
 */
class ServiceListHandler extends HandlerBase
{
	//{{{ ServiceListHandler constructor
	ServiceListHandler(PluginJAR plugin, URL uri)
	{
		this.plugin = plugin;
		this.uri = uri;
		stateStack = new Stack();
		cachedServices = new LinkedList();
	} //}}}
	//{{{ resolveEntity() method
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""services.dtd"".equals(systemId))
		{
			// this will result in a slight speed up, since we
			// don't need to read the DTD anyway, as AElfred is
			// non-validating
			return new StringReader(""<!-- -->"");
			/* try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream
					(""/org/gjt/sp/jedit/services.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" dockables.dtd:"");
				Log.log(Log.ERROR,this,e);
			} */
		}
		return null;
	} //}}}
	//{{{ attribute() method
	public void attribute(String aname, String value, boolean isSpecified)
	{
		if(aname.equals(""NAME""))
			serviceName = value;
		else if(aname.equals(""CLASS""))
			serviceClass = value;
	} //}}}
	//{{{ doctypeDecl() method
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""SERVICES"".equals(name))
			return;
		Log.log(Log.ERROR,this,uri + "": DOCTYPE must be SERVICES"");
	} //}}}
	//{{{ charData() method
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if (tag == ""SERVICE"")
		{
			code = text;
		}
	} //}}}
	//{{{ startElement() method
	public void startElement(String tag)
	{
		tag = pushElement(tag);
	} //}}}
	//{{{ endElement() method
	public void endElement(String name)
	{
		if(name == null)
			return;
		String tag = peekElement();
		if(name.equals(tag))
		{
			if(tag == ""SERVICE"")
			{
				ServiceManager.Descriptor d =
					new ServiceManager.Descriptor(
					serviceClass,serviceName,code,plugin);
				ServiceManager.registerService(d);
				cachedServices.add(d);
			}
			popElement();
		}
		else
		{
			// can't happen
			throw new InternalError();
		}
	} //}}}
	//{{{ startDocument() method
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	} //}}}
	//{{{ getCachedServices() method
	public ServiceManager.Descriptor[] getCachedServices()
	{
		return (ServiceManager.Descriptor[])cachedServices.toArray(
			new ServiceManager.Descriptor[cachedServices.size()]);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private PluginJAR plugin;
	private URL uri;
	private String serviceName;
	private String serviceClass;
	private String code;
	private Stack stateStack;
	private List cachedServices;
	//}}}
	//{{{ pushElement() method
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	} //}}}
	//{{{ peekElement() method
	private String peekElement()
	{
		return (String) stateStack.peek();
	} //}}}
	//{{{ popElement() method
	private String popElement()
	{
		return (String) stateStack.pop();
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.ServiceManager,"/*
 * ServiceManager.java - Handles services.xml files in plugins
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.*;
import org.gjt.sp.util.Log;
/**
 * A generic way for plugins to provide various API extensions.<p>
 * 
 * Services are loaded from files named <code>services.xml</code> inside the
 * plugin JAR. A service definition file has the following form:
 *
 * <pre>&lt;?xml version=""1.0""?&gt;
 *&lt;!DOCTYPE SERVICES SYSTEM ""services.dtd""&gt;
 *&lt;SERVICES&gt;
 *    &lt;SERVICE NAME=""service name"" CLASS=""fully qualified class name""&gt;
 *        // BeanShell code evaluated when the sevice is first activated
 *    &lt;/SERVICE&gt;
 *&lt;/SERVICES&gt;</pre>
 *
 * The following elements are valid:
 *
 * <ul>
 * <li>
 * <code>SERVICES</code> is the top-level element and refers
 * to the set of services offered by the plugin.
 * </li>
 * <li>
 * A <code>SERVICE</code> contains the data for a particular service
 * activation.
 * It has two attributes, both required: <code>NAME</code> and
 * <code>CLASS</code>. The <code>CLASS</code> attribute must be the name of
 * a known sevice type; see below.
 * </li>
 * <li>
 * A <code>SERVICE</code> element should the BeanShell code that returns a
 * new instance of the named class. Note that this code can return
 * <code>null</code>.
 * </li>
 * </ul>
 *
 * The jEdit core defines the following service types:
 * <ul>
 * <li>{@link org.gjt.sp.jedit.buffer.FoldHandler}</li>
 * <li>{@link org.gjt.sp.jedit.io.VFS}</li>
 * </ul>
 *
 * Plugins may provide more.<p>
 *
 * To have your plugin accept services, no extra steps are needed other than
 * a piece of code somewhere that calls {@link #getServiceNames(String)} and
 * {@link #getService(String,String)}.
 *
 * @see BeanShell
 * @see PluginJAR
 *
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: ServiceManager.java,v 1.8 2004/03/28 00:07:26 spestov Exp $
 */
public class ServiceManager
{
	//{{{ loadServices() method
	/**
	 * Loads a <code>services.xml</code> file.
	 * @since jEdit 4.2pre1
	 */
	public static void loadServices(PluginJAR plugin, URL uri,
		PluginJAR.PluginCacheEntry cache)
	{
		Reader in = null;
		try
		{
			Log.log(Log.DEBUG,jEdit.class,""Loading services from "" + uri);
			ServiceListHandler dh = new ServiceListHandler(plugin,uri);
			XmlParser parser = new XmlParser();
			parser.setHandler(dh);
			in = new BufferedReader(
				new InputStreamReader(
				uri.openStream()));
			parser.parse(null, null, in);
			if(cache != null)
				cache.cachedServices = dh.getCachedServices();
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,ServiceManager.class,uri + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,ServiceManager.class,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,ServiceManager.class,io);
			}
		}
	} //}}}
	//{{{ unloadServices() method
	/**
	 * Removes all services belonging to the specified plugin.
	 * @param plugin The plugin
	 * @since jEdit 4.2pre1
	 */
	public static void unloadServices(PluginJAR plugin)
	{
		Iterator descriptors = serviceMap.keySet().iterator();
		while(descriptors.hasNext())
		{
			Descriptor d = (Descriptor)descriptors.next();
			if(d.plugin == plugin)
				descriptors.remove();
		}
	} //}}}
	//{{{ registerService() method
	/**
	 * Registers a service. Plugins should provide a 
	 * <code>services.xml</code> file instead of calling this directly.
	 *
	 * @param clazz The service class
	 * @param name The service name
	 * @param code BeanShell code to create an instance of this
	 * @param plugin The plugin JAR, or null if this is a built-in service
	 *
	 * @since jEdit 4.2pre1
	 */
	public static void registerService(String clazz, String name,
		String code, PluginJAR plugin)
	{
		Descriptor d = new Descriptor(clazz,name,code,plugin);
		serviceMap.put(d,d);
	} //}}}
	//{{{ unregisterService() method
	/**
	 * Unregisters a service.
	 *
	 * @param clazz The service class
	 * @param name The service name
	 *
	 * @since jEdit 4.2pre1
	 */
	public static void unregisterService(String clazz, String name)
	{
		Descriptor d = new Descriptor(clazz,name);
		serviceMap.remove(d);
	} //}}}
	//{{{ getServiceTypes() method
	/**
	 * Returns all known service class types.
	 *
	 * @since jEdit 4.2pre1
	 */
	public static String[] getServiceTypes()
	{
		HashSet returnValue = new HashSet();
		Iterator descriptors = serviceMap.keySet().iterator();
		while(descriptors.hasNext())
		{
			Descriptor d = (Descriptor)descriptors.next();
			returnValue.add(d.clazz);
		}
		return (String[])returnValue.toArray(
			new String[returnValue.size()]);
	} //}}}
	//{{{ getServiceNames() method
	/**
	 * Returns the names of all registered services with the given
	 * class. For example, calling this with a parameter of
	 * ""org.gjt.sp.jedit.io.VFS"" returns all known virtual file
	 * systems.
	 *
	 * @param clazz The class name
	 * @since jEdit 4.2pre1
	 */
	public static String[] getServiceNames(String clazz)
	{
		ArrayList returnValue = new ArrayList();
		Iterator descriptors = serviceMap.keySet().iterator();
		while(descriptors.hasNext())
		{
			Descriptor d = (Descriptor)descriptors.next();
			if(d.clazz.equals(clazz))
				returnValue.add(d.name);
		}
		return (String[])returnValue.toArray(
			new String[returnValue.size()]);
	} //}}}
	//{{{ getService() method
	/**
	 * Returns an instance of the given service. The first time this is
	 * called for a given service, the BeanShell code is evaluated. The
	 * result is cached for future invocations, so in effect services are
	 * singletons.
	 *
	 * @param clazz The service class
	 * @param name The service name
	 * @since jEdit 4.2pre1
	 */
	public static Object getService(String clazz, String name)
	{
		// they never taught you this in undergrad computer science
		Descriptor key = new Descriptor(clazz,name);
		Descriptor value = (Descriptor)serviceMap.get(key);
		if(value == null)
		{
			// unknown service - <clazz,name> not in table
			return null;
		}
		else
		{
			if(value.code == null)
			{
				loadServices(value.plugin,
					value.plugin.getServicesURI(),
					null);
				value = (Descriptor)serviceMap.get(key);
			}
			return value.getInstance();
		}
	} //}}}
	//{{{ Package-private members
	//{{{ registerService() method
	/**
	 * Registers a service.
	 *
	 * @since jEdit 4.2pre1
	 */
	static void registerService(Descriptor d)
	{
		serviceMap.put(d,d);
	} //}}}
	//}}}
	//{{{ Private members
	private static Map serviceMap = new HashMap();
	//}}}
	//{{{ Descriptor class
	static class Descriptor
	{
		String clazz;
		String name;
		String code;
		PluginJAR plugin;
		Object instance;
		boolean instanceIsNull;
		// this constructor keys the hash table
		Descriptor(String clazz, String name)
		{
			this.clazz = clazz;
			this.name  = name;
		}
		// this constructor is the value of the hash table
		Descriptor(String clazz, String name, String code,
			PluginJAR plugin)
		{
			this.clazz  = clazz;
			this.name   = name;
			this.code   = code;
			this.plugin = plugin;
		}
		Object getInstance()
		{
			if(instanceIsNull)
				return null;
			else if(instance == null)
			{
				// lazy instantiation
				instance = BeanShell.eval(null,
					BeanShell.getNameSpace(),
					code);
				if(instance == null)
				{
					// avoid re-running script if it gives
					// us null
					instanceIsNull = true;
				}
			}
			return instance;
		}
		public int hashCode()
		{
			return name.hashCode();
		}
		public boolean equals(Object o)
		{
			if(o instanceof Descriptor)
			{
				Descriptor d = (Descriptor)o;
				return d.clazz.equals(clazz)
					&& d.name.equals(name);
			}
			else
				return false;
		}
	} //}}}
}
"
org.gjt.sp.jedit.SettingsReloader,"/*
 * SettingsReloader.java - Utility class reloads macros and modes when necessary
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import java.io.File;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.search.*;
//}}}
class SettingsReloader implements EBComponent
{
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof VFSUpdate)
		{
			VFSUpdate vmsg = (VFSUpdate)msg;
			maybeReload(vmsg.getPath());
		}
	} //}}}
	//{{{ maybeReload() method
	private void maybeReload(String path)
	{
		String jEditHome = jEdit.getJEditHome();
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(!MiscUtilities.isURL(path))
			path = MiscUtilities.resolveSymlinks(path);
		// On Windows and MacOS, path names are case insensitive
		if((VFSManager.getVFSForPath(path).getCapabilities()
			& VFS.CASE_INSENSITIVE_CAP) != 0)
		{
			path = path.toLowerCase();
			jEditHome = jEditHome.toLowerCase();
			settingsDirectory = settingsDirectory.toLowerCase();
		}
		// XXX: does this really belong here?
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		if(fileset instanceof DirectoryListSet)
		{
			DirectoryListSet dirset = (DirectoryListSet)fileset;
			String dir = MiscUtilities.resolveSymlinks(
				dirset.getDirectory());
			if(path.startsWith(dir))
				dirset.invalidateCachedList();
		}
		if(jEditHome != null && path.startsWith(jEditHome))
			path = path.substring(jEditHome.length());
		else if(settingsDirectory != null && path.startsWith(settingsDirectory))
			path = path.substring(settingsDirectory.length());
		else
		{
			// not in settings directory or jEdit home directory.
			// no need to reload anything.
			return;
		}
		if(path.startsWith(File.separator) || path.startsWith(""/""))
			path = path.substring(1);
		if(path.startsWith(""macros""))
			Macros.loadMacros();
		else if(path.startsWith(""modes"") && (path.endsWith("".xml"")
			|| path.endsWith(""catalog"")))
			jEdit.reloadModes();
	} //}}}
}
"
org.gjt.sp.jedit.TextUtilities,"/*
 * TextUtilities.java - Various text functions
 * Copyright (C) 1998, 2003 Slava Pestov
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.syntax.*;
//}}}
/**
 * Contains several text manipulation methods.
 *
 * <ul>
 * <li>Bracket matching
 * <li>Word start and end offset calculation
 * <li>String comparison
 * <li>Converting tabs to spaces and vice versa
 * <li>Wrapping text
 * <li>String case conversion
 * </ul>
 *
 * @author Slava Pestov
 * @version $Id: TextUtilities.java,v 1.47 2004/03/28 00:07:26 spestov Exp $
 */
public class TextUtilities
{
	// to avoid slowdown with large files; only scan 10000 lines either way
	public static final int BRACKET_MATCH_LIMIT = 10000;
	//{{{ getTokenAtOffset() method
	/**
	 * Returns the token that contains the specified offset.
	 * @param tokens The token list
	 * @param offset The offset
	 * @since jEdit 4.0pre3
	 */
	public static Token getTokenAtOffset(Token tokens, int offset)
	{
		if(offset == 0 && tokens.id == Token.END)
			return tokens;
		for(;;)
		{
			if(tokens.id == Token.END)
				throw new ArrayIndexOutOfBoundsException(""offset > line length"");
			if(tokens.offset + tokens.length > offset)
				return tokens;
			else
				tokens = tokens.next;
		}
	} //}}}
	//{{{ findMatchingBracket() method
	/**
	 * Returns the offset of the bracket matching the one at the
	 * specified offset of the buffer, or -1 if the bracket is
	 * unmatched (or if the character is not a bracket).
	 * @param buffer The buffer
	 * @param line The line
	 * @param offset The offset within that line
	 * @since jEdit 2.6pre1
	 */
	public static int findMatchingBracket(Buffer buffer, int line, int offset)
	{
		if(offset < 0 || offset >= buffer.getLineLength(line))
		{
			throw new ArrayIndexOutOfBoundsException(offset + "":""
				+ buffer.getLineLength(line));
		}
		Segment lineText = new Segment();
		buffer.getLineText(line,lineText);
		char c = lineText.array[lineText.offset + offset];
		char cprime; // corresponding character
		boolean direction; // false - backwards, true - forwards
		switch(c)
		{
		case '(': cprime = ')'; direction = true;  break;
		case ')': cprime = '('; direction = false; break;
		case '[': cprime = ']'; direction = true;  break;
		case ']': cprime = '['; direction = false; break;
		case '{': cprime = '}'; direction = true;  break;
		case '}': cprime = '{'; direction = false; break;
		default: return -1;
		}
		// 1 because we've already 'seen' the first bracket
		int count = 1;
		DefaultTokenHandler tokenHandler = new DefaultTokenHandler();
		buffer.markTokens(line,tokenHandler);
		// Get the syntax token at 'offset'
		// only tokens with the same type will be checked for
		// the corresponding bracket
		byte idOfBracket = getTokenAtOffset(tokenHandler.getTokens(),offset).id;
		boolean haveTokens = true;
		int startLine = line;
		//{{{ Forward search
		if(direction)
		{
			offset++;
			for(;;)
			{
				for(int i = offset; i < lineText.count; i++)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}
				//{{{ Go on to next line
				line++;
				if(line >= buffer.getLineCount() || (line - startLine) > BRACKET_MATCH_LIMIT)
					break;
				buffer.getLineText(line,lineText);
				offset = 0;
				haveTokens = false;
				//}}}
			}
		} //}}}
		//{{{ Backward search
		else
		{
			offset--;
			for(;;)
			{
				for(int i = offset; i >= 0; i--)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}
				//{{{ Go on to previous line
				line--;
				if(line < 0 || (startLine - line) > BRACKET_MATCH_LIMIT)
					break;
				buffer.getLineText(line,lineText);
				offset = lineText.count - 1;
				haveTokens = false;
				//}}}
			}
		} //}}}
		// Nothing found
		return -1;
	} //}}}
	//{{{ findWordStart() method
	/**
	 * Locates the start of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 */
	public static int findWordStart(String line, int pos, String noWordSep)
	{
		return findWordStart(line, pos, noWordSep, true, false);
	} //}}}
	//{{{ findWordStart() method
	/**
	 * Locates the start of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 * @param joinNonWordChars Treat consecutive non-alphanumeric
	 * characters as one word
	 * @since jEdit 4.2pre5
	 */
	public static int findWordStart(String line, int pos, String noWordSep,
		boolean joinNonWordChars)
	{
		return findWordStart(line,pos,noWordSep,joinNonWordChars,false);
	} //}}}
	//{{{ findWordStart() method
	/**
	 * Locates the start of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 * @param joinNonWordChars Treat consecutive non-alphanumeric
	 * characters as one word
	 * @param eatWhitespace Include whitespace at start of word
	 * @since jEdit 4.1pre2
	 */
	public static int findWordStart(String line, int pos, String noWordSep,
		boolean joinNonWordChars, boolean eatWhitespace)
	{
		char ch = line.charAt(pos);
		if(noWordSep == null)
			noWordSep = """";
		//{{{ the character under the cursor changes how we behave.
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		//}}}
loop:		for(int i = pos; i >= 0; i--)
		{
			ch = line.charAt(i);
			switch(type)
			{
			//{{{ Whitespace...
			case WHITESPACE:
				// only select other whitespace in this case
				if(Character.isWhitespace(ch))
					break;
				// word char or symbol; stop
				else
					return i + 1; //}}}
			//{{{ Word character...
			case WORD_CHAR:
				// word char; keep going
				if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				// whitespace; include in word if eating
				else if(Character.isWhitespace(ch)
					&& eatWhitespace)
				{
					type = WHITESPACE;
					break;
				}
				else
					return i + 1; //}}}
			//{{{ Symbol...
			case SYMBOL:
				if(!joinNonWordChars && pos != i)
					return i + 1;
				// whitespace; include in word if eating
				if(Character.isWhitespace(ch))
				{
					if(eatWhitespace)
					{
						type = WHITESPACE;
						break;
					}
					else
						return i + 1;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					return i + 1;
				}
				else
				{
					break;
				} //}}}
			}
		}
		return 0;
	} //}}}
	//{{{ findWordEnd() method
	/**
	 * Locates the end of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 */
	public static int findWordEnd(String line, int pos, String noWordSep)
	{
		return findWordEnd(line, pos, noWordSep, true);
	} //}}}
	//{{{ findWordEnd() method
	/**
	 * Locates the end of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 * @param joinNonWordChars Treat consecutive non-alphanumeric
	 * characters as one word
	 * @since jEdit 4.1pre2
	 */
	public static int findWordEnd(String line, int pos, String noWordSep,
		boolean joinNonWordChars)
	{
		return findWordEnd(line,pos,noWordSep,joinNonWordChars,false);
	} //}}}
	//{{{ findWordEnd() method
	/**
	 * Locates the end of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 * @param joinNonWordChars Treat consecutive non-alphanumeric
	 * characters as one word
	 * @param eatWhitespace Include whitespace at end of word
	 * @since jEdit 4.2pre5
	 */
	public static int findWordEnd(String line, int pos, String noWordSep,
		boolean joinNonWordChars, boolean eatWhitespace)
	{
		if(pos != 0)
			pos--;
		char ch = line.charAt(pos);
		if(noWordSep == null)
			noWordSep = """";
		//{{{ the character under the cursor changes how we behave.
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		//}}}
loop:		for(int i = pos; i < line.length(); i++)
		{
			ch = line.charAt(i);
			switch(type)
			{
			//{{{ Whitespace...
			case WHITESPACE:
				// only select other whitespace in this case
				if(Character.isWhitespace(ch))
					break;
				else
					return i; //}}}
			//{{{ Word character...
			case WORD_CHAR:
				if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				// whitespace; include in word if eating
				else if(Character.isWhitespace(ch)
					&& eatWhitespace)
				{
					type = WHITESPACE;
					break;
				}
				else
					return i; //}}}
			//{{{ Symbol...
			case SYMBOL:
				if(!joinNonWordChars && i != pos)
					return i;
				// if we see whitespace, set flag.
				if(Character.isWhitespace(ch))
				{
					if(eatWhitespace)
					{
						type = WHITESPACE;
						break;
					}
					else
						return i;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					return i;
				}
				else
				{
					break;
				} //}}}
			}
		}
		return line.length();
	} //}}}
	//{{{ spacesToTabs() method
	/**
	 * Converts consecutive spaces to tabs in the specified string.
	 * @param in The string
	 * @param tabSize The tab size
	 */
	public static String spacesToTabs(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		int whitespace = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case ' ':
				whitespace++;
				width++;
				break;
			case '\t':
				int tab = tabSize - (width % tabSize);
				width += tab;
				whitespace += tab;
				break;
			case '\n':
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize,
						width - whitespace));
				}
				whitespace = 0;
				width = 0;
				buf.append('\n');
				break;
			default:
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize,
						width - whitespace));
					whitespace = 0;
				}
				buf.append(in.charAt(i));
				width++;
				break;
			}
		}
		if(whitespace != 0)
		{
			buf.append(MiscUtilities.createWhiteSpace(whitespace,tabSize,
				width - whitespace));
		}
                return buf.toString();
	} //}}}
	//{{{ tabsToSpaces() method
	/**
	 * Converts tabs to consecutive spaces in the specified string.
	 * @param in The string
	 * @param tabSize The tab size
	 */
	public static String tabsToSpaces(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case '\t':
				int count = tabSize - (width % tabSize);
				width += count;
				while(--count >= 0)
					buf.append(' ');
				break;
			case '\n':
				width = 0;
				buf.append(in.charAt(i));
				break;
			default:
				width++;
				buf.append(in.charAt(i));
				break;
                        }
                }
                return buf.toString();
	} //}}}
	//{{{ format() method
	/**
	 * Formats the specified text by merging and breaking lines to the
	 * specified width.
	 * @param text The text
	 * @param maxLineLength The maximum line length
	 * @param tabSize The tab size
	 */
	public static String format(String text, int maxLineLength, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int index = 0;
		for(;;)
		{
			int newIndex = text.indexOf(""\n\n"",index);
			if(newIndex == -1)
				break;
			formatParagraph(text.substring(index,newIndex),
				maxLineLength,tabSize,buf);
			buf.append(""\n\n"");
			index = newIndex + 2;
		}
		if(index != text.length())
		{
			formatParagraph(text.substring(index),
				maxLineLength,tabSize,buf);
		}
		return buf.toString();
	} //}}}
	//{{{ getStringCase() method
	public static final int MIXED = 0;
	public static final int LOWER_CASE = 1;
	public static final int UPPER_CASE = 2;
	public static final int TITLE_CASE = 3;
	/**
	 * Returns if the specified string is all upper case, all lower case,
	 * or title case (first letter upper case, rest lower case).
	 * @param str The string
	 * @since jEdit 4.0pre1
	 */
	public static int getStringCase(String str)
	{
		if(str.length() == 0)
			return MIXED;
		int state = -1;
		char ch = str.charAt(0);
		if(Character.isLetter(ch))
		{
			if(Character.isUpperCase(ch))
				state = UPPER_CASE;
			else
				state = LOWER_CASE;
		}
		for(int i = 1; i < str.length(); i++)
		{
			ch = str.charAt(i);
			if(!Character.isLetter(ch))
				continue;
			switch(state)
			{
			case UPPER_CASE:
				if(Character.isLowerCase(ch))
				{
					if(i == 1)
						state = TITLE_CASE;
					else
						return MIXED;
				}
				break;
			case LOWER_CASE:
			case TITLE_CASE:
				if(Character.isUpperCase(ch))
					return MIXED;
				break;
			}
		}
		return state;
	} //}}}
	//{{{ toTitleCase() method
	/**
	 * Converts the specified string to title case, by capitalizing the
	 * first letter.
	 * @param str The string
	 * @since jEdit 4.0pre1
	 */
	public static String toTitleCase(String str)
	{
		if(str.length() == 0)
			return str;
		else
		{
			return Character.toUpperCase(str.charAt(0))
				+ str.substring(1).toLowerCase();
		}
	} //}}}
	//{{{ Private members
	private static final int WHITESPACE = 0;
	private static final int WORD_CHAR = 1;
	private static final int SYMBOL = 2;
	//{{{ formatParagraph() method
	private static void formatParagraph(String text, int maxLineLength,
		int tabSize, StringBuffer buf)
	{
		// align everything to paragraph's leading indent
		int leadingWhitespaceCount = MiscUtilities.getLeadingWhiteSpace(text);
		String leadingWhitespace = text.substring(0,leadingWhitespaceCount);
		int leadingWhitespaceWidth = MiscUtilities.getLeadingWhiteSpaceWidth(text,tabSize);
		buf.append(leadingWhitespace);
		int lineLength = leadingWhitespaceWidth;
		StringTokenizer st = new StringTokenizer(text);
		while(st.hasMoreTokens())
		{
			String word = st.nextToken();
			if(lineLength == leadingWhitespaceWidth)
			{
				// do nothing
			}
			else if(lineLength + word.length() + 1 > maxLineLength)
			{
				buf.append('\n');
				buf.append(leadingWhitespace);
				lineLength = leadingWhitespaceWidth;
			}
			else
			{
				buf.append(' ');
				lineLength++;
			}
			buf.append(word);
			lineLength += word.length();
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.View,"/*
 * View.java - jEdit view
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.IOException;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.net.Socket;
import java.util.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * A <code>View</code> is jEdit's top-level frame window.<p>
 *
 * In a BeanShell script, you can obtain the current view instance from the
 * <code>view</code> variable.<p>
 *
 * The largest component it contains is an {@link EditPane} that in turn
 * contains a {@link org.gjt.sp.jedit.textarea.JEditTextArea} that displays a
 * {@link Buffer}.
 * A view can have more than one edit pane in a split window configuration.
 * A view also contains a menu bar, an optional toolbar and other window
 * decorations, as well as docked windows.<p>
 *
 * The <b>View</b> class performs two important operations
 * dealing with plugins: creating plugin menu items, and managing dockable
 * windows.
 *
 * <ul>
 * <li>When a view is being created, its initialization routine
 * iterates through the collection of loaded plugins and constructs the
 * <b>Plugins</b> menu using the properties as specified in the
 * {@link EditPlugin} class.</li>
 * <li>The view also creates and initializes a
 * {@link org.gjt.sp.jedit.gui.DockableWindowManager}
 * object.  This object is
 * responsible for creating, closing and managing dockable windows.</li>
 * </ul>
 *
 * This class does not have a public constructor.
 * Views can be opened and closed using methods in the <code>jEdit</code>
 * class.
 *
 * @see org.gjt.sp.jedit.jEdit#newView(View)
 * @see org.gjt.sp.jedit.jEdit#newView(View,Buffer)
 * @see org.gjt.sp.jedit.jEdit#newView(View,Buffer,boolean)
 * @see org.gjt.sp.jedit.jEdit#closeView(View)
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: View.java,v 1.111 2004/05/06 22:35:11 spestov Exp $
 */
public class View extends JFrame implements EBComponent
{
	//{{{ User interface
	//{{{ ToolBar-related constants
	//{{{ Groups
	/**
	 * The group of tool bars above the DockableWindowManager
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int TOP_GROUP = 0;
	/**
	 * The group of tool bars below the DockableWindowManager
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int BOTTOM_GROUP = 1;
	public static final int DEFAULT_GROUP = TOP_GROUP;
	//}}}
	//{{{ Layers
	// Common layers
	/**
	 * The highest possible layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int TOP_LAYER = Integer.MAX_VALUE;
	/**
	 * The default layer for tool bars with no preference.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int DEFAULT_LAYER = 0;
	/**
	 * The lowest possible layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int BOTTOM_LAYER = Integer.MIN_VALUE;
	// Layers for top group
	/**
	 * Above system tool bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int ABOVE_SYSTEM_BAR_LAYER = 150;
	/**
	 * System tool bar layer.
	 * jEdit uses this for the main tool bar.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int SYSTEM_BAR_LAYER = 100;
	/**
	 * Below system tool bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int BELOW_SYSTEM_BAR_LAYER = 75;
	/**
	 * Search bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int SEARCH_BAR_LAYER = 75;
	/**
	 * Below search bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.0pre7
	 */
	public static final int BELOW_SEARCH_BAR_LAYER = 50;
	// Layers for bottom group
	/**
	 * @deprecated Status bar no longer added as a tool bar.
	 */
	public static final int ABOVE_ACTION_BAR_LAYER = -50;
	/**
	 * Action bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.2pre1
	 */
	public static final int ACTION_BAR_LAYER = -75;
	/**
	 * Status bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.2pre1
	 */
	public static final int STATUS_BAR_LAYER = -100;
	/**
	 * Status bar layer.
	 * @see #addToolBar(int,int,java.awt.Component)
	 * @since jEdit 4.2pre1
	 */
	public static final int BELOW_STATUS_BAR_LAYER = -150;
	//}}}
	//}}}
	//{{{ getDockableWindowManager() method
	/**
	 * Returns the dockable window manager associated with this view.
	 * @since jEdit 2.6pre3
	 */
	public DockableWindowManager getDockableWindowManager()
	{
		return dockableWindowManager;
	} //}}}
	//{{{ getToolBar() method
	/**
	 * Returns the view's tool bar.
	 * @since jEdit 4.2pre1
	 */
	public Box getToolBar()
	{
		return toolBar;
	} //}}}
	//{{{ addToolBar() method
	/**
	 * Adds a tool bar to this view.
	 * @param toolBar The tool bar
	 */
	public void addToolBar(Component toolBar)
	{
		addToolBar(DEFAULT_GROUP, DEFAULT_LAYER, toolBar);
	} //}}}
	//{{{ addToolBar() method
	/**
	 * Adds a tool bar to this view.
	 * @param group The tool bar group to add to
	 * @param toolBar The tool bar
	 * @see org.gjt.sp.jedit.gui.ToolBarManager
	 * @since jEdit 4.0pre7
	 */
	public void addToolBar(int group, Component toolBar)
	{
		addToolBar(group, DEFAULT_LAYER, toolBar);
	} //}}}
	//{{{ addToolBar() method
	/**
	 * Adds a tool bar to this view.
	 * @param group The tool bar group to add to
	 * @param layer The layer of the group to add to
	 * @param toolBar The tool bar
	 * @see org.gjt.sp.jedit.gui.ToolBarManager
	 * @since jEdit 4.0pre7
	 */
	public void addToolBar(int group, int layer, Component toolBar)
	{
		toolBarManager.addToolBar(group, layer, toolBar);
		getRootPane().revalidate();
	} //}}}
	//{{{ removeToolBar() method
	/**
	 * Removes a tool bar from this view.
	 * @param toolBar The tool bar
	 */
	public void removeToolBar(Component toolBar)
	{
		toolBarManager.removeToolBar(toolBar);
		getRootPane().revalidate();
	} //}}}
	//{{{ showWaitCursor() method
	/**
	 * Shows the wait cursor. This method and
	 * {@link #hideWaitCursor()} are implemented using a reference
	 * count of requests for wait cursors, so that nested calls work
	 * correctly; however, you should be careful to use these methods in
	 * tandem.<p>
	 *
	 * To ensure that {@link #hideWaitCursor()} is always called
	 * after a {@link #showWaitCursor()}, use a
	 * <code>try</code>/<code>finally</code> block, like this:
	 * <pre>try
	 *{
	 *    view.showWaitCursor();
	 *    // ...
	 *}
	 *finally
	 *{
	 *    view.hideWaitCursor();
	 *}</pre>
	 */
	public synchronized void showWaitCursor()
	{
		if(waitCount++ == 0)
		{
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			setCursor(cursor);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	} //}}}
	//{{{ hideWaitCursor() method
	/**
	 * Hides the wait cursor.
	 */
	public synchronized void hideWaitCursor()
	{
		if(waitCount > 0)
			waitCount--;
		if(waitCount == 0)
		{
			// still needed even though glass pane
			// has a wait cursor
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			setCursor(cursor);
			cursor = Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	} //}}}
	//{{{ getSearchBar() method
	/**
	 * Returns the search bar.
	 * @since jEdit 2.4pre4
	 */
	public final SearchBar getSearchBar()
	{
		return searchBar;
	} //}}}
	//{{{ getActionBar() method
	/**
	 * Returns the action bar.
	 * @since jEdit 4.2pre3
	 */
	public final ActionBar getActionBar()
	{
		return actionBar;
	} //}}}
	//{{{ getStatus() method
	/**
	 * Returns the status bar. The
	 * {@link org.gjt.sp.jedit.gui.StatusBar#setMessage(String)} and
	 * {@link org.gjt.sp.jedit.gui.StatusBar#setMessageAndClear(String)} methods can
	 * be called on the return value of this method to display status
	 * information to the user.
	 * @since jEdit 3.2pre2
	 */
	public StatusBar getStatus()
	{
		return status;
	} //}}}
	//{{{ quickIncrementalSearch() method
	/**
	 * Quick search.
	 * @since jEdit 4.0pre3
	 */
	public void quickIncrementalSearch(boolean word)
	{
		if(searchBar == null)
			searchBar = new SearchBar(this,true);
		if(searchBar.getParent() == null)
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);
		searchBar.setHyperSearch(false);
		JEditTextArea textArea = getTextArea();
		if(word)
		{
			String text = textArea.getSelectedText();
			if(text == null)
			{
				textArea.selectWord();
				text = textArea.getSelectedText();
			}
			else if(text.indexOf('\n') != -1)
				text = null;
			searchBar.getField().setText(text);
		}
		searchBar.getField().requestFocus();
		searchBar.getField().selectAll();
	} //}}}
	//{{{ quickHyperSearch() method
	/**
	 * Quick HyperSearch.
	 * @since jEdit 4.0pre3
	 */
	public void quickHyperSearch(boolean word)
	{
		JEditTextArea textArea = getTextArea();
		if(word)
		{
			String text = textArea.getSelectedText();
			if(text == null)
			{
				textArea.selectWord();
				text = textArea.getSelectedText();
			}
			if(text != null && text.indexOf('\n') == -1)
			{
				HistoryModel.getModel(""find"").addItem(text);
				SearchAndReplace.setSearchString(text);
				SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
				SearchAndReplace.hyperSearch(this);
				return;
			}
		}
		if(searchBar == null)
			searchBar = new SearchBar(this,true);
		if(searchBar.getParent() == null)
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);
		searchBar.setHyperSearch(true);
		searchBar.getField().setText(null);
		searchBar.getField().requestFocus();
		searchBar.getField().selectAll();
	} //}}}
	//{{{ actionBar() method
	/**
	 * Shows the action bar if needed, and sends keyboard focus there.
	 * @since jEdit 4.2pre1
	 */
	public void actionBar()
	{
		if(actionBar == null)
			actionBar = new ActionBar(this,true);
		if(actionBar.getParent() == null)
			addToolBar(BOTTOM_GROUP,ACTION_BAR_LAYER,actionBar);
		actionBar.goToActionBar();
	} //}}}
	//}}}
	//{{{ Input handling
	//{{{ getKeyEventInterceptor() method
	/**
	 * Returns the listener that will handle all key events in this
	 * view, if any.
	 */
	public KeyListener getKeyEventInterceptor()
	{
		return keyEventInterceptor;
	} //}}}
	//{{{ setKeyEventInterceptor() method
	/**
	 * Sets the listener that will handle all key events in this
	 * view. For example, the complete word command uses this so
	 * that all key events are passed to the word list popup while
	 * it is visible.
	 * @param listener The key event interceptor.
	 */
	public void setKeyEventInterceptor(KeyListener listener)
	{
		this.keyEventInterceptor = listener;
	} //}}}
	//{{{ getInputHandler() method
	/**
	 * Returns the input handler.
	 */
	public InputHandler getInputHandler()
	{
		return inputHandler;
	} //}}}
	//{{{ setInputHandler() method
	/**
	 * Sets the input handler.
	 * @param inputHandler The new input handler
	 */
	public void setInputHandler(InputHandler inputHandler)
	{
		this.inputHandler = inputHandler;
	} //}}}
	//{{{ getMacroRecorder() method
	/**
	 * Returns the macro recorder.
	 */
	public Macros.Recorder getMacroRecorder()
	{
		return recorder;
	} //}}}
	//{{{ setMacroRecorder() method
	/**
	 * Sets the macro recorder.
	 * @param recorder The macro recorder
	 */
	public void setMacroRecorder(Macros.Recorder recorder)
	{
		this.recorder = recorder;
	} //}}}
	//{{{ processKeyEvent() method
	/**
	 * Forwards key events directly to the input handler.
	 * This is slightly faster than using a KeyListener
	 * because some Swing overhead is avoided.
	 */
	public void processKeyEvent(KeyEvent evt)
	{
		processKeyEvent(evt,VIEW);
	} //}}}
	//{{{ processKeyEvent() method
	/**
	 * Forwards key events directly to the input handler.
	 * This is slightly faster than using a KeyListener
	 * because some Swing overhead is avoided.
	 */
	public void processKeyEvent(KeyEvent evt, boolean calledFromTextArea)
	{
		processKeyEvent(evt,calledFromTextArea
			? TEXT_AREA
			: VIEW);
	} //}}}
	//{{{ processKeyEvent() method
	public static final int VIEW = 0;
	public static final int TEXT_AREA = 1;
	public static final int ACTION_BAR = 2;
	/**
	 * Forwards key events directly to the input handler.
	 * This is slightly faster than using a KeyListener
	 * because some Swing overhead is avoided.
	 */
	public void processKeyEvent(KeyEvent evt, int from)
	{
		if(Debug.DUMP_KEY_EVENTS && from != VIEW)
		{
			Log.log(Log.DEBUG,this,""Key event: ""
				+ GrabKeyDialog.toString(evt));
		}
		if(getTextArea().hasFocus() && from == VIEW)
			return;
		evt = _preprocessKeyEvent(evt);
		if(evt == null)
			return;
		if(Debug.DUMP_KEY_EVENTS && from != VIEW)
		{
			Log.log(Log.DEBUG,this,""Key event after workaround: ""
				+ GrabKeyDialog.toString(evt));
		}
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			boolean focusOnTextArea = false;
			// if the user pressed eg C+e n n in the
			// search bar we want focus to go back there
			// after the prefix is done
			if(prefixFocusOwner != null)
			{
				if(prefixFocusOwner.isShowing())
				{
					prefixFocusOwner.requestFocus();
					focusOnTextArea = true;
				}
			}
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else if(from == ACTION_BAR
				|| inputHandler.isPrefixActive()
				|| getTextArea().hasFocus())
			{
				KeyEventTranslator.Key keyStroke
					= KeyEventTranslator
					.translateKeyEvent(evt);
				if(keyStroke != null)
				{
					if(Debug.DUMP_KEY_EVENTS
						&& from != VIEW)
					{
						Log.log(Log.DEBUG,this,
							""Translated: ""
							+ keyStroke);
					}
					if(inputHandler.handleKey(keyStroke))
						evt.consume();
				}
			}
			// we might have been closed as a result of
			// the above
			if(isClosed())
				return;
			// this is a weird hack.
			// we don't want C+e a to insert 'a' in the
			// search bar if the search bar has focus...
			if(inputHandler.isPrefixActive())
			{
				if(getFocusOwner() instanceof JTextComponent)
				{
					prefixFocusOwner = getFocusOwner();
					getTextArea().requestFocus();
				}
				else if(focusOnTextArea)
				{
					getTextArea().requestFocus();
				}
				else
				{
					prefixFocusOwner = null;
				}
			}
			else
			{
				prefixFocusOwner = null;
			}
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
			{
				/* boolean */ focusOnTextArea = false;
				if(prefixFocusOwner != null)
				{
					if(prefixFocusOwner.isShowing())
					{
						prefixFocusOwner.requestFocus();
						focusOnTextArea = true;
					}
					prefixFocusOwner = null;
				}
				KeyEventTranslator.Key keyStroke
					= KeyEventTranslator
					.translateKeyEvent(evt);
				if(keyStroke != null)
				{
					if(Debug.DUMP_KEY_EVENTS
						&& from != VIEW)
					{
						Log.log(Log.DEBUG,this,
							""Translated: ""
							+ keyStroke);
					}
					if(inputHandler.handleKey(keyStroke))
						evt.consume();
				}
				// we might have been closed as a result of
				// the above
				if(isClosed())
					return;
				// this is a weird hack.
				// we don't want C+e a to insert 'a' in the
				// search bar if the search bar has focus...
				if(inputHandler.isPrefixActive())
				{
					if(getFocusOwner() instanceof JTextComponent)
					{
						prefixFocusOwner = getFocusOwner();
						getTextArea().requestFocus();
					}
					else if(focusOnTextArea)
					{
						getTextArea().requestFocus();
					}
					else
					{
						prefixFocusOwner = null;
					}
				}
				else
				{
					prefixFocusOwner = null;
				}
			}
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			break;
		}
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} //}}}
	//}}}
	//{{{ Buffers, edit panes, split panes
	//{{{ splitHorizontally() method
	/**
	 * Splits the view horizontally.
	 * @since jEdit 4.1pre2
	 */
	public EditPane splitHorizontally()
	{
		return split(JSplitPane.VERTICAL_SPLIT);
	} //}}}
	//{{{ splitVertically() method
	/**
	 * Splits the view vertically.
	 * @since jEdit 4.1pre2
	 */
	public EditPane splitVertically()
	{
		return split(JSplitPane.HORIZONTAL_SPLIT);
	} //}}}
	//{{{ split() method
	/**
	 * Splits the view.
	 * @since jEdit 4.1pre2
	 */
	public EditPane split(int orientation)
	{
		PerspectiveManager.setPerspectiveDirty(true);
		editPane.saveCaretInfo();
		EditPane oldEditPane = editPane;
		setEditPane(createEditPane(oldEditPane.getBuffer()));
		editPane.loadCaretInfo();
		JComponent oldParent = (JComponent)oldEditPane.getParent();
		final JSplitPane newSplitPane = new JSplitPane(orientation);
		newSplitPane.setOneTouchExpandable(true);
		newSplitPane.setBorder(null);
		newSplitPane.setMinimumSize(new Dimension(0,0));
		int parentSize = (orientation == JSplitPane.VERTICAL_SPLIT
			? oldEditPane.getHeight() : oldEditPane.getWidth());
		final int dividerPosition = (int)((double)(parentSize
			- newSplitPane.getDividerSize()) * 0.5);
		newSplitPane.setDividerLocation(dividerPosition);
		if(oldParent instanceof JSplitPane)
		{
			JSplitPane oldSplitPane = (JSplitPane)oldParent;
			int dividerPos = oldSplitPane.getDividerLocation();
			Component left = oldSplitPane.getLeftComponent();
			if(left == oldEditPane)
				oldSplitPane.setLeftComponent(newSplitPane);
			else
				oldSplitPane.setRightComponent(newSplitPane);
			newSplitPane.setLeftComponent(oldEditPane);
			newSplitPane.setRightComponent(editPane);
			oldSplitPane.setDividerLocation(dividerPos);
		}
		else
		{
			this.splitPane = newSplitPane;
			newSplitPane.setLeftComponent(oldEditPane);
			newSplitPane.setRightComponent(editPane);
			oldParent.add(newSplitPane,0);
			oldParent.revalidate();
		}
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				newSplitPane.setDividerLocation(dividerPosition);
			}
		});
		editPane.focusOnTextArea();
		return editPane;
	} //}}}
	//{{{ unsplit() method
	/**
	 * Unsplits the view.
	 * @since jEdit 2.3pre2
	 */
	public void unsplit()
	{
		if(splitPane != null)
		{
			PerspectiveManager.setPerspectiveDirty(true);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane _editPane = editPanes[i];
				if(editPane != _editPane)
					_editPane.close();
			}
			JComponent parent = (JComponent)splitPane.getParent();
			parent.remove(splitPane);
			parent.add(editPane,0);
			parent.revalidate();
			splitPane = null;
			updateTitle();
			editPane.focusOnTextArea();
		}
		else
			getToolkit().beep();
	} //}}}
	//{{{ unsplitCurrent() method
	/**
	 * Removes the current split.
	 * @since jEdit 2.3pre2
	 */
	public void unsplitCurrent()
	{
		if(splitPane != null)
		{
			PerspectiveManager.setPerspectiveDirty(true);
			// find first split pane parenting current edit pane
			Component comp = editPane;
			while(!(comp instanceof JSplitPane))
			{
				comp = comp.getParent();
			}
			// get rid of any edit pane that is a child
			// of the current edit pane's parent splitter
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane _editPane = editPanes[i];
				if(GUIUtilities.isAncestorOf(comp,_editPane)
					&& _editPane != editPane)
					_editPane.close();
			}
			JComponent parent = (JComponent)comp.getParent();
			if(parent instanceof JSplitPane)
			{
				JSplitPane parentSplit = (JSplitPane)parent;
				int pos = parentSplit.getDividerLocation();
				if(parentSplit.getLeftComponent() == comp)
					parentSplit.setLeftComponent(editPane);
				else
					parentSplit.setRightComponent(editPane);
				parentSplit.setDividerLocation(pos);
			}
			else
			{
				parent.remove(comp);
				parent.add(editPane,0);
				splitPane = null;
			}
			parent.revalidate();
			updateTitle();
			editPane.focusOnTextArea();
		}
		else
			getToolkit().beep();
	} //}}}
	//{{{ nextTextArea() method
	/**
	 * Moves keyboard focus to the next text area.
	 * @since jEdit 2.7pre4
	 */
	public void nextTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == editPanes.length - 1)
					editPanes[0].focusOnTextArea();
				else
					editPanes[i+1].focusOnTextArea();
				break;
			}
		}
	} //}}}
	//{{{ prevTextArea() method
	/**
	 * Moves keyboard focus to the previous text area.
	 * @since jEdit 2.7pre4
	 */
	public void prevTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == 0)
					editPanes[editPanes.length - 1].focusOnTextArea();
				else
					editPanes[i-1].focusOnTextArea();
				break;
			}
		}
	} //}}}
	//{{{ getSplitPane() method
	/**
	 * Returns the top-level split pane, if any.
	 * @since jEdit 2.3pre2
	 */
	public JSplitPane getSplitPane()
	{
		return splitPane;
	} //}}}
	//{{{ getBuffer() method
	/**
	 * Returns the current edit pane's buffer.
	 */
	public Buffer getBuffer()
	{
		if(editPane == null)
			return null;
		else
			return editPane.getBuffer();
	} //}}}
	//{{{ setBuffer() method
	/**
	 * Sets the current edit pane's buffer.
	 */
	public void setBuffer(Buffer buffer)
	{
		editPane.setBuffer(buffer);
	} //}}}
	//{{{ goToBuffer() method
	/**
	 * If this buffer is open in one of the view's edit panes, sets focus
	 * to that edit pane. Otherwise, opens the buffer in the currently
	 * active edit pane.
	 * @param buffer The buffer
	 * @since jEdit 4.2pre1
	 */
	public EditPane goToBuffer(Buffer buffer)
	{
		if(editPane.getBuffer() == buffer)
		{
			editPane.focusOnTextArea();
			return editPane;
		}
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			EditPane ep = editPanes[i];
			if(ep.getBuffer() == buffer
				/* ignore zero-height splits, etc */
				&& ep.getTextArea().getVisibleLines() > 1)
			{
				setEditPane(ep);
				ep.focusOnTextArea();
				return ep;
			}
		}
		setBuffer(buffer);
		return editPane;
	} //}}}
	//{{{ getTextArea() method
	/**
	 * Returns the current edit pane's text area.
	 */
	public JEditTextArea getTextArea()
	{
		if(editPane == null)
			return null;
		else
			return editPane.getTextArea();
	} //}}}
	//{{{ getEditPane() method
	/**
	 * Returns the current edit pane.
	 * @since jEdit 2.5pre2
	 */
	public EditPane getEditPane()
	{
		return editPane;
	} //}}}
	//{{{ getEditPanes() method
	/**
	 * Returns all edit panes.
	 * @since jEdit 2.5pre2
	 */
	public EditPane[] getEditPanes()
	{
		if(splitPane == null)
		{
			EditPane[] ep = { editPane };
			return ep;
		}
		else
		{
			Vector vec = new Vector();
			getEditPanes(vec,splitPane);
			EditPane[] ep = new EditPane[vec.size()];
			vec.copyInto(ep);
			return ep;
		}
	} //}}}
	//{{{ getViewConfig() method
	/**
	 * @since jEdit 4.2pre1
	 */
	public ViewConfig getViewConfig()
	{
		StringBuffer splitConfig = new StringBuffer();
		if(splitPane != null)
			getSplitConfig(splitPane,splitConfig);
		else
		{
			splitConfig.append('""');
			splitConfig.append(MiscUtilities.charsToEscapes(
				getBuffer().getPath()));
			splitConfig.append(""\"" buffer"");
		}
		ViewConfig config = new ViewConfig();
		config.plainView = isPlainView();
		config.splitConfig = splitConfig.toString();
		config.x = getX();
		config.y = getY();
		config.width = getWidth();
		config.height = getHeight();
		config.extState = GUIUtilities.getExtendedState(this);
		config.top = dockableWindowManager.getTopDockingArea().getCurrent();
		config.left = dockableWindowManager.getLeftDockingArea().getCurrent();
		config.bottom = dockableWindowManager.getBottomDockingArea().getCurrent();
		config.right = dockableWindowManager.getRightDockingArea().getCurrent();
		config.topPos = dockableWindowManager.getTopDockingArea().getDimension();
		config.leftPos = dockableWindowManager.getLeftDockingArea().getDimension();
		config.bottomPos = dockableWindowManager.getBottomDockingArea().getDimension();
		config.rightPos = dockableWindowManager.getRightDockingArea().getDimension();
		return config;
	} //}}}
	//}}}
	//{{{ isClosed() method
	/**
	 * Returns true if this view has been closed with
	 * {@link jEdit#closeView(View)}.
	 */
	public boolean isClosed()
	{
		return closed;
	} //}}}
	//{{{ isPlainView() method
	/**
	 * Returns true if this is an auxilliary view with no dockable windows.
	 * @since jEdit 4.1pre2
	 */
	public boolean isPlainView()
	{
		return plainView;
	} //}}}
	//{{{ getNext() method
	/**
	 * Returns the next view in the list.
	 */
	public View getNext()
	{
		return next;
	} //}}}
	//{{{ getPrev() method
	/**
	 * Returns the previous view in the list.
	 */
	public View getPrev()
	{
		return prev;
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof SearchSettingsChanged)
		{
			if(searchBar != null)
				searchBar.update();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof EditPaneUpdate)
			handleEditPaneUpdate((EditPaneUpdate)msg);
	} //}}}
	//{{{ getMinimumSize() method
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} //}}}
	//{{{ setWaitSocket() method
	/**
	 * This socket is closed when the buffer is closed.
	 */
	public void setWaitSocket(Socket waitSocket)
	{
		this.waitSocket = waitSocket;
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		return getClass().getName() + ""[""
			+ (jEdit.getActiveView() == this
			? ""active"" : ""inactive"")
			+ ""]"";
	} //}}}
	//{{{ Package-private members
	View prev;
	View next;
	//{{{ View constructor
	View(Buffer buffer, ViewConfig config)
	{
		this.plainView = config.plainView;
		enableEvents(AWTEvent.KEY_EVENT_MASK);
		setIconImage(GUIUtilities.getEditorIcon());
		dockableWindowManager = new DockableWindowManager(this,config);
		topToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));
		bottomToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));
		toolBarManager = new ToolBarManager(topToolBars, bottomToolBars);
		status = new StatusBar(this);
		inputHandler = new DefaultInputHandler(this,(DefaultInputHandler)
			jEdit.getInputHandler());
		try
		{
			Component comp = restoreSplitConfig(buffer,config.splitConfig);
			dockableWindowManager.add(comp,0);
		}
		catch(IOException e)
		{
			// this should never throw an exception.
			throw new InternalError();
		}
		getContentPane().add(BorderLayout.CENTER,dockableWindowManager);
		dockableWindowManager.init();
		// tool bar and status bar gets added in propertiesChanged()
		// depending in the 'tool bar alternate layout' setting.
		propertiesChanged();
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());
		EditBus.addToBus(this);
		SearchDialog.preloadSearchDialog(this);
	} //}}}
	//{{{ close() method
	void close()
	{
		GUIUtilities.saveGeometry(this,plainView ? ""plain-view"" : ""view"");
		closed = true;
		// save dockable window geometry, and close 'em
		dockableWindowManager.close();
		EditBus.removeFromBus(this);
		dispose();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].close();
		// null some variables so that retaining references
		// to closed views won't hurt as much.
		toolBarManager = null;
		toolBar = null;
		searchBar = null;
		splitPane = null;
		inputHandler = null;
		recorder = null;
		getContentPane().removeAll();
		// notify clients with -wait
		if(waitSocket != null)
		{
			try
			{
				waitSocket.getOutputStream().write('\0');
				waitSocket.getOutputStream().flush();
				waitSocket.getInputStream().close();
				waitSocket.getOutputStream().close();
				waitSocket.close();
			}
			catch(IOException io)
			{
				//Log.log(Log.ERROR,this,io);
			}
		}
	} //}}}
	//{{{ updateTitle() method
	/**
	 * Updates the title bar.
	 */
	void updateTitle()
	{
		Vector buffers = new Vector();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			Buffer buffer = editPanes[i].getBuffer();
			if(buffers.indexOf(buffer) == -1)
				buffers.addElement(buffer);
		}
		StringBuffer title = new StringBuffer(jEdit.getProperty(""view.title""));
		for(int i = 0; i < buffers.size(); i++)
		{
			if(i != 0)
				title.append("", "");
			Buffer buffer = (Buffer)buffers.elementAt(i);
			title.append((showFullPath && !buffer.isNewFile())
				? buffer.getPath() : buffer.getName());
			if(buffer.isDirty())
				title.append(jEdit.getProperty(""view.title.dirty""));
		}
		setTitle(title.toString());
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private boolean closed;
	private DockableWindowManager dockableWindowManager;
	private JPanel topToolBars;
	private JPanel bottomToolBars;
	private ToolBarManager toolBarManager;
	private Box toolBar;
	private SearchBar searchBar;
	private ActionBar actionBar;
	private EditPane editPane;
	private JSplitPane splitPane;
	private StatusBar status;
	private KeyListener keyEventInterceptor;
	private InputHandler inputHandler;
	private Macros.Recorder recorder;
	private Component prefixFocusOwner;
	private int waitCount;
	private boolean showFullPath;
	private boolean plainView;
	private Socket waitSocket;
	//}}}
	//{{{ getEditPanes() method
	private void getEditPanes(Vector vec, Component comp)
	{
		if(comp instanceof EditPane)
			vec.addElement(comp);
		else if(comp instanceof JSplitPane)
		{
			JSplitPane split = (JSplitPane)comp;
			getEditPanes(vec,split.getLeftComponent());
			getEditPanes(vec,split.getRightComponent());
		}
	} //}}}
	//{{{ getSplitConfig() method
	/*
	 * The split config is recorded in a simple RPN ""language"".
	 */
	private void getSplitConfig(JSplitPane splitPane,
		StringBuffer splitConfig)
	{
		Component right = splitPane.getRightComponent();
		if(right instanceof JSplitPane)
			getSplitConfig((JSplitPane)right,splitConfig);
		else
		{
			splitConfig.append('""');
			splitConfig.append(MiscUtilities.charsToEscapes(
				((EditPane)right).getBuffer().getPath()));
			splitConfig.append(""\"" buffer"");
		}
		splitConfig.append(' ');
		Component left = splitPane.getLeftComponent();
		if(left instanceof JSplitPane)
			getSplitConfig((JSplitPane)left,splitConfig);
		else
		{
			splitConfig.append('""');
			splitConfig.append(MiscUtilities.charsToEscapes(
				((EditPane)left).getBuffer().getPath()));
			splitConfig.append(""\"" buffer"");
		}
		splitConfig.append(' ');
		splitConfig.append(splitPane.getDividerLocation());
		splitConfig.append(' ');
		splitConfig.append(splitPane.getOrientation()
			== JSplitPane.VERTICAL_SPLIT ? ""vertical"" : ""horizontal"");
	} //}}}
	//{{{ restoreSplitConfig() method
	private Component restoreSplitConfig(Buffer buffer, String splitConfig)
		throws IOException
	// this is where checked exceptions piss me off. this method only uses
	// a StringReader which can never throw an exception...
	{
		if(buffer != null)
			return (editPane = createEditPane(buffer));
		else if(splitConfig == null)
			return (editPane = createEditPane(jEdit.getFirstBuffer()));
		Buffer[] buffers = jEdit.getBuffers();
		Stack stack = new Stack();
		// we create a stream tokenizer for parsing a simple
		// stack-based language
		StreamTokenizer st = new StreamTokenizer(new StringReader(
			splitConfig));
		st.whitespaceChars(0,' ');
		/* all printable ASCII characters */
		st.wordChars('#','~');
		st.commentChar('!');
		st.quoteChar('""');
		st.eolIsSignificant(false);
loop:		for(;;)
		{
			switch(st.nextToken())
			{
			case StreamTokenizer.TT_EOF:
				break loop;
			case StreamTokenizer.TT_WORD:
				if(st.sval.equals(""vertical"") ||
					st.sval.equals(""horizontal""))
				{
					int orientation
						= (st.sval.equals(""vertical"")
						? JSplitPane.VERTICAL_SPLIT
						: JSplitPane.HORIZONTAL_SPLIT);
					int divider = ((Integer)stack.pop())
						.intValue();
					stack.push(splitPane = new JSplitPane(
						orientation,
						(Component)stack.pop(),
						(Component)stack.pop()));
					splitPane.setOneTouchExpandable(true);
					splitPane.setBorder(null);
					splitPane.setMinimumSize(
						new Dimension(0,0));
					splitPane.setDividerLocation(divider);
				}
				else if(st.sval.equals(""buffer""))
				{
					Object obj = stack.pop();
					if(obj instanceof Integer)
					{
						int index = ((Integer)obj).intValue();
						if(index >= 0 && index < buffers.length)
							buffer = buffers[index];
					}
					else if(obj instanceof String)
					{
						String path = (String)obj;
						buffer = jEdit.getBuffer(path);
					}
					if(buffer == null)
						buffer = jEdit.getFirstBuffer();
					stack.push(editPane = createEditPane(
						buffer));
				}
				break;
			case StreamTokenizer.TT_NUMBER:
				stack.push(new Integer((int)st.nval));
				break;
			case '""':
				stack.push(st.sval);
				break;
			}
		}
		updateGutterBorders();
		return (Component)stack.peek();
	} //}}}
	//{{{ propertiesChanged() method
	/**
	 * Reloads various settings from the properties.
	 */
	private void propertiesChanged()
	{
		setJMenuBar(GUIUtilities.loadMenuBar(""view.mbar""));
		loadToolBars();
		showFullPath = jEdit.getBooleanProperty(""view.showFullPath"");
		updateTitle();
		status.propertiesChanged();
		removeToolBar(status);
		getContentPane().remove(status);
		if(jEdit.getBooleanProperty(""view.toolbar.alternateLayout""))
		{
			getContentPane().add(BorderLayout.NORTH,topToolBars);
			getContentPane().add(BorderLayout.SOUTH,bottomToolBars);
			if(!plainView && jEdit.getBooleanProperty(""view.status.visible""))
				addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);
		}
		else
		{
			dockableWindowManager.add(topToolBars,
				DockableWindowManager.DockableLayout
				.TOP_TOOLBARS,0);
			dockableWindowManager.add(bottomToolBars,
				DockableWindowManager.DockableLayout
				.BOTTOM_TOOLBARS,0);
			if(!plainView && jEdit.getBooleanProperty(""view.status.visible""))
				getContentPane().add(BorderLayout.SOUTH,status);
		}
		getRootPane().revalidate();
		//SwingUtilities.updateComponentTreeUI(getRootPane());
	} //}}}
	//{{{ loadToolBars() method
	private void loadToolBars()
	{
		if(jEdit.getBooleanProperty(""view.showToolbar"") && !plainView)
		{
			if(toolBar != null)
				toolBarManager.removeToolBar(toolBar);
			toolBar = GUIUtilities.loadToolBar(""view.toolbar"");
			addToolBar(TOP_GROUP, SYSTEM_BAR_LAYER, toolBar);
		}
		else if(toolBar != null)
		{
			removeToolBar(toolBar);
			toolBar = null;
		}
		if(searchBar != null)
			removeToolBar(searchBar);
		if(jEdit.getBooleanProperty(""view.showSearchbar"") && !plainView)
		{
			if(searchBar == null)
				searchBar = new SearchBar(this,false);
			searchBar.propertiesChanged();
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);
		}
	} //}}}
	//{{{ createEditPane() method
	private EditPane createEditPane(Buffer buffer)
	{
		EditPane editPane = new EditPane(this,buffer);
		JEditTextArea textArea = editPane.getTextArea();
		textArea.addFocusListener(new FocusHandler());
		textArea.addCaretListener(new CaretHandler());
		textArea.addScrollListener(new ScrollHandler());
		EditBus.send(new EditPaneUpdate(editPane,EditPaneUpdate.CREATED));
		return editPane;
	} //}}}
	//{{{ setEditPane() method
	private void setEditPane(EditPane editPane)
	{
		this.editPane = editPane;
		status.updateCaretStatus();
		status.updateBufferStatus();
		status.updateMiscStatus();
		// repaint the gutter so that the border color
		// reflects the focus state
		updateGutterBorders();
		EditBus.send(new ViewUpdate(this,ViewUpdate.EDIT_PANE_CHANGED));
	} //}}}
	//{{{ handleBufferUpdate() method
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED
			|| msg.getWhat() == BufferUpdate.LOADED)
		{
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				if(editPanes[i].getBuffer() == buffer)
				{
					updateTitle();
					break;
				}
			}
		}
	} //}}}
	//{{{ handleEditPaneUpdate() method
	private void handleEditPaneUpdate(EditPaneUpdate msg)
	{
		EditPane editPane = msg.getEditPane();
		if(editPane.getView() == this
			&& msg.getWhat() == EditPaneUpdate.BUFFER_CHANGED
			&& editPane.getBuffer().isLoaded())
		{
			status.updateCaretStatus();
			status.updateBufferStatus();
			status.updateMiscStatus();
		}
	} //}}}
	//{{{ updateGutterBorders() method
	/**
	 * Updates the borders of all gutters in this view to reflect the
	 * currently focused text area.
	 * @since jEdit 2.6final
	 */
	private void updateGutterBorders()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].getTextArea().getGutter().updateBorder();
	} //}}}
	//{{{ _preprocessKeyEvent() method
	private KeyEvent _preprocessKeyEvent(KeyEvent evt)
	{
		if(isClosed())
			return null;
		if(getFocusOwner() instanceof JComponent)
		{
			JComponent comp = (JComponent)getFocusOwner();
			InputMap map = comp.getInputMap();
			ActionMap am = comp.getActionMap();
			if(map != null && am != null && comp.isEnabled())
			{
				Object binding = map.get(KeyStroke.getKeyStrokeForEvent(evt));
				if(binding != null && am.get(binding) != null)
				{
					return null;
				}
			}
		}
		if(getFocusOwner() instanceof JTextComponent)
		{
			// fix for the bug where key events in JTextComponents
			// inside views are also handled by the input handler
			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_ENTER:
				case KeyEvent.VK_TAB:
				case KeyEvent.VK_BACK_SPACE:
				case KeyEvent.VK_SPACE:
					return null;
				}
			}
		}
		if(evt.isConsumed())
			return null;
		return KeyEventWorkaround.processKeyEvent(evt);
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ CaretHandler class
	class CaretHandler implements CaretListener
	{
		public void caretUpdate(CaretEvent evt)
		{
			if(evt.getSource() == getTextArea())
				status.updateCaretStatus();
		}
	} //}}}
	//{{{ FocusHandler class
	class FocusHandler extends FocusAdapter
	{
		public void focusGained(FocusEvent evt)
		{
			// walk up hierarchy, looking for an EditPane
			Component comp = (Component)evt.getSource();
			while(!(comp instanceof EditPane))
			{
				if(comp == null)
					return;
				comp = comp.getParent();
			}
			if(comp != editPane)
				setEditPane((EditPane)comp);
			else
				updateGutterBorders();
		}
	} //}}}
	//{{{ ScrollHandler class
	class ScrollHandler implements ScrollListener
	{
		public void scrolledVertically(JEditTextArea textArea)
		{
			if(getTextArea() == textArea)
				status.updateCaretStatus();
		}
		public void scrolledHorizontally(JEditTextArea textArea) {}
	} //}}}
	//{{{ WindowHandler class
	class WindowHandler extends WindowAdapter
	{
		public void windowActivated(WindowEvent evt)
		{
			jEdit.setActiveView(View.this);
			// People have reported hangs with JDK 1.4; might be
			// caused by modal dialogs being displayed from
			// windowActivated()
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					jEdit.checkBufferStatus(View.this);
				}
			});
		}
		public void windowClosing(WindowEvent evt)
		{
			jEdit.closeView(View.this);
		}
	} //}}}
	//{{{ ViewConfig class
	public static class ViewConfig
	{
		public boolean plainView;
		public String splitConfig;
		public int x, y, width, height, extState;
		// dockables
		public String top, left, bottom, right;
		public int topPos, leftPos, bottomPos, rightPos;
		public ViewConfig()
		{
		}
		public ViewConfig(boolean plainView)
		{
			this.plainView = plainView;
			String prefix = (plainView ? ""plain-view"" : ""view"");
			x = jEdit.getIntegerProperty(prefix + "".x"",0);
			y = jEdit.getIntegerProperty(prefix + "".y"",0);
			width = jEdit.getIntegerProperty(prefix + "".width"",0);
			height = jEdit.getIntegerProperty(prefix + "".height"",0);
		}
		public ViewConfig(boolean plainView, String splitConfig,
			int x, int y, int width, int height, int extState)
		{
			this.plainView = plainView;
			this.splitConfig = splitConfig;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.extState = extState;
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.browser.BrowserCommandsMenu,"/*
 * BrowserCommandsMenu.java - provides various commands
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 * Portions copyright (C) 1999 Jason Ginchereau
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA	02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * @version $Id: BrowserCommandsMenu.java,v 1.25 2004/07/12 19:25:07 spestov Exp $
 * @author Slava Pestov and Jason Ginchereau
 */
public class BrowserCommandsMenu extends JPopupMenu
{
	//{{{ BrowserCommandsMenu constructor
	public BrowserCommandsMenu(VFSBrowser browser, VFS.DirectoryEntry[] files)
	{
		this.browser = browser;
		if(files != null)
		{
			VFS vfs = VFSManager.getVFSForPath(files[0].deletePath);
			int type = files[0].type;
			boolean fileOpen = (jEdit.getBuffer(files[0].path) != null);
			boolean delete = !fileOpen && (vfs.getCapabilities() & VFS.DELETE_CAP) != 0;
			boolean rename = !fileOpen && (vfs.getCapabilities() & VFS.RENAME_CAP) != 0;
			for(int i = 1; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				VFS _vfs = VFSManager.getVFSForPath(file.deletePath);
				delete &= (vfs == _vfs) && (_vfs.getCapabilities()
					& VFS.DELETE_CAP) != 0;
				if(type == file.type)
					/* all good */;
				else
				{
					// this will disable most operations if
					// files of multiple types are selected
					type = -1;
				}
				// set rename to false if > 1 file selected
				rename = false;
				// show 'close' item if at least one selected
				// file is currently open
				if(jEdit.getBuffer(file.path) != null)
					fileOpen = true;
			}
			if(type == VFS.DirectoryEntry.DIRECTORY
				|| type == VFS.DirectoryEntry.FILESYSTEM)
			{
				if(files.length == 1)
					add(createMenuItem(""browse""));
				if(browser.getMode() == VFSBrowser.BROWSER)
					add(createMenuItem(""browse-window""));
			}
			else if(type == VFS.DirectoryEntry.FILE
				&& (browser.getMode() == VFSBrowser.BROWSER
				|| browser.getMode() == VFSBrowser.BROWSER_DIALOG))
			{
				add(createMenuItem(""open""));
				add(GUIUtilities.loadMenu(
					VFSBrowser.getActionContext(),
					""vfs.browser.open-in""));
				add(createMenuItem(""insert""));
				if(fileOpen)
					add(createMenuItem(""close""));
			}
			else if(type != -1)
				add(createMenuItem(""open""));
			if(rename)
				add(createMenuItem(""rename""));
			if(delete)
				add(createMenuItem(""delete""));
			add(createMenuItem(""copy-path""));
			addSeparator();
		}
		add(createMenuItem(""up""));
		add(createMenuItem(""reload""));
		add(createMenuItem(""roots""));
		add(createMenuItem(""home""));
		add(createMenuItem(""synchronize""));
		addSeparator();
		if(browser.getMode() == VFSBrowser.BROWSER)
			add(createMenuItem(""new-file""));
		add(createMenuItem(""new-directory""));
		if(browser.getMode() == VFSBrowser.BROWSER)
		{
			addSeparator();
			add(createMenuItem(""search-directory""));
		}
		addSeparator();
		add(createMenuItem(""show-hidden-files""));
		if(browser.getMode() == VFSBrowser.BROWSER
			|| browser.getMode() == VFSBrowser.BROWSER_DIALOG)
		{
			addSeparator();
			add(createEncodingMenu());
		}
		update();
	} //}}}
	//{{{ update() method
	public void update()
	{
		if(encodingMenuItems != null)
		{
			JRadioButtonMenuItem mi = (JRadioButtonMenuItem)
				encodingMenuItems.get(browser.currentEncoding);
			if(mi != null)
			{
				mi.setSelected(true);
				otherEncoding.setText(jEdit.getProperty(
					""vfs.browser.other-encoding.label""));
			}
			else
			{
				otherEncoding.setSelected(true);
				otherEncoding.setText(jEdit.getProperty(
					""vfs.browser.other-encoding-2.label"",
					new String[] { browser.currentEncoding }));
			}
		}
	} //}}}
	//{{{ Private members
	private VFSBrowser browser;
	private HashMap encodingMenuItems;
	private JCheckBoxMenuItem autoDetect;
	private JRadioButtonMenuItem otherEncoding;
	//{{{ createMenuItem() method
	private JMenuItem createMenuItem(String name)
	{
		return GUIUtilities.loadMenuItem(VFSBrowser.getActionContext(),
			""vfs.browser."" + name,false);
	} //}}}
	//{{{ createEncodingMenu() method
	private JMenu createEncodingMenu()
	{
		ActionHandler actionHandler = new ActionHandler();
		encodingMenuItems = new HashMap();
		JMenu encodingMenu = new JMenu(jEdit.getProperty(
			""vfs.browser.commands.encoding.label""));
		JMenu menu = encodingMenu;
		autoDetect = new JCheckBoxMenuItem(
			jEdit.getProperty(
			""vfs.browser.commands.encoding.auto-detect""));
		autoDetect.setSelected(browser.autoDetectEncoding);
		autoDetect.setActionCommand(""auto-detect"");
		autoDetect.addActionListener(actionHandler);
		menu.add(autoDetect);
		menu.addSeparator();
		ButtonGroup grp = new ButtonGroup();
		List encodingMenuItemList = new ArrayList();
		String[] encodings = MiscUtilities.getEncodings();
		for(int i = 0; i < encodings.length; i++)
		{
			String encoding = encodings[i];
			JRadioButtonMenuItem mi = new JRadioButtonMenuItem(encoding);
			mi.setActionCommand(""encoding@"" + encoding);
			mi.addActionListener(actionHandler);
			grp.add(mi);
			encodingMenuItems.put(encoding,mi);
			encodingMenuItemList.add(mi);
		}
		String systemEncoding = System.getProperty(""file.encoding"");
		if(encodingMenuItems.get(systemEncoding) == null)
		{
			JRadioButtonMenuItem mi = new JRadioButtonMenuItem(
				systemEncoding);
			mi.setActionCommand(""encoding@"" + systemEncoding);
			mi.addActionListener(actionHandler);
			grp.add(mi);
			encodingMenuItems.put(systemEncoding,mi);
			encodingMenuItemList.add(mi);
		}
		Collections.sort(encodingMenuItemList,
			new MiscUtilities.MenuItemCompare());
		Iterator iter = encodingMenuItemList.iterator();
		while(iter.hasNext())
		{
			JRadioButtonMenuItem mi = (JRadioButtonMenuItem)
				iter.next();
			if(menu.getMenuComponentCount() > 20)
			{
				JMenu newMenu = new JMenu(
					jEdit.getProperty(""common.more""));
				menu.add(newMenu);
				menu = newMenu;
			}
			menu.add(mi);
		}
		menu.addSeparator();
		otherEncoding = new JRadioButtonMenuItem();
		otherEncoding.setActionCommand(""other-encoding"");
		otherEncoding.addActionListener(actionHandler);
		grp.add(otherEncoding);
		menu.add(otherEncoding);
		return encodingMenu;
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			String actionCommand = evt.getActionCommand();
			if(actionCommand.equals(""auto-detect""))
			{
				browser.autoDetectEncoding
					= autoDetect.isSelected();
			}
			else if(actionCommand.equals(""other-encoding""))
			{
				String encoding = GUIUtilities.input(browser,
					""encoding-prompt"",null,
					jEdit.getProperty(""buffer.encoding"",
					System.getProperty(""file.encoding"")));
				if(encoding == null)
					return;
				browser.currentEncoding = encoding;
			}
			else if(actionCommand.startsWith(""encoding@""))
			{
				browser.currentEncoding = actionCommand.substring(9);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.browser.BrowserIORequest,"/*
 * BrowserIORequest.java - VFS browser I/O request
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
//}}}
/**
 * A browser I/O request.
 * @author Slava Pestov
 * @version $Id: BrowserIORequest.java,v 1.20 2004/05/29 01:55:24 spestov Exp $
 */
class BrowserIORequest extends WorkRequest
{
	//{{{ Request types
	/**
	 * Directory listing I/O request.
	 */
	public static final int LIST_DIRECTORY = 0;
	/**
	 * Delete file I/O request.
	 */
	public static final int DELETE = 1;
	/**
	 * Rename file I/O request.
	 */
	public static final int RENAME = 2;
	/**
	 * Make directory I/O request.
	 */
	public static final int MKDIR = 3;
	//}}}
	//{{{ BrowserIORequest constructor
	/**
	 * Creates a new browser I/O request.
	 * @param type The request type
	 * @param browser The VFS browser instance
	 * @param path1 The first path name to operate on
	 * @param path2 The second path name to operate on
	 * @param loadInfo A two-element array filled out by the request;
	 * element 1 is the canonical path, element 2 is the file list.
	 */
	BrowserIORequest(int type, VFSBrowser browser,
		Object session, VFS vfs, String path1, String path2,
		Object[] loadInfo)
	{
		this.type = type;
		this.browser = browser;
		this.session = session;
		this.vfs = vfs;
		this.path1 = path1;
		this.path2 = path2;
		this.loadInfo = loadInfo;
	} //}}}
	//{{{ run() method
	public void run()
	{
		switch(type)
		{
		case LIST_DIRECTORY:
			listDirectory();
			break;
		case DELETE:
			delete();
			break;
		case RENAME:
			rename();
			break;
		case MKDIR:
			mkdir();
			break;
		}
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LIST_DIRECTORY:
			typeString = ""LIST_DIRECTORY"";
			break;
		case DELETE:
			typeString = ""DELETE"";
			break;
		case RENAME:
			typeString = ""RENAME"";
			break;
		case MKDIR:
			typeString = ""MKDIR"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
			break;
		}
		return getClass().getName() + ""[type="" + typeString
			+ "",vfs="" + vfs + "",path1="" + path1
			+ "",path2="" + path2 + ""]"";
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private int type;
	private VFSBrowser browser;
	private Object session;
	private VFS vfs;
	private String path1;
	private String path2;
	private Object[] loadInfo;
	//}}}
	//{{{ listDirectory() method
	private void listDirectory()
	{
		VFS.DirectoryEntry[] directory = null;
		String[] args = { path1 };
		setStatus(jEdit.getProperty(""vfs.status.listing-directory"",args));
		String canonPath = path1;
		try
		{
			setAbortable(true);
			canonPath = vfs._canonPath(session,path1,browser);
			directory = vfs._listDirectory(session,canonPath,browser);
		}
		catch(IOException io)
		{
			setAbortable(false);
			Log.log(Log.ERROR,this,io);
			String[] pp = { io.toString() };
			VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		setAbortable(false);
		loadInfo[0] = canonPath;
		loadInfo[1] = directory;
	} //}}}
	//{{{ delete() method
	private void delete()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.deleting"",args));
			try
			{
				path1 = vfs._canonPath(session,path1,browser);
				if(!vfs._delete(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.delete-error"",null);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} //}}}
	//{{{ rename() method
	private void rename()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1, path2 };
			setStatus(jEdit.getProperty(""vfs.status.renaming"",args));
			try
			{
				path1 = vfs._canonPath(session,path1,browser);
				path2 = vfs._canonPath(session,path2,browser);
				VFS.DirectoryEntry file = vfs._getDirectoryEntry(
					session,path2,browser);
				if(file != null)
				{
					if((OperatingSystem.isDOSDerived()
						|| OperatingSystem.isMacOS())
						&& path1.equalsIgnoreCase(path2))
					{
						// allow user to change name
						// case
					}
					else
					{
						VFSManager.error(browser,path1,
							""ioerror.rename-exists"",
							new String[] { path2 });
						return;
					}
				}
				if(!vfs._rename(session,path1,path2,browser))
					VFSManager.error(browser,path1,""ioerror.rename-error"",
						new String[] { path2 });
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} //}}}
	//{{{ mkdir() method
	private void mkdir()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.mkdir"",args));
			try
			{
				path1 = vfs._canonPath(session,path1,browser);
				if(!vfs._mkdir(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.mkdir-error"",null);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				args[0] = io.toString();
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] args = { io.toString() };
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.browser.BrowserListener,"/*
 * BrowserListener.java - VFS browser listener
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import java.util.EventListener;
import org.gjt.sp.jedit.io.VFS;
/**
 * A browser event listener.
 * @author Slava Pestov
 * @version $Id: BrowserListener.java,v 1.2 2001/09/08 04:50:46 spestov Exp $
 */
public interface BrowserListener extends EventListener
{
	/**
	 * The user has selected a set of files.
	 * @param browser The VFS browser
	 * @param files The selected files
	 */
	void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files);
	/**
	 * The user has double-clicked a set of files.
	 * @param browser The VFS browser
	 * @param files The selected files
	 */
	void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files);
}
"
org.gjt.sp.jedit.browser.BrowserView,"/*
 * BrowserView.java
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * VFS browser tree view.
 * @author Slava Pestov
 * @version $Id: BrowserView.java,v 1.79 2004/05/29 01:55:24 spestov Exp $
 */
class BrowserView extends JPanel
{
	//{{{ BrowserView constructor
	public BrowserView(final VFSBrowser browser)
	{
		this.browser = browser;
		tmpExpanded = new HashSet();
		parentDirectories = new JList();
		parentDirectories.getSelectionModel().setSelectionMode(
			ListSelectionModel.SINGLE_SELECTION);
		parentDirectories.setCellRenderer(new ParentDirectoryRenderer());
		parentDirectories.setVisibleRowCount(5);
		parentDirectories.addMouseListener(new ParentMouseHandler());
		final JScrollPane parentScroller = new JScrollPane(parentDirectories);
		parentScroller.setMinimumSize(new Dimension(0,0));
		table = new VFSDirectoryEntryTable(this);
		table.addMouseListener(new TableMouseHandler());
		JScrollPane tableScroller = new JScrollPane(table);
		tableScroller.setMinimumSize(new Dimension(0,0));
		tableScroller.getViewport().setBackground(table.getBackground());
		tableScroller.getViewport().addMouseListener(new TableMouseHandler());
		splitPane = new JSplitPane(
			browser.isHorizontalLayout()
			? JSplitPane.HORIZONTAL_SPLIT : JSplitPane.VERTICAL_SPLIT,
			parentScroller,tableScroller);
		splitPane.setOneTouchExpandable(true);
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				String prop = browser.isHorizontalLayout() ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
				int loc = jEdit.getIntegerProperty(prop,-1);
				if(loc == -1)
					loc = parentScroller.getPreferredSize().height;
				splitPane.setDividerLocation(loc);
				parentDirectories.ensureIndexIsVisible(
					parentDirectories.getModel()
					.getSize());
			}
		});
		if(browser.isMultipleSelectionEnabled())
			table.getSelectionModel().setSelectionMode(
				ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		else
			table.getSelectionModel().setSelectionMode(
				ListSelectionModel.SINGLE_SELECTION);
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER,splitPane);
		propertiesChanged();
	} //}}}
	//{{{ focusOnFileView() method
	public void focusOnFileView()
	{
		table.requestFocus();
	} //}}}
	//{{{ removeNotify() method
	public void removeNotify()
	{
		String prop = browser.isHorizontalLayout() ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
		jEdit.setIntegerProperty(prop,splitPane.getDividerLocation());
		super.removeNotify();
	} //}}}
	//{{{ getSelectedFiles() method
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		return table.getSelectedFiles();
	} //}}}
	//{{{ selectNone() method
	public void selectNone()
	{
		table.clearSelection();
	} //}}}
	//{{{ saveExpansionState() method
	public void saveExpansionState()
	{
		tmpExpanded.clear();
		table.getExpandedDirectories(tmpExpanded);
	} //}}}
	//{{{ clearExpansionState() method
	public void clearExpansionState()
	{
		tmpExpanded.clear();
	} //}}}
	//{{{ loadDirectory() method
	public void loadDirectory(Object node, String path)
	{
		path = MiscUtilities.constructPath(browser.getDirectory(),path);
		VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;
		if(node == null)
		{
			parentDirectories.setListData(new Object[] {
				new LoadingPlaceholder() });
		}
		Object[] loadInfo = new Object[2];
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.LIST_DIRECTORY,browser,
			session,vfs,path,null,loadInfo));
		browser.directoryLoaded(node,loadInfo);
	} //}}}
	//{{{ directoryLoaded() method
	public void directoryLoaded(Object node, String path, ArrayList directory)
	{
		//{{{ If reloading root, update parent directory list
		if(node == null)
		{
			DefaultListModel parentList = new DefaultListModel();
			String parent = path;
			for(;;)
			{
				VFS _vfs = VFSManager.getVFSForPath(
					parent);
				// create a DirectoryEntry manually
				// instead of using _vfs._getDirectoryEntry()
				// since so many VFS's have broken
				// implementations of this method
				parentList.insertElementAt(new VFS.DirectoryEntry(
					_vfs.getFileName(parent),
					parent,parent,
					VFS.DirectoryEntry.DIRECTORY,
					0L,false),0);
				String newParent = _vfs.getParentOfPath(parent);
				if(newParent == null ||
					VFSBrowser.pathsEqual(parent,newParent))
					break;
				else
					parent = newParent;
			}
			parentDirectories.setModel(parentList);
			int index = parentList.getSize() - 1;
			parentDirectories.setSelectedIndex(index);
			parentDirectories.ensureIndexIsVisible(index);
		} //}}}
		table.setDirectory(VFSManager.getVFSForPath(path),
			node,directory,tmpExpanded);
	} //}}}
	//{{{ updateFileView() method
	public void updateFileView()
	{
		table.repaint();
	} //}}}
	//{{{ maybeReloadDirectory() method
	public void maybeReloadDirectory(String path)
	{
		String browserDir = browser.getDirectory();
		String symlinkBrowserDir;
		if(MiscUtilities.isURL(browserDir))
		{
			symlinkBrowserDir = browserDir;
		}
		else
		{
			symlinkBrowserDir = MiscUtilities.resolveSymlinks(
				browserDir);
		}
		if(VFSBrowser.pathsEqual(path,symlinkBrowserDir))
		{
			saveExpansionState();
			loadDirectory(null,browserDir);
		}
		// because this method is called for *every* VFS update,
		// we don't want to scan the tree all the time. So we
		// use the following algorithm to determine if the path
		// might be part of the tree:
		// - if the path starts with the browser's current directory,
		//   we do the tree scan
		// - if the browser's directory is 'favorites:' -- we have to
		//   do the tree scan, as every path can appear under the
		//   favorites list
		// - if the browser's directory is 'roots:' and path is on
		//   the local filesystem, do a tree scan
		if(!browserDir.startsWith(FavoritesVFS.PROTOCOL)
			&& !browserDir.startsWith(FileRootsVFS.PROTOCOL)
			&& !path.startsWith(symlinkBrowserDir))
			return;
		if(browserDir.startsWith(FileRootsVFS.PROTOCOL)
			&& MiscUtilities.isURL(path)
			&& !MiscUtilities.getProtocolOfURL(path)
			.equals(""file""))
			return;
		table.maybeReloadDirectory(path);
	} //}}}
	//{{{ propertiesChanged() method
	public void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		table.propertiesChanged();
		splitPane.setBorder(null);
	} //}}}
	//{{{ getBrowser() method
	/**
	 * Returns the associated <code>VFSBrowser</code> instance.
	 * @since jEdit 4.2pre1
	 */
	public VFSBrowser getBrowser()
	{
		return browser;
	} //}}}
	//{{{ getTable() method
	public VFSDirectoryEntryTable getTable()
	{
		return table;
	} //}}}
	//{{{ getParentDirectoryList() method
	public JList getParentDirectoryList()
	{
		return parentDirectories;
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private VFSBrowser browser;
	private JSplitPane splitPane;
	private JList parentDirectories;
	private VFSDirectoryEntryTable table;
	private Set tmpExpanded;
	private BrowserCommandsMenu popup;
	private boolean showIcons;
	//}}}
	//{{{ showFilePopup() method
	private void showFilePopup(VFS.DirectoryEntry[] files, Component comp,
		Point point)
	{
		popup = new BrowserCommandsMenu(browser,files);
		// for the parent directory right-click; on the click we select
		// the clicked item, but when the popup goes away we select the
		// currently showing directory.
		popup.addPopupMenuListener(new PopupMenuListener()
		{
			public void popupMenuCanceled(PopupMenuEvent e) {}
			public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}
			public void popupMenuWillBecomeInvisible(PopupMenuEvent e)
			{
				// we use SwingUtilities.invokeLater()
				// so that the action is executed before
				// the popup is hidden.
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						int index = parentDirectories
							.getModel()
							.getSize() - 1;
						parentDirectories.setSelectedIndex(index);
					}
				});
			}
		});
		GUIUtilities.showPopupMenu(popup,comp,point.x,point.y);
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ParentDirectoryRenderer class
	class ParentDirectoryRenderer extends DefaultListCellRenderer
	{
		Font plainFont, boldFont;
		ParentDirectoryRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			if(plainFont == null)
				plainFont = jEdit.getFontProperty(""metal.secondary.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		}
		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			ParentDirectoryRenderer.this.setBorder(new EmptyBorder(
				1,index * 5 + 1,1,1));
			if(value instanceof LoadingPlaceholder)
			{
				ParentDirectoryRenderer.this.setFont(plainFont);
				setIcon(showIcons ? FileCellRenderer.loadingIcon : null);
				setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			}
			else if(value instanceof VFS.DirectoryEntry)
			{
				VFS.DirectoryEntry dirEntry = (VFS.DirectoryEntry)value;
				ParentDirectoryRenderer.this.setFont(boldFont);
				setIcon(showIcons ? FileCellRenderer.getIconForFile(dirEntry,true)
					: null);
				setText(dirEntry.name);
			}
			else if(value == null)
				setText(""VFS does not follow VFS API"");
			return this;
		}
	} //}}}
	//{{{ ParentMouseHandler class
	class ParentMouseHandler extends MouseAdapter
	{
		public void mousePressed(MouseEvent evt)
		{
			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentDirectories.getModel()
					.getElementAt(row);
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry dirEntry = ((VFS.DirectoryEntry)obj);
					if(GUIUtilities.isPopupTrigger(evt))
					{
						if(popup != null && popup.isVisible())
						{
							popup.setVisible(false);
							popup = null;
						}
						else
						{
							parentDirectories.setSelectedIndex(row);
							showFilePopup(new VFS.DirectoryEntry[] {
								dirEntry },parentDirectories,
								evt.getPoint());
						}
					}
				}
			}
		}
		public void mouseReleased(MouseEvent evt)
		{
			if(evt.getClickCount() % 2 != 0 &&
				!GUIUtilities.isMiddleButton(evt.getModifiers()))
				return;
			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentDirectories.getModel()
					.getElementAt(row);
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry dirEntry = ((VFS.DirectoryEntry)obj);
					if(!GUIUtilities.isPopupTrigger(evt))
					{
						browser.setDirectory(dirEntry.path);
						if(browser.getMode() == VFSBrowser.BROWSER)
						focusOnFileView();
					}
				}
			}
		}
	} //}}}
	//{{{ TableMouseHandler class
	class TableMouseHandler extends MouseAdapter
	{
		//{{{ mouseClicked() method
		public void mouseClicked(MouseEvent evt)
		{
			Point p = evt.getPoint();
			int row = table.rowAtPoint(p);
			int column = table.columnAtPoint(p);
			if(row == -1)
				return;
			if(column == 0)
			{
				VFSDirectoryEntryTableModel.Entry entry
					= (VFSDirectoryEntryTableModel.Entry)
					table.getModel().getValueAt(row,0);
				if(FileCellRenderer.ExpansionToggleBorder
					.isExpansionToggle(entry.level,p.x))
				{
					return;
				}
			}
			if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0
				&& evt.getClickCount() % 2 == 0)
			{
				browser.filesActivated((evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN),true);
			}
			else if(GUIUtilities.isMiddleButton(evt.getModifiers()))
			{
				if(evt.isShiftDown())
					table.getSelectionModel().addSelectionInterval(row,row);
				else
					table.getSelectionModel().setSelectionInterval(row,row);
				browser.filesActivated((evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN),true);
			}
		} //}}}
		//{{{ mousePressed() method
		public void mousePressed(MouseEvent evt)
		{
			Point p = evt.getPoint();
			if(evt.getSource() != table)
			{
				p.x -= table.getX();
				p.y -= table.getY();
			}
			int row = table.rowAtPoint(p);
			int column = table.columnAtPoint(p);
			if(column == 0 && row != -1)
			{
				VFSDirectoryEntryTableModel.Entry entry
					= (VFSDirectoryEntryTableModel.Entry)
					table.getModel().getValueAt(row,0);
				if(FileCellRenderer.ExpansionToggleBorder
					.isExpansionToggle(entry.level,p.x))
				{
					table.toggleExpanded(row);
					return;
				}
			}
			if(GUIUtilities.isMiddleButton(evt.getModifiers()))
			{
				if(row == -1)
					/* nothing */;
				else if(evt.isShiftDown())
					table.getSelectionModel().addSelectionInterval(row,row);
				else
					table.getSelectionModel().setSelectionInterval(row,row);
			}
			else if(GUIUtilities.isPopupTrigger(evt))
			{
				if(popup != null && popup.isVisible())
				{
					popup.setVisible(false);
					popup = null;
					return;
				}
				if(row == -1)
					showFilePopup(null,table,evt.getPoint());
				else
				{
					if(!table.getSelectionModel().isSelectedIndex(row))
						table.getSelectionModel().setSelectionInterval(row,row);
					showFilePopup(getSelectedFiles(),table,evt.getPoint());
				}
			}
		} //}}}
		//{{{ mouseReleased() method
		public void mouseReleased(MouseEvent evt)
		{
			if(!GUIUtilities.isPopupTrigger(evt)
				&& table.getSelectedRow() != -1)
			{
				browser.filesSelected();
			}
		} //}}}
	} //}}}
	static class LoadingPlaceholder {}
	//}}}
}
"
org.gjt.sp.jedit.browser.FileCellRenderer,"/*
 * FileCellRenderer.java - renders table cells for the VFS browser
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999 Jason Ginchereau
 * Portions copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import java.awt.*;
import java.awt.font.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.table.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;
//}}}
public class FileCellRenderer extends DefaultTableCellRenderer
{
	public static Icon fileIcon = GUIUtilities.loadIcon(""File.png"");
	public static Icon openFileIcon = GUIUtilities.loadIcon(""OpenFile.png"");
	public static Icon dirIcon = GUIUtilities.loadIcon(""Folder.png"");
	public static Icon openDirIcon = GUIUtilities.loadIcon(""OpenFolder.png"");
	public static Icon filesystemIcon = GUIUtilities.loadIcon(""DriveSmall.png"");
	public static Icon loadingIcon = GUIUtilities.loadIcon(""ReloadSmall.png"");
	//{{{ FileCellRenderer constructor
	public FileCellRenderer()
	{
		plainFont = UIManager.getFont(""Tree.font"");
		if(plainFont == null)
			plainFont = jEdit.getFontProperty(""metal.secondary.font"");
		boldFont = plainFont.deriveFont(Font.BOLD);
	} //}}}
	//{{{ getTableCellRendererComponent() method
	public Component getTableCellRendererComponent(JTable table,
		Object value, boolean isSelected, boolean hasFocus, 
		int row, int column)
	{
		super.getTableCellRendererComponent(table,value,isSelected,
			hasFocus,row,column);
		if(value instanceof VFSDirectoryEntryTableModel.Entry)
		{
			VFSDirectoryEntryTableModel.Entry entry =
				(VFSDirectoryEntryTableModel.Entry)value;
			VFS.DirectoryEntry file = entry.dirEntry;
			setFont(file.type == VFS.DirectoryEntry.FILE
				? plainFont : boldFont);
			this.isSelected = isSelected;
			this.file = file;
			if(column == 0)
			{
				// while its broken to have a null
				// symlinkPath, some older plugins
				// might...
				String path;
				if(file.symlinkPath == null)
					path = file.path;
				else
					path = file.symlinkPath;
				openBuffer = (jEdit._getBuffer(path) != null);
				setIcon(showIcons
					? getIconForFile(file,entry.expanded,
					openBuffer) : null);
				setText(file.name);
				int state;
				if(file.type == VFS.DirectoryEntry.FILE)
					state = ExpansionToggleBorder.STATE_NONE;
				else if(entry.expanded)
					state = ExpansionToggleBorder.STATE_EXPANDED;
				else
					state = ExpansionToggleBorder.STATE_COLLAPSED;
				setBorder(new ExpansionToggleBorder(
					state,entry.level));
			}
			else
			{
				VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)table.getModel();
				String extAttr = model.getExtendedAttribute(column - 1);
				openBuffer = false;
				setIcon(null);
				setText(file.getExtendedAttribute(extAttr));
				setBorder(new EmptyBorder(1,1,1,1));
			}
		}
		return this;
	} //}}}
	//{{{ paintComponent() method
	public void paintComponent(Graphics g)
	{
		if(!isSelected)
		{
			Color color = file.getColor();
			setForeground(color == null
				? UIManager.getColor(""Tree.foreground"")
				: color);
		}
		super.paintComponent(g);
		if(openBuffer)
		{
			Font font = getFont();
			FontMetrics fm = getFontMetrics(font);
			int x, y;
			if(getIcon() == null)
			{
				x = 0;
				y = fm.getAscent() + 2;
			}
			else
			{
				x = getIcon().getIconWidth() + getIconTextGap();
				y = Math.max(fm.getAscent() + 2,16);
			}
			Insets border = getBorder().getBorderInsets(this);
			x += border.left;
			g.setColor(getForeground());
			g.drawLine(x,y,x + fm.stringWidth(getText()),y);
		}
	} //}}}
	//{{{ getIconForFile() method
	/**
	 * @since jEdit 4.2pre7
	 */
	public static Icon getIconForFile(VFS.DirectoryEntry file,
		boolean expanded)
	{
		return getIconForFile(file,expanded,
			jEdit._getBuffer(file.symlinkPath) != null);
	} //}}}
	//{{{ getIconForFile() method
	public static Icon getIconForFile(VFS.DirectoryEntry file,
		boolean expanded, boolean openBuffer)
	{
		if(file.type == VFS.DirectoryEntry.DIRECTORY)
			return (expanded ? openDirIcon : dirIcon);
		else if(file.type == VFS.DirectoryEntry.FILESYSTEM)
			return filesystemIcon;
		else if(openBuffer)
			return openFileIcon;
		else
			return fileIcon;
	} //}}}
	//{{{ Package-private members
	Font plainFont;
	Font boldFont;
	boolean showIcons;
	//{{{ propertiesChanged() method
	void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
	} //}}}
	//{{{ getEntryWidth() method
	int getEntryWidth(VFSDirectoryEntryTableModel.Entry entry,
		Font font, FontRenderContext fontRenderContext)
	{
		String name = entry.dirEntry.name;
		int width = (int)font.getStringBounds(name,fontRenderContext)
			.getWidth();
		width += ExpansionToggleBorder.ICON_WIDTH
			+ entry.level * ExpansionToggleBorder.LEVEL_WIDTH
			+ 3;
		if(showIcons)
		{
			width += fileIcon.getIconWidth();
			width += getIconTextGap();
		}
		return width;
	} //}}}
	//}}}
	//{{{ Private members
	private boolean openBuffer;
	private boolean isSelected;
	private VFS.DirectoryEntry file;
	//}}}
	//{{{ ExpansionToggleBorder class
	static class ExpansionToggleBorder implements Border
	{
		static final Icon COLLAPSED_ICON;
		static final Icon EXPANDED_ICON;
		static final int ICON_WIDTH;
		static final int LEVEL_WIDTH = 15;
		static final int STATE_NONE = 0;
		static final int STATE_COLLAPSED = 1;
		static final int STATE_EXPANDED = 2;
		//{{{ ExpansionToggleBorder constructor
		public ExpansionToggleBorder(int state, int level)
		{
			this.state = state;
			this.level = level;
		} //}}}
		//{{{ paintBorder() method
		public void paintBorder(Component c, Graphics g,
			int x, int y, int width, int height)
		{
			switch(state)
			{
			case STATE_COLLAPSED:
				COLLAPSED_ICON.paintIcon(c,g,
					x + level * LEVEL_WIDTH + 2,
					y + (height - COLLAPSED_ICON.getIconHeight()) / 2);
				break;
			case STATE_EXPANDED:
				EXPANDED_ICON.paintIcon(c,g,
					x + level * LEVEL_WIDTH + 2,
					y + 2 + (height - EXPANDED_ICON.getIconHeight()) / 2);
				break;
			}
		} //}}}
		//{{{ getBorderInsets() method
		public Insets getBorderInsets(Component c)
		{
			return new Insets(1,level * LEVEL_WIDTH
				+ ICON_WIDTH + 4,1,1);
		} //}}}
		//{{{ isBorderOpaque() method
		public boolean isBorderOpaque()
		{
			return false;
		} //}}}
		//{{{ isExpansionToggle() method
		public static boolean isExpansionToggle(int level, int x)
		{
			return (x >= level * LEVEL_WIDTH)
				&& (x <= level * LEVEL_WIDTH + ICON_WIDTH);
		} //}}}
		//{{{ Private members
		private int state;
		private int level;
		static
		{
			COLLAPSED_ICON = GUIUtilities.loadIcon(""arrow1.png"");
			EXPANDED_ICON = GUIUtilities.loadIcon(""arrow2.png"");
			ICON_WIDTH = Math.max(COLLAPSED_ICON.getIconWidth(),
				EXPANDED_ICON.getIconWidth());
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.browser.VFSBrowser,"/*
 * VFSBrowser.java - VFS browser
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import bsh.*;
import gnu.regexp.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * The main class of the VFS browser.
 * @author Slava Pestov
 * @version $Id: VFSBrowser.java,v 1.110 2004/07/14 05:18:50 spestov Exp $
 */
public class VFSBrowser extends JPanel implements EBComponent, DefaultFocusComponent
{
	public static final String NAME = ""vfs.browser"";
	//{{{ Browser types
	/**
	 * Open file dialog mode. Equals JFileChooser.OPEN_DIALOG for
	 * backwards compatibility.
	 */
	public static final int OPEN_DIALOG = 0;
	/**
	 * Save file dialog mode. Equals JFileChooser.SAVE_DIALOG for
	 * backwards compatibility.
	 */
	public static final int SAVE_DIALOG = 1;
	/**
	 * Choose directory dialog mode.
	 */
	public static final int BROWSER_DIALOG = 4;
	/**
	 * Choose directory dialog mode.
	 */
	public static final int CHOOSE_DIRECTORY_DIALOG = 3;
	/**
	 * Stand-alone browser mode.
	 */
	public static final int BROWSER = 2;
	//}}}
	//{{{ browseDirectoryInNewWindow() method
	/**
	 * Opens the specified directory in a new, floating, file system browser.
	 * @param view The view
	 * @param path The directory's path
	 * @since jEdit 4.1pre2
	 */
	public static void browseDirectoryInNewWindow(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		if(path != null)
		{
			// this is such a bad way of doing it, but oh well...
			jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
		}
		wm.floatDockableWindow(""vfs.browser"");
		jEdit.unsetProperty(""vfs.browser.path.tmp"");
	} //}}}
	//{{{ browseDirectory() method
	/**
	 * Opens the specified directory in a file system browser.
	 * @param view The view
	 * @param path The directory's path
	 * @since jEdit 4.0pre3
	 */
	public static void browseDirectory(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		VFSBrowser browser = (VFSBrowser)wm.getDockable(NAME);
		if(browser != null)
		{
			wm.showDockableWindow(NAME);
			browser.setDirectory(path);
		}
		else
		{
			if(path != null)
			{
				// this is such a bad way of doing it, but oh well...
				jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
			}
			wm.addDockableWindow(""vfs.browser"");
			jEdit.unsetProperty(""vfs.browser.path.tmp"");
		}
	} //}}}
	//{{{ getActionContext() method
	/**
	 * Returns the browser action context.
	 * @since jEdit 4.2pre1
	 */
	public static ActionContext getActionContext()
	{
		return actionContext;
	} //}}}
	//{{{ VFSBrowser constructor
	/**
	 * Creates a new VFS browser.
	 * @param view The view to open buffers in by default
	 */
	public VFSBrowser(View view, String position)
	{
		this(view,null,BROWSER,true,position);
	} //}}}
	//{{{ VFSBrowser constructor
	/**
	 * Creates a new VFS browser.
	 * @param view The view to open buffers in by default
	 * @param path The path to display
	 * @param mode The browser mode
	 * @param multipleSelection True if multiple selection should be allowed
	 * @param position Where the browser is located
	 * @since jEdit 4.2pre1
	 */
	public VFSBrowser(View view, String path, int mode,
		boolean multipleSelection, String position)
	{
		super(new BorderLayout());
		listenerList = new EventListenerList();
		this.mode = mode;
		this.multipleSelection = multipleSelection;
		this.view = view;
		currentEncoding = jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding""));
		autoDetectEncoding = jEdit.getBooleanProperty(
			""buffer.encodingAutodetect"");
		ActionHandler actionHandler = new ActionHandler();
		Box topBox = new Box(BoxLayout.Y_AXIS);
		horizontalLayout = (mode != BROWSER
			|| DockableWindowManager.TOP.equals(position)
			|| DockableWindowManager.BOTTOM.equals(position));
		toolbarBox = new Box(horizontalLayout
			? BoxLayout.X_AXIS
			: BoxLayout.Y_AXIS);
		topBox.add(toolbarBox);
		GridBagLayout layout = new GridBagLayout();
		JPanel pathAndFilterPanel = new JPanel(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.EAST;
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.path""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		pathAndFilterPanel.add(label);
		pathField = new HistoryTextField(""vfs.browser.path"");
		pathField.setInstantPopups(true);
		pathField.setEnterAddsToHistory(false);
		pathField.setSelectAllOnFocus(true);
		// because its preferred size can be quite wide, we
		// don't want it to make the browser way too big,
		// so set the preferred width to 0.
		Dimension prefSize = pathField.getPreferredSize();
		prefSize.width = 0;
		pathField.setPreferredSize(prefSize);
		pathField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(pathField,cons);
		pathAndFilterPanel.add(pathField);
		filterCheckbox = new JCheckBox(jEdit.getProperty(""vfs.browser.filter""));
		filterCheckbox.setMargin(new Insets(0,0,0,0));
		filterCheckbox.setRequestFocusEnabled(false);
		filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));
		filterCheckbox.setSelected(jEdit.getBooleanProperty(
			""vfs.browser.filter-enabled""));
		filterCheckbox.addActionListener(actionHandler);
		if(mode != CHOOSE_DIRECTORY_DIALOG)
		{
			cons.gridx = 0;
			cons.weightx = 0.0f;
			cons.gridy = 1;
			layout.setConstraints(filterCheckbox,cons);
			pathAndFilterPanel.add(filterCheckbox);
		}
		filterField = new HistoryTextField(""vfs.browser.filter"");
		filterField.setInstantPopups(true);
		filterField.setSelectAllOnFocus(true);
		filterField.addActionListener(actionHandler);
		if(mode != CHOOSE_DIRECTORY_DIALOG)
		{
			cons.gridx = 1;
			cons.weightx = 1.0f;
			layout.setConstraints(filterField,cons);
			pathAndFilterPanel.add(filterField);
		}
		topBox.add(pathAndFilterPanel);
		add(BorderLayout.NORTH,topBox);
		add(BorderLayout.CENTER,browserView = new BrowserView(this));
		propertiesChanged();
		String filter;
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			filter = jEdit.getProperty(""vfs.browser.last-filter"");
			if(filter == null)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
		}
		else
		{
			String ext = MiscUtilities.getFileExtension(
				view.getBuffer().getName());
			if(ext.length() == 0)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
			else
				filter = ""*"" + ext;
		}
		filterField.setText(filter);
		filterField.addCurrentToHistory();
		updateFilterEnabled();
		// see VFSBrowser.browseDirectory()
		if(path == null)
			path = jEdit.getProperty(""vfs.browser.path.tmp"");
		if(path == null || path.length() == 0)
		{
			String userHome = System.getProperty(""user.home"");
			String defaultPath = jEdit.getProperty(""vfs.browser.defaultPath"");
			if(defaultPath.equals(""home""))
				path = userHome;
			else if(defaultPath.equals(""working""))
				path = System.getProperty(""user.dir"");
			else if(defaultPath.equals(""buffer""))
			{
				if(view != null)
				{
					Buffer buffer = view.getBuffer();
					path = buffer.getDirectory();
				}
				else
					path = userHome;
			}
			else if(defaultPath.equals(""last""))
			{
				HistoryModel pathModel = HistoryModel.getModel(""vfs.browser.path"");
				if(pathModel.getSize() == 0)
					path = ""~"";
				else
					path = pathModel.getItem(0);
			}
			else if(defaultPath.equals(""favorites""))
				path = ""favorites:"";
			else
			{
				// unknown value??!!!
				path = userHome;
			}
		}
		final String _path = path;
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				setDirectory(_path);
			}
		});
	} //}}}
	//{{{ focusOnDefaultComponent() method
	public void focusOnDefaultComponent()
	{
		browserView.focusOnFileView();
	} //}}}
	//{{{ addNotify() method
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} //}}}
	//{{{ removeNotify() method
	public void removeNotify()
	{
		super.removeNotify();
		jEdit.setBooleanProperty(""vfs.browser.filter-enabled"",
			filterCheckbox.isSelected());
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			jEdit.setProperty(""vfs.browser.last-filter"",
				filterField.getText());
		}
		EditBus.removeFromBus(this);
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			if(bmsg.getWhat() == BufferUpdate.CREATED
				|| bmsg.getWhat() == BufferUpdate.CLOSED)
				browserView.updateFileView();
			// hacked BufferIORequest to send VFSUpdates in case
			// two stage save is off now...
			/* else if(bmsg.getWhat() == BufferUpdate.SAVED)
			{
				maybeReloadDirectory(MiscUtilities.getParentOfPath(
					bmsg.getBuffer().getPath()));
			} */
		}
		else if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if(pmsg.getWhat() == PluginUpdate.LOADED
				|| pmsg.getWhat() == PluginUpdate.UNLOADED)
			{
				plugins.updatePopupMenu();
			}
		}
		else if(msg instanceof VFSUpdate)
		{
			maybeReloadDirectory(((VFSUpdate)msg).getPath());
		}
	} //}}}
	//{{{ getView() method
	public View getView()
	{
		return view;
	} //}}}
	//{{{ getMode() method
	public int getMode()
	{
		return mode;
	} //}}}
	//{{{ isMultipleSelectionEnabled() method
	public boolean isMultipleSelectionEnabled()
	{
		return multipleSelection;
	} //}}}
	//{{{ isHorizontalLayout() method
	public boolean isHorizontalLayout()
	{
		return horizontalLayout;
	} //}}}
	//{{{ getShowHiddenFiles() method
	public boolean getShowHiddenFiles()
	{
		return showHiddenFiles;
	} //}}}
	//{{{ setShowHiddenFiles() method
	public void setShowHiddenFiles(boolean showHiddenFiles)
	{
		this.showHiddenFiles = showHiddenFiles;
	} //}}}
	//{{{ getFilenameFilter() method
	/**
	 * Returns the file name filter glob.
	 * @since jEdit 3.2pre2
	 */
	public String getFilenameFilter()
	{
		if(filterCheckbox.isSelected())
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				return ""*"";
			else
				return filter;
		}
		else
			return ""*"";
	} //}}}
	//{{{ setFilenameFilter() method
	public void setFilenameFilter(String filter)
	{
		if(filter == null || filter.length() == 0 || filter.equals(""*""))
			filterCheckbox.setSelected(false);
		else
		{
			filterCheckbox.setSelected(true);
			filterField.setText(filter);
		}
	} //}}}
	//{{{ getDirectoryField() method
	public HistoryTextField getDirectoryField()
	{
		return pathField;
	} //}}}
	//{{{ getDirectory() method
	public String getDirectory()
	{
		return path;
	} //}}}
	//{{{ setDirectory() method
	public void setDirectory(String path)
	{
		if(path.startsWith(""file:""))
			path = path.substring(5);
		pathField.setText(path);
		if(!startRequest())
			return;
		updateFilenameFilter();
		browserView.saveExpansionState();
		browserView.loadDirectory(null,path);
		this.path = path;
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} //}}}
	//{{{ rootDirectory() method
	/**
	 * Goes to the local drives directory.
	 * @since jEdit 4.0pre4
	 */
	public void rootDirectory()
	{
		if(OperatingSystem.isMacOS() || OperatingSystem.isDOSDerived())
			setDirectory(FileRootsVFS.PROTOCOL + "":"");
		else
			setDirectory(""/"");
	} //}}}
	//{{{ reloadDirectory() method
	public void reloadDirectory()
	{
		// used by FTP plugin to clear directory cache
		VFSManager.getVFSForPath(path).reloadDirectory(path);
		updateFilenameFilter();
		browserView.saveExpansionState();
		browserView.loadDirectory(null,path);
	} //}}}
	//{{{ delete() method
	/**
	 * Note that all files must be on the same VFS.
	 */
	public void delete(VFS.DirectoryEntry[] files)
	{
		String dialogType;
		if(MiscUtilities.isURL(files[0].deletePath)
			&& FavoritesVFS.PROTOCOL.equals(
			MiscUtilities.getProtocolOfURL(files[0].deletePath)))
		{
			dialogType = ""vfs.browser.delete-favorites"";
		}
		else
		{
			dialogType = ""vfs.browser.delete-confirm"";
		}
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < files.length; i++)
		{
			buf.append(files[i].path);
			buf.append('\n');
		}
		Object[] args = { buf.toString() };
		int result = GUIUtilities.confirm(this,dialogType,args,
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE);
		if(result != JOptionPane.YES_OPTION)
			return;
		VFS vfs = VFSManager.getVFSForPath(files[0].deletePath);
		if(!startRequest())
			return;
		for(int i = 0; i < files.length; i++)
		{
			Object session = vfs.createVFSSession(files[i].deletePath,this);
			if(session == null)
				continue;
			VFSManager.runInWorkThread(new BrowserIORequest(
				BrowserIORequest.DELETE,this,
				session,vfs,files[i].deletePath,
				null,null));
		}
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} //}}}
	//{{{ rename() method
	public void rename(String from)
	{
		VFS vfs = VFSManager.getVFSForPath(from);
		String filename = vfs.getFileName(from);
		String[] args = { filename };
		String to = GUIUtilities.input(this,""vfs.browser.rename"",
			args,filename);
		if(to == null)
			return;
		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);
		Object session = vfs.createVFSSession(from,this);
		if(session == null)
			return;
		if(!startRequest())
			return;
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.RENAME,this,
			session,vfs,from,to,null));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} //}}}
	//{{{ mkdir() method
	public void mkdir()
	{
		String newDirectory = GUIUtilities.input(this,""vfs.browser.mkdir"",null);
		if(newDirectory == null)
			return;
		// if a directory is selected, create new dir in there.
		// if a file is selected, create new dir inside its parent.
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		String parent;
		if(selected.length == 0)
			parent = path;
		else if(selected[0].type == VFS.DirectoryEntry.FILE)
		{
			parent = selected[0].path;
			parent = VFSManager.getVFSForPath(parent)
				.getParentOfPath(parent);
		}
		else
			parent = selected[0].path;
		VFS vfs = VFSManager.getVFSForPath(parent);
		// path is the currently viewed directory in the browser
		newDirectory = MiscUtilities.constructPath(parent,newDirectory);
		Object session = vfs.createVFSSession(newDirectory,this);
		if(session == null)
			return;
		if(!startRequest())
			return;
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.MKDIR,this,
			session,vfs,newDirectory,null,null));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} //}}}
	//{{{ newFile() method
	/**
	 * Creates a new file in the current directory.
	 * @since jEdit 4.0pre2
	 */
	public void newFile()
	{
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFS.DirectoryEntry file = selected[0];
			if(file.type == VFS.DirectoryEntry.DIRECTORY)
				jEdit.newFile(view,file.path);
			else
			{
				VFS vfs = VFSManager.getVFSForPath(file.path);
				jEdit.newFile(view,vfs.getParentOfPath(file.path));
			}
		}
		else
			jEdit.newFile(view,path);
	} //}}}
	//{{{ searchInDirectory() method
	/**
	 * Opens a directory search in the current directory.
	 * @since jEdit 4.0pre2
	 */
	public void searchInDirectory()
	{
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFS.DirectoryEntry file = selected[0];
			searchInDirectory(file.path,file.type != VFS.DirectoryEntry.FILE);
		}
		else
		{
			searchInDirectory(this.path,true);
		}
	} //}}}
	//{{{ searchInDirectory() method
	/**
	 * Opens a directory search in the specified directory.
	 * @param path The path name
	 * @param directory True if the path is a directory, false if it is a file
	 * @since jEdit 4.2pre1
	 */
	public void searchInDirectory(String path, boolean directory)
	{
		String filter;
		if(directory)
		{
			filter = getFilenameFilter();
		}
		else
		{
			String name = MiscUtilities.getFileName(path);
			String ext = MiscUtilities.getFileExtension(name);
			filter = (ext == null || ext.length() == 0
				? getFilenameFilter()
				: ""*"" + ext);
			path = MiscUtilities.getParentOfPath(path);
		}
		SearchAndReplace.setSearchFileSet(new DirectoryListSet(
			path,filter,true));
		SearchDialog.showSearchDialog(view,null,SearchDialog.DIRECTORY);
	} //}}}
	//{{{ getBrowserView() method
	public BrowserView getBrowserView()
	{
		return browserView;
	} //}}}
	//{{{ getSelectedFiles() method
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		return browserView.getSelectedFiles();
	} //}}}
	//{{{ locateFile() method
	/**
	 * Goes to the given file's directory and selects the file in the list.
	 * @param path The file
	 * @since jEdit 4.2pre2
	 */
	public void locateFile(final String path)
	{
		if(!filenameFilter.isMatch(MiscUtilities.getFileName(path)))
			setFilenameFilter(null);
		setDirectory(MiscUtilities.getParentOfPath(path));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				browserView.getTable().selectFile(path);
			}
		});
	} //}}}
	//{{{ addBrowserListener() method
	public void addBrowserListener(BrowserListener l)
	{
		listenerList.add(BrowserListener.class,l);
	} //}}}
	//{{{ removeBrowserListener() method
	public void removeBrowserListener(BrowserListener l)
	{
		listenerList.remove(BrowserListener.class,l);
	} //}}}
	//{{{ filesActivated() method
	// canDoubleClickClose set to false when ENTER pressed
	public static final int M_OPEN = 0;
	public static final int M_OPEN_NEW_VIEW = 1;
	public static final int M_OPEN_NEW_PLAIN_VIEW = 2;
	public static final int M_OPEN_NEW_SPLIT = 3;
	public static final int M_INSERT = 4;
	/**
	 * This method does the ""double-click"" handling. It is public so that
	 * <code>browser.actions.xml</code> can bind to it.
	 * @since jEdit 4.2pre2
	 */
	public void filesActivated(int mode, boolean canDoubleClickClose)
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();
		Buffer buffer = null;
check_selected: for(int i = 0; i < selectedFiles.length; i++)
		{
			VFS.DirectoryEntry file = selectedFiles[i];
			if(file.type == VFS.DirectoryEntry.DIRECTORY
				|| file.type == VFS.DirectoryEntry.FILESYSTEM)
			{
				if(mode == M_OPEN_NEW_VIEW && this.mode == BROWSER)
					browseDirectoryInNewWindow(view,file.path);
				else
					setDirectory(file.path);
			}
			else if(this.mode == BROWSER || this.mode == BROWSER_DIALOG)
			{
				if(mode == M_INSERT)
				{
					view.getBuffer().insertFile(view,
						file.path);
					continue check_selected;
				}
				Buffer _buffer = jEdit.getBuffer(file.path);
				if(_buffer == null)
				{
					Hashtable props = new Hashtable();
					props.put(Buffer.ENCODING,currentEncoding);
					props.put(Buffer.ENCODING_AUTODETECT,
						new Boolean(autoDetectEncoding));
					_buffer = jEdit.openFile(null,null,
						file.path,false,props);
				}
				else if(doubleClickClose && canDoubleClickClose
					&& this.mode != BROWSER_DIALOG
					&& selectedFiles.length == 1)
				{
					// close if this buffer is currently
					// visible in the view.
					EditPane[] editPanes = view.getEditPanes();
					for(int j = 0; j < editPanes.length; j++)
					{
						if(editPanes[j].getBuffer() == _buffer)
						{
							jEdit.closeBuffer(view,_buffer);
							return;
						}
					}
				}
				if(_buffer != null)
					buffer = _buffer;
			}
			else
			{
				// if a file is selected in OPEN_DIALOG or
				// SAVE_DIALOG mode, just let the listener(s)
				// handle it
			}
		}
		if(buffer != null)
		{
			switch(mode)
			{
			case M_OPEN:
				view.setBuffer(buffer);
				break;
			case M_OPEN_NEW_VIEW:
				jEdit.newView(view,buffer,false);
				break;
			case M_OPEN_NEW_PLAIN_VIEW:
				jEdit.newView(view,buffer,true);
				break;
			case M_OPEN_NEW_SPLIT:
				view.splitHorizontally().setBuffer(buffer);
				break;
			}
		}
		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesActivated(this,selectedFiles);
			}
		}
	} //}}}
	//{{{ Package-private members
	String currentEncoding;
	boolean autoDetectEncoding;
	//{{{ pathsEqual() method
	/**
	 * This will be made public at some stage, in the io package, but not
	 * yet.
	 */
	static boolean pathsEqual(String p1, String p2)
	{
		if(p1.endsWith(""/"") || p1.endsWith(File.separator))
			p1 = p1.substring(0,p1.length() - 1);
		if(p2.endsWith(""/"") || p2.endsWith(File.separator))
			p2 = p2.substring(0,p2.length() - 1);
		return p1.equals(p2);
	} //}}}
	//{{{ updateFilenameFilter() method
	void updateFilenameFilter()
	{
		try
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				filter = ""*"";
			filenameFilter = new RE(MiscUtilities.globToRE(filter),RE.REG_ICASE);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,VFSBrowser.this,e);
			String[] args = { filterField.getText(),
				e.getMessage() };
			GUIUtilities.error(this,""vfs.browser.bad-filter"",args);
		}
	} //}}}
	//{{{ directoryLoaded() method
	void directoryLoaded(Object node, Object[] loadInfo)
	{
		VFSManager.runInAWTThread(new DirectoryLoadedAWTRequest(
			node,loadInfo));
	} //}}}
	//{{{ filesSelected() method
	void filesSelected()
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();
		if(mode == BROWSER)
		{
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file = selectedFiles[i];
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer != null && view != null)
					view.setBuffer(buffer);
			}
		}
		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesSelected(this,selectedFiles);
			}
		}
	} //}}}
	//{{{ endRequest() method
	void endRequest()
	{
		requestRunning = false;
	} //}}}
	//}}}
	//{{{ Private members
	private static ActionContext actionContext;
	static
	{
		actionContext = new BrowserActionContext();
		ActionSet builtInActionSet = new ActionSet(null,null,null,
			jEdit.class.getResource(""browser.actions.xml""));
		builtInActionSet.setLabel(jEdit.getProperty(""action-set.browser""));
		builtInActionSet.load();
		actionContext.addActionSet(builtInActionSet);
	}
	//{{{ Instance variables
	private EventListenerList listenerList;
	private View view;
	private boolean horizontalLayout;
	private String path;
	private HistoryTextField pathField;
	private JCheckBox filterCheckbox;
	private HistoryTextField filterField;
	private Box toolbarBox;
	private FavoritesMenuButton favorites;
	private PluginsMenuButton plugins;
	private BrowserView browserView;
	private RE filenameFilter;
	private int mode;
	private boolean multipleSelection;
	private boolean showHiddenFiles;
	private boolean sortMixFilesAndDirs;
	private boolean sortIgnoreCase;
	private boolean doubleClickClose;
	private boolean requestRunning;
	private boolean maybeReloadRequestRunning;
	//}}}
	//{{{ createMenuBar() method
	private JPanel createMenuBar()
	{
		JPanel menuBar = new JPanel();
		menuBar.setLayout(new BoxLayout(menuBar,BoxLayout.X_AXIS));
		menuBar.setBorder(new EmptyBorder(0,1,0,3));
		menuBar.add(new CommandsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(plugins = new PluginsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(favorites = new FavoritesMenuButton());
		return menuBar;
	} //}}}
	//{{{ createToolBar() method
	private Box createToolBar()
	{
		if(mode == BROWSER)
			return GUIUtilities.loadToolBar(actionContext,
				""vfs.browser.toolbar-browser"");
		else
			return GUIUtilities.loadToolBar(actionContext,
				""vfs.browser.toolbar-dialog"");
	} //}}}
	//{{{ propertiesChanged() method
	private void propertiesChanged()
	{
		showHiddenFiles = jEdit.getBooleanProperty(""vfs.browser.showHiddenFiles"");
		sortMixFilesAndDirs = jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs"");
		sortIgnoreCase = jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"");
		doubleClickClose = jEdit.getBooleanProperty(""vfs.browser.doubleClickClose"");
		browserView.propertiesChanged();
		toolbarBox.removeAll();
		if(jEdit.getBooleanProperty(""vfs.browser.showToolbar""))
		{
			Box toolbar = createToolBar();
			if(horizontalLayout)
				toolbarBox.add(toolbar);
			else
			{
				toolbar.add(Box.createGlue());
				toolbarBox.add(toolbar);
			}
		}
		if(jEdit.getBooleanProperty(""vfs.browser.showMenubar""))
		{
			JPanel menubar = createMenuBar();
			if(horizontalLayout)
			{
				toolbarBox.add(Box.createHorizontalStrut(6));
				toolbarBox.add(menubar,0);
			}
			else
			{
				menubar.add(Box.createGlue());
				toolbarBox.add(menubar);
			}
		}
		else
			favorites = null;
		toolbarBox.add(Box.createGlue());
		revalidate();
		if(path != null)
			reloadDirectory();
	} //}}}
	/* We do this stuff because the browser is not able to handle
	 * more than one request yet */
	//{{{ startRequest() method
	private boolean startRequest()
	{
		if(requestRunning)
		{
			// dump stack trace for debugging purposes
			Log.log(Log.DEBUG,this,new Throwable(""For debugging purposes""));
			GUIUtilities.error(this,""browser-multiple-io"",null);
			return false;
		}
		else
		{
			requestRunning = true;
			return true;
		}
	} //}}}
	//{{{ updateFilterEnabled() method
	private void updateFilterEnabled()
	{
		filterField.setEnabled(filterCheckbox.isSelected());
	} //}}}
	//{{{ maybeReloadDirectory() method
	private void maybeReloadDirectory(String dir)
	{
		if(MiscUtilities.isURL(dir)
			&& MiscUtilities.getProtocolOfURL(dir).equals(
			FavoritesVFS.PROTOCOL))
		{
			if(favorites != null)
				favorites.popup = null;
		}
		// this is a dirty hack and it relies on the fact
		// that updates for parents are sent before updates
		// for the changed nodes themselves (if this was not
		// the case, the browser wouldn't be updated properly
		// on delete, etc).
		//
		// to avoid causing '> 1 request' errors, don't reload
		// directory if request already active
		if(maybeReloadRequestRunning)
		{
			//Log.log(Log.WARNING,this,""VFS update: request already in progress"");
			return;
		}
		// save a file -> sends vfs update. if a VFS file dialog box
		// is shown from the same event frame as the save, the
		// VFSUpdate will be delivered before the directory is loaded,
		// and before the path is set.
		if(path != null)
		{
			try
			{
				maybeReloadRequestRunning = true;
				browserView.maybeReloadDirectory(dir);
			}
			finally
			{
				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						maybeReloadRequestRunning = false;
					}
				});
			}
		}
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == pathField || source == filterField
				|| source == filterCheckbox)
			{
				updateFilterEnabled();
				String path = pathField.getText();
				if(path != null)
					setDirectory(path);
				browserView.focusOnFileView();
			}
		}
	} //}}}
	//{{{ CommandsMenuButton class
	class CommandsMenuButton extends JButton
	{
		//{{{ CommandsMenuButton constructor
		CommandsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.commands.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);
			popup = new BrowserCommandsMenu(VFSBrowser.this,null);
			CommandsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			CommandsMenuButton.this.addMouseListener(new MouseHandler());
			if(OperatingSystem.isMacOSLF())
				CommandsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} //}}}
		BrowserCommandsMenu popup;
		//{{{ MouseHandler class
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(!popup.isVisible())
				{
					popup.update();
					GUIUtilities.showPopupMenu(
						popup,CommandsMenuButton.this,0,
						CommandsMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} //}}}
	} //}}}
	//{{{ PluginsMenuButton class
	class PluginsMenuButton extends JButton
	{
		//{{{ PluginsMenuButton constructor
		PluginsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.plugins.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);
			PluginsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			PluginsMenuButton.this.addMouseListener(new MouseHandler());
			if(OperatingSystem.isMacOSLF())
				PluginsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} //}}}
		JPopupMenu popup;
		//{{{ updatePopupMenu() method
		void updatePopupMenu()
		{
			popup = null;
		} //}}}
		//{{{ createPopupMenu() method
		private void createPopupMenu()
		{
			if(popup != null)
				return;
			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();
			if(getMode() == BROWSER)
			{
				popup.add(GUIUtilities.loadMenuItem(""plugin-manager"",false));
				popup.add(GUIUtilities.loadMenuItem(""plugin-options"",false));
				popup.addSeparator();
			}
			else
				/* we're in a modal dialog */;
			ArrayList vec = new ArrayList();
			//{{{ old API
			Enumeration e = VFSManager.getFilesystems();
			while(e.hasMoreElements())
			{
				VFS vfs = (VFS)e.nextElement();
				if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)
					continue;
				JMenuItem menuItem = new JMenuItem(jEdit.getProperty(
					""vfs."" + vfs.getName() + "".label""));
				menuItem.setActionCommand(vfs.getName());
				menuItem.addActionListener(actionHandler);
				vec.add(menuItem);
			} //}}}
			//{{{ new API
			EditPlugin[] plugins = jEdit.getPlugins();
			for(int i = 0; i < plugins.length; i++)
			{
				JMenuItem menuItem = plugins[i].createBrowserMenuItems();
				if(menuItem != null)
					vec.add(menuItem);
			} //}}}
			if(vec.size() != 0)
			{
				MiscUtilities.quicksort(vec,new MiscUtilities.MenuItemCompare());
				for(int i = 0; i < vec.size(); i++)
					popup.add((JMenuItem)vec.get(i));
			}
			else
			{
				JMenuItem mi = new JMenuItem(jEdit.getProperty(
					""vfs.browser.plugins.no-plugins.label""));
				mi.setEnabled(false);
				popup.add(mi);
			}
		} //}}}
		//{{{ ActionHandler class
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFS vfs = VFSManager.getVFSByName(evt.getActionCommand());
				String directory = vfs.showBrowseDialog(null,
					VFSBrowser.this);
				if(directory != null)
					setDirectory(directory);
			}
		} //}}}
		//{{{ MouseHandler class
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				createPopupMenu();
				if(!popup.isVisible())
				{
					GUIUtilities.showPopupMenu(
						popup,PluginsMenuButton.this,0,
						PluginsMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} //}}}
	} //}}}
	//{{{ FavoritesMenuButton class
	class FavoritesMenuButton extends JButton
	{
		//{{{ FavoritesMenuButton constructor
		FavoritesMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.favorites.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);
			FavoritesMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			FavoritesMenuButton.this.addMouseListener(new MouseHandler());
			if(OperatingSystem.isMacOSLF())
				FavoritesMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} //}}}
		JPopupMenu popup;
		//{{{ createPopupMenu() method
		void createPopupMenu()
		{
			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();
			JMenuItem mi = new JMenuItem(
				jEdit.getProperty(
				""vfs.browser.favorites""
				+ "".add-to-favorites.label""));
			mi.setActionCommand(""add-to-favorites"");
			mi.addActionListener(actionHandler);
			popup.add(mi);
			mi = new JMenuItem(
				jEdit.getProperty(
				""vfs.browser.favorites""
				+ "".edit-favorites.label""));
			mi.setActionCommand(""dir@favorites:"");
			mi.addActionListener(actionHandler);
			popup.add(mi);
			popup.addSeparator();
			VFS.DirectoryEntry[] favorites
				= FavoritesVFS.getFavorites();
			if(favorites.length == 0)
			{
				mi = new JMenuItem(
					jEdit.getProperty(
					""vfs.browser.favorites""
					+ "".no-favorites.label""));
				mi.setEnabled(false);
				popup.add(mi);
			}
			else
			{
				MiscUtilities.quicksort(favorites,
					new VFS.DirectoryEntryCompare(
					sortMixFilesAndDirs,
					sortIgnoreCase));
				for(int i = 0; i < favorites.length; i++)
				{
					VFS.DirectoryEntry favorite
						= favorites[i];
					mi = new JMenuItem(favorite.path);
					mi.setIcon(FileCellRenderer
						.getIconForFile(
						favorite,false));
					String cmd = (favorite.type ==
						VFS.DirectoryEntry.FILE
						? ""file@"" : ""dir@"")
						+ favorite.path;
					mi.setActionCommand(cmd);
					mi.addActionListener(actionHandler);
					popup.add(mi);
				}
			}
		} //}}}
		//{{{ ActionHandler class
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				String actionCommand = evt.getActionCommand();
				if(actionCommand.equals(""add-to-favorites""))
				{
					// if any directories are selected, add
					// them, otherwise add current directory
					VFS.DirectoryEntry[] selected = getSelectedFiles();
					if(selected == null || selected.length == 0)
					{
						if(path.equals(FavoritesVFS.PROTOCOL + "":""))
						{
							GUIUtilities.error(VFSBrowser.this,
								""vfs.browser.recurse-favorites"",
								null);
						}
						else
						{
							FavoritesVFS.addToFavorites(path,
								VFS.DirectoryEntry.DIRECTORY);
						}
					}
					else
					{
						for(int i = 0; i < selected.length; i++)
						{
							VFS.DirectoryEntry file
								= selected[i];
							FavoritesVFS.addToFavorites(file.path,file.type);
						}
					}
				}
				else if(actionCommand.startsWith(""dir@""))
				{
					setDirectory(actionCommand.substring(4));
				}
				else if(actionCommand.startsWith(""file@""))
				{
					switch(getMode())
					{
					case BROWSER:
						jEdit.openFile(view,actionCommand.substring(5));
						break;
					default:
						locateFile(actionCommand.substring(5));
						break;
					}
				}
			}
		} //}}}
		//{{{ MouseHandler class
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(popup != null && popup.isVisible())
				{
					popup.setVisible(false);
					return;
				}
				if(popup == null)
					createPopupMenu();
				GUIUtilities.showPopupMenu(
					popup,FavoritesMenuButton.this,0,
					FavoritesMenuButton.this.getHeight(),
					false);
			}
		} //}}}
	} //}}}
	//{{{ DirectoryLoadedAWTRequest class
	class DirectoryLoadedAWTRequest implements Runnable
	{
		Object node;
		Object[] loadInfo;
		DirectoryLoadedAWTRequest(Object node, Object[] loadInfo)
		{
			this.node = node;
			this.loadInfo = loadInfo;
		}
		public void run()
		{
			String path = (String)loadInfo[0];
			if(path == null)
			{
				// there was an error
				return;
			}
			VFS.DirectoryEntry[] list = (VFS.DirectoryEntry[])
				loadInfo[1];
			if(node == null)
			{
				// This is the new, canonical path
				VFSBrowser.this.path = path;
				if(!pathField.getText().equals(path))
					pathField.setText(path);
				if(path.endsWith(""/"") ||
					path.endsWith(File.separator))
				{
					// ensure consistent history;
					// eg we don't want both
					// foo/ and foo
					path = path.substring(0,
						path.length() - 1);
				}
				HistoryModel.getModel(""vfs.browser.path"")
					.addItem(path);
			}
			boolean filterEnabled = filterCheckbox.isSelected();
			ArrayList directoryVector = new ArrayList();
			int directories = 0;
			int files = 0;
			int invisible = 0;
			if(list != null)
			{
				for(int i = 0; i < list.length; i++)
				{
					VFS.DirectoryEntry file = list[i];
					if(file.hidden && !showHiddenFiles)
					{
						invisible++;
						continue;
					}
					if(file.type == VFS.DirectoryEntry.FILE
						&& filterEnabled
						&& filenameFilter != null
						&& !filenameFilter.isMatch(file.name))
					{
						invisible++;
						continue;
					}
					if(file.type == VFS.DirectoryEntry.FILE)
						files++;
					else
						directories++;
					directoryVector.add(file);
				}
				MiscUtilities.quicksort(directoryVector,
					new VFS.DirectoryEntryCompare(
					sortMixFilesAndDirs,
					sortIgnoreCase));
			}
			browserView.directoryLoaded(node,path,
				directoryVector);
			// to notify listeners that any existing
			// selection has been deactivated
			// turns out under some circumstances this
			// method can switch the current buffer in
			// BROWSER mode.
			// in any case, this is only needed for the
			// directory chooser (why?), so we add a
			// check. otherwise poor Rick will go insane.
			if(mode == CHOOSE_DIRECTORY_DIALOG)
				filesSelected();
		}
		public String toString()
		{
			return (String)loadInfo[0];
		}
	} //}}}
	//{{{ BrowserActionContext class
	static class BrowserActionContext extends ActionContext
	{
		/**
		 * If event source hierarchy contains a VFSDirectoryEntryTable,
		 * this is the currently selected files there. Otherwise, this
		 * is the currently selected item in the parent directory list.
		 */
		private VFS.DirectoryEntry[] getSelectedFiles(EventObject evt,
			VFSBrowser browser)
		{
			Component source = (Component)evt.getSource();
			if(GUIUtilities.getComponentParent(source,JList.class)
				!= null)
			{
				Object[] selected = browser.getBrowserView()
					.getParentDirectoryList()
					.getSelectedValues();
				VFS.DirectoryEntry[] returnValue
					= new VFS.DirectoryEntry[
					selected.length];
				System.arraycopy(selected,0,returnValue,0,
					selected.length);
				return returnValue;
			}
			else
			{
				return browser.getSelectedFiles();
			}
		}
		public void invokeAction(EventObject evt, EditAction action)
		{
			VFSBrowser browser = (VFSBrowser)
				GUIUtilities.getComponentParent(
				(Component)evt.getSource(),
				VFSBrowser.class);
			VFS.DirectoryEntry[] files = getSelectedFiles(evt,
				browser);
			// in the future we will want something better,
			// eg. having an 'evt' object passed to
			// EditAction.invoke().
			// for now, since all browser actions are
			// written in beanshell we set the 'browser'
			// variable directly.
			NameSpace global = BeanShell.getNameSpace();
			try
			{
				global.setVariable(""browser"",browser);
				global.setVariable(""files"",files);
				View view = browser.getView();
				// I guess ideally all browsers
				// should have views, but since they
				// don't, we just use the active view
				// in that case, since some actions
				// depend on a view being there and
				// I don't want to add checks to
				// them all
				if(view == null)
					view = jEdit.getActiveView();
				action.invoke(view);
			}
			catch(UtilEvalError err)
			{
				Log.log(Log.ERROR,this,err);
			}
			finally
			{
				try
				{
					global.setVariable(""browser"",null);
					global.setVariable(""files"",null);
				}
				catch(UtilEvalError err)
				{
					Log.log(Log.ERROR,this,err);
				}
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.browser.VFSDirectoryEntryTable,"/*
 * VFSDirectoryEntryTable.java - VFS directory entry table
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.Log;
//}}}
/**
 * @author Slava Pestov
 * @version $Id: VFSDirectoryEntryTable.java,v 1.21 2004/02/14 19:02:48 spestov Exp $
 * @since jEdit 4.2pre1
 */
public class VFSDirectoryEntryTable extends JTable
{
	//{{{ VFSDirectoryEntryTable constructor
	public VFSDirectoryEntryTable(BrowserView browserView)
	{
		super(new VFSDirectoryEntryTableModel());
		this.browserView = browserView;
		setShowGrid(false);
		setIntercellSpacing(new Dimension(0,0));
		/* TableColumn col1 = getColumnModel().getColumn(0);
		col1.setMinWidth(20);
		col1.setMaxWidth(20);
		col1.setPreferredWidth(20); */
		setDefaultRenderer(VFSDirectoryEntryTableModel.Entry.class,
			renderer = new FileCellRenderer());
		JTableHeader header = getTableHeader();
		header.setReorderingAllowed(false);
		setRowSelectionAllowed(true);
		//setColumnSelectionAllowed(true);
		//setCellSelectionEnabled(false);
		setAutoResizeMode(AUTO_RESIZE_OFF);
	} //}}}
	//{{{ selectFile() method
	public boolean selectFile(String path)
	{
		for(int i = 0; i < getRowCount(); i++)
		{
			VFSDirectoryEntryTableModel.Entry entry =
				(VFSDirectoryEntryTableModel.Entry)
				getValueAt(i,1);
			if(entry.dirEntry.path.equals(path))
			{
				setSelectedRow(i);
				return true;
			}
		}
		return false;
	} //}}}
	//{{{ doTypeSelect() method
	public void doTypeSelect(String str, boolean dirsOnly)
	{
		if(str.length() == 0)
			clearSelection();
		else if(getSelectedRow() == -1)
			doTypeSelect(str,0,getRowCount(),dirsOnly);
		else
		{
			int start = getSelectionModel().getMaxSelectionIndex();
			boolean retVal = doTypeSelect(str,start,getRowCount(),
				dirsOnly);
			if(!retVal)
			{
				// scan from selection to end failed, so
				// scan from start to selection
				doTypeSelect(str,0,start,dirsOnly);
			}
		}
	} //}}}
	//{{{ getSelectedFiles() method
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		VFSDirectoryEntryTableModel model
			= (VFSDirectoryEntryTableModel)getModel();
		LinkedList returnValue = new LinkedList();
		int[] selectedRows = getSelectedRows();
		for(int i = 0; i < selectedRows.length; i++)
		{
			returnValue.add(model.files[selectedRows[i]].dirEntry);
		}
		return (VFS.DirectoryEntry[])returnValue.toArray(new
		VFS.DirectoryEntry[returnValue.size()]);
	} //}}}
	//{{{ getExpandedDirectories() method
	public void getExpandedDirectories(Set set)
	{
		VFSDirectoryEntryTableModel model
			= (VFSDirectoryEntryTableModel)getModel();
		if(model.files != null)
		{
			for(int i = 0; i < model.files.length; i++)
			{
				if(model.files[i].expanded)
					set.add(model.files[i].dirEntry.path);
			}
		}
	} //}}}
	//{{{ toggleExpanded() method
	public void toggleExpanded(final int row)
	{
		VFSDirectoryEntryTableModel model
		= (VFSDirectoryEntryTableModel)getModel();
		VFSDirectoryEntryTableModel.Entry entry = model.files[row];
		if(entry.dirEntry.type == VFS.DirectoryEntry.FILE)
			return;
		if(entry.expanded)
		{
			model.collapse(VFSManager.getVFSForPath(
				entry.dirEntry.path),row);
			resizeColumnsAppropriately();
		}
		else
		{
			browserView.clearExpansionState();
			browserView.loadDirectory(entry,entry.dirEntry.path);
		}
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setSelectedRow(row);
			}
		});
	} //}}}
	//{{{ setDirectory() method
	public void setDirectory(VFS vfs, Object node, ArrayList list,
		Set tmpExpanded)
	{
		timer.stop();
		typeSelectBuffer.setLength(0);
		VFSDirectoryEntryTableModel model = ((VFSDirectoryEntryTableModel)getModel());
		int startIndex;
		if(node == null)
		{
			startIndex = 0;
			model.setRoot(vfs,list);
		}
		else
		{
			startIndex =
				model.expand(
				vfs,
				(VFSDirectoryEntryTableModel.Entry)node,
				list);
			startIndex++;
		}
		for(int i = 0; i < list.size(); i++)
		{
			VFSDirectoryEntryTableModel.Entry e
				= model.files[startIndex + i];
			String path = e.dirEntry.path;
			if(tmpExpanded.contains(path))
			{
				browserView.loadDirectory(e,path);
				tmpExpanded.remove(path);
			}
		}
		resizeColumnsAppropriately();
	} //}}}
	//{{{ maybeReloadDirectory() method
	public void maybeReloadDirectory(String path)
	{
		VFSDirectoryEntryTableModel model
		= (VFSDirectoryEntryTableModel)getModel();
		for(int i = 0; i < model.files.length; i++)
		{
			VFSDirectoryEntryTableModel.Entry e = model.files[i];
			if(!e.expanded || e.dirEntry.type == VFS.DirectoryEntry.FILE)
				continue;
			VFS.DirectoryEntry dirEntry = e.dirEntry;
			// work around for broken FTP plugin!
			String otherPath;
			if(dirEntry.symlinkPath == null)
				otherPath = dirEntry.path;
			else
				otherPath = dirEntry.symlinkPath;
			if(VFSBrowser.pathsEqual(path,otherPath))
			{
				browserView.saveExpansionState();
				browserView.loadDirectory(e,path);
				return;
			}
		}
	} //}}}
	//{{{ propertiesChanged() method
	public void propertiesChanged()
	{
		renderer.propertiesChanged();
		VFS.DirectoryEntry template = new VFS.DirectoryEntry(
			""foo"",""foo"",""foo"",VFS.DirectoryEntry.FILE,0L,false);
		setRowHeight(renderer.getTableCellRendererComponent(
			this,new VFSDirectoryEntryTableModel.Entry(template,0),
			false,false,0,0).getPreferredSize().height);
		Dimension prefSize = getPreferredSize();
		setPreferredScrollableViewportSize(new Dimension(prefSize.width,
			getRowHeight() * 12));
	} //}}}
	//{{{ scrollRectToVisible() method
	public void scrollRectToVisible(Rectangle rect)
	{
		// avoid scrolling to the right
		rect.width = 0;
		super.scrollRectToVisible(rect);
	} //}}}
	//{{{ processKeyEvent() method
	public void processKeyEvent(KeyEvent evt)
	{
		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			VFSDirectoryEntryTableModel model =
				(VFSDirectoryEntryTableModel)getModel();
			int row = getSelectedRow();
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_LEFT:
				evt.consume();
				if(row != -1)
				{
					if(model.files[row].expanded)
					{
						model.collapse(
							VFSManager.getVFSForPath(
							model.files[row].dirEntry.path),
							row);
						break;
					}
					for(int i = row - 1; i >= 0; i--)
					{
						if(model.files[i].expanded)
						{
							setSelectedRow(i);
							break;
						}
					}
				}
				String dir = browserView.getBrowser()
					.getDirectory();
				dir = MiscUtilities.getParentOfPath(dir);
				browserView.getBrowser().setDirectory(dir);
				break;
			case KeyEvent.VK_RIGHT:
				if(row != -1)
				{
					if(!model.files[row].expanded)
						toggleExpanded(row);
				}
				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				// stupid Swing
				if(row == -1 && getModel().getRowCount() != 0)
				{
					setSelectedRow(0);
					evt.consume();
				}
				break;
			case KeyEvent.VK_ENTER:
				browserView.getBrowser().filesActivated(
					(evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN),false);
				evt.consume();
				break;
			}
		}
		else if(evt.getID() == KeyEvent.KEY_TYPED)
		{
			if(evt.isControlDown() || evt.isAltDown()
				|| evt.isMetaDown())
			{
				return;
			}
			// hack...
			if(evt.isShiftDown() && evt.getKeyChar() == '\n')
				return;
			VFSBrowser browser = browserView.getBrowser();
			switch(evt.getKeyChar())
			{
			case '~':
				if(browser.getMode() == VFSBrowser.BROWSER)
					browser.setDirectory(System.getProperty(
						""user.home""));
				break;
			case '/':
				if(browser.getMode() == VFSBrowser.BROWSER)
					browser.rootDirectory();
				break;
			case '-':
				if(browser.getMode() == VFSBrowser.BROWSER)
				{
					browser.setDirectory(
						browser.getView().getBuffer()
						.getDirectory());
				}
				break;
			default:
				typeSelectBuffer.append(evt.getKeyChar());
				doTypeSelect(typeSelectBuffer.toString(),
					browser.getMode() == VFSBrowser
					.CHOOSE_DIRECTORY_DIALOG);
				timer.stop();
				timer.setInitialDelay(750);
				timer.setRepeats(false);
				timer.start();
				return;
			}
		}
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} //}}}
	//{{{ setSelectedRow() method
	public void setSelectedRow(int row)
	{
		getSelectionModel().setSelectionInterval(row,row);
		scrollRectToVisible(getCellRect(row,0,true));
	} //}}}
	//{{{ Private members
	private BrowserView browserView;
	private FileCellRenderer renderer;
	private StringBuffer typeSelectBuffer = new StringBuffer();
	private Timer timer = new Timer(0,new ClearTypeSelect());
	//{{{ doTypeSelect() method
	private boolean doTypeSelect(String str, int start, int end,
		boolean dirsOnly)
	{
		for(int i = start; i < end; i++)
		{
			VFSDirectoryEntryTableModel.Entry entry =
				(VFSDirectoryEntryTableModel.Entry)getValueAt(i,1);
			if(dirsOnly && entry.dirEntry.type
				== VFS.DirectoryEntry.FILE)
			{
				continue;
			}
			String matchAgainst = (MiscUtilities.isAbsolutePath(str)
				? entry.dirEntry.path : entry.dirEntry.name);
			if(matchAgainst.regionMatches(true,
				0,str,0,str.length()))
			{
				setSelectedRow(i);
				return true;
			}
		}
		return false;
	} //}}}
	//{{{ resizeColumnsAppropriately() method
	private void resizeColumnsAppropriately()
	{
		VFSDirectoryEntryTableModel model
		= (VFSDirectoryEntryTableModel)getModel();
		FontRenderContext fontRenderContext = new FontRenderContext(
			null,false,false);
		int[] widths = new int[model.getColumnCount()];
		for(int i = 0; i < widths.length; i++)
		{
			String columnName = model.getColumnName(i);
			if(columnName != null)
			{
				widths[i] = (int)renderer.plainFont
					.getStringBounds(columnName,
					fontRenderContext).getWidth();
			}
		}
		for(int i = 0; i < model.files.length; i++)
		{
			VFSDirectoryEntryTableModel.Entry entry
				= model.files[i];
			Font font = (entry.dirEntry.type
				== VFS.DirectoryEntry.FILE
				? renderer.plainFont : renderer.boldFont);
			widths[0] = Math.max(widths[0],renderer.getEntryWidth(
				entry,font,fontRenderContext));
			for(int j = 1; j < widths.length; j++)
			{
				String extAttr = model.getExtendedAttribute(
					j - 1);
				String attr = entry.dirEntry
					.getExtendedAttribute(
					extAttr);
				if(attr != null)
				{
					widths[j] = Math.max(widths[j],
						(int)font.getStringBounds(
						attr,fontRenderContext)
						.getWidth());
				}
			}
		}
		for(int i = 0; i < widths.length; i++)
		{
			int width = widths[i];
			if(i != widths.length - 1 && width != 0)
				width += 10;
			else
				width += 2;
			getColumnModel().getColumn(i).setPreferredWidth(width);
			getColumnModel().getColumn(i).setMinWidth(width);
			getColumnModel().getColumn(i).setMaxWidth(width);
			getColumnModel().getColumn(i).setWidth(width);
		}
		doLayout();
	} //}}}
	//}}}
	//{{{ ClearTypeSelect class
	class ClearTypeSelect implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			typeSelectBuffer.setLength(0);
		}
	} //}}}
}
"
org.gjt.sp.jedit.browser.VFSDirectoryEntryTableModel,"/*
 * VFSDirectoryEntryTableModel.java - VFS directory entry table model
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import javax.swing.table.*;
import javax.swing.*;
import java.util.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * @author Slava Pestov
 * @version $Id: VFSDirectoryEntryTableModel.java,v 1.9 2004/01/14 04:36:50 spestov Exp $
 * @since jEdit 4.2pre1
 */
public class VFSDirectoryEntryTableModel extends AbstractTableModel
{
	//{{{ VFSDirectoryEntryTableModel constructor
	public VFSDirectoryEntryTableModel()
	{
		extAttrs = new ArrayList();
	} //}}}
	//{{{ setRoot() method
	public void setRoot(VFS vfs, ArrayList list)
	{
		extAttrs.clear();
		addExtendedAttributes(vfs);
		/* if(files != null && files.length != 0)
			fireTableRowsDeleted(0,files.length - 1); */
		files = new Entry[list.size()];
		for(int i = 0; i < files.length; i++)
		{
			files[i] = new Entry((VFS.DirectoryEntry)list.get(i),0);
		}
		/* if(files.length != 0)
			fireTableRowsInserted(0,files.length - 1); */
		fireTableStructureChanged();
	} //}}}
	//{{{ expand() method
	public int expand(VFS vfs, Entry entry, ArrayList list)
	{
		int startIndex = -1;
		for(int i = 0; i < files.length; i++)
		{
			if(files[i] == entry)
				startIndex = i;
		}
		collapse(vfs,startIndex);
		addExtendedAttributes(vfs);
		entry.expanded = true;
		if(list != null)
		{
			Entry[] newFiles = new Entry[files.length + list.size()];
			System.arraycopy(files,0,newFiles,0,startIndex + 1);
			for(int i = 0; i < list.size(); i++)
			{
				newFiles[startIndex + i + 1] = new Entry(
					(VFS.DirectoryEntry)list.get(i),
					entry.level + 1);
			}
			System.arraycopy(files,startIndex + 1,
				newFiles,startIndex + list.size() + 1,
				files.length - startIndex - 1);
			this.files = newFiles;
			/* fireTableRowsInserted(startIndex + 1,
				startIndex + list.size() + 1); */
		}
		/* fireTableRowsUpdated(startIndex,startIndex); */
		fireTableStructureChanged();
		return startIndex;
	} //}}}
	//{{{ collapse() method
	public void collapse(VFS vfs, int index)
	{
		Entry entry = files[index];
		if(!entry.expanded)
			return;
		entry.expanded = false;
		int lastIndex = index + 1;
		while(lastIndex < files.length)
		{
			Entry e = files[lastIndex];
			if(e.level <= entry.level)
				break;
			else
				lastIndex++;
			if(e.expanded)
			{
				removeExtendedAttributes(VFSManager.getVFSForPath(
					e.dirEntry.path));
			}
		}
		removeExtendedAttributes(vfs);
		Entry[] newFiles = new Entry[files.length - lastIndex + index + 1];
		System.arraycopy(files,0,newFiles,0,index + 1);
		System.arraycopy(files,lastIndex,newFiles,index + 1,
			files.length - lastIndex);
		files = newFiles;
		/* fireTableRowsUpdated(index,index);
		fireTableRowsDeleted(index + 1,lastIndex); */
		fireTableStructureChanged();
	} //}}}
	//{{{ getColumnCount() method
	public int getColumnCount()
	{
		return 1 + extAttrs.size();
	} //}}}
	//{{{ getRowCount() method
	public int getRowCount()
	{
		if(files == null)
			return 0;
		else
			return files.length;
	} //}}}
	//{{{ getColumnName() method
	public String getColumnName(int col)
	{
		if(col == 0)
			return jEdit.getProperty(""vfs.browser.name"");
		else
			return jEdit.getProperty(""vfs.browser."" + getExtendedAttribute(col - 1));
	} //}}}
	//{{{ getColumnClass() method
	public Class getColumnClass(int col)
	{
		return Entry.class;
	} //}}}
	//{{{ getValueAt() method
	public Object getValueAt(int row, int col)
	{
		if(files == null)
			return null;
		else
			return files[row];
	} //}}}
	//{{{ getExtendedAttribute() method
	public String getExtendedAttribute(int index)
	{
		return ((ExtendedAttribute)extAttrs.get(index)).name;
	} //}}}
	//{{{ Package-private members
	Entry[] files;
	//}}}
	//{{{ Private members
	private List extAttrs;
	//{{{ addExtendedAttributes() method
	private void addExtendedAttributes(VFS vfs)
	{
		String[] attrs = vfs.getExtendedAttributes();
vfs_attr_loop:	for(int i = 0; i < attrs.length; i++)
		{
			Iterator iter = extAttrs.iterator();
			while(iter.hasNext())
			{
				ExtendedAttribute attr = (ExtendedAttribute)
					iter.next();
				if(attrs[i].equals(attr.name))
				{
					attr.ref++;
					continue vfs_attr_loop;
				}
			}
			// this vfs has an extended attribute which is not
			// in the list. add it to the end with a ref count
			// of 1
			extAttrs.add(new ExtendedAttribute(attrs[i]));
		}
	} //}}}
	//{{{ removeExtendedAttributes() method
	private void removeExtendedAttributes(VFS vfs)
	{
		String[] attrs = vfs.getExtendedAttributes();
vfs_attr_loop:	for(int i = 0; i < attrs.length; i++)
		{
			Iterator iter = extAttrs.iterator();
			while(iter.hasNext())
			{
				ExtendedAttribute attr = (ExtendedAttribute)
					iter.next();
				if(attrs[i].equals(attr.name))
				{
					if(--attr.ref == 0)
					{
						// we no longer have any
						// dirs using this extended
						// attribute
						iter.remove();
					}
					continue vfs_attr_loop;
				}
			}
			// this vfs has an extended attribute which is not
			// in the list ???
			Log.log(Log.WARNING,this,""We forgot about "" + attrs[i]);
		}
	} //}}}
	//}}}
	//{{{ Entry class
	static class Entry
	{
		VFS.DirectoryEntry dirEntry;
		boolean expanded;
		// how deeply we are nested
		int level;
		Entry(VFS.DirectoryEntry dirEntry, int level)
		{
			this.dirEntry = dirEntry;
			this.level = level;
		}
	} //}}}
	//{{{ ExtendedAttribute class
	static class ExtendedAttribute
	{
		/* reference counter allows us to remove a column from
		 * the table when no directory using this column is
		 * visible */
		int ref;
		String name;
		ExtendedAttribute(String name)
		{
			this.name = name;
			ref = 1;
		}
	} //}}}
}
"
org.gjt.sp.jedit.browser.VFSFileChooserDialog,"/*
 * VFSFileChooserDialog.java - VFS file chooser
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.util.*;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
//}}}
/**
 * Wraps the VFS browser in a modal dialog.
 * @author Slava Pestov
 * @version $Id: VFSFileChooserDialog.java,v 1.44 2004/06/28 06:45:26 spestov Exp $
 */
public class VFSFileChooserDialog extends EnhancedDialog
{
	//{{{ VFSFileChooserDialog constructor
	public VFSFileChooserDialog(View view, String path,
		int mode, boolean multipleSelection)
	{
		super(view,jEdit.getProperty(""vfs.browser.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		String name;
		if(mode == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
			name = null;
		else if(path == null || path.endsWith(File.separator)
			|| path.endsWith(""/""))
		{
			name = null;
		}
		else
		{
			VFS vfs = VFSManager.getVFSForPath(path);
			name = vfs.getFileName(path);
			path = vfs.getParentOfPath(path);
		}
		browser = new VFSBrowser(view,path,mode,multipleSelection,null);
		browser.getBrowserView().getTable().setRequestFocusEnabled(false);
		browser.getBrowserView().getParentDirectoryList()
			.setRequestFocusEnabled(false);
		/* browser.getBrowserView().getTable().addKeyListener(new KeyHandler()); */
		browser.addBrowserListener(new BrowserHandler());
		content.add(BorderLayout.CENTER,browser);
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		filenameField = new VFSFileNameField(browser,null);
		filenameField.setText(name);
		filenameField.selectAll();
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		box.add(filenameField);
		box.add(Box.createGlue());
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.dialog.filename""));
		label.setDisplayedMnemonic(jEdit.getProperty(
			""vfs.browser.dialog.filename.mnemonic"").charAt(0));
		label.setLabelFor(filenameField);
		panel.add(label);
		panel.add(Box.createHorizontalStrut(12));
		panel.add(box);
		panel.add(Box.createHorizontalStrut(12));
		GUIUtilities.requestFocus(this,filenameField);
		ok = new JButton();
		getRootPane().setDefaultButton(ok);
		switch(mode)
		{
		case VFSBrowser.OPEN_DIALOG:
		case VFSBrowser.BROWSER_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.open""));
			break;
		case VFSBrowser.CHOOSE_DIRECTORY_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.choose-dir""));
			// so that it doesn't resize...
			Dimension dim = ok.getPreferredSize();
			ok.setPreferredSize(dim);
			break;
		case VFSBrowser.SAVE_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.save""));
			break;
		}
		ok.addActionListener(new ActionHandler());
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		panel.add(cancel);
		content.add(BorderLayout.SOUTH,panel);
		VFSManager.getIOThreadPool().addProgressListener(
			workThreadHandler = new WorkThreadHandler());
		pack();
		GUIUtilities.loadGeometry(this,""vfs.browser.dialog"");
		setVisible(true);
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""vfs.browser.dialog"");
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.dispose();
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		VFS.DirectoryEntry[] files = browser.getSelectedFiles();
		filename = filenameField.getText();
		if(files.length != 0)
		{
			browser.filesActivated(VFSBrowser.M_OPEN,false);
			return;
		}
		else if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG
			&& (filename == null || filename.length() == 0))
		{
			isOK = true;
			dispose();
			return;
		}
		else if(filename == null || filename.length() == 0)
		{
			getToolkit().beep();
			return;
		}
		String bufferDir = browser.getView().getBuffer()
			.getDirectory();
		if(filename.equals(""-""))
			filename = bufferDir;
		else if(filename.startsWith(""-/"")
			|| filename.startsWith(""-"" + File.separator))
		{
			filename = MiscUtilities.constructPath(
				bufferDir,filename.substring(2));
		}
		final int[] type = { -1 };
		final String path = MiscUtilities.constructPath(
			browser.getDirectory(),filename);
		final VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;
		VFSManager.runInWorkThread(new GetFileTypeRequest(
			vfs,session,path,type));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				switch(type[0])
				{
				case VFS.DirectoryEntry.FILE:
					if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
						break;
					if(vfs instanceof FileVFS)
					{
						if(doFileExistsWarning(path))
							break;
					}
					isOK = true;
					if(browser.getMode() == VFSBrowser.BROWSER_DIALOG)
					{
						Hashtable props = new Hashtable();
						props.put(Buffer.ENCODING,browser.currentEncoding);
						jEdit.openFile(browser.getView(),
							browser.getDirectory(),
							path,false,props);
					}
					dispose();
					break;
				case VFS.DirectoryEntry.DIRECTORY:
				case VFS.DirectoryEntry.FILESYSTEM:
					browser.setDirectory(path);
					break;
				}
			}
		});
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ getSelectedFiles() method
	public String[] getSelectedFiles()
	{
		if(!isOK)
			return null;
		//String filename = filenameField.getText();
		if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
		{
			return new String[] { browser.getDirectory() };
		}
		else if(filename != null && filename.length() != 0)
		{
			String path = browser.getDirectory();
			return new String[] { MiscUtilities.constructPath(
				path,filename) };
		}
		else
		{
			Vector vector = new Vector();
			VFS.DirectoryEntry[] selectedFiles = browser.getSelectedFiles();
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file = selectedFiles[i];
				if(file.type == VFS.DirectoryEntry.FILE)
					vector.addElement(file.path);
			}
			String[] retVal = new String[vector.size()];
			vector.copyInto(retVal);
			return retVal;
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private VFSBrowser browser;
	private VFSFileNameField filenameField;
	private String filename;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	private WorkThreadHandler workThreadHandler;
	//}}}
	//{{{ doFileExistsWarning() method
	private boolean doFileExistsWarning(String filename)
	{
		if(browser.getMode() == VFSBrowser.SAVE_DIALOG
			&& new File(filename).exists())
		{
			String[] args = { MiscUtilities.getFileName(filename) };
			int result = GUIUtilities.confirm(browser,
				""fileexists"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return true;
		}
		return false;
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(!browser.getDirectory().equals(
					browser.getDirectoryField().getText()))
				{
					browser.setDirectory(browser.getDirectoryField().getText());
				}
				else
					ok();
			}
			else if(evt.getSource() == cancel)
				cancel();
		}
	} //}}}
	//{{{ BrowserHandler class
	class BrowserHandler implements BrowserListener
	{
		//{{{ filesSelected() method
		public void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			if(files.length == 0)
			{
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.choose-dir""));
				}
				return;
			}
			else if(files.length == 1)
			{
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.open""));
				}
				VFS.DirectoryEntry file = files[0];
				if(file.type == VFS.DirectoryEntry.FILE)
				{
					String path = file.path;
					String directory = browser.getDirectory();
					String parent = MiscUtilities
						.getParentOfPath(path);
					if(VFSBrowser.pathsEqual(parent,directory))
						path = file.name;
					filenameField.setText(path);
					filenameField.selectAll();
				}
			}
			else
			{
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.open""));
				}
				filenameField.setText(null);
			}
		} //}}}
		//{{{ filesActivated() method
		public void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			filenameField.selectAll();
			if(files.length == 0)
			{
				// user pressed enter when the vfs table or
				// file name field has focus, with nothing
				// selected.
				ok();
				return;
			}
			for(int i = 0; i < files.length; i++)
			{
				if(files[i].type == VFS.DirectoryEntry.FILE)
				{
					String path = files[i].path;
					VFS vfs = VFSManager.getVFSForPath(path);
					if(browser.getMode() == VFSBrowser.SAVE_DIALOG
						&& vfs instanceof FileVFS)
					{
						if(doFileExistsWarning(path))
							return;
					}
					isOK = true;
					filenameField.setText(null);
					if(browser.getMode() != VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
					{
						dispose();
					}
					return;
				}
				else
					return;
			}
		} //}}}
	} //}}}
	//{{{ KeyHandler class
	class KeyHandler extends KeyAdapter
	{
		public void keyTyped(KeyEvent evt)
		{
			switch(evt.getKeyChar())
			{
			case '/':
			case '-':
			case '~':
				filenameField.processKeyEvent(evt);
				filenameField.requestFocus();
				break;
			}
		}
	} //}}}
	//{{{ WorkThreadListener class
	class WorkThreadHandler implements WorkThreadProgressListener
	{
		//{{{ statusUpdate() method
		public void statusUpdate(final WorkThreadPool threadPool,
			final int threadIndex)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					int requestCount = threadPool.getRequestCount();
					if(requestCount == 0)
					{
						getContentPane().setCursor(
							Cursor.getDefaultCursor());
					}
					else if(requestCount >= 1)
					{
						getContentPane().setCursor(
							Cursor.getPredefinedCursor(
							Cursor.WAIT_CURSOR));
					}
				}
			});
		} //}}}
		//{{{ progressUpdate() method
		public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
		{
		} //}}}
	} //}}}
	//{{{ GetFileTypeRequest class
	class GetFileTypeRequest implements Runnable
	{
		VFS    vfs;
		Object session;
		String path;
		int[]  type;
		GetFileTypeRequest(VFS vfs, Object session,
			String path, int[] type)
		{
			this.vfs     = vfs;
			this.session = session;
			this.path    = path;
			this.type    = type;
		}
		public void run()
		{
			try
			{
				VFS.DirectoryEntry entry
					= vfs._getDirectoryEntry(
						session,
						path,
						browser);
				if(entry == null)
				{
					// non-existent file
					type[0] = VFS.DirectoryEntry.FILE;
				}
				else
					type[0] = entry.type;
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,this,e);
				VFSManager.error(browser,path,
					""ioerror"",
					new String[]
					{ e.toString() });
				return;
			}
			finally
			{
				try
				{
					vfs._endVFSSession(
						session,
						browser);
				}
				catch(IOException e)
				{
					Log.log(Log.ERROR,this,e);
					VFSManager.error(browser,path,
						""ioerror"",
						new String[]
						{ e.toString() });
					return;
				}
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.browser.VFSFileNameField,"/*
 * VFSFileNameField.java - File name field with completion
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import org.gjt.sp.jedit.gui.HistoryTextField;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.OperatingSystem;
//}}}
/**
 * @author Slava Pestov
 * @version $Id: VFSFileNameField.java,v 1.22 2004/07/30 07:25:02 spestov Exp $
 * @since jEdit 4.2pre1
 */
class VFSFileNameField extends HistoryTextField
{
	//{{{ VFSFileNameField constructor
	VFSFileNameField(VFSBrowser browser, String model)
	{
		super(model);
		setEnterAddsToHistory(false);
		this.browser = browser;
		Dimension dim = getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		setMaximumSize(dim);
		ActionMap map = getActionMap();
		Action backspace = map.get(""delete-previous"");
		map.put(""delete-previous"",new BackspaceAction(backspace));
	} //}}}
	//{{{ isManagingFocus() method
	public boolean isManagingFocus()
	{
		return false;
	} //}}}
	//{{{ getFocusTraversalKeysEnabled() method
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} //}}}
	//{{{ processKeyEvent() method
	public void processKeyEvent(KeyEvent evt)
	{
		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			String path = getText();
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_TAB:
				doComplete(path);
				break;
			case KeyEvent.VK_LEFT:
				if(getCaretPosition() == 0)
					browser.getBrowserView().getTable().processKeyEvent(evt);
				else
					super.processKeyEvent(evt);
				break;
			case KeyEvent.VK_RIGHT:
				if(getCaretPosition() == getDocument().getLength())
					browser.getBrowserView().getTable().processKeyEvent(evt);
				else
					super.processKeyEvent(evt);
				break;
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
			case KeyEvent.VK_PAGE_UP:
			case KeyEvent.VK_PAGE_DOWN:
				browser.getBrowserView().getTable()
					.processKeyEvent(evt);
				break;
			case KeyEvent.VK_ENTER:
				browser.filesActivated(
					(evt.isShiftDown()
					? VFSBrowser.M_OPEN_NEW_VIEW
					: VFSBrowser.M_OPEN),false);
				setText(null);
				evt.consume();
				break;
			default:
				super.processKeyEvent(evt);
				break;
			}
		}
		else if(evt.getID() == KeyEvent.KEY_TYPED)
		{
			char ch = evt.getKeyChar();
			if((ch == '/' || ch == File.separatorChar)
				&& getCaretPosition()
				== getDocument().getLength())
			{
				super.processKeyEvent(evt);
				String path = getText();
				if(path.length() == 2 && path.charAt(0) == '-')
				{
					path = browser.getView().getBuffer()
						.getDirectory();
				}
				else if(path.length() == 3 && path.startsWith(""..""))
				{
					path = MiscUtilities.getParentOfPath(
						browser.getDirectory());
					VFS vfs = VFSManager.getVFSForPath(path);
					if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
					{
						browser.setDirectory(path);
						VFSManager.waitForRequests();
						setText(null);
					}
				}
				else if(!MiscUtilities.isAbsolutePath(path))
				{
					VFS.DirectoryEntry[] files = browser
						.getBrowserView().getSelectedFiles();
					if(files.length != 1
						|| files[0].type ==
						VFS.DirectoryEntry.FILE)
					{
						return;
					}
					path = files[0].path;
				}
				else if(OperatingSystem.isDOSDerived()
					&& path.length() == 3
					&& path.charAt(1) == ':')
				{
					browser.setDirectory(path);
					VFSManager.waitForRequests();
					setText(null);
				}
				VFS vfs = VFSManager.getVFSForPath(path);
				if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
				{
					setText(null);
					browser.setDirectory(path);
					VFSManager.waitForRequests();
				}
				else
				{
					if(path.endsWith(""/"") || path.endsWith(File.separator))
						setText(path);
					else
						setText(path + vfs.getFileSeparator());
				}
			}
			else if(ch > 0x20 && ch != 0x7f && ch != 0xff)
			{
				super.processKeyEvent(evt);
				String path = getText();
				BrowserView view = browser.getBrowserView();
				view.selectNone();
				int mode = browser.getMode();
				// fix for bug #765507
				// we don't type complete in save dialog
				// boxes. Press TAB to do an explicit
				// complete
				view.getTable().doTypeSelect(path,
					mode == VFSBrowser
					.CHOOSE_DIRECTORY_DIALOG
					||
					mode == VFSBrowser
					.SAVE_DIALOG);
			}
			else
				super.processKeyEvent(evt);
		}
	} //}}}
	//{{{ Private members
	private VFSBrowser browser;
	//{{{ doComplete() method
	private void doComplete(String currentText)
	{
		BrowserView view = browser.getBrowserView();
		view.selectNone();
		view.getTable().doTypeSelect(currentText,
			browser.getMode() == VFSBrowser
			.CHOOSE_DIRECTORY_DIALOG);
		VFS.DirectoryEntry[] files = view.getSelectedFiles();
		if(files.length == 0)
			return;
		String path = files[0].path;
		String name = files[0].name;
		String parent = MiscUtilities.getParentOfPath(path);
		String newText;
		if(MiscUtilities.isAbsolutePath(currentText)
			&& !currentText.startsWith(browser.getDirectory()))
		{
			newText = path;
		}
		else
		{
			if(VFSBrowser.pathsEqual(parent,browser.getDirectory()))
				newText = name;
			else
				newText = path;
		}
		setText(newText);
	} //}}}
	//{{{ goToParent() method
	private void goToParent()
	{
		String name = MiscUtilities.getFileName(browser.getDirectory());
		String parent = MiscUtilities.getParentOfPath(
			browser.getDirectory());
		browser.setDirectory(parent);
		VFS vfs = VFSManager.getVFSForPath(parent);
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)
		{
			VFSManager.waitForRequests();
			setText(name);
			browser.getBrowserView().getTable().doTypeSelect(
				name,browser.getMode() == VFSBrowser
				.CHOOSE_DIRECTORY_DIALOG);
		}
	} //}}}
	//}}}
	//{{{ BackspaceAction class
	/**
	 * In 4.3, I need to change all the keystrokes to use actions.
	 */
	class BackspaceAction extends AbstractAction
	{
		private Action delegate;
		BackspaceAction(Action delegate)
		{
			this.delegate = delegate;
		}
		public void actionPerformed(ActionEvent evt)
		{
			if(getSelectionStart() == 0
				&& getSelectionEnd() == 0)
			{
				goToParent();
			}
			else
			{
				delegate.actionPerformed(evt);
				String path = getText();
				BrowserView view = browser.getBrowserView();
				view.selectNone();
				int mode = browser.getMode();
				// fix for bug #765507
				// we don't type complete in save dialog
				// boxes. Press TAB to do an explicit
				// complete
				view.getTable().doTypeSelect(path,
					mode == VFSBrowser
					.CHOOSE_DIRECTORY_DIALOG
					||
					mode == VFSBrowser
					.SAVE_DIALOG);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.buffer.BufferChangeAdapter,"/*
 * BufferChangeListener.java - Buffer listener adapter
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import org.gjt.sp.jedit.Buffer;
/**
 * An adapter you can subclass to avoid having to implement all the methods
 * of the {@link BufferChangeListener} interface.
 * @author Slava Pestov
 * @version $Id: BufferChangeAdapter.java,v 1.12 2003/11/16 22:54:36 spestov Exp $
 * @since jEdit 4.0pre1
 */
public abstract class BufferChangeAdapter implements BufferChangeListener
{
	//{{{ foldLevelChanged() method
	/**
	 * Called when line fold levels change.
	 * @param buffer The buffer in question
	 * @param start The start line number
	 * @param end The end line number
	 * @since jEdit 4.0pre1
	 */
	public void foldLevelChanged(Buffer buffer, int start, int end)
	{
	} //}}}
	//{{{ contentInserted() method
	/**
	 * Called when text is inserted into the buffer.
	 * @param buffer The buffer in question
	 * @param startLine The first line
	 * @param offset The start offset, from the beginning of the buffer
	 * @param numLines The number of lines inserted
	 * @param length The number of characters inserted
	 * @since jEdit 4.0pre1
	 */
	public void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	//}}}
	//{{{ preContentRemoved() method
	/**
	 * Called when text is about to be removed from the buffer, but is
	 * still present.
	 * @param buffer The buffer in question
	 * @param startLine The first line
	 * @param offset The start offset, from the beginning of the buffer
	 * @param numLines The number of lines to be removed
	 * @param length The number of characters to be removed
	 * @since jEdit 4.2pre1
	 */
	public void preContentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	//}}}
	//{{{ contentRemoved() method
	/**
	 * Called when text is removed from the buffer.
	 * @param buffer The buffer in question
	 * @param startLine The first line
	 * @param offset The start offset, from the beginning of the buffer
	 * @param numLines The number of lines removed
	 * @param length The number of characters removed
	 * @since jEdit 4.0pre1
	 */
	public void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	//}}}
	//{{{ transactionComplete() method
	/**
	 * Called after an undo or compound edit has finished. The text area
	 * uses this event to queue up and collapse cleanup operations so they
	 * are only run once during a long transaction (such as a ""Replace All""
	 * operation.)
	 *
	 * @param buffer The buffer in question
	 * @since jEdit 4.0pre6
	 */
	public void transactionComplete(Buffer buffer) {}
	//}}}
	//{{{ foldHandlerChanged() method
	/**
	 * Called to notify the text area that folds need to be collapsed if
	 * the ""collapseFolds"" property is set. This method is called after the
	 * buffer has been loaded, and also if the user changes the fold
	 * handler.
	 *
	 * @param buffer The buffer in question
	 * @since jEdit 4.2pre2
	 */
	public void foldHandlerChanged(Buffer buffer) {}
	//}}}
}
"
org.gjt.sp.jedit.buffer.BufferChangeListener,"/*
 * BufferChangeListener.java - Buffer listener interface
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import org.gjt.sp.jedit.Buffer;
/**
 * A interface for notification of changes to buffer text. While the
 * {@link org.gjt.sp.jedit.msg.BufferUpdate} EditBus message is used for
 * general buffer state changes, this interface is used for events which are
 * fired frequently, or for which performance is essential.<p>
 *
 * Because this interface is subject to change in the future, you
 * should subclass <code>BufferChangeAdapter</code> instead of
 * implementing it directly.
 *
 * @author Slava Pestov
 * @version $Id: BufferChangeListener.java,v 1.12 2004/03/28 00:07:26 spestov Exp $
 * @since jEdit 4.0pre1
 */
public interface BufferChangeListener
{
	//{{{ foldLevelChanged() method
	/**
	 * Called when line fold levels change.
	 * @param buffer The buffer in question
	 * @param startLine The start line number
	 * @param endLine The end line number
	 * @since jEdit 4.0pre1
	 */
	void foldLevelChanged(Buffer buffer, int startLine, int endLine);
	//}}}
	//{{{ contentInserted() method
	/**
	 * Called when text is inserted into the buffer.
	 * @param buffer The buffer in question
	 * @param startLine The first line
	 * @param offset The start offset, from the beginning of the buffer
	 * @param numLines The number of lines inserted
	 * @param length The number of characters inserted
	 * @since jEdit 4.0pre1
	 */
	void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	//}}}
	//{{{ contentRemoved() method
	/**
	 * Called when text is removed from the buffer.
	 * @param buffer The buffer in question
	 * @param startLine The first line
	 * @param offset The start offset, from the beginning of the buffer
	 * @param numLines The number of lines removed
	 * @param length The number of characters removed
	 * @since jEdit 4.0pre1
	 */
	void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	//}}}
	//{{{ preContentRemoved() method
	/**
	 * Called when text is about to be removed from the buffer, but is
	 * still present.
	 * @param buffer The buffer in question
	 * @param startLine The first line
	 * @param offset The start offset, from the beginning of the buffer
	 * @param numLines The number of lines to be removed
	 * @param length The number of characters to be removed
	 * @since jEdit 4.2pre1
	 */
	public void preContentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	//}}}
	//{{{ transactionComplete() method
	/**
	 * Called after an undo or compound edit has finished. The text area
	 * uses this event to queue up and collapse cleanup operations so they
	 * are only run once during a long transaction (such as a ""Replace All""
	 * operation.)
	 *
	 * @param buffer The buffer in question
	 * @since jEdit 4.0pre6
	 */
	void transactionComplete(Buffer buffer);
	//}}}
	//{{{ foldHandlerChanged() method
	/**
	 * Called to notify the text area that folds need to be collapsed if
	 * the ""collapseFolds"" property is set. This method is called after the
	 * buffer has been loaded, and also if the user changes the fold
	 * handler.
	 *
	 * @param buffer The buffer in question
	 * @since jEdit 4.2pre2
	 */
	void foldHandlerChanged(Buffer buffer);
	//}}}
}
"
org.gjt.sp.jedit.buffer.BufferIORequest,"/*
 * BufferIORequest.java - I/O request
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
//{{{ Imports
import javax.swing.text.Segment;
import java.io.*;
import java.util.zip.*;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
//}}}
/**
 * A buffer I/O request.
 * @author Slava Pestov
 * @version $Id: BufferIORequest.java,v 1.28 2004/08/29 02:58:43 spestov Exp $
 */
public class BufferIORequest extends WorkRequest
{
	//{{{ Constants
	/**
	 * Size of I/O buffers.
	 */
	public static final int IOBUFSIZE = 32768;
	/**
	 * Number of lines per progress increment.
	 */
	public static final int PROGRESS_INTERVAL = 300;
	public static final String LOAD_DATA = ""BufferIORequest__loadData"";
	public static final String END_OFFSETS = ""BufferIORequest__endOffsets"";
	public static final String NEW_PATH = ""BufferIORequest__newPath"";
	/**
	 * Buffer boolean property set when an error occurs.
	 */
	public static final String ERROR_OCCURRED = ""BufferIORequest__error"";
	/**
	 * A file load request.
	 */
	public static final int LOAD = 0;
	/**
	 * A file save request.
	 */
	public static final int SAVE = 1;
	/**
	 * An autosave request. Only supported for local files.
	 */
	public static final int AUTOSAVE = 2;
	/**
	 * An insert file request.
	 */
	public static final int INSERT = 3;
	/**
	 * Magic numbers used for auto-detecting Unicode and GZIP files.
	 */
	public static final int GZIP_MAGIC_1 = 0x1f;
	public static final int GZIP_MAGIC_2 = 0x8b;
	public static final int UNICODE_MAGIC_1 = 0xfe;
	public static final int UNICODE_MAGIC_2 = 0xff;
	public static final int UTF8_MAGIC_1 = 0xef;
	public static final int UTF8_MAGIC_2 = 0xbb;
	public static final int UTF8_MAGIC_3 = 0xbf;
	/**
	 * Length of longest XML PI used for encoding detection.<p>
	 * &lt;?xml version=""1.0"" encoding=""................""?&gt;
	 */
	public static final int XML_PI_LENGTH = 50;
	//}}}
	//{{{ BufferIORequest constructor
	/**
	 * Creates a new buffer I/O request.
	 * @param type The request type
	 * @param view The view
	 * @param buffer The buffer
	 * @param session The VFS session
	 * @param vfs The VFS
	 * @param path The path
	 */
	public BufferIORequest(int type, View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		this.type = type;
		this.view = view;
		this.buffer = buffer;
		this.session = session;
		this.vfs = vfs;
		this.path = path;
		markersPath = vfs.getParentOfPath(path)
			+ '.' + vfs.getFileName(path)
			+ "".marks"";
	} //}}}
	//{{{ run() method
	public void run()
	{
		switch(type)
		{
		case LOAD:
			load();
			break;
		case SAVE:
			save();
			break;
		case AUTOSAVE:
			autosave();
			break;
		case INSERT:
			insert();
			break;
		default:
			throw new InternalError();
		}
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LOAD:
			typeString = ""LOAD"";
			break;
		case SAVE:
			typeString = ""SAVE"";
			break;
		case AUTOSAVE:
			typeString = ""AUTOSAVE"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
		}
		return getClass().getName() + ""[type="" + typeString
			+ "",buffer="" + buffer + ""]"";
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private int type;
	private View view;
	private Buffer buffer;
	private Object session;
	private VFS vfs;
	private String path;
	private String markersPath;
	//}}}
	//{{{ load() method
	private void load()
	{
		InputStream in = null;
		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setAbortable(true);
				if(!buffer.isTemporary())
				{
					setStatus(jEdit.getProperty(""vfs.status.load"",args));
					setProgressValue(0);
				}
				path = vfs._canonPath(session,path,view);
				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;
				in = vfs._createInputStream(session,path,
					false,view);
				if(in == null)
					return;
				read(autodetect(in),length,false);
				buffer.setNewFile(false);
			}
			catch(CharConversionException ch)
			{
				Log.log(Log.ERROR,this,ch);
				Object[] pp = { buffer.getProperty(Buffer.ENCODING),
					ch.toString() };
				VFSManager.error(view,path,""ioerror.encoding-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(UnsupportedEncodingException uu)
			{
				Log.log(Log.ERROR,this,uu);
				Object[] pp = { buffer.getProperty(Buffer.ENCODING),
					uu.toString() };
				VFSManager.error(view,path,""ioerror.encoding-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				Object[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(OutOfMemoryError oom)
			{
				Log.log(Log.ERROR,this,oom);
				VFSManager.error(view,path,""out-of-memory-error"",null);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			if(jEdit.getBooleanProperty(""persistentMarkers""))
			{
				try
				{
					String[] args = { vfs.getFileName(path) };
					if(!buffer.isTemporary())
						setStatus(jEdit.getProperty(""vfs.status.load-markers"",args));
					setAbortable(true);
					in = vfs._createInputStream(session,markersPath,true,view);
					if(in != null)
						readMarkers(buffer,in);
				}
				catch(IOException io)
				{
					// ignore
				}
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} //}}}
	//{{{ autodetect() method
	/**
	 * Tries to detect if the stream is gzipped, and if it has an encoding
	 * specified with an XML PI.
	 */
	private Reader autodetect(InputStream in) throws IOException
	{
		in = new BufferedInputStream(in);
		String encoding = buffer.getStringProperty(Buffer.ENCODING);
		if(!in.markSupported())
			Log.log(Log.WARNING,this,""Mark not supported: "" + in);
		else if(buffer.getBooleanProperty(Buffer.ENCODING_AUTODETECT))
		{
			in.mark(XML_PI_LENGTH);
			int b1 = in.read();
			int b2 = in.read();
			int b3 = in.read();
			if(encoding.equals(MiscUtilities.UTF_8_Y))
			{
				// Java does not support this encoding so
				// we have to handle it manually.
				if(b1 != UTF8_MAGIC_1 || b2 != UTF8_MAGIC_2
					|| b3 != UTF8_MAGIC_3)
				{
					// file does not begin with UTF-8-Y
					// signature. reset stream, read as
					// UTF-8.
					in.reset();
				}
				else
				{
					// file begins with UTF-8-Y signature.
					// discard the signature, and read
					// the remainder as UTF-8.
				}
				encoding = ""UTF-8"";
			}
			else if(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)
			{
				in.reset();
				in = new GZIPInputStream(in);
				buffer.setBooleanProperty(Buffer.GZIPPED,true);
				// auto-detect encoding within the gzip stream.
				return autodetect(in);
			}
			else if((b1 == UNICODE_MAGIC_1
				&& b2 == UNICODE_MAGIC_2)
				|| (b1 == UNICODE_MAGIC_2
				&& b2 == UNICODE_MAGIC_1))
			{
				in.reset();
				encoding = ""UTF-16"";
				buffer.setProperty(Buffer.ENCODING,encoding);
			}
			else if(b1 == UTF8_MAGIC_1 && b2 == UTF8_MAGIC_2
				&& b3 == UTF8_MAGIC_3)
			{
				// do not reset the stream and just treat it
				// like a normal UTF-8 file.
				buffer.setProperty(Buffer.ENCODING,
					MiscUtilities.UTF_8_Y);
				encoding = ""UTF-8"";
			}
			else
			{
				in.reset();
				byte[] _xmlPI = new byte[XML_PI_LENGTH];
				int offset = 0;
				int count;
				while((count = in.read(_xmlPI,offset,
					XML_PI_LENGTH - offset)) != -1)
				{
					offset += count;
					if(offset == XML_PI_LENGTH)
						break;
				}
				String xmlPI = new String(_xmlPI,0,offset,
				""ASCII"");
				if(xmlPI.startsWith(""<?xml""))
				{
					int index = xmlPI.indexOf(""encoding="");
					if(index != -1
						&& index + 9 != xmlPI.length())
					{
						char ch = xmlPI.charAt(index
						+ 9);
						int endIndex = xmlPI.indexOf(ch,
							index + 10);
						encoding = xmlPI.substring(
							index + 10,endIndex);
						if(MiscUtilities.isSupportedEncoding(encoding))
						{
							buffer.setProperty(Buffer.ENCODING,encoding);
						}
						else
						{
							Log.log(Log.WARNING,this,""XML PI specifies unsupported encoding: "" + encoding);
						}
					}
				}
				in.reset();
			}
		}
		return new InputStreamReader(in,encoding);
	} //}}}
	//{{{ read() method
	private SegmentBuffer read(Reader in, long length,
		boolean insert) throws IOException
	{
		/* we guess an initial size for the array */
		IntegerArray endOffsets = new IntegerArray(
			Math.max(1,(int)(length / 50)));
		// only true if the file size is known
		boolean trackProgress = (!buffer.isTemporary() && length != 0);
		if(trackProgress)
		{
			setProgressValue(0);
			setProgressMaximum((int)length);
		}
		// if the file size is not known, start with a resonable
		// default buffer size
		if(length == 0)
			length = IOBUFSIZE;
		SegmentBuffer seg = new SegmentBuffer((int)length + 1);
		char[] buf = new char[IOBUFSIZE];
		// Number of characters in 'buf' array.
		// InputStream.read() doesn't always fill the
		// array (eg, the file size is not a multiple of
		// IOBUFSIZE, or it is a GZipped file, etc)
		int len;
		// True if a \n was read after a \r. Usually
		// means this is a DOS/Windows file
		boolean CRLF = false;
		// A \r was read, hence a MacOS file
		boolean CROnly = false;
		// Was the previous read character a \r?
		// If we read a \n and this is true, we assume
		// we have a DOS/Windows file
		boolean lastWasCR = false;
		// Number of lines read. Every 100 lines, we update the
		// progress bar
		int lineCount = 0;
		while((len = in.read(buf,0,buf.length)) != -1)
		{
			// Offset of previous line, relative to
			// the start of the I/O buffer (NOT
			// relative to the start of the document)
			int lastLine = 0;
			for(int i = 0; i < len; i++)
			{
				// Look for line endings.
				switch(buf[i])
				{
				case '\r':
					// If we read a \r and
					// lastWasCR is also true,
					// it is probably a Mac file
					// (\r\r in stream)
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
					}
					// Otherwise set a flag,
					// so that \n knows that last
					// was a \r
					else
					{
						lastWasCR = true;
					}
					// Insert a line
					seg.append(buf,lastLine,i -
						lastLine);
					seg.append('\n');
					endOffsets.add(seg.count);
					if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
						setProgressValue(seg.count);
					// This is i+1 to take the
					// trailing \n into account
					lastLine = i + 1;
					break;
				case '\n':
					// If lastWasCR is true,
					// we just read a \r followed
					// by a \n. We specify that
					// this is a Windows file,
					// but take no further
					// action and just ignore
					// the \r.
					if(lastWasCR)
					{
						CROnly = false;
						CRLF = true;
						lastWasCR = false;
						// Bump lastLine so
						// that the next line
						// doesn't erronously
						// pick up the \r
						lastLine = i + 1;
					}
					// Otherwise, we found a \n
					// that follows some other
					// character, hence we have
					// a Unix file
					else
					{
						CROnly = false;
						CRLF = false;
						seg.append(buf,lastLine,
							i - lastLine);
						seg.append('\n');
						endOffsets.add(seg.count);
						if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
							setProgressValue(seg.count);
						lastLine = i + 1;
					}
					break;
				default:
					// If we find some other
					// character that follows
					// a \r, so it is not a
					// Windows file, and probably
					// a Mac file
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
						lastWasCR = false;
					}
					break;
				}
			}
			if(trackProgress)
				setProgressValue(seg.count);
			// Add remaining stuff from buffer
			seg.append(buf,lastLine,len - lastLine);
		}
		setAbortable(false);
		String lineSeparator;
		if(seg.count == 0)
		{
			// fix for ""[ 865589 ] 0-byte files should open using
			// the default line seperator""
			lineSeparator = jEdit.getProperty(
				""buffer.lineSeparator"",
				System.getProperty(""line.separator""));
		}
		else if(CRLF)
			lineSeparator = ""\r\n"";
		else if(CROnly)
			lineSeparator = ""\r"";
		else
			lineSeparator = ""\n"";
		in.close();
		// Chop trailing newline and/or ^Z (if any)
		int bufferLength = seg.count;
		if(bufferLength != 0)
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == 0x1a /* DOS ^Z */)
				seg.count--;
		}
		buffer.setBooleanProperty(Buffer.TRAILING_EOL,false);
		if(bufferLength != 0 && jEdit.getBooleanProperty(""stripTrailingEOL""))
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == '\n')
			{
				buffer.setBooleanProperty(Buffer.TRAILING_EOL,true);
				seg.count--;
				endOffsets.setSize(endOffsets.getSize() - 1);
			}
		}
		// add a line marker at the end for proper offset manager
		// operation
		endOffsets.add(seg.count + 1);
		// to avoid having to deal with read/write locks and such,
		// we insert the loaded data into the buffer in the
		// post-load cleanup runnable, which runs in the AWT thread.
		if(!insert)
		{
			buffer.setProperty(LOAD_DATA,seg);
			buffer.setProperty(END_OFFSETS,endOffsets);
			buffer.setProperty(NEW_PATH,path);
			if(lineSeparator != null)
				buffer.setProperty(Buffer.LINESEP,lineSeparator);
		}
		// used in insert()
		return seg;
	} //}}}
	//{{{ readMarkers() method
	private void readMarkers(Buffer buffer, InputStream _in)
		throws IOException
	{
		// For `reload' command
		buffer.removeAllMarkers();
		BufferedReader in = new BufferedReader(new InputStreamReader(_in));
		try
		{
			String line;
			while((line = in.readLine()) != null)
			{
				// compatibility kludge for jEdit 3.1 and earlier
				if(!line.startsWith(""!""))
					continue;
				char shortcut = line.charAt(1);
				int start = line.indexOf(';');
				int end = line.indexOf(';',start + 1);
				int position = Integer.parseInt(line.substring(start + 1,end));
				buffer.addMarker(shortcut,position);
			}
		}
		finally
		{
			in.close();
		}
	} //}}}
	//{{{ save() method
	private void save()
	{
		OutputStream out = null;
		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.save"",args));
			// the entire save operation can be aborted...
			setAbortable(true);
			path = vfs._canonPath(session,path,view);			if(!MiscUtilities.isURL(path))
				path = MiscUtilities.resolveSymlinks(path);
			// Only backup once per session
			if(buffer.getProperty(Buffer.BACKED_UP) == null
				|| jEdit.getBooleanProperty(""backupEverySave""))
			{
				vfs._backup(session,path,view);
				buffer.setBooleanProperty(Buffer.BACKED_UP,true);
			}
			/* if the VFS supports renaming files, we first
			 * save to #<filename>#save#, then rename that
			 * to <filename>, so that if the save fails,
			 * data will not be lost.
			 *
			 * as of 4.1pre7 we now call vfs.getTwoStageSaveName()
			 * instead of constructing the path directly
			 * since some VFS's might not allow # in filenames.
			 */
			String savePath;
			boolean twoStageSave = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0
				&& jEdit.getBooleanProperty(""twoStageSave"");
			if(twoStageSave)
				savePath = vfs.getTwoStageSaveName(path);
			else
				savePath = path;
			out = vfs._createOutputStream(session,savePath,view);
			try
			{
				// this must be after the stream is created or
				// we deadlock with SSHTools.
				buffer.readLock();
				if(out != null)
				{
					// Can't use buffer.getName() here because
					// it is not changed until the save is
					// complete
					if(savePath.endsWith("".gz""))
						buffer.setBooleanProperty(Buffer.GZIPPED,true);
					if(buffer.getBooleanProperty(Buffer.GZIPPED))
						out = new GZIPOutputStream(out);
					write(buffer,out);
					if(twoStageSave)
					{
						if(!vfs._rename(session,savePath,path,view))
							throw new IOException(""Rename failed: "" + savePath);
					}
					// We only save markers to VFS's that support deletion.
					// Otherwise, we will accumilate stale marks files.
					if((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)
					{
						if(jEdit.getBooleanProperty(""persistentMarkers"")
							&& buffer.getMarkers().size() != 0)
						{
							setStatus(jEdit.getProperty(""vfs.status.save-markers"",args));
							setProgressValue(0);
							out = vfs._createOutputStream(session,markersPath,view);
							if(out != null)
								writeMarkers(buffer,out);
						}
						else
							vfs._delete(session,markersPath,view);
					}
				}
				else
					buffer.setBooleanProperty(ERROR_OCCURRED,true);
				if(!twoStageSave)
					VFSManager.sendVFSUpdate(vfs,path,true);
			}
			finally
			{
				buffer.readUnlock();
			}
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			String[] pp = { io.toString() };
			VFSManager.error(view,path,""ioerror.write-error"",pp);
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._saveComplete(session,buffer,path,view);
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} //}}}
	//{{{ autosave() method
	private void autosave()
	{
		OutputStream out = null;
		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.autosave"",args));
			// the entire save operation can be aborted...
			setAbortable(true);
			try
			{
				//buffer.readLock();
				if(!buffer.isDirty())
				{
					// buffer has been saved while we
					// were waiting.
					return;
				}
				out = vfs._createOutputStream(session,path,view);
				if(out == null)
					return;
				write(buffer,out);
			}
			catch(Exception e)
			{
			}
			finally
			{
				//buffer.readUnlock();
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}
		}
	} //}}}
	//{{{ write() method
	private void write(Buffer buffer, OutputStream _out)
		throws IOException
	{
		BufferedWriter out = null;
		try
		{
			String encoding = buffer.getStringProperty(Buffer.ENCODING);
			if(encoding.equals(MiscUtilities.UTF_8_Y))
			{
				// not supported by Java...
				_out.write(UTF8_MAGIC_1);
				_out.write(UTF8_MAGIC_2);
				_out.write(UTF8_MAGIC_3);
				_out.flush();
				encoding = ""UTF-8"";
			}
			out = new BufferedWriter(
				new OutputStreamWriter(_out,encoding),
				IOBUFSIZE);
			Segment lineSegment = new Segment();
			String newline = buffer.getStringProperty(Buffer.LINESEP);
			if(newline == null)
				newline = System.getProperty(""line.separator"");
			setProgressMaximum(buffer.getLineCount() / PROGRESS_INTERVAL);
			setProgressValue(0);
			int i = 0;
			while(i < buffer.getLineCount())
			{
				buffer.getLineText(i,lineSegment);
				out.write(lineSegment.array,lineSegment.offset,
					lineSegment.count);
				if(i != buffer.getLineCount() - 1)
				{
					out.write(newline);
				}
				if(++i % PROGRESS_INTERVAL == 0)
					setProgressValue(i / PROGRESS_INTERVAL);
			}
			if(jEdit.getBooleanProperty(""stripTrailingEOL"")
				&& buffer.getBooleanProperty(Buffer.TRAILING_EOL))
			{
				out.write(newline);
			}
		}
		finally
		{
			if(out != null)
				out.close();
			else
				_out.close();
		}
	} //}}}
	//{{{ writeMarkers() method
	private void writeMarkers(Buffer buffer, OutputStream out)
		throws IOException
	{
		Writer o = new BufferedWriter(new OutputStreamWriter(out));
		try
		{
			Vector markers = buffer.getMarkers();
			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				o.write('!');
				o.write(marker.getShortcut());
				o.write(';');
				String pos = String.valueOf(marker.getPosition());
				o.write(pos);
				o.write(';');
				o.write(pos);
				o.write('\n');
			}
		}
		finally
		{
			o.close();
		}
	} //}}}
	//{{{ insert() method
	private void insert()
	{
		InputStream in = null;
		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setAbortable(true);
				path = vfs._canonPath(session,path,view);
				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;
				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
					return;
				final SegmentBuffer seg = read(
					autodetect(in),length,true);
				/* we don't do this in Buffer.insert() so that
				   we can insert multiple files at once */
				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						view.getTextArea().setSelectedText(
							seg.toString());
					}
				});
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}
			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.buffer.ContentManager,"/*
 * ContentManager.java - Manages text content
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import javax.swing.text.Segment;
/**
 * A class internal to jEdit's document model. You should not use it
 * directly. To improve performance, none of the methods in this class
 * check for out of bounds access, nor are they thread-safe. The
 * <code>Buffer</code> class, through which these methods must be
 * called through, implements such protection.
 *
 * @author Slava Pestov
 * @version $Id: ContentManager.java,v 1.11 2003/03/09 19:26:05 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class ContentManager
{
	//{{{ getLength() method
	public final int getLength()
	{
		return length;
	} //}}}
	//{{{ getText() method
	public String getText(int start, int len)
	{
		if(start >= gapStart)
			return new String(text,start + gapEnd - gapStart,len);
		else if(start + len <= gapStart)
			return new String(text,start,len);
		else
		{
			return new String(text,start,gapStart - start)
				.concat(new String(text,gapEnd,start + len - gapStart));
		}
	} //}}}
	//{{{ getText() method
	public void getText(int start, int len, Segment seg)
	{
		if(start >= gapStart)
		{
			seg.array = text;
			seg.offset = start + gapEnd - gapStart;
			seg.count = len;
		}
		else if(start + len <= gapStart)
		{
			seg.array = text;
			seg.offset = start;
			seg.count = len;
		}
		else
		{
			seg.array = new char[len];
			// copy text before gap
			System.arraycopy(text,start,seg.array,0,gapStart - start);
			// copy text after gap
			System.arraycopy(text,gapEnd,seg.array,gapStart - start,
				len + start - gapStart);
			seg.offset = 0;
			seg.count = len;
		}
	} //}}}
	//{{{ insert() method
	public void insert(int start, String str)
	{
		int len = str.length();
		moveGapStart(start);
		if(gapEnd - gapStart < len)
		{
			ensureCapacity(length + len + 1024);
			moveGapEnd(start + len + 1024);
		}
		str.getChars(0,len,text,start);
		gapStart += len;
		length += len;
	} //}}}
	//{{{ insert() method
	public void insert(int start, Segment seg)
	{
		moveGapStart(start);
		if(gapEnd - gapStart < seg.count)
		{
			ensureCapacity(length + seg.count + 1024);
			moveGapEnd(start + seg.count + 1024);
		}
		System.arraycopy(seg.array,seg.offset,text,start,seg.count);
		gapStart += seg.count;
		length += seg.count;
	} //}}}
	//{{{ _setContent() method
	public void _setContent(char[] text, int length)
	{
		this.text = text;
		this.gapStart = this.gapEnd = 0;
		this.length = length;
	} //}}}
	//{{{ remove() method
	public void remove(int start, int len)
	{
		moveGapStart(start);
		gapEnd += len;
		length -= len;
	} //}}}
	//{{{ Private members
	private char[] text;
	private int gapStart;
	private int gapEnd;
	private int length;
	//{{{ moveGapStart() method
	private void moveGapStart(int newStart)
	{
		int newEnd = gapEnd + (newStart - gapStart);
		if(newStart == gapStart)
		{
			// nothing to do
		}
		else if(newStart > gapStart)
		{
			System.arraycopy(text,gapEnd,text,gapStart,
				newStart - gapStart);
		}
		else if(newStart < gapStart)
		{
			System.arraycopy(text,newStart,text,newEnd,
				gapStart - newStart);
		}
		gapStart = newStart;
		gapEnd = newEnd;
	} //}}}
	//{{{ moveGapEnd() method
	private void moveGapEnd(int newEnd)
	{
		System.arraycopy(text,gapEnd,text,newEnd,length - gapStart);
		gapEnd = newEnd;
	} //}}}
	//{{{ ensureCapacity() method
	private void ensureCapacity(int capacity)
	{
		if(capacity >= text.length)
		{
			char[] textN = new char[capacity * 2];
			System.arraycopy(text,0,textN,0,length + (gapEnd - gapStart));
			text = textN;
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.buffer.DummyFoldHandler,"/*
 * DummyFoldHandler.java - Fold handler used when folding is switched off
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;
/**
 * A fold handler that does nothing.
 * @author Slava Pestov
 * @version $Id: DummyFoldHandler.java,v 1.3 2002/02/09 09:13:20 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class DummyFoldHandler extends FoldHandler
{
	//{{{ DummyFoldHandler constructor
	public DummyFoldHandler()
	{
		super(""none"");
	}
	//}}}
	//{{{ getFoldLevel() method
	/**
	 * Returns the fold level of the specified line.
	 * @param buffer The buffer in question
	 * @param lineIndex The line index
	 * @param seg A segment the fold handler can use to obtain any
	 * text from the buffer, if necessary
	 * @return The fold level of the specified line
	 * @since jEdit 4.0pre1
	 */
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		return 0;
	} //}}}
}
"
org.gjt.sp.jedit.buffer.ExplicitFoldHandler,"/*
 * ExplicitFoldHandler.java - Explicit fold handler
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;
/**
 * A fold handler that folds lines based on markers (""{{{"" and ""}}}"")
 * embedded in the text.
 *
 * @author Slava Pestov
 * @version $Id: ExplicitFoldHandler.java,v 1.8 2003/11/18 20:51:57 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class ExplicitFoldHandler extends FoldHandler
{
	//{{{ ExplicitFoldHandler constructor
	public ExplicitFoldHandler()
	{
		super(""explicit"");
	} //}}}
	//{{{ getFoldLevel() method
	/**
	 * Returns the fold level of the specified line.
	 * @param buffer The buffer in question
	 * @param lineIndex The line index
	 * @param seg A segment the fold handler can use to obtain any
	 * text from the buffer, if necessary
	 * @return The fold level of the specified line
	 * @since jEdit 4.0pre1
	 */
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		if(lineIndex == 0)
			return 0;
		else
		{
			int foldLevel = buffer.getFoldLevel(lineIndex - 1);
			buffer.getLineText(lineIndex - 1,seg);
			int offset = seg.offset;
			int count = seg.count;
			int openingBrackets = 0, closingBrackets = 0;
			for(int i = 0; i < count; i++)
			{
				switch(seg.array[offset + i])
				{
				case '{':
					closingBrackets = 0;
					openingBrackets++;
					if(openingBrackets == 3)
					{
						foldLevel++;
						openingBrackets = 0;
					}
					break;
				case '}':
					openingBrackets = 0;
					closingBrackets++;
					if(closingBrackets == 3)
					{
						if(foldLevel > 0)
							foldLevel--;
						closingBrackets = 0;
					}
					break;
				default:
					closingBrackets = openingBrackets = 0;
					break;
				}
			}
			return foldLevel;
		}
	} //}}}
}
"
org.gjt.sp.jedit.buffer.FoldHandler,"/*
 * FoldHandler.java - Fold handler interface
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.ServiceManager;
import org.gjt.sp.util.Log;
/**
 * Interface for obtaining the fold level of a specified line.<p>
 *
 * Plugins can provide fold handlers by defining entries in their
 * <code>services.xml</code> files like so:
 *
 * <pre>&lt;SERVICE CLASS=""org.gjt.sp.jedit.buffer.FoldHandler"" NAME=""<i>name</i>""&gt;
 *    new <i>MyFoldHandler<i>();
 *&lt;/SERVICE&gt;</pre>
 *
 * See {@link org.gjt.sp.jedit.ServiceManager} for details.
 *
 * @author Slava Pestov
 * @version $Id: FoldHandler.java,v 1.14 2003/11/18 20:51:57 spestov Exp $
 * @since jEdit 4.0pre1
 */
public abstract class FoldHandler
{
	/**
	 * The service type. See {@link org.gjt.sp.jedit.ServiceManager}.
	 * @since jEdit 4.2pre1
	 */
	public static final String SERVICE = ""org.gjt.sp.jedit.buffer.FoldHandler"";
	//{{{ getName() method
	/**
	 * Returns the internal name of this FoldHandler
	 * @return The internal name of this FoldHandler
	 * @since jEdit 4.0pre6
	 */
	public String getName()
	{
		return name;
	}
	//}}}
	//{{{ getFoldLevel() method
	/**
	 * Returns the fold level of the specified line.
	 * @param buffer The buffer in question
	 * @param lineIndex The line index
	 * @param seg A segment the fold handler can use to obtain any
	 * text from the buffer, if necessary
	 * @return The fold level of the specified line
	 * @since jEdit 4.0pre1
	 */
	public abstract int getFoldLevel(Buffer buffer, int lineIndex, Segment seg);
	//}}}
	//{{{ equals() method
	/**
	 * Returns if the specified fold handler is equal to this one.
	 * @param o The object
	 */
	public boolean equals(Object o)
	{
		// Default implementation... subclasses can extend this.
		if(o == null)
			return false;
		else
			return getClass() == o.getClass();
	} //}}}
	//{{{ hashCode() method
	public int hashCode()
	{
		return getClass().hashCode();
	} //}}}
	//{{{ registerFoldHandler() method
	/**
	 * @deprecated Write a <code>services.xml</code> file instead;
	 * see {@link org.gjt.sp.jedit.ServiceManager}.
	 */
	public static void registerFoldHandler(FoldHandler handler)
	{
		if (getFoldHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, FoldHandler.class, ""Cannot register more than one fold handler with the same name"");
			return;
		}
		foldHandlers.add(handler);
	}
	//}}}
	//{{{ unregisterFoldHandler() method
	/**
	 * @deprecated Write a <code>services.xml</code> file instead;
	 * see {@link org.gjt.sp.jedit.ServiceManager}.
	 */
	public static void unregisterFoldHandler(FoldHandler handler)
	{
		foldHandlers.remove(handler);
	}
	//}}}
	//{{{ getFoldHandlers() method
	/**
	 * @deprecated Call
	 * <code>ServiceManager.getServiceNames(
	 * ""org.gjt.sp.jedit.buffer.FoldHandler"" );</code> instead. See
	 * {@link org.gjt.sp.jedit.ServiceManager}.
	 */
	public static FoldHandler[] getFoldHandlers()
	{
		FoldHandler[] handlers = new FoldHandler[foldHandlers.size()];
		return (FoldHandler[])foldHandlers.toArray(handlers);
	}
	//}}}
	//{{{ getFoldHandler() method
	/**
	 * Returns the fold handler with the specified name, or null if
	 * there is no registered handler with that name.
	 * @param name The name of the desired fold handler
	 * @since jEdit 4.0pre6
	 */
	public static FoldHandler getFoldHandler(String name)
	{
		FoldHandler handler = (FoldHandler)ServiceManager
			.getService(SERVICE,name);
		if(handler != null)
			return handler;
		Iterator i = foldHandlers.iterator();
		while (i.hasNext())
		{
			handler = (FoldHandler)i.next();
			if (name.equals(handler.getName())) return handler;
		}
		return null;
	}
	//}}}
	//{{{ getFoldModes() method
	/**
	 * Returns an array containing the names of all registered fold
	 * handlers.
	 *
	 * @since jEdit 4.0pre6
	 */
	public static String[] getFoldModes()
	{
		FoldHandler[] handlers = getFoldHandlers();
		String[] newApi = ServiceManager.getServiceNames(SERVICE);
		String[] foldModes = new String[handlers.length
			+ newApi.length];
		System.arraycopy(newApi,0,foldModes,0,newApi.length);
		for (int i = 0; i < handlers.length; i++)
		{
			foldModes[i + newApi.length] = handlers[i].getName();
		}
		Arrays.sort(foldModes,new MiscUtilities.StringCompare());
		return foldModes;
	}
	//}}}
	//{{{ FoldHandler() constructor
	protected FoldHandler(String name)
	{
		this.name = name;
	}
	//}}}
	//{{{ toString() method
	public String toString()
	{
		return name;
	} //}}}
	//{{{ Private members
	private String name;
	/**
	 * @deprecated
	 */
	private static ArrayList foldHandlers;
	//}}}
	//{{{ Static initializer
	static
	{
		foldHandlers = new ArrayList();
	}
	//}}}
}
"
org.gjt.sp.jedit.buffer.IndentFoldHandler,"/*
 * IndentFoldHandler.java - Indent-based fold handler
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;
/**
 * A fold handler that folds lines based on their indent level.
 * @author Slava Pestov
 * @version $Id: IndentFoldHandler.java,v 1.5 2002/03/17 01:28:43 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class IndentFoldHandler extends FoldHandler
{
	public IndentFoldHandler()
	{
		super(""indent"");
	}
	//{{{ getFoldLevel() method
	/**
	 * Returns the fold level of the specified line.
	 * @param buffer The buffer in question
	 * @param lineIndex The line index
	 * @param seg A segment the fold handler can use to obtain any
	 * text from the buffer, if necessary
	 * @return The fold level of the specified line
	 * @since jEdit 4.0pre1
	 */
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		int tabSize = buffer.getTabSize();
		buffer.getLineText(lineIndex,seg);
		int offset = seg.offset;
		int count = seg.count;
		int whitespace = 0;
		boolean seenNonWhiteSpace = false;
loop:		for(int i = 0; i < count; i++)
		{
			switch(seg.array[offset + i])
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				seenNonWhiteSpace = true;
				break loop;
			}
		}
		if(!seenNonWhiteSpace)
		{
			// empty line. inherit previous line's fold level
			if(lineIndex != 0)
				return buffer.getFoldLevel(lineIndex - 1);
			else
				return 0;
		}
			return whitespace;
	} //}}}
}
"
org.gjt.sp.jedit.buffer.KillRing,"/*
 * KillRing.java - Stores deleted text
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
import com.microstar.xml.*;
import javax.swing.event.ListDataListener;
import javax.swing.ListModel;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class KillRing
{
	//{{{ propertiesChanged() method
	public static void propertiesChanged()
	{
		int newSize = jEdit.getIntegerProperty(""history"",25);
		if(ring == null)
			ring = new UndoManager.Remove[newSize];
		else if(newSize != ring.length)
		{
			UndoManager.Remove[] newRing = new UndoManager.Remove[
				newSize];
			ListModel model = new RingListModel();
			int newCount = Math.min(model.getSize(),newSize);
			for(int i = 0; i < newCount; i++)
			{
				newRing[i] = (UndoManager.Remove)
					model.getElementAt(i);
			}
			ring = newRing;
			count = newCount;
			wrap = false;
		}
		else if(count == ring.length)
		{
			count = 0;
			wrap = true;
		}
	} //}}}
	//{{{ getListModel() method
	public static ListModel getListModel()
	{
		return new RingListModel();
	} //}}}
	//{{{ load() method
	public static void load()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		File killRing = new File(MiscUtilities.constructPath(
			settingsDirectory,""killring.xml""));
		if(!killRing.exists())
			return;
		killRingModTime = killRing.lastModified();
		Log.log(Log.MESSAGE,KillRing.class,""Loading killring.xml"");
		KillRingHandler handler = new KillRingHandler();
		XmlParser parser = new XmlParser();
		Reader in = null;
		parser.setHandler(handler);
		try
		{
			in = new BufferedReader(new FileReader(killRing));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,KillRing.class,killRing + "":"" + line
				+ "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
			//Log.log(Log.DEBUG,BufferHistory.class,fnf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,KillRing.class,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,KillRing.class,io);
			}
		}
		ring = (UndoManager.Remove[])handler.list.toArray(
			new UndoManager.Remove[handler.list.size()]);
		count = ring.length;
	} //}}}
	//{{{ save() method
	public static void save()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		File file1 = new File(MiscUtilities.constructPath(
			settingsDirectory, ""#killring.xml#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			settingsDirectory, ""killring.xml""));
		if(file2.exists() && file2.lastModified() != killRingModTime)
		{
			Log.log(Log.WARNING,KillRing.class,file2
				+ "" changed on disk; will not save recent""
				+ "" files"");
			return;
		}
		jEdit.backupSettingsFile(file2);
		Log.log(Log.MESSAGE,KillRing.class,""Saving killring.xml"");
		String lineSep = System.getProperty(""line.separator"");
		BufferedWriter out = null;
		try
		{
			out = new BufferedWriter(new FileWriter(file1));
			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE KILLRING SYSTEM \""killring.dtd\"">"");
			out.write(lineSep);
			out.write(""<KILLRING>"");
			out.write(lineSep);
			ListModel model = getListModel();
			int size = model.getSize();
			for(int i = size - 1; i >=0; i--)
			{
				out.write(""<ENTRY>"");
				out.write(MiscUtilities.charsToEntities(
					model.getElementAt(i).toString()));
				out.write(""</ENTRY>"");
				out.write(lineSep);
			}
			out.write(""</KILLRING>"");
			out.write(lineSep);
			out.close();
			/* to avoid data loss, only do this if the above
			 * completed successfully */
			file2.delete();
			file1.renameTo(file2);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,KillRing.class,e);
		}
		finally
		{
			try
			{
				if(out != null)
					out.close();
			}
			catch(IOException e)
			{
			}
		}
		killRingModTime = file2.lastModified();
	} //}}}
	//{{{ Package-private members
	static UndoManager.Remove[] ring;
	static int count;
	static boolean wrap;
	//{{{ changed() method
	static void changed(UndoManager.Remove rem)
	{
		if(rem.inKillRing)
		{
			// compare existing entries' hashcode with this
			int length = (wrap ? ring.length : count);
			int kill = -1;
			for(int i = 0; i < length; i++)
			{
				if(ring[i] != rem
					&& ring[i].hashcode == rem.hashcode
					&& ring[i].str.equals(rem.str))
				{
					// we don't want duplicate
					// entries in the kill ring
					kill = i;
					break;
				}
			}
			if(kill != -1)
				remove(kill);
		}
		else
			add(rem);
	} //}}}
	//{{{ add() method
	static void add(UndoManager.Remove rem)
	{
		// compare existing entries' hashcode with this
		int length = (wrap ? ring.length : count);
		for(int i = 0; i < length; i++)
		{
			if(ring[i].hashcode == rem.hashcode)
			{
				// strings might be equal!
				if(ring[i].str.equals(rem.str))
				{
					// we don't want duplicate entries
					// in the kill ring
					return;
				}
			}
		}
		// no duplicates, check for all-whitespace string
		boolean allWhitespace = true;
		for(int i = 0; i < rem.str.length(); i++)
		{
			if(!Character.isWhitespace(rem.str.charAt(i)))
			{
				allWhitespace = false;
				break;
			}
		}
		if(allWhitespace)
			return;
		rem.inKillRing = true;
		if(ring[count] != null)
			ring[count].inKillRing = false;
		ring[count] = rem;
		if(++count >= ring.length)
		{
			wrap = true;
			count = 0;
		}
	} //}}}
	//{{{ remove() method
	static void remove(int i)
	{
		if(wrap)
		{
			UndoManager.Remove[] newRing = new UndoManager.Remove[
				ring.length];
			int newCount = 0;
			for(int j = 0; j < ring.length; j++)
			{
				int index;
				if(j < count)
					index = count - j - 1;
				else
					index = count + ring.length - j - 1;
				if(i == index)
				{
					ring[index].inKillRing = false;
					continue;
				}
				newRing[newCount++] = ring[index];
			}
			ring = newRing;
			count = newCount;
			wrap = false;
		}
		else
		{
			System.arraycopy(ring,i + 1,ring,i,count - i - 1);
			count--;
		}
	} //}}}
	//}}}
	//{{{ Private members
	private static long killRingModTime;
	private KillRing() {}
	//}}}
	//{{{ RingListModel class
	static class RingListModel implements ListModel
	{
		public void addListDataListener(ListDataListener listener)
		{
		}
		public void removeListDataListener(ListDataListener listener)
		{
		}
		public Object getElementAt(int index)
		{
			UndoManager.Remove rem;
			if(wrap)
			{
				if(index < count)
					rem = ring[count - index - 1];
				else
					rem = ring[count + ring.length - index - 1];
			}
			else
				rem = ring[count - index - 1];
			return rem;
		}
		public int getSize()
		{
			if(wrap)
				return ring.length;
			else
				return count;
		}
	} //}}}
	//{{{ KillRingHandler class
	static class KillRingHandler extends HandlerBase
	{
		List list = new LinkedList();
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""killring.dtd"".equals(systemId))
			{
				// this will result in a slight speed up, since we
				// don't need to read the DTD anyway, as AElfred is
				// non-validating
				return new StringReader(""<!-- -->"");
			}
			return null;
		}
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""KILLRING"".equals(name))
				return;
			Log.log(Log.ERROR,this,""killring.xml: DOCTYPE must be KILLRING"");
		}
		public void endElement(String name)
		{
			if(name.equals(""ENTRY""))
			{
				list.add(new UndoManager.Remove(null,0,0,charData));
			}
		}
		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		}
		private String charData;
	} //}}}
}
"
org.gjt.sp.jedit.buffer.LineElement,"/*
 * LineElement.java - For compatibility with Swing document API
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
//{{{ Imports
import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;
//}}}
/**
 * @deprecated Used to implement backwards-compatibility with jEdit 3.2.2-style
 * document model.
 *
 * @author Slava Pestov
 * @version $Id: LineElement.java,v 1.2 2003/02/19 23:26:01 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class LineElement implements Element
{
	//{{{ LineElement constructor
	public LineElement(Buffer buffer, int line)
	{
		this.buffer = buffer;
		this.line = line;
	} //}}}
	//{{{ getDocument() method
	public Document getDocument()
	{
		return null;
	} //}}}
	//{{{ getParentElement() method
	public Element getParentElement()
	{
		return null;
	} //}}}
	//{{{ getName() method
	public String getName()
	{
		return null;
	} //}}}
	//{{{ getAttributes() method
	public AttributeSet getAttributes()
	{
		return null;
	} //}}}
	//{{{ getStartOffset() method
	public int getStartOffset()
	{
		return buffer.getLineStartOffset(line);
	} //}}}
	//{{{ getEndOffset() method
	public int getEndOffset()
	{
		return buffer.getLineEndOffset(line);
	} //}}}
	//{{{ getElementIndex() method
	public int getElementIndex(int offset)
	{
		return 0;
	} //}}}
	//{{{ getElementCount() method
	public int getElementCount()
	{
		return 0;
	} //}}}
	//{{{ getElement() method
	public Element getElement(int line)
	{
		return null;
	} //}}}
	//{{{ isLeaf() method
	public boolean isLeaf()
	{
		return true;
	} //}}}
	//{{{ Private members
	private Buffer buffer;
	private int line;
	//}}}
} //}}}
"
org.gjt.sp.jedit.buffer.LineManager,"/*
 * LineManager.java - Manages line info, line start offsets, positions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
//{{{ Imports
import javax.swing.text.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.Log;
//}}}
/**
 * A class internal to jEdit's document model. You should not use it
 * directly. To improve performance, none of the methods in this class
 * check for out of bounds access, nor are they thread-safe. The
 * <code>Buffer</code> class, through which these methods must be
 * called through, implements such protection.
 *
 * @author Slava Pestov
 * @version $Id: LineManager.java,v 1.6 2004/06/26 19:10:58 spestov Exp $
 * @since jEdit 4.2pre3
 */
public class LineManager
{
	//{{{ LineManager constructor
	public LineManager()
	{
		endOffsets = new int[1];
		endOffsets[0] = 1;
		lineInfo = new int[1];
		lineInfo[0] = (1 << SCREEN_LINES_SHIFT);
		lineContext = new TokenMarker.LineContext[1];
		lineCount = 1;
	} //}}}
	//{{{ getLineCount() method
	public final int getLineCount()
	{
		return lineCount;
	} //}}}
	//{{{ getLineOfOffset() method
	public int getLineOfOffset(int offset)
	{
		int start = 0;
		int end = lineCount - 1;
		for(;;)
		{
			switch(end - start)
			{
			case 0:
				if(getLineEndOffset(start) <= offset)
					return start + 1;
				else
					return start;
			case 1:
				if(getLineEndOffset(start) <= offset)
				{
					if(getLineEndOffset(end) <= offset)
						return end + 1;
					else
						return end;
				}
				else
					return start;
			default:
				int pivot = (end + start) / 2;
				int value = getLineEndOffset(pivot);
				if(value == offset)
					return pivot + 1;
				else if(value < offset)
					start = pivot + 1;
				else
					end = pivot - 1;
				break;
			}
		}
	} //}}}
	//{{{ getLineEndOffset() method
	public final int getLineEndOffset(int line)
	{
		if(gapLine != -1 && line >= gapLine)
			return endOffsets[line] + gapWidth;
		else
			return endOffsets[line];
	} //}}}
	//{{{ getFoldLevel() method
	public final int getFoldLevel(int line)
	{
		return (lineInfo[line] & FOLD_LEVEL_MASK);
	} //}}}
	//{{{ setFoldLevel() method
	// Also sets 'fold level valid' flag
	public final void setFoldLevel(int line, int level)
	{
		if(level > 0xffff)
		{
			// limitations...
			level = 0xffff;
		}
		lineInfo[line] = ((lineInfo[line] & ~FOLD_LEVEL_MASK) | level);
	} //}}}
	//{{{ setFirstInvalidFoldLevel() method
	public void setFirstInvalidFoldLevel(int firstInvalidFoldLevel)
	{
		this.firstInvalidFoldLevel = firstInvalidFoldLevel;
	} //}}}
	//{{{ getFirstInvalidFoldLevel() method
	public int getFirstInvalidFoldLevel()
	{
		return firstInvalidFoldLevel;
	} //}}}
	//{{{ isScreenLineCountValid() method
	public final boolean isScreenLineCountValid(int line)
	{
		return (lineInfo[line] & SCREEN_LINES_VALID_MASK) != 0;
	} //}}}
	//{{{ getScreenLineCount() method
	public final int getScreenLineCount(int line)
	{
		return ((lineInfo[line] & SCREEN_LINES_MASK)
			>> SCREEN_LINES_SHIFT);
	} //}}}
	//{{{ setScreenLineCount() method
	public final void setScreenLineCount(int line, int count)
	{
		if(count > 0x7fff)
		{
			// limitations...
			count = 0x7fff;
		}
		if(Debug.SCREEN_LINES_DEBUG)
			Log.log(Log.DEBUG,this,new Exception(""setScreenLineCount("" + line + "","" + count + "")""));
		lineInfo[line] =
			((lineInfo[line] & ~SCREEN_LINES_MASK)
			| (count << SCREEN_LINES_SHIFT)
			| SCREEN_LINES_VALID_MASK);
	} //}}}
	//{{{ getLineContext() method
	public final TokenMarker.LineContext getLineContext(int line)
	{
		return lineContext[line];
	} //}}}
	//{{{ setLineContext() method
	public final void setLineContext(int line, TokenMarker.LineContext context)
	{
		lineContext[line] = context;
	} //}}}
	//{{{ setFirstInvalidLineContext() method
	public void setFirstInvalidLineContext(int firstInvalidLineContext)
	{
		this.firstInvalidLineContext = firstInvalidLineContext;
	} //}}}
	//{{{ getFirstInvalidLineContext() method
	public int getFirstInvalidLineContext()
	{
		return firstInvalidLineContext;
	} //}}}
	//{{{ invalidateScreenLineCounts() method
	public void invalidateScreenLineCounts()
	{
		for(int i = 0; i < lineCount; i++)
			lineInfo[i] &= ~SCREEN_LINES_VALID_MASK;
	} //}}}
	//{{{ _contentInserted() method
	public void _contentInserted(IntegerArray endOffsets)
	{
		gapLine = -1;
		gapWidth = 0;
		firstInvalidLineContext = firstInvalidFoldLevel = 0;
		lineCount = endOffsets.getSize();
		this.endOffsets = endOffsets.getArray();
		lineInfo = new int[lineCount];
		for(int i = 0; i < lineInfo.length; i++)
			lineInfo[i] = 1 << SCREEN_LINES_SHIFT;
		lineContext = new TokenMarker.LineContext[lineCount];
	} //}}}
	//{{{ contentInserted() method
	public void contentInserted(int startLine, int offset,
		int numLines, int length, IntegerArray endOffsets)
	{
		int endLine = startLine + numLines;
		lineInfo[startLine] &= ~SCREEN_LINES_VALID_MASK;
		//{{{ Update line info and line context arrays
		if(numLines > 0)
		{
			//moveGap(-1,0,""contentInserted"");
			lineCount += numLines;
			if(this.endOffsets.length <= lineCount)
			{
				int[] endOffsetsN = new int[(lineCount + 1) * 2];
				System.arraycopy(this.endOffsets,0,endOffsetsN,0,
						 this.endOffsets.length);
				this.endOffsets = endOffsetsN;
			}
			if(lineInfo.length <= lineCount)
			{
				int[] lineInfoN = new int[(lineCount + 1) * 2];
				System.arraycopy(lineInfo,0,lineInfoN,0,
						 lineInfo.length);
				lineInfo = lineInfoN;
			}
			if(lineContext.length <= lineCount)
			{
				TokenMarker.LineContext[] lineContextN
					= new TokenMarker.LineContext[(lineCount + 1) * 2];
				System.arraycopy(lineContext,0,lineContextN,0,
						 lineContext.length);
				lineContext = lineContextN;
			}
			System.arraycopy(this.endOffsets,startLine,
				this.endOffsets,endLine,lineCount - endLine);
			System.arraycopy(lineInfo,startLine,lineInfo,
				endLine,lineCount - endLine);
			System.arraycopy(lineContext,startLine,lineContext,
				endLine,lineCount - endLine);
			if(startLine <= gapLine)
				gapLine += numLines;
			else if(gapLine != -1)
				offset -= gapWidth;
			if(startLine < firstInvalidLineContext)
				firstInvalidLineContext += numLines;
			for(int i = 0; i < numLines; i++)
			{
				this.endOffsets[startLine + i] = (offset + endOffsets.get(i));
				lineInfo[startLine + i] = 0;
			}
		} //}}}
		if(firstInvalidFoldLevel == -1 || firstInvalidFoldLevel > startLine)
			firstInvalidFoldLevel = startLine;
		moveGap(endLine,length,""contentInserted"");
	} //}}}
	//{{{ contentRemoved() method
	public void contentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		int endLine = startLine + numLines;
		lineInfo[startLine] &= ~SCREEN_LINES_VALID_MASK;
		//{{{ Update line info and line context arrays
		if(numLines > 0)
		{
			//moveGap(-1,0,""contentRemoved"");
			if(startLine + numLines < gapLine)
				gapLine -= numLines;
			else if(startLine < gapLine)
				gapLine = startLine;
			if(startLine + numLines < firstInvalidLineContext)
				firstInvalidLineContext -= numLines;
			else if(startLine < firstInvalidLineContext)
				firstInvalidLineContext = startLine - 1;
			lineCount -= numLines;
			System.arraycopy(endOffsets,endLine,endOffsets,
				startLine,lineCount - startLine);
			System.arraycopy(lineInfo,endLine,lineInfo,
				startLine,lineCount - startLine);
			System.arraycopy(lineContext,endLine,lineContext,
				startLine,lineCount - startLine);
		} //}}}
		if(firstInvalidFoldLevel == -1 || firstInvalidFoldLevel > startLine)
			firstInvalidFoldLevel = startLine;
		moveGap(startLine,-length,""contentRemoved"");
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	/* Having all the info packed into an int is not very OO and makes the
	 * code somewhat more complicated, but it saves a lot of memory.
	 *
	 * The new document model has just 12 bytes of overhead per line.
	 * LineContext instances are now internalized, so only a few should
	 * actually be in the heap.
	 *
	 * In the old document model there were 5 objects per line, for a
	 * total of about 100 bytes, plus a cached token list, which used
	 * another 100 or so bytes. */
	private static final int FOLD_LEVEL_MASK         = 0x0000ffff;
	private static final int SCREEN_LINES_MASK       = 0x7fff0000;
	private static final int SCREEN_LINES_SHIFT      = 16;
	private static final int SCREEN_LINES_VALID_MASK = 1<<31;
	private int[] endOffsets;
	private int[] lineInfo;
	private TokenMarker.LineContext[] lineContext;
	private int lineCount;
	/**
	 * If -1, then there is no gap.
	 * Otherwise, all lines from this line onwards need to have gapWidth
	 * added to their end offsets.
	 */
	private int gapLine;
	private int gapWidth;
	/**
	 * If -1, all contexts are valid. Otherwise, all lines after this have
	 * an invalid context.
	 */
	private int firstInvalidLineContext;
	/**
	 * If -1, all fold levels are valid. Otherwise, all lines after this
	 * have an invalid fold level.
	 */
	private int firstInvalidFoldLevel;
	//}}}
	//{{{ setLineEndOffset() method
	private final void setLineEndOffset(int line, int end)
	{
		endOffsets[line] = end;
	} //}}}
	//{{{ moveGap() method
	private final void moveGap(int newGapLine, int newGapWidth, String method)
	{
		if(gapLine == -1)
			gapWidth = newGapWidth;
		else if(newGapLine == -1)
		{
			if(gapWidth != 0)
			{
				if(Debug.OFFSET_DEBUG && gapLine != lineCount)
					Log.log(Log.DEBUG,this,method + "": update from "" + gapLine + "" to "" + lineCount + "" width "" + gapWidth);
				for(int i = gapLine; i < lineCount; i++)
					setLineEndOffset(i,getLineEndOffset(i));
			}
			gapWidth = newGapWidth;
		}
		else if(newGapLine < gapLine)
		{
			if(gapWidth != 0)
			{
				if(Debug.OFFSET_DEBUG && newGapLine != gapLine)
					Log.log(Log.DEBUG,this,method + "": update from "" + newGapLine + "" to "" + gapLine + "" width "" + gapWidth);
				for(int i = newGapLine; i < gapLine; i++)
					setLineEndOffset(i,getLineEndOffset(i) - gapWidth);
			}
			gapWidth += newGapWidth;
		}
		else //if(newGapLine >= gapLine)
		{
			if(gapWidth != 0)
			{
				if(Debug.OFFSET_DEBUG && gapLine != newGapLine)
					Log.log(Log.DEBUG,this,method + "": update from "" + gapLine + "" to "" + newGapLine + "" width "" + gapWidth);
				for(int i = gapLine; i < newGapLine; i++)
					setLineEndOffset(i,getLineEndOffset(i));
			}
			gapWidth += newGapWidth;
		}
		if(newGapLine == lineCount)
			gapLine = -1;
		else
			gapLine = newGapLine;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.buffer.PositionManager,"/*
 * PositionManager.java - Manages positions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
//{{{ Imports
import javax.swing.text.Position;
import java.util.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * A class internal to jEdit's document model. You should not use it
 * directly.
 *
 * @author Slava Pestov
 * @version $Id: PositionManager.java,v 1.35 2003/11/18 20:51:57 spestov Exp $
 * @since jEdit 4.2pre3
 */
public class PositionManager
{
	//{{{ createPosition() method
	public synchronized Position createPosition(int offset)
	{
		PosBottomHalf bh = new PosBottomHalf(offset);
		PosBottomHalf existing = (PosBottomHalf)positions.get(bh);
		if(existing == null)
		{
			positions.put(bh,bh);
			existing = bh;
		}
		return new PosTopHalf(existing);
	} //}}}
	//{{{ contentInserted() method
	public synchronized void contentInserted(int offset, int length)
	{
		if(positions.size() == 0)
			return;
		/* get all positions from offset to the end, inclusive */
		Iterator iter = positions.tailMap(new PosBottomHalf(offset))
			.keySet().iterator();
		iteration = true;
		while(iter.hasNext())
		{
			PosBottomHalf bh = (PosBottomHalf)iter.next();
			bh.offset += length;
		}
		iteration = false;
	} //}}}
	//{{{ contentRemoved() method
	public synchronized void contentRemoved(int offset, int length)
	{
		if(positions.size() == 0)
			return;
		/* get all positions from offset to the end, inclusive */
		Iterator iter = positions.tailMap(new PosBottomHalf(offset))
			.keySet().iterator();
		iteration = true;
		while(iter.hasNext())
		{
			PosBottomHalf bh = (PosBottomHalf)iter.next();
			if(bh.offset <= offset + length)
				bh.offset = offset;
			else
				bh.offset -= length;
		}
		iteration = false;
	} //}}}
	boolean iteration;
	//{{{ Private members
	private SortedMap positions = new TreeMap();
	//}}}
	//{{{ Inner classes
	//{{{ PosTopHalf class
	class PosTopHalf implements Position
	{
		PosBottomHalf bh;
		//{{{ PosTopHalf constructor
		PosTopHalf(PosBottomHalf bh)
		{
			this.bh = bh;
			bh.ref();
		} //}}}
		//{{{ getOffset() method
		public int getOffset()
		{
			return bh.offset;
		} //}}}
		//{{{ finalize() method
		protected void finalize()
		{
			synchronized(PositionManager.this)
			{
				bh.unref();
			}
		} //}}}
	} //}}}
	//{{{ PosBottomHalf class
	class PosBottomHalf implements Comparable
	{
		int offset;
		int ref;
		//{{{ PosBottomHalf constructor
		PosBottomHalf(int offset)
		{
			this.offset = offset;
		} //}}}
		//{{{ ref() method
		void ref()
		{
			ref++;
		} //}}}
		//{{{ unref() method
		void unref()
		{
			if(--ref == 0)
				positions.remove(this);
		} //}}}
		//{{{ equals() method
		public boolean equals(Object o)
		{
			if(!(o instanceof PosBottomHalf))
				return false;
			return ((PosBottomHalf)o).offset == offset;
		} //}}}
		//{{{ compareTo() method
		public int compareTo(Object o)
		{
			if(iteration)
				Log.log(Log.ERROR,this,""Consistency failure"");
			return offset - ((PosBottomHalf)o).offset;
		} //}}}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.buffer.RootElement,"/*
 * RootElement.java - For compatibility with Swing document API
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
//{{{ Imports
import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;
//}}}
/**
 * A class internal to jEdit's document model. You should not use it
 * directly.
 *
 * @author Slava Pestov
 * @version $Id: RootElement.java,v 1.1 2001/10/20 09:32:23 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class RootElement implements Element
{
	//{{{ RootElement constructor
	public RootElement(Buffer buffer)
	{
		this.buffer = buffer;
	} //}}}
	//{{{ getDocument() method
	public Document getDocument()
	{
		return null;
	} //}}}
	//{{{ getParentElement() method
	public Element getParentElement()
	{
		return null;
	} //}}}
	//{{{ getName() method
	public String getName()
	{
		return null;
	} //}}}
	//{{{ getAttributes() method
	public AttributeSet getAttributes()
	{
		return null;
	} //}}}
	//{{{ getStartOffset() method
	public int getStartOffset()
	{
		return 0;
	} //}}}
	//{{{ getEndOffset() method
	public int getEndOffset()
	{
		return buffer.getLength() + 1;
	} //}}}
	//{{{ getElementIndex() method
	public int getElementIndex(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} //}}}
	//{{{ getElementCount() method
	public int getElementCount()
	{
		return buffer.getLineCount();
	} //}}}
	//{{{ getElement() method
	public Element getElement(int line)
	{
		return new LineElement(buffer,line);
	} //}}}
	//{{{ isLeaf() method
	public boolean isLeaf()
	{
		return false;
	} //}}}
	//{{{ Private members
	private Buffer buffer;
	//}}}
} //}}}
"
org.gjt.sp.jedit.buffer.UndoManager,"/*
 * UndoManager.java - Buffer undo manager
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.buffer;
//{{{ Imports
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;
//}}}
/**
 * A class internal to jEdit's document model. You should not use it
 * directly. To improve performance, none of the methods in this class
 * check for out of bounds access, nor are they thread-safe. The
 * <code>Buffer</code> class, through which these methods must be
 * called through, implements such protection.
 *
 * @author Slava Pestov
 * @version $Id: UndoManager.java,v 1.25 2004/07/04 06:56:17 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class UndoManager
{
	//{{{ UndoManager constructor
	public UndoManager(Buffer buffer)
	{
		this.buffer = buffer;
	} //}}}
	//{{{ setLimit() method
	public void setLimit(int limit)
	{
		this.limit = limit;
	} //}}}
	//{{{ clear() method
	public void clear()
	{
		undosFirst = undosLast = redosFirst = redosLast = null;
		undoCount = 0;
	} //}}}
	//{{{ undo() method
	public int undo()
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");
		if(undosLast == null)
			return -1;
		else
		{
			undoCount--;
			int caret = undosLast.undo();
			redosFirst = undosLast;
			undosLast = undosLast.prev;
			if(undosLast == null)
				undosFirst = null;
			return caret;
		}
	} //}}}
	//{{{ redo() method
	public int redo()
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");
		if(redosFirst == null)
			return -1;
		else
		{
			undoCount++;
			int caret = redosFirst.redo();
			undosLast = redosFirst;
			if(undosFirst == null)
				undosFirst = undosLast;
			redosFirst = redosFirst.next;
			return caret;
		}
	} //}}}
	//{{{ beginCompoundEdit() method
	public void beginCompoundEdit()
	{
		if(compoundEditCount == 0)
			compoundEdit = new CompoundEdit();
		compoundEditCount++;
	} //}}}
	//{{{ endCompoundEdit() method
	public void endCompoundEdit()
	{
		if(compoundEditCount == 0)
		{
			Log.log(Log.WARNING,this,new Exception(""Unbalanced begin/endCompoundEdit()""));
			return;
		}
		else if(compoundEditCount == 1)
		{
			if(compoundEdit.first == null)
				/* nothing done between begin/end calls */;
			else if(compoundEdit.first == compoundEdit.last)
				addEdit(compoundEdit.first);
			else
				addEdit(compoundEdit);
			compoundEdit = null;
		}
		compoundEditCount--;
	} //}}}
	//{{{ insideCompoundEdit() method
	public boolean insideCompoundEdit()
	{
		return compoundEditCount != 0;
	} //}}}
	//{{{ contentInserted() method
	public void contentInserted(int offset, int length, String text, boolean clearDirty)
	{
		Edit last = getLastEdit();
		Edit toMerge = getMergeEdit();
		if(!clearDirty && toMerge instanceof Insert
			&& redosFirst == null)
		{
			Insert ins = (Insert)toMerge;
			if(ins.offset == offset)
			{
				ins.str = text.concat(ins.str);
				ins.length += length;
				return;
			}
			else if(ins.offset + ins.length == offset)
			{
				ins.str = ins.str.concat(text);
				ins.length += length;
				return;
			}
		}
		Insert ins = new Insert(this,offset,length,text);
		if(clearDirty)
		{
			redoClearDirty = last;
			undoClearDirty = ins;
		}
		if(compoundEdit != null)
			compoundEdit.add(ins);
		else
			addEdit(ins);
	} //}}}
	//{{{ contentRemoved() method
	public void contentRemoved(int offset, int length, String text, boolean clearDirty)
	{
		Edit last = getLastEdit();
		Edit toMerge = getMergeEdit();
		if(!clearDirty && toMerge instanceof Remove
			&& redosFirst == null)
		{
			Remove rem = (Remove)toMerge;
			if(rem.offset == offset)
			{
				rem.str = rem.str.concat(text);
				rem.hashcode = rem.str.hashCode();
				rem.length += length;
				KillRing.changed(rem);
				return;
			}
			else if(offset + length == rem.offset)
			{
				rem.str = text.concat(rem.str);
				rem.hashcode = rem.str.hashCode();
				rem.length += length;
				rem.offset = offset;
				KillRing.changed(rem);
				return;
			}
		}
		Remove rem = new Remove(this,offset,length,text);
		if(clearDirty)
		{
			redoClearDirty = last;
			undoClearDirty = rem;
		}
		if(compoundEdit != null)
			compoundEdit.add(rem);
		else
			addEdit(rem);
		KillRing.add(rem);
	} //}}}
	//{{{ bufferSaved() method
	public void bufferSaved()
	{
		redoClearDirty = getLastEdit();
		if(redosFirst instanceof CompoundEdit)
			undoClearDirty = ((CompoundEdit)redosFirst).first;
		else
			undoClearDirty = redosFirst;
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private Buffer buffer;
	// queue of undos. last is most recent, first is oldest
	private Edit undosFirst;
	private Edit undosLast;
	// queue of redos. first is most recent, last is oldest
	private Edit redosFirst;
	private Edit redosLast;
	private int limit;
	private int undoCount;
	private int compoundEditCount;
	private CompoundEdit compoundEdit;
	private Edit undoClearDirty, redoClearDirty;
	//}}}
	//{{{ addEdit() method
	private void addEdit(Edit edit)
	{
		if(undosFirst == null)
			undosFirst = undosLast = edit;
		else
		{
			undosLast.next = edit;
			edit.prev = undosLast;
			undosLast = edit;
		}
		redosFirst = redosLast = null;
		undoCount++;
		while(undoCount > limit)
		{
			undoCount--;
			if(undosFirst == undosLast)
				undosFirst = undosLast = null;
			else
			{
				undosFirst.next.prev = null;
				undosFirst = undosFirst.next;
			}
		}
	} //}}}
	//{{{ getMergeEdit() method
	private Edit getMergeEdit()
	{
		Edit last = getLastEdit();
		return (compoundEdit != null ? compoundEdit.last : last);
	} //}}}
	//{{{ getLastEdit() method
	private Edit getLastEdit()
	{
		if(undosLast instanceof CompoundEdit)
			return ((CompoundEdit)undosLast).last;
		else
			return undosLast;
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ Edit class
	abstract static class Edit
	{
		Edit prev, next;
		//{{{ undo() method
		abstract int undo();
		//}}}
		//{{{ redo() method
		abstract int redo();
		//}}}
	} //}}}
	//{{{ Insert class
	static class Insert extends Edit
	{
		//{{{ Insert constructor
		Insert(UndoManager mgr, int offset, int length, String str)
		{
			this.mgr = mgr;
			this.offset = offset;
			this.length = length;
			this.str = str;
		} //}}}
		//{{{ undo() method
		int undo()
		{
			mgr.buffer.remove(offset,length);
			if(mgr.undoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset;
		} //}}}
		//{{{ redo() method
		int redo()
		{
			mgr.buffer.insert(offset,str);
			if(mgr.redoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset + length;
		} //}}}
		UndoManager mgr;
		int offset;
		int length;
		String str;
	} //}}}
	//{{{ Remove class
	static class Remove extends Edit
	{
		//{{{ Remove constructor
		Remove(UndoManager mgr, int offset, int length, String str)
		{
			this.mgr = mgr;
			this.offset = offset;
			this.length = length;
			this.str = str;
			hashcode = str.hashCode();
		} //}}}
		//{{{ undo() method
		int undo()
		{
			mgr.buffer.insert(offset,str);
			if(mgr.undoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset + length;
		} //}}}
		//{{{ redo() method
		int redo()
		{
			mgr.buffer.remove(offset,length);
			if(mgr.redoClearDirty == this)
				mgr.buffer.setDirty(false);
			return offset;
		} //}}}
		//{{{ toString() method
		public String toString()
		{
			return str;
		} //}}}
		UndoManager mgr;
		int offset;
		int length;
		String str;
		int hashcode;
		boolean inKillRing;
	} //}}}
	//{{{ CompoundEdit class
	static class CompoundEdit extends Edit
	{
		//{{{ undo() method
		public int undo()
		{
			int retVal = -1;
			Edit edit = last;
			while(edit != null)
			{
				retVal = edit.undo();
				edit = edit.prev;
			}
			return retVal;
		} //}}}
		//{{{ redo() method
		public int redo()
		{
			int retVal = -1;
			Edit edit = first;
			while(edit != null)
			{
				retVal = edit.redo();
				edit = edit.next;
			}
			return retVal;
		} //}}}
		//{{{ add() method
		public void add(Edit edit)
		{
			if(first == null)
				first = last = edit;
			else
			{
				edit.prev = last;
				last.next = edit;
				last = edit;
			}
		} //}}}
		Edit first, last;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.AbbrevEditor,"/*
 * AbbrevEditor.java - Panel for editing abbreviations
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
//}}}
public class AbbrevEditor extends JPanel
{
	//{{{ AbbrevEditor constructor
	public AbbrevEditor()
	{
		GridBagLayout layout = new GridBagLayout();
		setLayout(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.anchor = cons.WEST;
		cons.fill = cons.BOTH;
		cons.weightx = 0.0f;
		cons.gridx = 1;
		cons.gridy = 1;
		JLabel label = new JLabel(jEdit.getProperty(""abbrev-editor.abbrev""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridx++;
		cons.weightx = 1.0f;
		abbrev = new JTextField();
		layout.setConstraints(abbrev,cons);
		add(abbrev);
		cons.gridx = 1;
		cons.weightx = 0.0f;
		cons.gridwidth = 2;
		cons.gridy++;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.before""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridy++;
		cons.weighty = 1.0f;
		beforeCaret = new JTextArea(4,40);
		JScrollPane scroller = new JScrollPane(beforeCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
		cons.gridy++;
		cons.weighty = 0.0f;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.after""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridy++;
		cons.weighty = 1.0f;
		afterCaret = new JTextArea(4,40);
		scroller = new JScrollPane(afterCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
	} //}}}
	//{{{ getAbbrev() method
	public String getAbbrev()
	{
		return abbrev.getText();
	} //}}}
	//{{{ setAbbrev() method
	public void setAbbrev(String abbrev)
	{
		this.abbrev.setText(abbrev);
	} //}}}
	//{{{ getExpansion() method
	public String getExpansion()
	{
		StringBuffer buf = new StringBuffer();
		String beforeCaretText = beforeCaret.getText();
		String afterCaretText = afterCaret.getText();
		for(int i = 0; i < beforeCaretText.length(); i++)
		{
			char ch = beforeCaretText.charAt(i);
			switch(ch)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}
		if(afterCaretText.length() != 0)
		{
			buf.append(""\\|"");
			for(int i = 0; i < afterCaretText.length(); i++)
			{
				char ch = afterCaretText.charAt(i);
				switch(ch)
				{
				case '\n':
					buf.append(""\\n"");
					break;
				case '\t':
					buf.append(""\\t"");
					break;
				case '\\':
					buf.append(""\\\\"");
					break;
				default:
					buf.append(ch);
					break;
				}
			}
		}
		return buf.toString();
	} //}}}
	//{{{ setExpansion() method
	public void setExpansion(String expansion)
	{
		if(expansion == null)
		{
			beforeCaret.setText(null);
			afterCaret.setText(null);
			return;
		}
		String beforeCaretText = null;
		String afterCaretText = null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < expansion.length(); i++)
		{
			char ch = expansion.charAt(i);
			if(ch == '\\' && i != expansion.length() - 1)
			{
				ch = expansion.charAt(++i);
				switch(ch)
				{
				case 't':
					buf.append('\t');
					break;
				case 'n':
					buf.append('\n');
					break;
				case '|':
					beforeCaretText = buf.toString();
					buf.setLength(0);
					break;
				default:
					buf.append(ch);
					break;
				}
			}
			else
				buf.append(ch);
		}
		if(beforeCaretText == null)
			beforeCaretText = buf.toString();
		else
			afterCaretText = buf.toString();
		beforeCaret.setText(beforeCaretText);
		afterCaret.setText(afterCaretText);
	} //}}}
	//{{{ getAbbrevField() method
	public JTextField getAbbrevField()
	{
		return abbrev;
	} //}}}
	//{{{ getBeforeCaretTextArea() method
	public JTextArea getBeforeCaretTextArea()
	{
		return beforeCaret;
	} //}}}
	//{{{ getAfterCaretTextArea() method
	public JTextArea getAfterCaretTextArea()
	{
		return afterCaret;
	} //}}}
	//{{{ Private members
	private JTextField abbrev;
	private JTextArea beforeCaret, afterCaret;
	//}}}
}
"
org.gjt.sp.jedit.gui.AboutDialog,"/*
 * AboutDialog.java - About jEdit dialog box
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
//}}}
public class AboutDialog extends EnhancedDialog
{
	//{{{ AboutDialog constructor
	public AboutDialog(View view)
	{
		super(view,jEdit.getProperty(""about.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		content.add(BorderLayout.CENTER,new AboutPanel());
		JPanel buttonPanel = new JPanel();
		buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.X_AXIS));
		buttonPanel.setBorder(new EmptyBorder(12,0,0,0));
		buttonPanel.add(Box.createGlue());
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(close);
		buttonPanel.add(close);
		buttonPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttonPanel);
		pack();
		setResizable(false);
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	// private members
	private JButton close;
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		}
	} //}}}
	//{{{ AboutPanel class
	static class AboutPanel extends JComponent
	{
		ImageIcon image;
		Vector text;
		int scrollPosition;
		AnimationThread thread;
		int maxWidth;
		FontMetrics fm;
		public static int TOP = 120;
		public static int BOTTOM = 30;
		AboutPanel()
		{
			setFont(UIManager.getFont(""Label.font""));
			fm = getFontMetrics(getFont());
			setForeground(new Color(96,96,96));
			image = new ImageIcon(getClass().getResource(
				""/org/gjt/sp/jedit/icons/about.png""));
			setBorder(new MatteBorder(1,1,1,1,Color.gray));
			text = new Vector(50);
			StringTokenizer st = new StringTokenizer(
				jEdit.getProperty(""about.text""),""\n"");
			while(st.hasMoreTokens())
			{
				String line = st.nextToken();
				text.addElement(line);
				maxWidth = Math.max(maxWidth,
					fm.stringWidth(line) + 10);
			}
			scrollPosition = -250;
			thread = new AnimationThread();
		}
		public void paintComponent(Graphics g)
		{
			g.setColor(new Color(96,96,96));
			image.paintIcon(this,g,1,1);
			FontMetrics fm = g.getFontMetrics();
			String[] args = { jEdit.getVersion() };
			String version = jEdit.getProperty(""about.version"",args);
			g.drawString(version,(getWidth() - fm.stringWidth(version)) / 2,
				getHeight() - 5);
			g = g.create((getWidth() - maxWidth) / 2,TOP,maxWidth,
				getHeight() - TOP - BOTTOM);
			int height = fm.getHeight();
			int firstLine = scrollPosition / height;
			int firstLineOffset = height - scrollPosition % height;
			int lines = (getHeight() - TOP - BOTTOM) / height;
			int y = firstLineOffset;
			for(int i = 0; i <= lines; i++)
			{
				if(i + firstLine >= 0 && i + firstLine < text.size())
				{
					String line = (String)text.get(i + firstLine);
					g.drawString(line,(maxWidth - fm.stringWidth(line))/2,y);
				}
				y += fm.getHeight();
			}
		}
		public Dimension getPreferredSize()
		{
			return new Dimension(1 + image.getIconWidth(),
				1 + image.getIconHeight());
		}
		public void addNotify()
		{
			super.addNotify();
			thread.start();
		}
		public void removeNotify()
		{
			super.removeNotify();
			thread.kill();
		}
		class AnimationThread extends Thread
		{
			private boolean running = true;
			private long last;
			AnimationThread()
			{
				super(""About box animation thread"");
				setPriority(Thread.MIN_PRIORITY);
			}
			public void kill()
			{
				running = false;
			}
			public void run()
			{
				FontMetrics fm = getFontMetrics(getFont());
				int max = (text.size() * fm.getHeight());
				while (running)
				{
					scrollPosition += 2;
					if(scrollPosition > max)
						scrollPosition = -250;
					if(last != 0)
					{
						long frameDelay =
							System.currentTimeMillis()
							- last;
						try
						{
							Thread.sleep(
								75
								- frameDelay);
						}
						catch(Exception e)
						{
						}
					}
					last = System.currentTimeMillis();
					repaint(getWidth() / 2 - maxWidth,
						TOP,maxWidth * 2,
						getHeight() - TOP - BOTTOM);
				}
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.ActionBar,"/*
 * ActionBar.java - For invoking actions directly
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import bsh.NameSpace;
import java.awt.event.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * Action invocation bar.
 */
public class ActionBar extends JPanel
{
	//{{{ ActionBar constructor
	public ActionBar(final View view, boolean temp)
	{
		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
		this.view = view;
		this.temp = temp;
		add(Box.createHorizontalStrut(2));
		JLabel label = new JLabel(jEdit.getProperty(""view.action.prompt""));
		add(label);
		add(Box.createHorizontalStrut(12));
		add(action = new ActionTextField());
		action.setEnterAddsToHistory(false);
		Dimension max = action.getPreferredSize();
		max.width = Integer.MAX_VALUE;
		action.setMaximumSize(max);
		action.addActionListener(new ActionHandler());
		action.getDocument().addDocumentListener(new DocumentHandler());
		if(temp)
		{
			close = new RolloverButton(GUIUtilities.loadIcon(""closebox.gif""));
			close.addActionListener(new ActionHandler());
			close.setToolTipText(jEdit.getProperty(
				""view.action.close-tooltip""));
			add(close);
		}
		// if 'temp' is true, hide search bar after user is done with it
		this.temp = temp;
	} //}}}
	//{{{ getField() method
	public HistoryTextField getField()
	{
		return action;
	} //}}}
	//{{{ goToActionBar() method
	public void goToActionBar()
	{
		repeatCount = view.getInputHandler().getRepeatCount();
		action.setText(null);
		action.requestFocus();
	} //}}}
	//{{{ Private members
	private static NameSpace namespace = new NameSpace(
		BeanShell.getNameSpace(),""action bar namespace"");
	//{{{ Instance variables
	private View view;
	private boolean temp;
	private int repeatCount;
	private HistoryTextField action;
	private CompletionPopup popup;
	private RolloverButton close;
	//}}}
	//{{{ invoke() method
	private void invoke()
	{
		String cmd;
		if(popup != null)
			cmd = popup.list.getSelectedValue().toString();
		else
		{
			cmd = action.getText().trim();
			int index = cmd.indexOf('=');
			if(index != -1)
			{
				action.addCurrentToHistory();
				String propName = cmd.substring(0,index).trim();
				String propValue = cmd.substring(index + 1).trim();
				String code;
				/* construct a BeanShell snippet instead of
				 * invoking directly so that user can record
				 * property changes in macros. */
				if(propName.startsWith(""buffer.""))
				{
					if(propName.equals(""buffer.mode""))
					{
						code = ""buffer.setMode(\""""
							+ MiscUtilities.charsToEscapes(
							propValue) + ""\"");"";
					}
					else
					{
						code = ""buffer.setStringProperty(\""""
							+ MiscUtilities.charsToEscapes(
							propName.substring(""buffer."".length())
							) + ""\"",\""""
							+ MiscUtilities.charsToEscapes(
							propValue) + ""\"");"";
					}
					code = code + ""\nbuffer.propertiesChanged();"";
				}
				else if(propName.startsWith(""!buffer.""))
				{
					code = ""jEdit.setProperty(\""""
						+ MiscUtilities.charsToEscapes(
						propName.substring(1)) + ""\"",\""""
						+ MiscUtilities.charsToEscapes(
						propValue) + ""\"");\n""
						+ ""jEdit.propertiesChanged();"";
				}
				else
				{
					code = ""jEdit.setProperty(\""""
						+ MiscUtilities.charsToEscapes(
						propName) + ""\"",\""""
						+ MiscUtilities.charsToEscapes(
						propValue) + ""\"");\n""
						+ ""jEdit.propertiesChanged();"";
				}
				Macros.Recorder recorder = view.getMacroRecorder();
				if(recorder != null)
					recorder.record(code);
				BeanShell.eval(view,namespace,code);
				cmd = null;
			}
			else if(cmd.length() != 0)
			{
				String[] completions = getCompletions(cmd);
				if(completions.length != 0)
				{
					cmd = completions[0];
				}
			}
			else
				cmd = null;
		}
		if(popup != null)
		{
			popup.dispose();
			popup = null;
		}
		final String finalCmd = cmd;
		final EditAction act = (finalCmd == null ? null : jEdit.getAction(finalCmd));
		if(temp)
			view.removeToolBar(ActionBar.this);
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				view.getTextArea().requestFocus();
				if(act == null)
				{
					if(finalCmd != null)
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(
							""view.action.no-completions""));
					}
				}
				else
				{
					view.getInputHandler().setRepeatCount(repeatCount);
					view.getInputHandler().invokeAction(act);
				}
			}
		});
	} //}}}
	//{{{ getCompletions() method
	private String[] getCompletions(String str)
	{
		str = str.toLowerCase();
		String[] actions = jEdit.getActionNames();
		ArrayList returnValue = new ArrayList(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			if(actions[i].toLowerCase().indexOf(str) != -1)
				returnValue.add(actions[i]);
		}
		return (String[])returnValue.toArray(new String[returnValue.size()]);
	} //}}}
	//{{{ complete() method
	private void complete(boolean insertLongestPrefix)
	{
		String text = action.getText().trim();
		String[] completions = getCompletions(text);
		if(completions.length == 1)
		{
			if(insertLongestPrefix)
				action.setText(completions[0]);
		}
		else if(completions.length != 0)
		{
			if(insertLongestPrefix)
			{
				String prefix = MiscUtilities.getLongestPrefix(
					completions,true);
				if(prefix.indexOf(text) != -1)
					action.setText(prefix);
			}
			if(popup != null)
				popup.setModel(completions);
			else
				popup = new CompletionPopup(completions);
			return;
		}
		if(popup != null)
		{
			popup.dispose();
			popup = null;
		}
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == close)
				view.removeToolBar(ActionBar.this);
			else
				invoke();
		}
	} //}}}
	//{{{ DocumentHandler class
	class DocumentHandler implements DocumentListener
	{
		//{{{ insertUpdate() method
		public void insertUpdate(DocumentEvent evt)
		{
			if(popup != null)
				complete(false);
		} //}}}
		//{{{ removeUpdate() method
		public void removeUpdate(DocumentEvent evt)
		{
			if(popup != null)
				complete(false);
		} //}}}
		//{{{ changedUpdate() method
		public void changedUpdate(DocumentEvent evt) {}
		//}}}
	} //}}}
	//{{{ ActionTextField class
	class ActionTextField extends HistoryTextField
	{
		boolean repeat;
		boolean nonDigit;
		ActionTextField()
		{
			super(""action"");
			setSelectAllOnFocus(true);
		}
		public boolean isManagingFocus()
		{
			return false;
		}
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		}
		public void processKeyEvent(KeyEvent evt)
		{
			evt = KeyEventWorkaround.processKeyEvent(evt);
			if(evt == null)
				return;
			switch(evt.getID())
			{
			case KeyEvent.KEY_TYPED:
				char ch = evt.getKeyChar();
				if(!nonDigit && Character.isDigit(ch))
				{
					super.processKeyEvent(evt);
					repeat = true;
					repeatCount = Integer.parseInt(action.getText());
				}
				else
				{
					nonDigit = true;
					if(repeat)
					{
						passToView(evt);
					}
					else
						super.processKeyEvent(evt);
				}
				break;
			case KeyEvent.KEY_PRESSED:
				int keyCode = evt.getKeyCode();
				if(evt.isActionKey()
					|| evt.isControlDown()
					|| evt.isAltDown()
					|| evt.isMetaDown()
					|| keyCode == KeyEvent.VK_BACK_SPACE
					|| keyCode == KeyEvent.VK_DELETE
					|| keyCode == KeyEvent.VK_ENTER
					|| keyCode == KeyEvent.VK_TAB
					|| keyCode == KeyEvent.VK_ESCAPE)
				{
					nonDigit = true;
					if(repeat)
					{
						passToView(evt);
						break;
					}
					else if(keyCode == KeyEvent.VK_TAB)
					{
						complete(true);
						evt.consume();
					}
					else if(keyCode == KeyEvent.VK_ESCAPE)
					{
						evt.consume();
						if(popup != null)
						{
							popup.dispose();
							popup = null;
							action.requestFocus();
						}
						else
						{
							if(temp)
								view.removeToolBar(ActionBar.this);
							view.getEditPane().focusOnTextArea();
						}
						break;
					}
					else if((keyCode == KeyEvent.VK_UP
						|| keyCode == KeyEvent.VK_DOWN)
						&& popup != null)
					{
						popup.list.processKeyEvent(evt);
						break;
					}
				}
				super.processKeyEvent(evt);
				break;
			}
		}
		private void passToView(final KeyEvent evt)
		{
			if(temp)
				view.removeToolBar(ActionBar.this);
			view.getTextArea().requestFocus();
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					view.getTextArea().requestFocus();
					view.getInputHandler().setRepeatCount(repeatCount);
					view.processKeyEvent(evt,
						View.ACTION_BAR);
				}
			});
		}
		public void addNotify()
		{
			super.addNotify();
			repeat = nonDigit = false;
		}
	} //}}}
	//{{{ CompletionPopup class
	class CompletionPopup extends JWindow
	{
		CompletionList list;
		//{{{ CompletionPopup constructor
		CompletionPopup(String[] actions)
		{
			super(view);
			setContentPane(new JPanel(new BorderLayout())
			{
				/**
				 * Returns if this component can be traversed by pressing the
				 * Tab key. This returns false.
				 */
				public boolean isManagingFocus()
				{
					return false;
				}
				/**
				 * Makes the tab key work in Java 1.4.
				 */
				public boolean getFocusTraversalKeysEnabled()
				{
					return false;
				}
			});
			list = new CompletionList(actions);
			list.setVisibleRowCount(8);
			list.addMouseListener(new MouseHandler());
			list.setSelectedIndex(0);
			list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			// stupid scrollbar policy is an attempt to work around
			// bugs people have been seeing with IBM's JDK -- 7 Sep 2000
			JScrollPane scroller = new JScrollPane(list,
				JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
				JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
			getContentPane().add(scroller, BorderLayout.CENTER);
			GUIUtilities.requestFocus(this,list);
			pack();
			Point p = new Point(0,-getHeight());
			SwingUtilities.convertPointToScreen(p,action);
			setLocation(p);
			setVisible(true);
			KeyHandler keyHandler = new KeyHandler();
			addKeyListener(keyHandler);
			list.addKeyListener(keyHandler);
		} //}}}
		//{{{ setModel() method
		void setModel(String[] actions)
		{
			list.setListData(actions);
			list.setSelectedIndex(0);
		} //}}}
		//{{{ MouseHandler class
		class MouseHandler extends MouseAdapter
		{
			public void mouseClicked(MouseEvent evt)
			{
				invoke();
			}
		} //}}}
		//{{{ CompletionList class
		class CompletionList extends JList
		{
			CompletionList(Object[] data)
			{
				super(data);
			}
			// we need this public not protected
			public void processKeyEvent(KeyEvent evt)
			{
				super.processKeyEvent(evt);
			}
		} //}}}
		//{{{ KeyHandler class
		class KeyHandler extends KeyAdapter
		{
			public void keyTyped(KeyEvent evt)
			{
				action.processKeyEvent(evt);
			}
			public void keyPressed(KeyEvent evt)
			{
				int keyCode = evt.getKeyCode();
				if(keyCode == KeyEvent.VK_ESCAPE)
					action.processKeyEvent(evt);
				else if(keyCode == KeyEvent.VK_ENTER)
					invoke();
				else if(keyCode == KeyEvent.VK_UP)
				{
					int selected = list.getSelectedIndex();
					if(selected == 0)
					{
						list.setSelectedIndex(
							list.getModel().getSize()
							- 1);
						evt.consume();
					}
				}
				else if(keyCode == KeyEvent.VK_DOWN)
				{
					int selected = list.getSelectedIndex();
					if(selected == list.getModel().getSize() - 1)
					{
						list.setSelectedIndex(0);
						evt.consume();
					}
				}
			}
		} //}}}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.AddAbbrevDialog,"/*
 * AddAbbrevDialog.java - Displayed when expanding unknown abbrev
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class AddAbbrevDialog extends JDialog
{
	public AddAbbrevDialog(View view, String abbrev)
	{
		super(view,jEdit.getProperty(""add-abbrev.title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setBorder(new EmptyBorder(6,0,12,0));
		content.add(BorderLayout.CENTER,editor);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		global = new JButton(jEdit.getProperty(""add-abbrev.global""));
		global.addActionListener(new ActionHandler());
		box.add(global);
		box.add(Box.createHorizontalStrut(6));
		modeSpecific = new JButton(jEdit.getProperty(""add-abbrev.mode""));
		modeSpecific.addActionListener(new ActionHandler());
		box.add(modeSpecific);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		if(abbrev == null)
			GUIUtilities.requestFocus(this,editor.getAbbrevField());
		else
			GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	}
	// private members
	private View view;
	private AbbrevEditor editor;
	private JButton global;
	private JButton modeSpecific;
	private JButton cancel;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == global)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addGlobalAbbrev(_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			else if(source == modeSpecific)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addModeAbbrev(view.getBuffer().getMode().getName(),
					_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			dispose();
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	}
}
"
org.gjt.sp.jedit.gui.AnimatedIcon,"/*
 * AnimatedIcon.java - Animated version of ImageIcon
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
//}}}
/**
 * A animated version of ImageIcon. It can be used anywhere an ImageIcon can be.
 */
public class AnimatedIcon extends ImageIcon
{
	//{{{ AnimatedIcon constructor
	/**
	 * @param frames The frames to be used in the animation
	 * @param rate The frame rate of the animation, in frames per second
	 * @param host The container that the animation is used in
	 */
	public AnimatedIcon(Image icon, Image[] frames, int rate, Component host)
	{
		super(icon);
		this.icon = icon;
		this.frames = frames;
		delay = 1000/rate;
		this.host = host;
	} //}}}
	//{{{ getFrames() method
	public Image[] getFrames()
	{
		return frames;
	} //}}}
	//{{{ getIcon() method
	public Image getIcon()
	{
		return icon;
	} //}}}
	//{{{ getRate() method
	public int getRate()
	{
		return 1000/delay;
	} //}}}
	//{{{ setFrames() method
	public void setFrames(Image[] frames)
	{
		this.frames = frames;
	} //}}}
	//{{{ setIcon() method
	public void setIcon(Image icon)
	{
		this.icon = icon;
	} //}}}
	//{{{ setRate() method
	public void setRate(int rate)
	{
		delay = 1000/rate;
	} //}}}
	//{{{ start() method
	/**
	 * Starts the animation rolling
	 */
	public void start()
	{
		if(timer != null)
			return;
		timer = new Timer(delay,new Animator());
		timer.start();
	} //}}}
	//{{{ stop() method
	/**
	 * Stops the animation, and resets to frame 0
	 */
	public void stop()
	{
		current = 0;
		if(timer != null)
		{
			timer.stop();
			timer = null;
		}
		setImage(icon);
		host.repaint();
	} //}}}
	//{{{ Private members
	private Image[] frames;
	private int current;
	private int delay;
	private Timer timer;
	private Component host;
	private Image icon;
	//}}}
	//{{{ Animator class
	class Animator implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			current = (current + 1) % frames.length;
			setImage(frames[current]);
			host.repaint();
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.BeanShellErrorDialog,"/*
 * BeanShellErrorDialog.java - BeanShell execution error dialog box
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * A dialog box showing a stack trace. Perhaps badly named, since any error, not
 * just a BeanShell error can be shown.
 * @author Slava Pestov
 * @version $Id: BeanShellErrorDialog.java,v 1.7 2004/04/05 03:11:47 spestov Exp $
 */
public class BeanShellErrorDialog extends TextAreaDialog
{
	public BeanShellErrorDialog(Frame frame, Throwable t)
	{
		super(frame,""beanshell-error"",t);
	}
	// for ABI compatibility
	public BeanShellErrorDialog(View view, Throwable t)
	{
		this((Frame)view,t);
	}
}
"
org.gjt.sp.jedit.gui.BufferOptions,"/*
 * BufferOptions.java - Buffer-specific options dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Arrays;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.*;
//}}}
/**
 * Buffer-specific options dialog.
 * @author Slava Pestov
 * @version $Id: BufferOptions.java,v 1.31 2004/06/28 06:45:26 spestov Exp $
 */
public class BufferOptions extends EnhancedDialog
{
	//{{{ BufferOptions constructor
	public BufferOptions(View view, Buffer buffer)
	{
		super(view,jEdit.getProperty(""buffer-options.title""),true);
		this.view = view;
		this.buffer = buffer;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		ActionHandler actionListener = new ActionHandler();
		AbstractOptionPane panel = new AbstractOptionPane(null);
		panel.addComponent(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""buffer-options.caption"")));
		panel.addSeparator(""buffer-options.loading-saving"");
		//{{{ Line separator
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = buffer.getStringProperty(Buffer.LINESEP);
		if(lineSep == null)
			lineSep = System.getProperty(""line.separator"");
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		panel.addComponent(jEdit.getProperty(""buffer-options.lineSeparator""),
			lineSeparator);
		//}}}
		//{{{ Encoding
		String[] encodings = MiscUtilities.getEncodings();
		Arrays.sort(encodings,new MiscUtilities.StringICaseCompare());
		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(buffer.getStringProperty(Buffer.ENCODING));
		panel.addComponent(jEdit.getProperty(""buffer-options.encoding""),
			encoding);
		//}}}
		//{{{ GZipped setting
		gzipped = new JCheckBox(jEdit.getProperty(
			""buffer-options.gzipped""));
		gzipped.setSelected(buffer.getBooleanProperty(Buffer.GZIPPED));
		panel.addComponent(gzipped);
		//}}}
		panel.addSeparator(""buffer-options.editing"");
		//{{{ Edit mode
		modes = jEdit.getModes();
		MiscUtilities.quicksort(modes,new MiscUtilities.StringICaseCompare());
		mode = new JComboBox(modes);
		mode.setSelectedItem(buffer.getMode());
		mode.addActionListener(actionListener);
		panel.addComponent(jEdit.getProperty(""buffer-options.mode""),mode);
		//}}}
		//{{{ Fold mode
		String[] foldModes = FoldHandler.getFoldModes();
		folding = new JComboBox(foldModes);
		folding.setSelectedItem(buffer.getStringProperty(""folding""));
		panel.addComponent(jEdit.getProperty(""options.editing.folding""),
			folding);
		//}}}
		//{{{ Wrap mode
		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};
		wrap = new JComboBox(wrapModes);
		wrap.setSelectedItem(buffer.getStringProperty(""wrap""));
		panel.addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap);
		wrap.addActionListener(new ActionHandler());
		//}}}
		//{{{ Max line length
		String[] lineLengths = { ""0"", ""72"", ""76"", ""80"" };
		maxLineLen = new JComboBox(lineLengths);
		maxLineLen.setEditable(true);
		maxLineLen.setSelectedItem(buffer.getStringProperty(""maxLineLen""));
		maxLineLen.addActionListener(new ActionHandler());
		panel.addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen);
		//}}}
		//{{{ Tab size
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(buffer.getStringProperty(""tabSize""));
		panel.addComponent(jEdit.getProperty(""options.editing.tabSize""),tabSize);
		//}}}
		//{{{ Indent size
		indentSize = new JComboBox(tabSizes);
		indentSize.setEditable(true);
		indentSize.setSelectedItem(buffer.getStringProperty(""indentSize""));
		panel.addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize);
		//}}}
		//{{{ Soft tabs
		noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs""));
		noTabs.setSelected(buffer.getBooleanProperty(""noTabs""));
		panel.addComponent(noTabs);
		//}}}
		content.add(BorderLayout.NORTH,panel);
		//{{{ Buttons
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionListener);
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionListener);
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		//}}}
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		int index = lineSeparator.getSelectedIndex();
		String lineSep;
		if(index == 0)
			lineSep = ""\n"";
		else if(index == 1)
			lineSep = ""\r\n"";
		else if(index == 2)
			lineSep = ""\r"";
		else
			throw new InternalError();
		String oldLineSep = buffer.getStringProperty(Buffer.LINESEP);
		if(oldLineSep == null)
			oldLineSep = System.getProperty(""line.separator"");
		if(!oldLineSep.equals(lineSep))
		{
			buffer.setStringProperty(""lineSeparator"",lineSep);
			buffer.setDirty(true);
		}
		String encoding = (String)this.encoding.getSelectedItem();
		String oldEncoding = buffer.getStringProperty(Buffer.ENCODING);
		if(!oldEncoding.equals(encoding))
		{
			buffer.setStringProperty(Buffer.ENCODING,encoding);
			buffer.setDirty(true);
		}
		boolean gzippedValue = gzipped.isSelected();
		boolean oldGzipped = buffer.getBooleanProperty(
			Buffer.GZIPPED);
		if(gzippedValue != oldGzipped)
		{
			buffer.setBooleanProperty(Buffer.GZIPPED,gzippedValue);
			buffer.setDirty(true);
		}
		buffer.setStringProperty(""folding"",(String)folding.getSelectedItem());
		buffer.setStringProperty(""wrap"",(String)wrap.getSelectedItem());
		try
		{
			buffer.setProperty(""maxLineLen"",new Integer(
				maxLineLen.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}
		try
		{
			buffer.setProperty(""tabSize"",new Integer(
				tabSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}
		try
		{
			buffer.setProperty(""indentSize"",new Integer(
				indentSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}
		buffer.setBooleanProperty(""noTabs"",noTabs.isSelected());
		index = mode.getSelectedIndex();
		buffer.setMode(modes[index]);
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
        //{{{ Private members
	//{{{ Instance variables
	private View view;
	private Buffer buffer;
	private Mode[] modes;
	private JComboBox mode;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JCheckBox gzipped;
	private JComboBox folding;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	private JButton ok;
	private JButton cancel;
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == mode)
			{
				Mode _mode = (Mode)mode.getSelectedItem();
				folding.setSelectedItem(_mode.getProperty(
					""folding""));
				wrap.setSelectedItem(_mode.getProperty(
					""wrap""));
				maxLineLen.setSelectedItem(_mode.getProperty(
					""maxLineLen""));
				tabSize.setSelectedItem(_mode.getProperty(
					""tabSize""));
				indentSize.setSelectedItem(_mode.getProperty(
					""indentSize""));
				noTabs.setSelected(_mode.getBooleanProperty(
					""noTabs""));
			}
			else if(source == wrap)
			{
				if(!wrap.getSelectedItem().equals(""none""))
				{
					if(maxLineLen.getSelectedItem()
						.equals(""0""))
					{
						maxLineLen.setSelectedItem(""80"");
					}
				}
			}
			else if(source == maxLineLen)
			{
				if(!wrap.getSelectedItem().equals(""none""))
				{
					if(maxLineLen.getSelectedItem()
						.equals(""0""))
					{
						wrap.setSelectedItem(""none"");
					}
				}
			}
		} //}}}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.BufferSwitcher,"/*
 * BufferSwitcher.java - Status bar
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class BufferSwitcher extends JComboBox
{
	public BufferSwitcher(EditPane editPane)
	{
		this.editPane = editPane;
		//setFont(new Font(""Dialog"",Font.BOLD,10));
		setRenderer(new BufferCellRenderer());
		setMaximumRowCount(jEdit.getIntegerProperty(""bufferSwitcher.maxRowCount"",10));
		addActionListener(new ActionHandler());
	}
	public void updateBufferList()
	{
		// if the buffer count becomes 0, then it is guaranteed to
		// become 1 very soon, so don't do anything in that case.
		if(jEdit.getBufferCount() == 0)
			return;
		updating = true;
		setMaximumRowCount(jEdit.getIntegerProperty(""bufferSwitcher.maxRowCount"",10));
		setModel(new DefaultComboBoxModel(jEdit.getBuffers()));
		setSelectedItem(editPane.getBuffer());
		updating = false;
	}
	// private members
	private EditPane editPane;
	private boolean updating;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(!updating)
			{
				Buffer buffer = (Buffer)getSelectedItem();
				if(buffer != null)
					editPane.setBuffer(buffer);
			}
		}
	}
	class BufferCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Buffer buffer = (Buffer)value;
			if(buffer == null)
				setIcon(null);
			else
				setIcon(buffer.getIcon());
			return this;
		}
	}
}
"
org.gjt.sp.jedit.gui.CloseDialog,"/*
 * CloseDialog.java - Close all buffers dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.buffer.BufferIORequest;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
//}}}
public class CloseDialog extends EnhancedDialog
{
	//{{{ CloseDialog constructor
	public CloseDialog(View view)
	{
		super(view,jEdit.getProperty(""close.title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.warningIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);
		JPanel centerPanel = new JPanel(new BorderLayout());
		JLabel label = new JLabel(jEdit.getProperty(""close.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);
		bufferList = new JList(bufferModel = new DefaultListModel());
		bufferList.setVisibleRowCount(10);
		bufferList.addListSelectionListener(new ListHandler());
		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(buffer.isDirty())
			{
				bufferModel.addElement(buffer.getPath());
			}
		}
		centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferList));
		content.add(BorderLayout.CENTER,centerPanel);
		ActionHandler actionListener = new ActionHandler();
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		buttons.add(selectAll = new JButton(jEdit.getProperty(""close.selectAll"")));
		selectAll.setMnemonic(jEdit.getProperty(""close.selectAll.mnemonic"").charAt(0));
		selectAll.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(save = new JButton(jEdit.getProperty(""close.save"")));
		save.setMnemonic(jEdit.getProperty(""close.save.mnemonic"").charAt(0));
		save.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(discard = new JButton(jEdit.getProperty(""close.discard"")));
		discard.setMnemonic(jEdit.getProperty(""close.discard.mnemonic"").charAt(0));
		discard.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(actionListener);
		buttons.add(Box.createGlue());
		bufferList.setSelectedIndex(0);
		content.add(BorderLayout.SOUTH,buttons);
		GUIUtilities.requestFocus(this,bufferList);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ isOK() method
	public boolean isOK()
	{
		return ok;
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		// do nothing
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ Private members
	private View view;
	private JList bufferList;
	private DefaultListModel bufferModel;
	private JButton selectAll;
	private JButton save;
	private JButton discard;
	private JButton cancel;
	private boolean ok; // only set if all buffers saved/closed
	boolean selectAllFlag;
	private void updateButtons()
	{
		int index = bufferList.getSelectedIndex();
		save.getModel().setEnabled(index != -1);
		discard.getModel().setEnabled(index != -1);
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
			{
				// I'm too tired to think of a better way
				// to handle this right now.
				try
				{
					selectAllFlag = true;
					bufferList.setSelectionInterval(0,
						bufferModel.getSize() - 1);
				}
				finally
				{
					selectAllFlag = false;
				}
				bufferList.requestFocus();
			}
			else if(source == save)
			{
				Object[] paths = bufferList.getSelectedValues();
				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					if(!buffer.save(view,null,true))
						return;
					VFSManager.waitForRequests();
					if(buffer.getBooleanProperty(BufferIORequest
						.ERROR_OCCURRED))
						return;
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}
				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == discard)
			{
				Object[] paths = bufferList.getSelectedValues();
				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}
				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == cancel)
				cancel();
		}
	} //}}}
	//{{{ ListHandler class
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			if(selectAllFlag)
				return;
			int index = bufferList.getSelectedIndex();
			if(index != -1)
				view.goToBuffer(jEdit.getBuffer((String)
					bufferModel.getElementAt(index)));
			updateButtons();
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.ColorWellButton,"/*
 * ColorWellButton.java - Shows color chooser when clicked
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.OperatingSystem;
//}}}
/**
 * A button that, when clicked, shows a color chooser.
 *
 * You can get and set the currently selected color using
 * {@link #getSelectedColor()} and {@link #setSelectedColor(Color)}.
 * @author Slava Pestov
 * @version $Id: ColorWellButton.java,v 1.7 2004/06/28 06:45:27 spestov Exp $
 */
public class ColorWellButton extends JButton
{
	//{{{ ColorWellButton constructor
	public ColorWellButton(Color color)
	{
		setIcon(new ColorWell(color));
		setMargin(new Insets(2,2,2,2));
		addActionListener(new ActionHandler());
		// according to krisk this looks better on OS X...
		if(OperatingSystem.isMacOSLF())
			putClientProperty(""JButton.buttonType"",""toolbar"");
	} //}}}
	//{{{ getSelectedColor() method
	public Color getSelectedColor()
	{
		return ((ColorWell)getIcon()).color;
	} //}}}
	//{{{ setSelectedColor() method
	public void setSelectedColor(Color color)
	{
		((ColorWell)getIcon()).color = color;
		repaint();
	} //}}}
	//{{{ ColorWell class
	static class ColorWell implements Icon
	{
		Color color;
		ColorWell(Color color)
		{
			this.color = color;
		}
		public int getIconWidth()
		{
			return 35;
		}
		public int getIconHeight()
		{
			return 10;
		}
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			if(color == null)
				return;
			g.setColor(color);
			g.fillRect(x,y,getIconWidth(),getIconHeight());
			g.setColor(color.darker());
			g.drawRect(x,y,getIconWidth()-1,getIconHeight()-1);
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			JDialog parent = GUIUtilities.getParentDialog(ColorWellButton.this);
			JDialog dialog;
			if (parent != null)
			{
				dialog = new ColorPickerDialog(parent,
					jEdit.getProperty(""colorChooser.title""),
					true);
			}
			else
			{
				dialog = new ColorPickerDialog(
					JOptionPane.getFrameForComponent(
					ColorWellButton.this),
					jEdit.getProperty(""colorChooser.title""),
					true);
			}
			dialog.pack();
			dialog.setVisible(true);
		}
	} //}}}
	//{{{ ColorPickerDialog class
	/**
	 * Replacement for the color picker dialog provided with Swing. This version
	 * supports dialog as well as frame parents.
	 * @since jEdit 4.1pre7
	 */
	private class ColorPickerDialog extends EnhancedDialog implements ActionListener
	{
		public ColorPickerDialog(Frame parent, String title, boolean modal)
		{
			super(parent,title,modal);
			init();
		}
		public ColorPickerDialog(Dialog parent, String title, boolean modal)
		{
			super(parent,title,modal);
			getContentPane().setLayout(new BorderLayout());
			init();
		}
		public void ok()
		{
			Color c = chooser.getColor();
			if (c != null)
				setSelectedColor(c);
			setVisible(false);
		}
		public void cancel()
		{
			setVisible(false);
		}
		public void actionPerformed(ActionEvent evt)
		{
			if (evt.getSource() == ok)
				ok();
			else
				cancel();
		}
		//{{{ Private members
		private JColorChooser chooser;
		private JButton ok;
		private JButton cancel;
		private void init()
		{
			Color c = getSelectedColor();
			if(c == null)
				chooser = new JColorChooser();
			else
				chooser = new JColorChooser(c);
			getContentPane().add(BorderLayout.CENTER, chooser);
			Box buttons = new Box(BoxLayout.X_AXIS);
			buttons.add(Box.createGlue());
			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(this);
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(6));
			getRootPane().setDefaultButton(ok);
			cancel = new JButton(jEdit.getProperty(""common.cancel""));
			cancel.addActionListener(this);
			buttons.add(cancel);
			buttons.add(Box.createGlue());
			getContentPane().add(BorderLayout.SOUTH, buttons);
			pack();
			setLocationRelativeTo(getParent());
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.CompleteWord,"/*
 * CompleteWord.java - Complete word dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.HashSet;
import java.util.TreeSet;
import java.util.Set;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
//}}}
public class CompleteWord extends JWindow
{
	//{{{ completeWord() method
	public static void completeWord(View view)
	{
		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();
		int caretLine = textArea.getCaretLine();
		int caret = textArea.getCaretPosition();
		if(!buffer.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}
		KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
		String noWordSep = getNonAlphaNumericWordChars(
			buffer,keywordMap);
		String word = getWordToComplete(buffer,caretLine,
			caret,noWordSep);
		if(word == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		Completion[] completions = getCompletions(buffer,word,caret);
		if(completions.length == 0)
		{
			textArea.getToolkit().beep();
		}
		//{{{ if there is only one competion, insert in buffer
		else if(completions.length == 1)
		{
			Completion c = completions[0];
			if(c.text.equals(word))
			{
				textArea.getToolkit().beep();
			}
			else
			{
				textArea.setSelectedText(c.text.substring(
					word.length()));
			}
		} //}}}
		//{{{ show popup if > 1
		else
		{
			String longestPrefix = MiscUtilities.getLongestPrefix(
				completions,
				keywordMap != null
				? keywordMap.getIgnoreCase()
				: false);
			if (word.length() < longestPrefix.length())
			{
				buffer.insert(caret,longestPrefix.substring(
					word.length()));
			}
			textArea.scrollToCaret(false);
			Point location = textArea.offsetToXY(
				caret - word.length());
			location.y += textArea.getPainter().getFontMetrics()
				.getHeight();
			SwingUtilities.convertPointToScreen(location,
				textArea.getPainter());
			new CompleteWord(view,longestPrefix,
				completions,location,noWordSep);
		} //}}}
	} //}}}
	//{{{ CompleteWord constructor
	public CompleteWord(View view, String word, Completion[] completions,
		Point location, String noWordSep)
	{
		super(view);
		this.noWordSep = noWordSep;
		setContentPane(new JPanel(new BorderLayout())
		{
			/**
			 * Returns if this component can be traversed by pressing the
			 * Tab key. This returns false.
			 */
			public boolean isManagingFocus()
			{
				return false;
			}
			/**
			 * Makes the tab key work in Java 1.4.
			 */
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		});
		this.view = view;
		this.textArea = view.getTextArea();
		this.buffer = view.getBuffer();
		this.word = word;
		words = new JList(completions);
		words.setVisibleRowCount(Math.min(completions.length,8));
		words.addMouseListener(new MouseHandler());
		words.setSelectedIndex(0);
		words.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		words.setCellRenderer(new Renderer());
		// stupid scrollbar policy is an attempt to work around
		// bugs people have been seeing with IBM's JDK -- 7 Sep 2000
		JScrollPane scroller = new JScrollPane(words,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		getContentPane().add(scroller, BorderLayout.CENTER);
		GUIUtilities.requestFocus(this,words);
		pack();
		setLocation(location);
		setVisible(true);
		KeyHandler keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		words.addKeyListener(keyHandler);
		view.setKeyEventInterceptor(keyHandler);
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		view.setKeyEventInterceptor(null);
		super.dispose();
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				textArea.requestFocus();
			}
		});
	} //}}}
	//{{{ Private members
	//{{{ getNonAlphaNumericWordChars() method
	private static String getNonAlphaNumericWordChars(Buffer buffer,
		KeywordMap keywordMap)
	{
		// figure out what constitutes a word character and what
		// doesn't
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		if(noWordSep == null)
			noWordSep = """";
		if(keywordMap != null)
		{
			String keywordNoWordSep = keywordMap.getNonAlphaNumericChars();
			if(keywordNoWordSep != null)
				noWordSep = noWordSep + keywordNoWordSep;
		}
		return noWordSep;
	} //}}}
	//{{{ getWordToComplete() method
	private static String getWordToComplete(Buffer buffer, int caretLine,
		int caret, String noWordSep)
	{
		String line = buffer.getLineText(caretLine);
		int dot = caret - buffer.getLineStartOffset(caretLine);
		if(dot == 0)
			return null;
		char ch = line.charAt(dot-1);
		if(!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1)
		{
			// attempting to expand non-word char
			return null;
		}
		int wordStart = TextUtilities.findWordStart(line,dot-1,noWordSep);
		String word = line.substring(wordStart,dot);
		if(word.length() == 0)
			return null;
		return word;
	} //}}}
	//{{{ getCompletions() method
	private static Completion[] getCompletions(Buffer buffer, String word,
		int caret)
	{
		// build a list of unique words in all visible buffers
		Set completions = new TreeSet(new MiscUtilities
			.StringCompare());
		Set buffers = new HashSet();
		// only complete current buffer's keyword map
		KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
		String noWordSep = getNonAlphaNumericWordChars(
			buffer,keywordMap);
		View views = jEdit.getFirstView();
		while(views != null)
		{
			EditPane[] panes = views.getEditPanes();
			for(int i = 0; i < panes.length; i++)
			{
				Buffer b = panes[i].getBuffer();
				if(buffers.contains(b))
					continue;
				buffers.add(b);
				// only complete current buffer's keyword map
				KeywordMap _keywordMap;
				if(b == buffer)
					_keywordMap = keywordMap;
				else
					_keywordMap = null;
				int offset = (b == buffer ? caret : 0);
				getCompletions(b,word,keywordMap,noWordSep,
					offset,completions);
			}
			views = views.getNext();
		}
		Completion[] completionArray = (Completion[])completions
			.toArray(new Completion[completions.size()]);
		return completionArray;
	} //}}}
	//{{{ getCompletions() method
	private static void getCompletions(Buffer buffer, String word,
		KeywordMap keywordMap, String noWordSep, int caret,
		Set completions)
	{
		int wordLen = word.length();
		//{{{ try to find matching keywords
		if(keywordMap != null)
		{
			String[] keywords = keywordMap.getKeywords();
			for(int i = 0; i < keywords.length; i++)
			{
				String _keyword = keywords[i];
				if(_keyword.regionMatches(keywordMap.getIgnoreCase(),
					0,word,0,wordLen))
				{
					Completion keyword = new Completion(_keyword,true);
					if(!completions.contains(keyword))
					{
						completions.add(keyword);
					}
				}
			}
		} //}}}
		//{{{ loop through all lines of current buffer
		for(int i = 0; i < buffer.getLineCount(); i++)
		{
			String line = buffer.getLineText(i);
			int start = buffer.getLineStartOffset(i);
			// check for match at start of line
			if(line.startsWith(word) && caret != start + word.length())
			{
				String _word = completeWord(line,0,noWordSep);
				Completion comp = new Completion(_word,false);
				// remove duplicates
				if(!completions.contains(comp))
				{
					completions.add(comp);
				}
			}
			// check for match inside line
			int len = line.length() - word.length();
			for(int j = 0; j < len; j++)
			{
				char c = line.charAt(j);
				if(!Character.isLetterOrDigit(c) && noWordSep.indexOf(c) == -1)
				{
					if(line.regionMatches(j + 1,word,0,wordLen)
						&& caret != start + j + word.length() + 1)
					{
						String _word = completeWord(line,j + 1,noWordSep);
						Completion comp = new Completion(_word,false);
						// remove duplicates
						if(!completions.contains(comp))
						{
							completions.add(comp);
						}
					}
				}
			}
		} //}}}
	} //}}}
	//{{{ completeWord() method
	private static String completeWord(String line, int offset, String noWordSep)
	{
		// '+ 1' so that findWordEnd() doesn't pick up the space at the start
		int wordEnd = TextUtilities.findWordEnd(line,offset + 1,noWordSep);
		return line.substring(offset,wordEnd);
	} //}}}
	//{{{ Instance variables
	private View view;
	private JEditTextArea textArea;
	private Buffer buffer;
	private String word;
	private JList words;
	private String noWordSep;
	//}}}
	//{{{ insertSelected() method
	private void insertSelected()
	{
		textArea.setSelectedText(words.getSelectedValue().toString()
			.substring(word.length()));
		dispose();
	} //}}}
	//}}}
	//{{{ Completion class
	static class Completion
	{
		String text;
		boolean keyword;
		Completion(String text, boolean keyword)
		{
			this.text = text;
			this.keyword = keyword;
		}
		public String toString()
		{
			return text;
		}
		public int hashCode()
		{
			return text.hashCode();
		}
		public boolean equals(Object obj)
		{
			if(obj instanceof Completion)
				return ((Completion)obj).text.equals(text);
			else
				return false;
		}
	} //}}}
	//{{{ Renderer class
	static class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list, Object value,
			int index, boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,null,index,
				isSelected,cellHasFocus);
			Completion comp = (Completion)value;
			if(index < 9)
				setText((index + 1) + "": "" + comp.text);
			else if(index == 9)
				setText(""0: "" + comp.text);
			else
				setText(comp.text);
			if(comp.keyword)
				setFont(list.getFont().deriveFont(Font.BOLD));
			else
				setFont(list.getFont());
			return this;
		}
	} //}}}
	//{{{ KeyHandler class
	class KeyHandler extends KeyAdapter
	{
		//{{{ keyPressed() method
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_TAB:
			case KeyEvent.VK_ENTER:
				insertSelected();
				evt.consume();
				break;
			case KeyEvent.VK_ESCAPE:
				dispose();
				evt.consume();
				break;
			case KeyEvent.VK_UP:
				int selected = words.getSelectedIndex();
				if(selected == 0)
					selected = words.getModel().getSize() - 1;
				else if(getFocusOwner() == words)
					return;
				else
					selected = selected - 1;
				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);
				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				/* int */ selected = words.getSelectedIndex();
				if(selected == words.getModel().getSize() - 1)
					selected = 0;
				else if(getFocusOwner() == words)
					return;
				else
					selected = selected + 1;
				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);
				evt.consume();
				break;
			case KeyEvent.VK_BACK_SPACE:
				if(word.length() == 1)
				{
					textArea.backspace();
					evt.consume();
					dispose();
				}
				else
				{
					word = word.substring(0,word.length() - 1);
					textArea.backspace();
					int caret = textArea.getCaretPosition();
					Completion[] completions
						= getCompletions(buffer,word,
						caret);
					if(completions.length == 0)
					{
						dispose();
						return;
					}
					words.setListData(completions);
					words.setSelectedIndex(0);
					words.setVisibleRowCount(Math.min(completions.length,8));
					pack();
					evt.consume();
				}
				break;
			default:
				if(evt.isActionKey()
					|| evt.isControlDown()
					|| evt.isAltDown()
					|| evt.isMetaDown())
				{
					dispose();
					view.processKeyEvent(evt);
				}
				break;
			}
		} //}}}
		//{{{ keyTyped() method
		public void keyTyped(KeyEvent evt)
		{
			char ch = evt.getKeyChar();
			evt = KeyEventWorkaround.processKeyEvent(evt);
			if(evt == null)
				return;
			if(Character.isDigit(ch))
			{
				int index = ch - '0';
				if(index == 0)
					index = 9;
				else
					index--;
				if(index < words.getModel().getSize())
				{
					words.setSelectedIndex(index);
					textArea.setSelectedText(words.getModel()
						.getElementAt(index).toString()
						.substring(word.length()));
					dispose();
					return;
				}
				else
					/* fall through */;
			}
			// \t handled above
			if(ch != '\b' && ch != '\t')
			{
				/* eg, foo<C+b>, will insert foobar, */
				if(!Character.isLetterOrDigit(ch) && noWordSep.indexOf(ch) == -1)
				{
					insertSelected();
					textArea.userInput(ch);
					dispose();
					return;
				}
				textArea.userInput(ch);
				word = word + ch;
				int caret = textArea.getCaretPosition();
				Completion[] completions = getCompletions(
					buffer,word,caret);
				if(completions.length == 0)
				{
					dispose();
					return;
				}
				words.setListData(completions);
				words.setSelectedIndex(0);
				words.setVisibleRowCount(Math.min(completions.length,8));
			}
		} //}}}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			insertSelected();
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.DefaultFocusComponent,"/*
 * DefaultFocusComponent.java - Interface for dockable windows
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
/**
 * An interface that provides a method for focusing on the default
 * component. The file system browser implements this in order to
 * focus on the file system view by default, for example.
 *
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: DefaultFocusComponent.java,v 1.1 2003/04/14 05:28:12 spestov Exp $
 */
public interface DefaultFocusComponent
{
	/**
	 * Sets focus on the default component.
	 * @since jEdit 4.2pre1
	 */
	void focusOnDefaultComponent();
}
"
org.gjt.sp.jedit.gui.DefaultInputHandler,"/*
 * DefaultInputHandler.java - Default implementation of an input handler
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import java.awt.event.InputEvent;
import java.awt.Toolkit;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * The default input handler. It maps sequences of keystrokes into actions
 * and inserts key typed events into the text area.
 * @author Slava Pestov
 * @version $Id: DefaultInputHandler.java,v 1.40 2004/04/19 05:59:31 spestov Exp $
 */
public class DefaultInputHandler extends InputHandler
{
	//{{{ DefaultInputHandler constructor
	/**
	 * Creates a new input handler with no key bindings defined.
	 * @param view The view
	 */
	public DefaultInputHandler(View view)
	{
		super(view);
		bindings = currentBindings = new Hashtable();
	} //}}}
	//{{{ DefaultInputHandler constructor
	/**
	 * Creates a new input handler with the same set of key bindings
	 * as the one specified. Note that both input handlers share
	 * a pointer to exactly the same key binding table; so adding
	 * a key binding in one will also add it to the other.
	 * @param copy The input handler to copy key bindings from
	 * @param view The view
	 */
	public DefaultInputHandler(View view, DefaultInputHandler copy)
	{
		super(view);
		bindings = currentBindings = copy.bindings;
	} //}}}
	//{{{ addKeyBinding() method
	/**
	 * Adds a key binding to this input handler. The key binding is
	 * a list of white space separated key strokes of the form
	 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,
	 * or S for Shift, and key is either a character (a-z) or a field
	 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)
	 * @param keyBinding The key binding
	 * @param action The action
	 * @since jEdit 4.2pre1
	 */
	public void addKeyBinding(String keyBinding, String action)
	{
		_addKeyBinding(keyBinding,(Object)action);
	} //}}}
	//{{{ addKeyBinding() method
	/**
	 * Adds a key binding to this input handler. The key binding is
	 * a list of white space separated key strokes of the form
	 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,
	 * or S for Shift, and key is either a character (a-z) or a field
	 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)
	 * @param keyBinding The key binding
	 * @param action The action
	 */
	public void addKeyBinding(String keyBinding, EditAction action)
	{
		_addKeyBinding(keyBinding,(Object)action);
	} //}}}
	//{{{ removeKeyBinding() method
	/**
	 * Removes a key binding from this input handler. This is not yet
	 * implemented.
	 * @param keyBinding The key binding
	 */
	public void removeKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			String keyCodeStr = st.nextToken();
			KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(keyCodeStr);
			if(keyStroke == null)
				return;
			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = ((Hashtable)o);
				else if(o != null)
				{
					// we have binding foo
					// but user asks to remove foo bar?
					current.remove(keyStroke);
					return;
				}
				else
				{
					// user asks to remove non-existent
					return;
				}
			}
			else
				current.remove(keyStroke);
		}
	} //}}}
	//{{{ removeAllKeyBindings() method
	/**
	 * Removes all key bindings from this input handler.
	 */
	public void removeAllKeyBindings()
	{
		bindings.clear();
	} //}}}
	//{{{ getKeyBinding() method
	/**
	 * Returns either an edit action, or a hashtable if the specified key
	 * is a prefix.
	 * @param keyBinding The key binding
	 * @since jEdit 3.2pre5
	 */
	public Object getKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(
				st.nextToken());
			if(keyStroke == null)
				return null;
			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
				{
					if(!st.hasMoreTokens())
						return o;
					else
						current = (Hashtable)o;
				}
				else
					return o;
			}
			else
			{
				return current.get(keyStroke);
			}
		}
		return null;
	} //}}}
	//{{{ isPrefixActive() method
	/**
	 * Returns if a prefix key has been pressed.
	 */
	public boolean isPrefixActive()
	{
		return bindings != currentBindings
			|| super.isPrefixActive();
	} //}}}
	//{{{ handleKey() method
	/**
	 * Handles the given keystroke.
	 * @param keyStroke The key stroke
	 * @since jEdit 4.2pre5
	 */
	public boolean handleKey(KeyEventTranslator.Key keyStroke)
	{
		char input = '\0';
		if(keyStroke.modifiers == null
			|| keyStroke.modifiers.equals(""S""))
		{
			switch(keyStroke.key)
			{
			case '\n':
			case '\t':
				input = (char)keyStroke.key;
				break;
			default:
				input = keyStroke.input;
				break;
			}
		}
		if(readNextChar != null)
		{
			if(input != '\0')
			{
				setCurrentBindings(bindings);
				invokeReadNextChar(input);
				repeatCount = 1;
				return true;
			}
			else
			{
				readNextChar = null;
				view.getStatus().setMessage(null);
			}
		}
		Object o = currentBindings.get(keyStroke);
		if(o == null)
		{
			// Don't beep if the user presses some
			// key we don't know about unless a
			// prefix is active. Otherwise it will
			// beep when caps lock is pressed, etc.
			if(currentBindings != bindings)
			{
				Toolkit.getDefaultToolkit().beep();
				// F10 should be passed on, but C+e F10
				// shouldn't
				repeatCount = 1;
				setCurrentBindings(bindings);
			}
			if(input != '\0')
				userInput(input);
			else
			{
				// this is retarded. excuse me while I drool
				// and make stupid noises
				switch(keyStroke.key)
				{
				case KeyEvent.VK_NUMPAD0:
				case KeyEvent.VK_NUMPAD1:
				case KeyEvent.VK_NUMPAD2:
				case KeyEvent.VK_NUMPAD3:
				case KeyEvent.VK_NUMPAD4:
				case KeyEvent.VK_NUMPAD5:
				case KeyEvent.VK_NUMPAD6:
				case KeyEvent.VK_NUMPAD7:
				case KeyEvent.VK_NUMPAD8:
				case KeyEvent.VK_NUMPAD9:
				case KeyEvent.VK_MULTIPLY:
				case KeyEvent.VK_ADD:
				/* case KeyEvent.VK_SEPARATOR: */
				case KeyEvent.VK_SUBTRACT:
				case KeyEvent.VK_DECIMAL:
				case KeyEvent.VK_DIVIDE:
					KeyEventWorkaround.numericKeypadKey();
					break;
				}
			}
		}
		else if(o instanceof Hashtable)
		{
			setCurrentBindings((Hashtable)o);
			return true;
		}
		else if(o instanceof String)
		{
			setCurrentBindings(bindings);
			invokeAction((String)o);
			return true;
		}
		else if(o instanceof EditAction)
		{
			setCurrentBindings(bindings);
			invokeAction((EditAction)o);
			return true;
		}
		return false;
	} //}}}
	//{{{ getSymbolicModifierName() method
	/**
	 * Returns a the symbolic modifier name for the specified Java modifier
	 * flag.
	 *
	 * @param mod A modifier constant from <code>InputEvent</code>
	 *
	 * @since jEdit 4.1pre3
	 */
	public static char getSymbolicModifierName(int mod)
	{
		return KeyEventTranslator.getSymbolicModifierName(mod);
	} //}}}
	//{{{ getModifierString() method
	/**
	 * Returns a string containing symbolic modifier names set in the
	 * specified event.
	 *
	 * @param evt The event
	 *
	 * @since jEdit 4.1pre3
	 */
	public static String getModifierString(InputEvent evt)
	{
		return KeyEventTranslator.getModifierString(evt);
	} //}}}
	//{{{ parseKeyStroke() method
	/**
	 * @deprecated We don't use Swing KeyStrokes anymore.
	 */
	public static KeyStroke parseKeyStroke(String keyStroke)
	{
		if(keyStroke == null)
			return null;
		int modifiers = 0;
		int index = keyStroke.indexOf('+');
		if(index != -1)
		{
			for(int i = 0; i < index; i++)
			{
				switch(Character.toUpperCase(keyStroke
					.charAt(i)))
				{
				case 'A':
					modifiers |= KeyEventTranslator.a;
					break;
				case 'C':
					modifiers |= KeyEventTranslator.c;
					break;
				case 'M':
					modifiers |= KeyEventTranslator.m;
					break;
				case 'S':
					modifiers |= KeyEventTranslator.s;
					break;
				}
			}
		}
		String key = keyStroke.substring(index + 1);
		if(key.length() == 1)
		{
			char ch = key.charAt(0);
			if(modifiers == 0)
				return KeyStroke.getKeyStroke(ch);
			else
			{
				return KeyStroke.getKeyStroke(Character.toUpperCase(ch),
					modifiers);
			}
		}
		else if(key.length() == 0)
		{
			Log.log(Log.ERROR,DefaultInputHandler.class,
				""Invalid key stroke: "" + keyStroke);
			return null;
		}
		else
		{
			int ch;
			try
			{
				ch = KeyEvent.class.getField(""VK_"".concat(key))
					.getInt(null);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,DefaultInputHandler.class,
					""Invalid key stroke: ""
					+ keyStroke);
				return null;
			}
			return KeyStroke.getKeyStroke(ch,modifiers);
		}
	} //}}}
	//{{{ Private members
	// Stores prefix name in bindings hashtable
	private static Object PREFIX_STR = ""PREFIX_STR"";
	private Hashtable bindings;
	private Hashtable currentBindings;
	//{{{ setCurrentBindings() method
	private void setCurrentBindings(Hashtable bindings)
	{
		view.getStatus().setMessage((String)bindings.get(PREFIX_STR));
		currentBindings = bindings;
	} //}}}
	//{{{ _addKeyBinding() method
	/**
	 * Adds a key binding to this input handler. The key binding is
	 * a list of white space separated key strokes of the form
	 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,
	 * or S for Shift, and key is either a character (a-z) or a field
	 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)
	 * @param keyBinding The key binding
	 * @param action The action
	 */
	public void _addKeyBinding(String keyBinding, Object action)
	{
		Hashtable current = bindings;
		String prefixStr = null;
		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			String keyCodeStr = st.nextToken();
			if(prefixStr == null)
				prefixStr = keyCodeStr;
			else
				prefixStr = prefixStr + "" "" + keyCodeStr;
			KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(keyCodeStr);
			if(keyStroke == null)
				return;
			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
				{
					Hashtable hash = new Hashtable();
					hash.put(PREFIX_STR,prefixStr);
					o = hash;
					current.put(keyStroke,o);
					current = (Hashtable)o;
				}
			}
			else
				current.put(keyStroke,action);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.DockableWindowContainer,"/*
 * DockableWindowContainer.java - holds dockable windows
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
/**
 * A container for dockable windows. This class should never be used
 * directly.
 * @author Slava Pestov
 * @version $Id: DockableWindowContainer.java,v 1.8 2003/05/07 22:40:00 spestov Exp $
 * @since jEdit 2.6pre3
 */
public interface DockableWindowContainer
{
	void register(DockableWindowManager.Entry entry);
	void remove(DockableWindowManager.Entry entry);
	void unregister(DockableWindowManager.Entry entry);
	void show(DockableWindowManager.Entry entry);
	boolean isVisible(DockableWindowManager.Entry entry);
}
"
org.gjt.sp.jedit.gui.DockableWindowManager,"/*
 * DockableWindowManager.java - manages dockable windows
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
 import bsh.*;
 import com.microstar.xml.*;
 import javax.swing.*;
 import java.awt.event.*;
 import java.awt.*;
 import java.io.*;
 import java.net.URL;
 import java.util.*;
 import org.gjt.sp.jedit.msg.*;
 import org.gjt.sp.jedit.*;
 import org.gjt.sp.util.Log;
//}}}
/**
 * The <code>DockableWindowManager</code> keeps track of dockable windows.
 * Each {@link org.gjt.sp.jedit.View} has an instance of this class.<p>
 *
 * <b>dockables.xml:</b><p>
 *
 * Dockable window definitions are read from <code>dockables.xml</code> files
 * contained inside plugin JARs. A dockable definition file has the following
 * form:
 *
 * <pre>&lt;?xml version=""1.0""?&gt;
 *&lt;!DOCTYPE DOCKABLES SYSTEM ""dockables.dtd""&gt;
 *&lt;DOCKABLES&gt;
 *    &lt;DOCKABLE NAME=""name""&gt;
 *        // Code to create the dockable
 *    &lt;/DOCKABLE&gt;
 *&lt;/DOCKABLES&gt;</pre>
 *
 * More than one <code>&lt;DOCKABLE&gt;<code> tag may be present. The code that
 * creates the dockable can reference any BeanShell built-in variable
 * (see {@link org.gjt.sp.jedit.BeanShell}), along with a variable
 * <code>position</code> whose value is one of
 * {@link #FLOATING}, {@link #TOP}, {@link #LEFT}, {@link #BOTTOM},
 * and {@link #RIGHT}.<p>
 *
 * The following properties must be defined for each dockable window:
 *
 * <ul>
 * <li><code><i>name</i>.title</code> - the string to show in the title bar
 * of the dockable.</li>
 * <li><code><i>name</i>.label</code> - the dockable's menu item label.</li>
 * </ul>
 *
 * A number of actions are automatically created for each dockable window:
 *
 * <ul>
 * <li><code><i>name</i></code> - opens the dockable window.</li>
 * <li><code><i>name</i>-toggle</code> - toggles the dockable window's visibility.</li>
 * <li><code><i>name</i>-float</code> - opens the dockable window in a new
 * floating window.</li>
 * </ul>
 *
 * Note that only the first action needs a <code>label</code> property, the
 * rest have automatically-generated labels.
 *
 * <b>Implementation details:</b><p>
 *
 * When an instance of this class is initialized by the {@link org.gjt.sp.jedit.View}
 * class, it
 * iterates through the list of registered dockable windows (from jEdit itself,
 * and any loaded plugins) and
 * examines options supplied by the user in the <b>Global
 * Options</b> dialog box. Any plugins designated for one of the
 * four docking positions are displayed.<p>
 *
 * To create an instance of a dockable window, the <code>DockableWindowManager</code>
 * finds and executes the BeanShell code extracted from the appropriate
 * <code>dockables.xml</code> file. This code will typically consist of a call
 * to the constructor of the dockable window component. The result of the
 * BeanShell expression, typically a newly constructed component, is placed
 * in a window managed by this class.
 *
 * @see org.gjt.sp.jedit.View#getDockableWindowManager()
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: DockableWindowManager.java,v 1.98 2004/06/09 16:48:40 spestov Exp $
 * @since jEdit 2.6pre3
 */
public class DockableWindowManager extends JPanel implements EBComponent
{
	//{{{ Static part of class
	//{{{ Constants
	/**
	 * Floating position.
	 * @since jEdit 2.6pre3
	 */
	public static final String FLOATING = ""floating"";
	/**
	 * Top position.
	 * @since jEdit 2.6pre3
	 */
	public static final String TOP = ""top"";
	/**
	 * Left position.
	 * @since jEdit 2.6pre3
	 */
	public static final String LEFT = ""left"";
	/**
	 * Bottom position.
	 * @since jEdit 2.6pre3
	 */
	public static final String BOTTOM = ""bottom"";
	/**
	 * Right position.
	 * @since jEdit 2.6pre3
	 */
	public static final String RIGHT = ""right"";
	//}}}
	//{{{ loadDockableWindows() method
	/**
	 * Plugins shouldn't need to call this method.
	 * @since jEdit 4.2pre1
	 */
	public static void loadDockableWindows(PluginJAR plugin, URL uri,
		PluginJAR.PluginCacheEntry cache)
	{
		Reader in = null;
		try
		{
			Log.log(Log.DEBUG,DockableWindowManager.class,
				""Loading dockables from "" + uri);
			DockableListHandler dh = new DockableListHandler(plugin,uri);
			in = new BufferedReader(
				new InputStreamReader(
				uri.openStream()));
			XmlParser parser = new XmlParser();
			parser.setHandler(dh);
			parser.parse(null, null, in);
			if(cache != null)
			{
				cache.cachedDockableNames = dh.getCachedDockableNames();
				cache.cachedDockableActionFlags = dh.getCachedDockableActionFlags();
			}
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,DockableWindowManager.class,uri + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,DockableWindowManager.class,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,DockableWindowManager.class,io);
			}
		}
	} //}}}
	//{{{ unloadDockableWindows() method
	/**
	 * Plugins shouldn't need to call this method.
	 * @since jEdit 4.2pre1
	 */
	public static void unloadDockableWindows(PluginJAR plugin)
	{
		Iterator entries = dockableWindowFactories.entrySet().iterator();
		while(entries.hasNext())
		{
			Map.Entry entry = (Map.Entry)entries.next();
			Factory factory = (Factory)entry.getValue();
			if(factory.plugin == plugin)
				entries.remove();
		}
	} //}}}
	//{{{ cacheDockableWindows() method
	/**
	 * @since jEdit 4.2pre1
	 */
	public static void cacheDockableWindows(PluginJAR plugin,
		String[] name, boolean[] actions)
	{
		for(int i = 0; i < name.length; i++)
		{
			Factory factory = new Factory(plugin,
				name[i],null,actions[i]);
			dockableWindowFactories.put(name[i],factory);
		}
	} //}}}
	//{{{ registerDockableWindow() method
	public static void registerDockableWindow(PluginJAR plugin,
		String name, String code, boolean actions)
	{
		Factory factory = (Factory)dockableWindowFactories.get(name);
		if(factory != null)
		{
			factory.code = code;
			factory.loaded = true;
		}
		else
		{
			factory = new Factory(plugin,name,code,actions);
			dockableWindowFactories.put(name,factory);
		}
	} //}}}
	//{{{ getRegisteredDockableWindows() method
	public static String[] getRegisteredDockableWindows()
	{
		String[] retVal = new String[dockableWindowFactories.size()];
		Iterator entries = dockableWindowFactories.values().iterator();
		int i = 0;
		while(entries.hasNext())
		{
			Factory factory = (Factory)entries.next();
			retVal[i++] = factory.name;
		}
		return retVal;
	} //}}}
	//{{{ DockableListHandler class
	static class DockableListHandler extends HandlerBase
	{
		//{{{ DockableListHandler constructor
		DockableListHandler(PluginJAR plugin, URL uri)
		{
			this.plugin = plugin;
			this.uri = uri;
			stateStack = new Stack();
			actions = true;
			cachedDockableNames = new LinkedList();
			cachedDockableActionFlags = new LinkedList();
		} //}}}
		//{{{ resolveEntity() method
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""dockables.dtd"".equals(systemId))
			{
				// this will result in a slight speed up, since we
				// don't need to read the DTD anyway, as AElfred is
				// non-validating
				return new StringReader(""<!-- -->"");
				/* try
				{
					return new BufferedReader(new InputStreamReader(
						getClass().getResourceAsStream
						(""/org/gjt/sp/jedit/dockables.dtd"")));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,""Error while opening""
						+ "" dockables.dtd:"");
					Log.log(Log.ERROR,this,e);
				} */
			}
			return null;
		} //}}}
		//{{{ attribute() method
		public void attribute(String aname, String value, boolean isSpecified)
		{
			aname = (aname == null) ? null : aname.intern();
			value = (value == null) ? null : value.intern();
			if(aname == ""NAME"")
				dockableName = value;
			else if(aname == ""NO_ACTIONS"")
				actions = (value == ""FALSE"");
		} //}}}
		//{{{ doctypeDecl() method
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""DOCKABLES"".equals(name))
				return;
			Log.log(Log.ERROR,this,uri + "": DOCTYPE must be DOCKABLES"");
		} //}}}
		//{{{ charData() method
		public void charData(char[] c, int off, int len)
		{
			String tag = peekElement();
			String text = new String(c, off, len);
			if (tag == ""DOCKABLE"")
			{
				code = text;
			}
		} //}}}
		//{{{ startElement() method
		public void startElement(String tag)
		{
			tag = pushElement(tag);
		} //}}}
		//{{{ endElement() method
		public void endElement(String name)
		{
			if(name == null)
				return;
			String tag = peekElement();
			if(name.equals(tag))
			{
				if(tag == ""DOCKABLE"")
				{
					registerDockableWindow(plugin,
						dockableName,code,actions);
					cachedDockableNames.add(dockableName);
					cachedDockableActionFlags.add(
						new Boolean(actions));
					// make default be true for the next
					// action
					actions = true;
				}
				popElement();
			}
			else
			{
				// can't happen
				throw new InternalError();
			}
		} //}}}
		//{{{ startDocument() method
		public void startDocument()
		{
			try
			{
				pushElement(null);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		} //}}}
		//{{{ getCachedDockableNames() method
		public String[] getCachedDockableNames()
		{
			return (String[])cachedDockableNames.toArray(new String[cachedDockableNames.size()]);
		} //}}}
		//{{{ getCachedDockableActionFlags() method
		public boolean[] getCachedDockableActionFlags()
		{
			boolean[] returnValue = new boolean[
				cachedDockableActionFlags.size()];
			Iterator iter = cachedDockableActionFlags.iterator();
			int i = 0;
			while(iter.hasNext())
			{
				boolean flag = ((Boolean)iter.next())
					.booleanValue();
				returnValue[i++] = flag;
			}
			return returnValue;
		} //}}}
		//{{{ Private members
		//{{{ Instance variables
		private PluginJAR plugin;
		private URL uri;
		private java.util.List cachedDockableNames;
		private java.util.List cachedDockableActionFlags;
		private String dockableName;
		private String code;
		private boolean actions;
		private Stack stateStack;
		//}}}
		//{{{ pushElement() method
		private String pushElement(String name)
		{
			name = (name == null) ? null : name.intern();
			stateStack.push(name);
			return name;
		} //}}}
		//{{{ peekElement() method
		private String peekElement()
		{
			return (String) stateStack.peek();
		} //}}}
		//{{{ popElement() method
		private String popElement()
		{
			return (String) stateStack.pop();
		} //}}}
		//}}}
	} //}}}
	//{{{ Factory class
	static class Factory
	{
		PluginJAR plugin;
		String name;
		String code;
		boolean loaded;
		//{{{ Factory constructor
		Factory(PluginJAR plugin, String name, String code,
			boolean actions)
		{
			this.plugin = plugin;
			this.name = name;
			this.code = code;
			if(code != null)
				loaded = true;
			if(actions)
			{
				ActionSet actionSet = (plugin == null
					? jEdit.getBuiltInActionSet()
					: plugin.getActionSet());
				actionSet.addAction(new OpenAction(name));
				actionSet.addAction(new ToggleAction(name));
				actionSet.addAction(new FloatAction(name));
				String label = jEdit.getProperty(name
					+ "".label"");
				if(label == null)
					label = ""NO LABEL PROPERTY: "" + name;
				String[] args = { label };
				jEdit.setTemporaryProperty(name + "".label"",
					label);
				jEdit.setTemporaryProperty(name
					+ ""-toggle.label"",
					jEdit.getProperty(
					""view.docking.toggle.label"",args));
				jEdit.setTemporaryProperty(name
					+ ""-toggle.toggle"",""true"");
				jEdit.setTemporaryProperty(name
					+ ""-float.label"",
					jEdit.getProperty(
					""view.docking.float.label"",args));
			}
		} //}}}
		//{{{ load() method
		void load()
		{
			if(loaded)
				return;
			loadDockableWindows(plugin,plugin.getDockablesURI(),null);
		} //}}}
		//{{{ createDockableWindow() method
		JComponent createDockableWindow(View view, String position)
		{
			load();
			if(!loaded)
			{
				Log.log(Log.WARNING,this,""Outdated cache"");
				return null;
			}
			NameSpace nameSpace = new NameSpace(
				BeanShell.getNameSpace(),
				""DockableWindowManager.Factory""
				+ "".createDockableWindow()"");
			try
			{
				nameSpace.setVariable(
					""position"",position);
			}
			catch(UtilEvalError e)
			{
				Log.log(Log.ERROR,this,e);
			}
			JComponent win = (JComponent)BeanShell.eval(view,
				nameSpace,code);
			return win;
		} //}}}
		//{{{ OpenAction class
		static class OpenAction extends EditAction
		{
			private String dockable;
			//{{{ OpenAction constructor
			OpenAction(String name)
			{
				super(name);
				this.dockable = name;
			} //}}}
			//{{{ invoke() method
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.showDockableWindow(dockable);
			} //}}}
			//{{{ getCode() method
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".showDockableWindow(\"""" + dockable + ""\"");"";
			} //}}}
		} //}}}
		//{{{ ToggleAction class
		static class ToggleAction extends EditAction
		{
			private String dockable;
			//{{{ ToggleAction constructor
			ToggleAction(String name)
			{
				super(name + ""-toggle"");
				this.dockable = name;
			} //}}}
			//{{{ invoke() method
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.toggleDockableWindow(dockable);
			} //}}}
			//{{{ isSelected() method
			public boolean isSelected(View view)
			{
				return view.getDockableWindowManager()
					.isDockableWindowVisible(dockable);
			} //}}}
			//{{{ getCode() method
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".toggleDockableWindow(\"""" + dockable + ""\"");"";
			} //}}}
		} //}}}
		//{{{ FloatAction class
		static class FloatAction extends EditAction
		{
			private String dockable;
			//{{{ FloatAction constructor
			FloatAction(String name)
			{
				super(name + ""-float"");
				this.dockable = name;
			} //}}}
			//{{{ invoke() method
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.floatDockableWindow(dockable);
			} //}}}
			//{{{ getCode() method
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".floatDockableWindow(\"""" + dockable + ""\"");"";
			} //}}}
		} //}}}
	} //}}}
	private static HashMap dockableWindowFactories;
	//{{{ Static initializer
	static
	{
		dockableWindowFactories = new HashMap();
	} //}}}
	//}}}
	//{{{ Instance part of class
	//{{{ DockableWindowManager constructor
	/**
	 * Creates a new dockable window manager.
	 * @param view The view
	 * @since jEdit 2.6pre3
	 */
	public DockableWindowManager(View view, View.ViewConfig config)
	{
		setLayout(new DockableLayout());
		this.view = view;
		windows = new Hashtable();
		clones = new ArrayList();
		top = new PanelWindowContainer(this,TOP,config.topPos);
		left = new PanelWindowContainer(this,LEFT,config.leftPos);
		bottom = new PanelWindowContainer(this,BOTTOM,config.bottomPos);
		right = new PanelWindowContainer(this,RIGHT,config.rightPos);
		add(DockableLayout.TOP_BUTTONS,top.buttonPanel);
		add(DockableLayout.LEFT_BUTTONS,left.buttonPanel);
		add(DockableLayout.BOTTOM_BUTTONS,bottom.buttonPanel);
		add(DockableLayout.RIGHT_BUTTONS,right.buttonPanel);
		add(TOP,top.dockablePanel);
		add(LEFT,left.dockablePanel);
		add(BOTTOM,bottom.dockablePanel);
		add(RIGHT,right.dockablePanel);
	} //}}}
	//{{{ init() method
	/**
	 * Initialises dockable window manager. Do not call this method directly.
	 */
	public void init()
	{
		EditBus.addToBus(this);
		Iterator entries = dockableWindowFactories.values().iterator();
		while(entries.hasNext())
			addEntry((Factory)entries.next());
		propertiesChanged();
	} //}}}
	//{{{ getView() method
	/**
	 * Returns this dockable window manager's view.
	 * @since jEdit 4.0pre2
	 */
	public View getView()
	{
		return view;
	} //}}}
	//{{{ floatDockableWindow() method
	/**
	 * Opens a new instance of the specified dockable window in a floating
	 * container.
	 * @param name The dockable window name
	 * @return The new dockable window instance
	 * @since jEdit 4.1pre2
	 */
	public JComponent floatDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return null;
		}
		// create a copy of this dockable window and float it
		Entry newEntry = new Entry(entry.factory,FLOATING);
		newEntry.win = newEntry.factory.createDockableWindow(view,FLOATING);
		if(newEntry.win != null)
		{
			newEntry.container = new FloatingWindowContainer(this,true);
			newEntry.container.register(newEntry);
			newEntry.container.show(newEntry);
		}
		clones.add(newEntry);
		return newEntry.win;
	} //}}}
	//{{{ showDockableWindow() method
	/**
	 * Opens the specified dockable window.
	 * @param name The dockable window name
	 * @since jEdit 2.6pre3
	 */
	public void showDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}
		if(entry.win == null)
		{
			entry.win = entry.factory.createDockableWindow(
				view,entry.position);
		}
		if(entry.win != null)
		{
			if(entry.position.equals(FLOATING)
				&& entry.container == null)
			{
				entry.container = new FloatingWindowContainer(
					this,view.isPlainView());
				entry.container.register(entry);
			}
			entry.container.show(entry);
		}
		else
			/* an error occurred */;
	} //}}}
	//{{{ addDockableWindow() method
	/**
	 * Opens the specified dockable window. As of jEdit 4.0pre1, has the
	 * same effect as calling showDockableWindow().
	 * @param name The dockable window name
	 * @since jEdit 2.6pre3
	 */
	public void addDockableWindow(String name)
	{
		showDockableWindow(name);
	} //}}}
	//{{{ hideDockableWindow() method
	/**
	 * Hides the specified dockable window.
	 * @param name The dockable window name
	 * @since jEdit 2.6pre3
	 */
	public void hideDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}
		if(entry.win == null)
			return;
		entry.container.show(null);
	} //}}}
	//{{{ removeDockableWindow() method
	/**
	 * Hides the specified dockable window. As of jEdit 4.2pre1, has the
	 * same effect as calling hideDockableWindow().
	 * @param name The dockable window name
	 * @since jEdit 4.2pre1
	 */
	public void removeDockableWindow(String name)
	{
		hideDockableWindow(name);
	} //}}}
	//{{{ toggleDockableWindow() method
	/**
	 * Toggles the visibility of the specified dockable window.
	 * @param name The dockable window name
	 */
	public void toggleDockableWindow(String name)
	{
		if(isDockableWindowVisible(name))
			removeDockableWindow(name);
		else
			addDockableWindow(name);
	} //}}}
	//{{{ getDockableWindow() method
	/**
	 * Returns the specified dockable window.
	 *
	 * Note that this method
	 * will return null if the dockable has not been added yet.
	 * Make sure you call {@link #addDockableWindow(String)} first.
	 *
	 * @param name The name of the dockable window
	 * @since jEdit 4.1pre2
	 */
	public JComponent getDockableWindow(String name)
	{
		return getDockable(name);
	} //}}}
	//{{{ getDockable() method
	/**
	 * Returns the specified dockable window.
	 *
	 * Note that this method
	 * will return null if the dockable has not been added yet.
	 * Make sure you call {@link #addDockableWindow(String)} first.
	 *
	 * For historical reasons, this
	 * does the same thing as {@link #getDockableWindow(String)}.
	 *
	 * @param name The name of the dockable window
	 * @since jEdit 4.0pre1
	 */
	public JComponent getDockable(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null || entry.win == null)
			return null;
		else
			return entry.win;
	} //}}}
	//{{{ getDockableTitle() method
	/**
	 * Returns the title of the specified dockable window.
	 * @param name The name of the dockable window.
	 * @since jEdit 4.1pre5
	 */
	public String getDockableTitle(String name)
	{
		String title = jEdit.getProperty(name + "".title"");
		if(title == null)
			return ""NO TITLE PROPERTY: "" + name;
		else
			return title;
	} //}}}
	//{{{ isDockableWindowVisible() method
	/**
	 * Returns if the specified dockable window is visible.
	 * @param name The dockable window name
	 */
	public boolean isDockableWindowVisible(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null || entry.win == null)
			return false;
		else
			return entry.container.isVisible(entry);
	} //}}}
	//{{{ isDockableWindowDocked() method
	/**
	 * Returns if the specified dockable window is docked into the
	 * view.
	 * @param name The dockable's name
	 * @since jEdit 4.0pre2
	 */
	public boolean isDockableWindowDocked(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
			return false;
		else
			return !entry.position.equals(FLOATING);
	} //}}}
	//{{{ closeCurrentArea() method
	/**
	 * Closes the currently focused docking area.
	 * @since jEdit 4.1pre3
	 */
	public void closeCurrentArea()
	{
		// I don't know of any other way to fix this, since invoking this
		// command from a menu results in the focus owner being the menu
		// until the menu goes away.
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				Component comp = view.getFocusOwner();
				while(comp != null)
				{
					//System.err.println(comp.getClass());
					if(comp instanceof PanelWindowContainer
						.DockablePanel)
					{
						PanelWindowContainer container =
							((PanelWindowContainer.DockablePanel)
							comp).getWindowContainer();
						container.show(null);
						return;
					}
					comp = comp.getParent();
				}
				getToolkit().beep();
			}
		});
	} //}}}
	//{{{ close() method
	/**
	 * Called when the view is being closed.
	 * @since jEdit 2.6pre3
	 */
	public void close()
	{
		EditBus.removeFromBus(this);
		Iterator iter = windows.values().iterator();
		while(iter.hasNext())
		{
			Entry entry = (Entry)iter.next();
			if(entry.win != null)
			{
				entry.container.unregister(entry);
			}
		}
		iter = clones.iterator();
		while(iter.hasNext())
		{
			Entry entry = (Entry)iter.next();
			if(entry.win != null)
			{
				entry.container.unregister(entry);
			}
		}
	} //}}}
	//{{{ getTopDockingArea() method
	public PanelWindowContainer getTopDockingArea()
	{
		return top;
	} //}}}
	//{{{ getLeftDockingArea() method
	public PanelWindowContainer getLeftDockingArea()
	{
		return left;
	} //}}}
	//{{{ getBottomDockingArea() method
	public PanelWindowContainer getBottomDockingArea()
	{
		return bottom;
	} //}}}
	//{{{ getRightDockingArea() method
	public PanelWindowContainer getRightDockingArea()
	{
		return right;
	} //}}}
	//{{{ createPopupMenu() method
	public JPopupMenu createPopupMenu(
		final DockableWindowContainer container,
		final String dockable,
		final boolean clone)
	{
		JPopupMenu popup = new JPopupMenu();
		if(dockable == null && container instanceof PanelWindowContainer)
		{
			ActionListener listener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					showDockableWindow(evt.getActionCommand());
				}
			};
			String[] dockables = ((PanelWindowContainer)
				container).getDockables();
			for(int i = 0; i < dockables.length; i++)
			{
				String name = dockables[i];
				JMenuItem item = new JMenuItem(getDockableTitle(name));
				item.setActionCommand(name);
				item.addActionListener(listener);
				popup.add(item);
			}
		}
		else
		{
			JMenuItem caption = new JMenuItem(getDockableTitle(dockable));
			caption.setEnabled(false);
			popup.add(caption);
			popup.addSeparator();
			String currentPos = jEdit.getProperty(dockable + "".dock-position"",FLOATING);
			if(!clone)
			{
				String[] positions = { FLOATING, TOP, LEFT, BOTTOM, RIGHT };
				for(int i = 0; i < positions.length; i++)
				{
					final String pos = positions[i];
					if(pos.equals(currentPos))
						continue;
					JMenuItem moveMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-""
						+ pos));
					moveMenuItem.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent evt)
						{
							jEdit.setProperty(dockable + "".dock-position"",pos);
							EditBus.send(new DockableWindowUpdate(
								DockableWindowManager.this,
								DockableWindowUpdate.PROPERTIES_CHANGED,
								null
							));
							showDockableWindow(dockable);
						}
					});
					popup.add(moveMenuItem);
				}
				popup.addSeparator();
			}
			JMenuItem cloneMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-clone""));
			cloneMenuItem.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					floatDockableWindow(dockable);
				}
			});
			popup.add(cloneMenuItem);
			popup.addSeparator();
			JMenuItem closeMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-close""));
			closeMenuItem.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					if(clone)
						((FloatingWindowContainer)container).dispose();
					else
						removeDockableWindow(dockable);
				}
			});
			popup.add(closeMenuItem);
			if(!(clone || currentPos.equals(FLOATING)))
			{
				JMenuItem undockMenuItem = new JMenuItem(jEdit.getProperty(""view.docking.menu-undock""));
				undockMenuItem.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent evt)
					{
						jEdit.setProperty(dockable + "".dock-position"",FLOATING);
						EditBus.send(new DockableWindowUpdate(
							DockableWindowManager.this,
							DockableWindowUpdate.PROPERTIES_CHANGED,
							null
						));
					}
				});
				popup.add(undockMenuItem);
			}
		}
		return popup;
	} //}}}
	//{{{ paintChildren() method
	public void paintChildren(Graphics g)
	{
		super.paintChildren(g);
		if(resizeRect != null)
		{
			g.setColor(Color.darkGray);
			g.fillRect(resizeRect.x,resizeRect.y,
				resizeRect.width,resizeRect.height);
		}
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof DockableWindowUpdate)
		{
			if(((DockableWindowUpdate)msg).getWhat()
				== DockableWindowUpdate.PROPERTIES_CHANGED)
				propertiesChanged();
		}
		else if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if(pmsg.getWhat() == PluginUpdate.LOADED)
			{
				Iterator iter = dockableWindowFactories
					.values().iterator();
				while(iter.hasNext())
				{
					Factory factory = (Factory)iter.next();
					if(factory.plugin == pmsg.getPluginJAR())
						addEntry(factory);
				}
				propertiesChanged();
			}
			else if(pmsg.isExiting())
			{
				// we don't care
			}
			else if(pmsg.getWhat() == PluginUpdate.DEACTIVATED)
			{
				Iterator iter = getAllPluginEntries(
					pmsg.getPluginJAR(),false);
				while(iter.hasNext())
				{
					Entry entry = (Entry)iter.next();
					if(entry.container != null)
						entry.container.remove(entry);
				}
			}
			else if(pmsg.getWhat() == PluginUpdate.UNLOADED)
			{
				Iterator iter = getAllPluginEntries(
					pmsg.getPluginJAR(),true);
				while(iter.hasNext())
				{
					Entry entry = (Entry)iter.next();
					if(entry.container != null)
					{
						entry.container.unregister(entry);
						entry.win = null;
						entry.container = null;
					}
				}
			}
		}
	} //}}}
	//{{{ Package-private members
	int resizePos;
	Rectangle resizeRect;
	//{{{ setResizePos() method
	void setResizePos(int resizePos, PanelWindowContainer resizing)
	{
		this.resizePos = resizePos;
		if(resizePos < 0)
			resizePos = 0;
		Rectangle newResizeRect = new Rectangle(0,0,
			PanelWindowContainer.SPLITTER_WIDTH - 2,
			PanelWindowContainer.SPLITTER_WIDTH - 2);
		if(resizing == top)
		{
			resizePos = Math.min(resizePos,getHeight()
				- top.buttonPanel.getHeight()
				- bottom.dockablePanel.getHeight()
				- bottom.buttonPanel.getHeight()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = top.dockablePanel.getX() + 1;
			newResizeRect.y = resizePos + top.buttonPanel.getHeight() + 1;
			newResizeRect.width = top.dockablePanel.getWidth() - 2;
		}
		else if(resizing == left)
		{
			resizePos = Math.min(resizePos,getWidth()
				- left.buttonPanel.getWidth()
				- right.dockablePanel.getWidth()
				- right.buttonPanel.getWidth()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = resizePos + left.buttonPanel.getWidth() + 1;
			newResizeRect.y = left.dockablePanel.getY() + 1;
			newResizeRect.height = left.dockablePanel.getHeight() - 2;
		}
		else if(resizing == bottom)
		{
			resizePos = Math.min(resizePos,getHeight()
				- bottom.buttonPanel.getHeight()
				- top.dockablePanel.getHeight()
				- top.buttonPanel.getHeight()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = bottom.dockablePanel.getX() + 1;
			newResizeRect.y = getHeight() - bottom.buttonPanel.getHeight() - resizePos
				- PanelWindowContainer.SPLITTER_WIDTH + 2;
			newResizeRect.width = bottom.dockablePanel.getWidth() - 2;
		}
		else if(resizing == right)
		{
			resizePos = Math.min(resizePos,getWidth()
				- right.buttonPanel.getWidth()
				- left.dockablePanel.getWidth()
				- left.buttonPanel.getWidth()
				- PanelWindowContainer.SPLITTER_WIDTH);
			newResizeRect.x = getWidth() - right.buttonPanel.getWidth() - resizePos
				- PanelWindowContainer.SPLITTER_WIDTH + 1;
			newResizeRect.y = right.dockablePanel.getY() + 1;
			newResizeRect.height = right.dockablePanel.getHeight() - 2;
		}
		Rectangle toRepaint;
		if(resizeRect == null)
			toRepaint = newResizeRect;
		else
			toRepaint = resizeRect.union(newResizeRect);
		resizeRect = newResizeRect;
		repaint(toRepaint);
	} //}}}
	//{{{ finishResizing() method
	void finishResizing()
	{
		resizeRect = null;
		repaint();
	} //}}}
	//}}}
	//{{{ Private members
	private View view;
	private Hashtable windows;
	private boolean alternateLayout;
	private PanelWindowContainer left;
	private PanelWindowContainer right;
	private PanelWindowContainer top;
	private PanelWindowContainer bottom;
	private ArrayList clones;
	//{{{ propertiesChanged() method
	private void propertiesChanged()
	{
		if(view.isPlainView())
			return;
		alternateLayout = jEdit.getBooleanProperty(""view.docking.alternateLayout"");
		String[] windowList = getRegisteredDockableWindows();
		for(int i = 0; i < windowList.length; i++)
		{
			String dockable = windowList[i];
			Entry entry = (Entry)windows.get(dockable);
			String newPosition = jEdit.getProperty(dockable
				+ "".dock-position"",FLOATING);
			if(newPosition.equals(entry.position))
			{
				continue;
			}
			entry.position = newPosition;
			if(entry.container != null)
			{
				entry.container.unregister(entry);
				entry.container = null;
				entry.win = null;
			}
			if(newPosition.equals(FLOATING))
				/* do nothing */;
			else
			{
				if(newPosition.equals(TOP))
					entry.container = top;
				else if(newPosition.equals(LEFT))
					entry.container = left;
				else if(newPosition.equals(BOTTOM))
					entry.container = bottom;
				else if(newPosition.equals(RIGHT))
					entry.container = right;
				else
				{
					Log.log(Log.WARNING,this,
						""Unknown position: ""
						+ newPosition);
					continue;
				}
				entry.container.register(entry);
			}
		}
		top.sortDockables();
		left.sortDockables();
		bottom.sortDockables();
		right.sortDockables();
		revalidate();
		repaint();
	} //}}}
	//{{{ addEntry() method
	private void addEntry(Factory factory)
	{
		Entry e;
		if(view.isPlainView())
		{
			// don't show menu items to dock into a plain view
			e = new Entry(factory,FLOATING);
		}
		else
		{
			e = new Entry(factory);
			if(e.position.equals(FLOATING))
				/* nothing to do */;
			else if(e.position.equals(TOP))
				e.container = top;
			else if(e.position.equals(LEFT))
				e.container = left;
			else if(e.position.equals(BOTTOM))
				e.container = bottom;
			else if(e.position.equals(RIGHT))
				e.container = right;
			else
			{
				Log.log(Log.WARNING,this,
					""Unknown position: ""
					+ e.position);
			}
			if(e.container != null)
				e.container.register(e);
		}
		windows.put(factory.name,e);
	} //}}}
	//{{{ getAllPluginEntries() method
	/**
	 * If remove is false, only remove from clones list, otherwise remove
	 * from both entries and clones.
	 */
	private Iterator getAllPluginEntries(PluginJAR plugin, boolean remove)
	{
		java.util.List returnValue = new LinkedList();
		Iterator iter = windows.values().iterator();
		while(iter.hasNext())
		{
			Entry entry = (Entry)iter.next();
			if(entry.factory.plugin == plugin)
			{
				returnValue.add(entry);
				if(remove)
					iter.remove();
			}
		}
		iter = clones.iterator();
		while(iter.hasNext())
		{
			Entry entry = (Entry)iter.next();
			if(entry.factory.plugin == plugin)
			{
				returnValue.add(entry);
				iter.remove();
			}
		}
		return returnValue.iterator();
	} //}}}
	//}}}
	//}}}
	//{{{ DockableLayout class
	public class DockableLayout implements LayoutManager2
	{
		// for backwards compatibility with plugins that fiddle with
		// jEdit's UI layout
		static final String CENTER = BorderLayout.CENTER;
		public static final String TOP_TOOLBARS = ""top-toolbars"";
		public static final String BOTTOM_TOOLBARS = ""bottom-toolbars"";
		static final String TOP_BUTTONS = ""top-buttons"";
		static final String LEFT_BUTTONS = ""left-buttons"";
		static final String BOTTOM_BUTTONS = ""bottom-buttons"";
		static final String RIGHT_BUTTONS = ""right-buttons"";
		Component topToolbars, bottomToolbars;
		Component center;
		Component top, left, bottom, right;
		Component topButtons, leftButtons, bottomButtons, rightButtons;
		//{{{ addLayoutComponent() method
		public void addLayoutComponent(String name, Component comp)
		{
			addLayoutComponent(comp,name);
		} //}}}
		//{{{ addLayoutComponent() method
		public void addLayoutComponent(Component comp, Object cons)
		{
			if(cons == null || CENTER.equals(cons))
				center = comp;
			else if(TOP_TOOLBARS.equals(cons))
				topToolbars = comp;
			else if(BOTTOM_TOOLBARS.equals(cons))
				bottomToolbars = comp;
			else if(TOP.equals(cons))
				top = comp;
			else if(LEFT.equals(cons))
				left = comp;
			else if(BOTTOM.equals(cons))
				bottom = comp;
			else if(RIGHT.equals(cons))
				right = comp;
			else if(TOP_BUTTONS.equals(cons))
				topButtons = comp;
			else if(LEFT_BUTTONS.equals(cons))
				leftButtons = comp;
			else if(BOTTOM_BUTTONS.equals(cons))
				bottomButtons = comp;
			else if(RIGHT_BUTTONS.equals(cons))
				rightButtons = comp;
		} //}}}
		//{{{ removeLayoutComponent() method
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			if(comp == topToolbars)
				topToolbars = null;
			if(comp == bottomToolbars)
				bottomToolbars = null;
			{
				// none of the others are ever meant to be
				// removed. retarded, eh? this needs to be
				// fixed eventually, for plugins might
				// want to do weird stuff to jEdit's UI
			}
		} //}}}
		//{{{ preferredLayoutSize() method
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension prefSize = new Dimension(0,0);
			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();
			Dimension _topButtons = topButtons.getPreferredSize();
			Dimension _leftButtons = leftButtons.getPreferredSize();
			Dimension _bottomButtons = bottomButtons.getPreferredSize();
			Dimension _rightButtons = rightButtons.getPreferredSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getPreferredSize());
			Dimension _topToolbars = (topToolbars == null
				? new Dimension(0,0)
				: topToolbars.getPreferredSize());
			Dimension _bottomToolbars = (bottomToolbars == null
				? new Dimension(0,0)
				: bottomToolbars.getPreferredSize());
			prefSize.height = _top.height + _bottom.height + _center.height
				+ _topButtons.height + _bottomButtons.height
				+ _topToolbars.height + _bottomToolbars.height;
			prefSize.width = _left.width + _right.width
				+ Math.max(_center.width,
				Math.max(_topToolbars.width,_bottomToolbars.width))
				+ _leftButtons.width + _rightButtons.width;
			return prefSize;
		} //}}}
		//{{{ minimumLayoutSize() method
		public Dimension minimumLayoutSize(Container parent)
		{
			// I'm lazy
			return preferredLayoutSize(parent);
		} //}}}
		//{{{ maximumLayoutSize() method
		public Dimension maximumLayoutSize(Container parent)
		{
			return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);
		} //}}}
		//{{{ layoutContainer() method
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Dimension _topToolbars = (topToolbars == null
				? new Dimension(0,0)
				: topToolbars.getPreferredSize());
			Dimension _bottomToolbars = (bottomToolbars == null
				? new Dimension(0,0)
				: bottomToolbars.getPreferredSize());
			int topButtonHeight = -1;
			int bottomButtonHeight = -1;
			int leftButtonWidth = -1;
			int rightButtonWidth = -1;
			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();
			int topHeight = _top.height;
			int bottomHeight = _bottom.height;
			int leftWidth = _left.width;
			int rightWidth = _right.width;
			boolean topEmpty = ((Container)topButtons)
				.getComponentCount() <= 2;
			boolean leftEmpty = ((Container)leftButtons)
				.getComponentCount() <= 2;
			boolean bottomEmpty = ((Container)bottomButtons)
				.getComponentCount() <= 2;
			boolean rightEmpty = ((Container)rightButtons)
				.getComponentCount() <= 2;
			Dimension closeBoxSize;
			if(((Container)topButtons).getComponentCount() == 0)
				closeBoxSize = new Dimension(0,0);
			else
			{
				closeBoxSize = ((Container)topButtons)
					.getComponent(0).getPreferredSize();
			}
			int closeBoxWidth = Math.max(closeBoxSize.width,
				closeBoxSize.height) + 1;
			if(alternateLayout)
			{
				//{{{ Lay out independent buttons
				int _width = size.width;
				int padding = (leftEmpty&&rightEmpty)
					? 0 : closeBoxWidth;
				topButtonHeight = DockableWindowManager.this.
					top.getWrappedDimension(_width
					- closeBoxWidth * 2);
				topButtons.setBounds(
					padding,
					0,
					size.width - padding * 2,
					topButtonHeight);
				bottomButtonHeight = DockableWindowManager.this.
					bottom.getWrappedDimension(_width);
				bottomButtons.setBounds(
					padding,
					size.height - bottomButtonHeight,
					size.width - padding * 2,
					bottomButtonHeight);
				int _height = size.height
					- topButtonHeight
					- bottomButtonHeight;
				//}}}
				//{{{ Lay out dependent buttons
				leftButtonWidth = DockableWindowManager.this.
					left.getWrappedDimension(_height);
				leftButtons.setBounds(
					0,
					topHeight + topButtonHeight,
					leftButtonWidth,
					_height - topHeight - bottomHeight);
				rightButtonWidth = DockableWindowManager.this.
					right.getWrappedDimension(_height);
				rightButtons.setBounds(
					size.width - rightButtonWidth,
					topHeight + topButtonHeight,
					rightButtonWidth,
					_height - topHeight - bottomHeight);
				//}}}
				int[] dimensions = adjustDockingAreasToFit(
					size,
					topHeight,
					leftWidth,
					bottomHeight,
					rightWidth,
					topButtonHeight,
					leftButtonWidth,
					bottomButtonHeight,
					rightButtonWidth,
					_topToolbars,
					_bottomToolbars);
				topHeight = dimensions[0];
				leftWidth = dimensions[1];
				bottomHeight = dimensions[2];
				rightWidth = dimensions[3];
				//{{{ Lay out docking areas
				top.setBounds(
					0,
					topButtonHeight,
					size.width,
					topHeight);
				bottom.setBounds(
					0,
					size.height
					- bottomHeight
					- bottomButtonHeight,
					size.width,
					bottomHeight);
				left.setBounds(
					leftButtonWidth,
					topButtonHeight + topHeight,
					leftWidth,
					_height - topHeight - bottomHeight);
				right.setBounds(
					_width - rightButtonWidth - rightWidth,
					topButtonHeight + topHeight,
					rightWidth,
					_height - topHeight - bottomHeight); //}}}
			}
			else
			{
				//{{{ Lay out independent buttons
				int _height = size.height;
				int padding = (topEmpty && bottomEmpty
					? 0 : closeBoxWidth);
				leftButtonWidth = DockableWindowManager.this.
					left.getWrappedDimension(_height
					- closeBoxWidth * 2);
				leftButtons.setBounds(
					0,
					padding,
					leftButtonWidth,
					_height - padding * 2);
				rightButtonWidth = DockableWindowManager.this.
					right.getWrappedDimension(_height);
				rightButtons.setBounds(
					size.width - rightButtonWidth,
					padding,
					rightButtonWidth,
					_height - padding * 2);
				int _width = size.width
					- leftButtonWidth
					- rightButtonWidth;
				//}}}
				//{{{ Lay out dependent buttons
				topButtonHeight = DockableWindowManager.this.
					top.getWrappedDimension(_width);
				topButtons.setBounds(
					leftButtonWidth + leftWidth,
					0,
					_width - leftWidth - rightWidth,
					topButtonHeight);
				bottomButtonHeight = DockableWindowManager.this.
					bottom.getWrappedDimension(_width);
				bottomButtons.setBounds(
					leftButtonWidth + leftWidth,
					_height - bottomButtonHeight,
					_width - leftWidth - rightWidth,
					bottomButtonHeight); //}}}
				int[] dimensions = adjustDockingAreasToFit(
					size,
					topHeight,
					leftWidth,
					bottomHeight,
					rightWidth,
					topButtonHeight,
					leftButtonWidth,
					bottomButtonHeight,
					rightButtonWidth,
					_topToolbars,
					_bottomToolbars);
				topHeight = dimensions[0];
				leftWidth = dimensions[1];
				bottomHeight = dimensions[2];
				rightWidth = dimensions[3];
				//{{{ Lay out docking areas
				top.setBounds(
					leftButtonWidth + leftWidth,
					topButtonHeight,
					_width - leftWidth - rightWidth,
					topHeight);
				bottom.setBounds(
					leftButtonWidth + leftWidth,
					size.height - bottomHeight - bottomButtonHeight,
					_width - leftWidth - rightWidth,
					bottomHeight);
				left.setBounds(
					leftButtonWidth,
					0,
					leftWidth,
					_height);
				right.setBounds(
					size.width - rightWidth - rightButtonWidth,
					0,
					rightWidth,
					_height); //}}}
			}
			//{{{ Position tool bars if they are managed by us
			if(topToolbars != null)
			{
				topToolbars.setBounds(
					leftButtonWidth + leftWidth,
					topButtonHeight + topHeight,
					size.width - leftWidth - rightWidth
					- leftButtonWidth - rightButtonWidth,
					_topToolbars.height);
			}
			if(bottomToolbars != null)
			{
				bottomToolbars.setBounds(
					leftButtonWidth + leftWidth,
					size.height - bottomHeight
					- bottomButtonHeight
					- _bottomToolbars.height
					+ topButtonHeight
					+ topHeight,
					size.width - leftWidth - rightWidth
					- leftButtonWidth - rightButtonWidth,
					_bottomToolbars.height);
			} //}}}
			//{{{ Position center (edit pane, or split pane)
			if(center != null)
			{
				center.setBounds(
					leftButtonWidth + leftWidth,
					topButtonHeight + topHeight
					+ _topToolbars.height,
					size.width
					- leftWidth
					- rightWidth
					- leftButtonWidth
					- rightButtonWidth,
					size.height
					- topHeight
					- topButtonHeight
					- bottomHeight
					- bottomButtonHeight
					- _topToolbars.height
					- _bottomToolbars.height);
			} //}}}
		} //}}}
		//{{{ adjustDockingAreasToFit() method
		private int[] adjustDockingAreasToFit(
			Dimension size,
			int topHeight,
			int leftWidth,
			int bottomHeight,
			int rightWidth,
			int topButtonHeight,
			int leftButtonWidth,
			int bottomButtonHeight,
			int rightButtonWidth,
			Dimension _topToolbars,
			Dimension _bottomToolbars)
		{
			int maxTopHeight = size.height - bottomHeight
				- topButtonHeight - bottomButtonHeight
				- _topToolbars.height - _bottomToolbars.height;
			topHeight = Math.min(Math.max(0,maxTopHeight),
				topHeight);
			leftWidth = Math.min(Math.max(0,
				size.width - leftButtonWidth
				- rightButtonWidth - rightWidth),leftWidth);
			int maxBottomHeight = size.height - topHeight
				- topButtonHeight - bottomButtonHeight
				- _topToolbars.height - _bottomToolbars.height;
			bottomHeight = Math.min(Math.max(0,maxBottomHeight),
				bottomHeight);
			rightWidth = Math.min(Math.max(0,
				size.width - leftButtonWidth
				- rightButtonWidth - leftWidth),rightWidth);
			DockableWindowManager.this.top.setDimension(topHeight);
			DockableWindowManager.this.left.setDimension(leftWidth);
			DockableWindowManager.this.bottom.setDimension(bottomHeight);
			DockableWindowManager.this.right.setDimension(rightWidth);
			return new int[] {
				topHeight,
				leftWidth,
				bottomHeight,
				rightWidth
			};
		} //}}}
		//{{{ getLayoutAlignmentX() method
		public float getLayoutAlignmentX(Container target)
		{
			return 0.5f;
		} //}}}
		//{{{ getLayoutAlignmentY() method
		public float getLayoutAlignmentY(Container target)
		{
			return 0.5f;
		} //}}}
		//{{{ invalidateLayout() method
		public void invalidateLayout(Container target) {}
		//}}}
	} //}}}
	//{{{ Entry class
	class Entry
	{
		Factory factory;
		String title;
		String position;
		DockableWindowContainer container;
		// only set if open
		JComponent win;
		// only for docked
		AbstractButton btn;
		//{{{ Entry constructor
		Entry(Factory factory)
		{
			this(factory,jEdit.getProperty(factory.name
				+ "".dock-position"",FLOATING));
		} //}}}
		//{{{ Entry constructor
		Entry(Factory factory, String position)
		{
			this.factory = factory;
			this.position = position;
			// get the title here, not in the factory constructor,
			// since the factory might be created before a plugin's
			// props are loaded
			title = getDockableTitle(factory.name);
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.EditAbbrevDialog,"/*
 * EditAbbrevDialog.java - Displayed when editing abbrevs
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
//}}}
public class EditAbbrevDialog extends JDialog
{
	//{{{ EditAbbrevDialog constructor
	/**
	 * @since jEdit 4.2pre3
	 */
	public EditAbbrevDialog(Frame frame, String abbrev, String expansion,
		Map abbrevs)
	{
		super(frame,jEdit.getProperty(""edit-abbrev.title""),true);
		init(abbrev, expansion, abbrevs);
	} //}}}
	//{{{ EditAbbrevDialog constructor
	public EditAbbrevDialog(Dialog dialog, String abbrev, String expansion,
		Map abbrevs)
	{
		super(dialog,jEdit.getProperty(""edit-abbrev.title""),true);
		init(abbrev, expansion, abbrevs);
	} //}}}
	//{{{ getAbbrev() method
	public String getAbbrev()
	{
		if(!isOK)
			return null;
		return editor.getAbbrev();
	} //}}}
	//{{{ getExpansion() method
	public String getExpansion()
	{
		if(!isOK)
			return null;
		return editor.getExpansion();
	} //}}}
	//{{{ Private members
	private AbbrevEditor editor;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	private String originalAbbrev;
	private Map abbrevs;
	//{{{ init() method
	private void init(String abbrev, String expansion, Map abbrevs)
	{
		this.abbrevs = abbrevs;
		this.originalAbbrev = abbrev;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setExpansion(expansion);
		editor.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.CENTER,editor);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		box.add(ok);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(getParent());
		setVisible(true);
	} //}}}
	//{{{ checkForExistingAbbrev() method
	private boolean checkForExistingAbbrev()
	{
		String abbrev = editor.getAbbrev();
		if(abbrevs.get(abbrev) != null)
		{
			if(abbrev.equals(originalAbbrev))
				return true;
			int result = GUIUtilities.confirm(this,
				""edit-abbrev.duplicate"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			return (result == JOptionPane.YES_OPTION);
		}
		return true;
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(editor.getAbbrev() == null
					|| editor.getAbbrev().length() == 0)
				{
					getToolkit().beep();
					return;
				}
				if(!checkForExistingAbbrev())
					return;
				isOK = true;
			}
			dispose();
		}
	} //}}}
	//{{{ KeyHandler class
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.EnhancedButton,"/*
 * EnhancedButton.java - Tool bar button
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
//}}}
public class EnhancedButton extends RolloverButton
{
	//{{{ EnhancedButton constructor
	public EnhancedButton(Icon icon, String toolTip, String action,
		ActionContext context)
	{
		super(icon);
		this.action = action;
		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(context,action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);
		setToolTipText(toolTip);
	} //}}}
	//{{{ isFocusTraversable() method
	public boolean isFocusTraversable()
	{
		return false;
	} //}}}
	//{{{ Private members
	private String action;
	//}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		boolean msgSet = false;
		public void mouseReleased(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
		public void mouseEntered(MouseEvent evt)
		{
			String msg = jEdit.getProperty(action + "".mouse-over"");
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
				msgSet = true;
			}
		}
		public void mouseExited(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.EnhancedDialog,"/*
 * EnhancedDialog.java - Handles OK/Cancel for you
 * Copyright (C) 1998, 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
/**
 * A dialog box that handles window closing, the ENTER key and the ESCAPE
 * key for you. All you have to do is implement ok() (called when
 * Enter is pressed) and cancel() (called when Escape is pressed, or window
 * is closed).
 * @author Slava Pestov
 * @version $Id: EnhancedDialog.java,v 1.2 2002/10/07 21:13:19 spestov Exp $
 */
public abstract class EnhancedDialog extends JDialog
{
	public EnhancedDialog(Frame parent, String title, boolean modal)
	{
		super(parent,title,modal);
		_init();
	}
	public EnhancedDialog(Dialog parent, String title, boolean modal)
	{
		super(parent,title,modal);
		_init();
	}
	public abstract void ok();
	public abstract void cancel();
	//{{{ Private members
	private void _init() {
		((Container)getLayeredPane()).addContainerListener(
			new ContainerHandler());
		getContentPane().addContainerListener(new ContainerHandler());
		keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		addWindowListener(new WindowHandler());
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
	}
	//}}}
	// protected members
	protected KeyHandler keyHandler;
	// Recursively adds our key listener to sub-components
	class ContainerHandler extends ContainerAdapter
	{
		public void componentAdded(ContainerEvent evt)
		{
			componentAdded(evt.getChild());
		}
		public void componentRemoved(ContainerEvent evt)
		{
			componentRemoved(evt.getChild());
		}
		private void componentAdded(Component comp)
		{
			comp.addKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.addContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentAdded(comps[i]);
				}
			}
		}
		private void componentRemoved(Component comp)
		{
			comp.removeKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.removeContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentRemoved(comps[i]);
				}
			}
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.isConsumed())
				return;
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				// crusty workaround
				Component comp = getFocusOwner();
				while(comp != null)
				{
					if(comp instanceof JComboBox)
					{
						JComboBox combo = (JComboBox)comp;
						if(combo.isEditable())
						{
							Object selected = combo.getEditor().getItem();
							if(selected != null)
								combo.setSelectedItem(selected);
						}
						break;
					}
					comp = comp.getParent();
				}
				ok();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				cancel();
				evt.consume();
			}
		}
	}
	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			cancel();
		}
	}
}
"
org.gjt.sp.jedit.gui.ErrorListCellRenderer,"/*
 * ErrorListCellRenderer.java - Used to list I/O and plugin load errors
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
//}}}
class ErrorListCellRenderer extends JComponent implements ListCellRenderer
{
	//{{{ ErrorListCellRenderer constructor
	ErrorListCellRenderer()
	{
		// fucking GTK look and feel!
		plainFont = new JLabel().getFont();
		//UIManager.getFont(""Label.font"");
		boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		plainFM = getFontMetrics(plainFont);
		boldFM = getFontMetrics(boldFont);
		setBorder(new EmptyBorder(2,2,2,2));
	} //}}}
	//{{{ getListCellRendererComponent() method
	public Component getListCellRendererComponent(JList list, Object value,
		int index, boolean isSelected, boolean cellHasFocus)
	{
		ErrorListDialog.ErrorEntry entry = (ErrorListDialog.ErrorEntry)value;
		this.path = entry.path + "":"";
		this.messages = entry.messages;
		return this;
	} //}}}
	//{{{ getPreferredSize() method
	public Dimension getPreferredSize()
	{
		int width = boldFM.stringWidth(path);
		int height = boldFM.getHeight();
		for(int i = 0; i < messages.length; i++)
		{
			width = Math.max(plainFM.stringWidth(messages[i]),width);
			height += plainFM.getHeight();
		}
		Insets insets = getBorder().getBorderInsets(this);
		width += insets.left + insets.right;
		height += insets.top + insets.bottom;
		return new Dimension(width,height);
	} //}}}
	//{{{ paintComponent() method
	public void paintComponent(Graphics g)
	{
		Insets insets = getBorder().getBorderInsets(this);
		g.setFont(boldFont);
		g.drawString(path,insets.left,insets.top + boldFM.getAscent());
		int y = insets.top + boldFM.getHeight() + 2;
		g.setFont(plainFont);
		for(int i = 0; i < messages.length; i++)
		{
			g.drawString(messages[i],insets.left,y + plainFM.getAscent());
			y += plainFM.getHeight();
		}
	} //}}}
	//{{{ Instance variables
	private String path;
	private String[] messages;
	private Font plainFont;
	private Font boldFont;
	private FontMetrics plainFM;
	private FontMetrics boldFM;
	//}}}
}
"
org.gjt.sp.jedit.gui.ErrorListDialog,"/*
 * ErrorListDialog.java - Used to list I/O and plugin load errors
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import javax.swing.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class ErrorListDialog extends EnhancedDialog
{
	//{{{ ErrorEntry class
	public static class ErrorEntry
	{
		String path;
		String[] messages;
		public ErrorEntry(String path, String messageProp, Object[] args)
		{
			this.path = path;
			String message = jEdit.getProperty(messageProp,args);
			if(message == null)
				message = ""Undefined property: "" + messageProp;
			Log.log(Log.ERROR,this,path + "":"");
			Log.log(Log.ERROR,this,message);
			Vector tokenizedMessage = new Vector();
			int lastIndex = -1;
			for(int i = 0; i < message.length(); i++)
			{
				if(message.charAt(i) == '\n')
				{
					tokenizedMessage.addElement(message.substring(
						lastIndex + 1,i));
					lastIndex = i;
				}
			}
			if(lastIndex != message.length())
			{
				tokenizedMessage.addElement(message.substring(
					lastIndex + 1));
			}
			messages = new String[tokenizedMessage.size()];
			tokenizedMessage.copyInto(messages);
		}
		public boolean equals(Object o)
		{
			if(o instanceof ErrorEntry)
			{
				ErrorEntry e = (ErrorEntry)o;
				return e.path.equals(path);
			}
			else
				return false;
		}
	} //}}}
	//{{{ ErrorListDialog constructor
	public ErrorListDialog(Frame frame, String title, String caption,
		Vector messages, boolean pluginError)
	{
		super(frame,title,!pluginError);
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.errorIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);
		JPanel centerPanel = new JPanel(new BorderLayout());
		JLabel label = new JLabel(caption);
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);
		JList errors = new JList(messages);
		errors.setCellRenderer(new ErrorListCellRenderer());
		errors.setVisibleRowCount(Math.min(messages.size(),4));
		// need this bullshit scroll bar policy for the preferred size
		// hack to work
		JScrollPane scrollPane = new JScrollPane(errors,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
		Dimension size = scrollPane.getPreferredSize();
		size.width = Math.min(size.width,400);
		scrollPane.setPreferredSize(size);
		centerPanel.add(BorderLayout.CENTER,scrollPane);
		content.add(BorderLayout.CENTER,centerPanel);
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		if(pluginError)
		{
			pluginMgr = new JButton(jEdit.getProperty(""error-list.plugin-manager""));
			pluginMgr.addActionListener(new ActionHandler());
			buttons.add(pluginMgr);
			buttons.add(Box.createHorizontalStrut(6));
		}
		buttons.add(ok);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		getRootPane().setDefaultButton(ok);
		pack();
		setLocationRelativeTo(frame);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ Private members
	private JButton ok, pluginMgr;
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				dispose();
			else if(evt.getSource() == pluginMgr)
			{
				org.gjt.sp.jedit.pluginmgr.PluginManager
					.showPluginManager(JOptionPane
					.getFrameForComponent(
					ErrorListDialog.this));
			}
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.FilesChangedDialog,"/*
 * FilesChangedDialog.java - Files changed on disk
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * Files changed on disk dialog.
 *
 * @author Slava Pestov
 * @version $Id: FilesChangedDialog.java,v 1.11 2004/06/28 06:45:27 spestov Exp $
 */
public class FilesChangedDialog extends EnhancedDialog
{
	//{{{ FilesChangedDialog constructor
	public FilesChangedDialog(View view, int[] states,
		boolean alreadyReloaded)
	{
		super(view,jEdit.getProperty(""files-changed.title""),false);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.warningIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);
		JPanel centerPanel = new JPanel(new BorderLayout());
		JLabel label = new JLabel(jEdit.getProperty(""files-changed.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);
		DefaultMutableTreeNode deleted = new DefaultMutableTreeNode(
			jEdit.getProperty(""files-changed.deleted""),true);
		DefaultMutableTreeNode changed = new DefaultMutableTreeNode(
			jEdit.getProperty(""files-changed.changed""
			+ (alreadyReloaded ? ""-auto"" : """")),true);
		DefaultMutableTreeNode changedDirty = new DefaultMutableTreeNode(
			jEdit.getProperty(""files-changed.changed-dirty""
			+ (alreadyReloaded ? ""-auto"" : """")),true);
		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < states.length; i++)
		{
			Buffer buffer = buffers[i];
			DefaultMutableTreeNode addTo;
			switch(states[i])
			{
			case Buffer.FILE_DELETED:
				addTo = deleted;
				break;
			case Buffer.FILE_CHANGED:
				addTo = (buffer.isDirty() ? changedDirty : changed);
				break;
			default:
				addTo = null;
				break;
			}
			if(addTo != null)
			{
				addTo.add(new DefaultMutableTreeNode(
					buffer.getPath()));
			}
		}
		root = new DefaultMutableTreeNode("""",true);
		if(deleted.getChildCount() != 0)
		{
			root.add(deleted);
		}
		if(changed.getChildCount() != 0)
		{
			root.add(changed);
		}
		if(changedDirty.getChildCount() != 0)
		{
			root.add(changedDirty);
		}
		bufferTreeModel = new DefaultTreeModel(root);
		bufferTree = new JTree(bufferTreeModel);
		bufferTree.setRootVisible(false);
		bufferTree.setVisibleRowCount(10);
		bufferTree.setCellRenderer(new Renderer());
		bufferTree.getSelectionModel().addTreeSelectionListener(new TreeHandler());
		bufferTree.getSelectionModel().setSelectionMode(
			TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
		centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferTree));
		content.add(BorderLayout.CENTER,centerPanel);
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		if(!alreadyReloaded)
		{
			selectAll = new JButton(jEdit.getProperty(
				""files-changed.select-all""));
			selectAll.setMnemonic(jEdit.getProperty(
				""files-changed.select-all.mnemonic"").charAt(0));
			buttons.add(selectAll);
			selectAll.addActionListener(new ActionHandler());
			buttons.add(Box.createHorizontalStrut(12));
			reload = new JButton(jEdit.getProperty(
				""files-changed.reload""));
			reload.setMnemonic(jEdit.getProperty(
				""files-changed.reload.mnemonic"").charAt(0));
			buttons.add(reload);
			reload.addActionListener(new ActionHandler());
			buttons.add(Box.createHorizontalStrut(12));
		}
		close = new JButton(jEdit.getProperty(""common.close""));
		getRootPane().setDefaultButton(close);
		buttons.add(close);
		close.addActionListener(new ActionHandler());
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		bufferTree.expandPath(new TreePath(
			new Object[] {
				root,
				deleted
			}));
		bufferTree.expandPath(new TreePath(
			new Object[] {
				root,
				changed
			}));
		bufferTree.expandPath(new TreePath(
			new Object[] {
				root,
				changedDirty
			}));
		GUIUtilities.requestFocus(this,bufferTree);
		updateEnabled();
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ Private members
	private View view;
	private JTree bufferTree;
	private DefaultTreeModel bufferTreeModel;
	private DefaultMutableTreeNode root;
	private JButton selectAll;
	// hack so that 'select all' does not change current buffer
	private boolean selectAllInProgress;
	private JButton reload;
	private JButton close;
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		TreePath[] paths = bufferTree
			.getSelectionPaths();
		boolean enabled = false;
		if(paths != null)
		{
			for(int i = 0; i < paths.length; i++)
			{
				Object[] path = paths[i].getPath();
				if(path.length == 3)
					enabled = true;
			}
		}
		if(reload != null)
			reload.setEnabled(enabled);
	} //}}}
	//{{{ selectAll() method
	private void selectAll()
	{
		selectAllInProgress = true;
		TreeNode[] path = new TreeNode[3];
		path[0] = root;
		for(int i = 0; i < root.getChildCount(); i++)
		{
			DefaultMutableTreeNode node =
				(DefaultMutableTreeNode)
				root.getChildAt(i);
			path[1] = node;
			for(int j = 0; j < node.getChildCount(); j++)
			{
				DefaultMutableTreeNode node2 =
					(DefaultMutableTreeNode)
					node.getChildAt(j);
				path[2] = node2;
				bufferTree.getSelectionModel()
					.addSelectionPath(
					new TreePath(path));
			}
		}
		selectAllInProgress = false;
		updateEnabled();
	} //}}}
	//{{{ reload() method
	private void reload()
	{
		TreePath[] paths = bufferTree
			.getSelectionPaths();
		if(paths == null || paths.length == 0)
			return;
		int row = bufferTree.getRowForPath(paths[0]);
		for(int i = 0; i < paths.length; i++)
		{
			TreePath path = paths[i];
			// is it a header?
			if(path.getPathCount() == 2)
				continue;
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(!(node.getUserObject() instanceof String))
			{
				return;
			}
			Buffer buffer = jEdit.getBuffer(
				(String)node.getUserObject());
			if(buffer == null)
				return;
			buffer.reload(view);
			DefaultMutableTreeNode parent =
				(DefaultMutableTreeNode)
				node.getParent();
			parent.remove(node);
		}
		bufferTreeModel.reload(root);
		// we expand those that are non-empty, and
		// remove those that are empty
		TreeNode[] nodes = { root, null };
		// remove empty category branches
		for(int j = 0; j < root.getChildCount(); j++)
		{
			DefaultMutableTreeNode node
				= (DefaultMutableTreeNode)
				root.getChildAt(j);
			if(root.getChildAt(j)
				.getChildCount() == 0)
			{
				root.remove(j);
				j--;
			}
			else
			{
				nodes[1] = node;
				bufferTree.expandPath(
					new TreePath(nodes));
			}
		}
		if(root.getChildCount() == 0)
			dispose();
		else
		{
			if(row >= bufferTree.getRowCount())
				row = bufferTree.getRowCount() - 1;
			TreePath path = bufferTree.getPathForRow(row);
			if(path.getPathCount() == 2)
			{
				// selected a header; skip to the next row
				bufferTree.setSelectionRow(row + 1);
			}
			else
				bufferTree.setSelectionPath(path);
		}
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
				selectAll();
			else if(source == reload)
				reload();
			else if(source == close)
				dispose();
		}
	} //}}}
	//{{{ TreeHandler class
	class TreeHandler implements TreeSelectionListener
	{
		public void valueChanged(TreeSelectionEvent evt)
		{
			if(selectAllInProgress)
				return;
			updateEnabled();
			TreePath[] paths = bufferTree
				.getSelectionPaths();
			if(paths == null || paths.length == 0)
				return;
			TreePath path = paths[paths.length - 1];
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(node.getUserObject() instanceof String)
			{
				Buffer buffer = jEdit.getBuffer(
					(String)node.getUserObject());
				if(buffer != null)
					view.goToBuffer(buffer);
			}
		}
	} //}}}
	//{{{ Renderer class
	class Renderer extends DefaultTreeCellRenderer
	{
		public Renderer()
		{
			entryFont = UIManager.getFont(""Tree.font"");
			if(entryFont == null)
				entryFont = jEdit.getFontProperty(""metal.secondary.font"");
			groupFont = entryFont.deriveFont(Font.BOLD);
		}
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
			if(node.getParent() == tree.getModel().getRoot())
				this.setFont(groupFont);
			else
				this.setFont(entryFont);
			setIcon(null);
			return this;
		}
		private Font entryFont;
		private Font groupFont;
	} //}}}
}
"
org.gjt.sp.jedit.gui.FloatingWindowContainer,"/*
 * FloatingWindowContainer.java - holds dockable windows
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * A container for dockable windows. This class should never be used
 * directly.
 * @version $Id: FloatingWindowContainer.java,v 1.18 2004/06/28 06:45:27 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class FloatingWindowContainer extends JFrame implements DockableWindowContainer
{
	//{{{ FloatingWindowContainer constructor
	public FloatingWindowContainer(DockableWindowManager dockableWindowManager,
		boolean clone)
	{
		this.dockableWindowManager = dockableWindowManager;
		this.clone = clone;
		setIconImage(GUIUtilities.getPluginIcon());
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		Box caption = new Box(BoxLayout.X_AXIS);
		caption.add(menu = new RolloverButton(GUIUtilities
			.loadIcon(""ToolbarMenu.gif"")));
		menu.addMouseListener(new MouseHandler());
		Box separatorBox = new Box(BoxLayout.Y_AXIS);
		separatorBox.add(Box.createVerticalStrut(3));
		separatorBox.add(new JSeparator(JSeparator.HORIZONTAL));
		separatorBox.add(Box.createVerticalStrut(3));
		caption.add(separatorBox);
		getContentPane().add(BorderLayout.NORTH,caption);
	} //}}}
	//{{{ register() method
	public void register(DockableWindowManager.Entry entry)
	{
		this.entry = entry;
		setTitle(entry.title);
		getContentPane().add(BorderLayout.CENTER,entry.win);
		pack();
		GUIUtilities.loadGeometry(this,entry.factory.name);
		setVisible(true);
	} //}}}
	//{{{ remove() method
	public void remove(DockableWindowManager.Entry entry)
	{
		entry.container = null;
		dispose();
	} //}}}
	//{{{ unregister() method
	public void unregister(DockableWindowManager.Entry entry)
	{
		dispose();
	} //}}}
	//{{{ show() method
	public void show(final DockableWindowManager.Entry entry)
	{
		if(entry == null)
			dispose();
		else
		{
			toFront();
			requestFocus();
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(entry.win instanceof DefaultFocusComponent)
					{
						((DefaultFocusComponent)entry.win)
							.focusOnDefaultComponent();
					}
					else
					{
						entry.win.requestDefaultFocus();
					}
				}
			});
		}
	} //}}}
	//{{{ isVisible() method
	public boolean isVisible(DockableWindowManager.Entry entry)
	{
		return true;
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,entry.factory.name);
		entry.container = null;
		entry.win = null;
		super.dispose();
	} //}}}
	//{{{ getDockableWindowManager() method
	public DockableWindowManager getDockableWindowManager()
	{
		return dockableWindowManager;
	} //}}}
	//{{{ getMinimumSize() method
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} //}}}
	//{{{ Private members
	private DockableWindowManager dockableWindowManager;
	private boolean clone;
	private DockableWindowManager.Entry entry;
	private JButton menu;
	//}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		JPopupMenu popup;
		public void mousePressed(MouseEvent evt)
		{
			if(popup != null && popup.isVisible())
				popup.setVisible(false);
			else
			{
				popup = dockableWindowManager.createPopupMenu(
					FloatingWindowContainer.this,
					entry.factory.name,clone);
				GUIUtilities.showPopupMenu(popup,
					menu,menu.getX(),menu.getY() + menu.getHeight(),
					false);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.FontSelector,"/*
 * FontSelector.java - Font selector
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 * Portions copyright (C) 1999 Jason Ginchereau
 * Portions copyright (C) 2003 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
//{{{ FontSelector class
/**
 * A font chooser widget.
 * @author Slava Pestov
 * @version $Id: FontSelector.java,v 1.8 2004/06/28 06:45:27 spestov Exp $
 */
public class FontSelector extends JButton
{
	//{{{ FontSelector constructor
	/**
	 * Creates a new font selector control.
	 * @param font The font
	 */
	public FontSelector(Font font)
	{
		this(font,false);
	} //}}}
	//{{{ FontSelector constructor
	/**
	 * Creates a new font selector control.
	 * @param font The font
	 * @param antiAlias Is anti-aliasing enabled?
	 * @since jEdit 4.2pre7
	 */
	public FontSelector(Font font, boolean antiAlias)
	{
		setFont(font);
		this.antiAlias = antiAlias;
		updateText();
		setRequestFocusEnabled(false);
		addActionListener(new ActionHandler());
	} //}}}
	//{{{ paintComponent() method
	public void paintComponent(Graphics g)
	{
		setAntiAliasEnabled(g);
		super.paintComponent(g);
	} //}}}
	//{{{ isAntiAliasEnabled() method
	public boolean isAntiAliasEnabled()
	{
		return antiAlias;
	} //}}}
	//{{{ setAntiAliasEnabled() method
	public void setAntiAliasEnabled(boolean antiAlias)
	{
		this.antiAlias = antiAlias;
	} //}}}
	//{{{ updateText() method
	private void updateText()
	{
		Font font = getFont();
		String styleString;
		switch(font.getStyle())
		{
		case Font.PLAIN:
			styleString = jEdit.getProperty(""font-selector.plain"");
			break;
		case Font.BOLD:
			styleString = jEdit.getProperty(""font-selector.bold"");
			break;
		case Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.italic"");
			break;
		case Font.BOLD | Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.bolditalic"");
			break;
		default:
			styleString = ""UNKNOWN!!!???"";
			break;
		}
		setText(font.getName() + "" "" + font.getSize() + "" "" + styleString);
	} //}}}
	//{{{ setAntiAliasEnabled() method
	void setAntiAliasEnabled(Graphics g)
	{
		if (antiAlias)
		{
			Graphics2D g2 = (Graphics2D)g;
			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		}
	} //}}}
	private boolean antiAlias;
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Font font;
			JDialog dialog = GUIUtilities.getParentDialog(FontSelector.this);
			if(dialog == null)
			{
				font = new FontSelectorDialog(
					JOptionPane.getFrameForComponent(
					FontSelector.this),getFont(),
					FontSelector.this)
					.getSelectedFont();
			}
			else
			{
				font = new FontSelectorDialog(dialog,getFont(),
					FontSelector.this)
					.getSelectedFont();
			}
			if(font != null)
			{
				setFont(font);
				updateText();
			}
		}
	} //}}}
} //}}}
//{{{ FontSelectorDialog class
class FontSelectorDialog extends EnhancedDialog
{
	//{{{ FontSelectorDialog constructor
	public FontSelectorDialog(Frame parent, Font font)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		init(font);
	} //}}}
	//{{{ FontSelectorDialog constructor
	public FontSelectorDialog(Dialog parent, Font font)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		init(font);
	} //}}}
	//{{{ FontSelectorDialog constructor
	public FontSelectorDialog(Frame parent, Font font,
		FontSelector fontSelector)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		this.fontSelector = fontSelector;
		init(font);
	} //}}}
	//{{{ FontSelectorDialog constructor
	public FontSelectorDialog(Dialog parent, Font font,
		FontSelector fontSelector)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		this.fontSelector = fontSelector;
		init(font);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		isOK = true;
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ getSelectedFont() method
	public Font getSelectedFont()
	{
		if(!isOK)
			return null;
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}
		return new Font(familyField.getText(),styleList
			.getSelectedIndex(),size);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private FontSelector fontSelector;
	private boolean isOK;
	private JTextField familyField;
	private JList familyList;
	private JTextField sizeField;
	private JList sizeList;
	private JTextField styleField;
	private JList styleList;
	private JLabel preview;
	private JButton ok;
	private JButton cancel;
	//}}}
	/**
	 * For some reason the default Java fonts show up in the
	 * list with .bold, .bolditalic, and .italic extensions.
	 */
	private static final String[] HIDEFONTS = {
		"".bold"",
		"".italic""
	};
	//{{{ init() method
	private void init(Font font)
	{
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel listPanel = new JPanel(new GridLayout(1,3,6,6));
		String[] fonts;
		try
		{
			fonts = getFontList();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Broken Java implementation!"");
			/* Log.log(Log.ERROR,this,""Using deprecated Toolkit.getFontList()""); */
			Log.log(Log.ERROR,this,e);
			/* fonts = getToolkit().getFontList(); */
			fonts = new String[] { ""Broken Java implementation!"" };
		}
		JPanel familyPanel = createTextFieldAndListPanel(
			""font-selector.family"",
			familyField = new JTextField(),
			familyList = new JList(fonts));
		listPanel.add(familyPanel);
		String[] sizes = { ""9"", ""10"", ""12"", ""14"", ""16"", ""18"", ""24"" };
		JPanel sizePanel = createTextFieldAndListPanel(
			""font-selector.size"",
			sizeField = new JTextField(),
			sizeList = new JList(sizes));
		listPanel.add(sizePanel);
		String[] styles = {
			jEdit.getProperty(""font-selector.plain""),
			jEdit.getProperty(""font-selector.bold""),
			jEdit.getProperty(""font-selector.italic""),
			jEdit.getProperty(""font-selector.bolditalic"")
		};
		JPanel stylePanel = createTextFieldAndListPanel(
			""font-selector.style"",
			styleField = new JTextField(),
			styleList = new JList(styles));
		styleField.setEditable(false);
		listPanel.add(stylePanel);
		familyList.setSelectedValue(font.getFamily(),true);
		familyField.setText(font.getFamily());
		sizeList.setSelectedValue(String.valueOf(font.getSize()),true);
		sizeField.setText(String.valueOf(font.getSize()));
		styleList.setSelectedIndex(font.getStyle());
		styleField.setText((String)styleList.getSelectedValue());
		ListHandler listHandler = new ListHandler();
		familyList.addListSelectionListener(listHandler);
		sizeList.addListSelectionListener(listHandler);
		styleList.addListSelectionListener(listHandler);
		content.add(BorderLayout.NORTH,listPanel);
		preview = new JLabel(jEdit.getProperty(""font-selector.long-text"")) {
			public void paintComponent(Graphics g)
			{
				if(fontSelector != null)
					fontSelector.setAntiAliasEnabled(g);
				super.paintComponent(g);
			}
		};
		preview.setBorder(new TitledBorder(jEdit.getProperty(
			""font-selector.preview"")));
		updatePreview();
		Dimension prefSize = preview.getPreferredSize();
		prefSize.height = 50;
		preview.setPreferredSize(prefSize);
		content.add(BorderLayout.CENTER,preview);
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		pack();
		setLocationRelativeTo(getParent());
		setVisible(true);
	} //}}}
	//{{{ getFontList() method
	private String[] getFontList()
	{
		String[] nameArray = GraphicsEnvironment
			.getLocalGraphicsEnvironment()
			.getAvailableFontFamilyNames();
		Vector nameVector = new Vector(nameArray.length);
		for(int i = 0, j; i < nameArray.length; i++)
		{
			for(j = 0; j < HIDEFONTS.length; j++)
			{
				if(nameArray[i].indexOf(HIDEFONTS[j]) >= 0)
					break;
			}
			if(j == HIDEFONTS.length)
				nameVector.addElement(nameArray[i]);
		}
		String[] _array = new String[nameVector.size()];
		nameVector.copyInto(_array);
		return _array;
	} //}}}
	//{{{ createTextFieldAndListPanel() method
	private JPanel createTextFieldAndListPanel(String label,
		JTextField textField, JList list)
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 1.0f;
		JLabel _label = new JLabel(jEdit.getProperty(label));
		layout.setConstraints(_label,cons);
		panel.add(_label);
		cons.gridy = 1;
		Component vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);
		cons.gridy = 2;
		layout.setConstraints(textField,cons);
		panel.add(textField);
		cons.gridy = 3;
		vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);
		cons.gridy = 4;
		cons.gridheight = GridBagConstraints.REMAINDER;
		cons.weighty = 1.0f;
		JScrollPane scroller = new JScrollPane(list);
		layout.setConstraints(scroller,cons);
		panel.add(scroller);
		return panel;
	} //}}}
	//{{{ updatePreview() method
	private void updatePreview()
	{
		String family = familyField.getText();
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}
		int style = styleList.getSelectedIndex();
		preview.setFont(new Font(family,style,size));
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	} //}}}
	//{{{ ListHandler class
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object source = evt.getSource();
			if(source == familyList)
			{
				String family = (String)familyList.getSelectedValue();
				if(family != null)
					familyField.setText(family);
			}
			else if(source == sizeList)
			{
				String size = (String)sizeList.getSelectedValue();
				if(size != null)
					sizeField.setText(size);
			}
			else if(source == styleList)
			{
				String style = (String)styleList.getSelectedValue();
				if(style != null)
					styleField.setText(style);
			}
			updatePreview();
		}
	} //}}}
} //}}}
"
org.gjt.sp.jedit.gui.GrabKeyDialog,"/*
 * GrabKeyDialog.java - Grabs keys from the keyboard
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.lang.reflect.Field;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * A dialog for getting shortcut keys.
 */
public class GrabKeyDialog extends JDialog
{
	//{{{ toString() method
	public static String toString(KeyEvent evt)
	{
		String id;
		switch(evt.getID())
		{
		case KeyEvent.KEY_PRESSED:
			id = ""KEY_PRESSED"";
			break;
		case KeyEvent.KEY_RELEASED:
			id = ""KEY_RELEASED"";
			break;
		case KeyEvent.KEY_TYPED:
			id = ""KEY_TYPED"";
			break;
		default:
			id = ""unknown type"";
			break;
		}
		return id + "",keyCode=0x""
			+ Integer.toString(evt.getKeyCode(),16)
			+ "",keyChar=0x""
			+ Integer.toString(evt.getKeyChar(),16)
			+ "",modifiers=0x""
			+ Integer.toString(evt.getModifiers(),16);
	} //}}}
	//{{{ GrabKeyDialog constructor
	/**
	 * Create and show a new modal dialog.
	 *
	 * @param  parent  center dialog on this component.
	 * @param  binding  the action/macro that should get a binding.
	 * @param  allBindings  all other key bindings.
	 * @param  debugBuffer  debug info will be dumped to this buffer
	 * (may be null)
	 * @since jEdit 4.1pre7
	 */
	public GrabKeyDialog(Dialog parent, KeyBinding binding,
		Vector allBindings, Buffer debugBuffer)
	{
		super(parent,jEdit.getProperty(""grab-key.title""),true);
		init(binding,allBindings,debugBuffer);
	} //}}}
	//{{{ GrabKeyDialog constructor
	/**
	 * Create and show a new modal dialog.
	 *
	 * @param  parent  center dialog on this component.
	 * @param  binding  the action/macro that should get a binding.
	 * @param  allBindings  all other key bindings.
	 * @param  debugBuffer  debug info will be dumped to this buffer
	 * (may be null)
	 * @since jEdit 4.1pre7
	 */
	public GrabKeyDialog(Frame parent, KeyBinding binding,
		Vector allBindings, Buffer debugBuffer)
	{
		super(parent,jEdit.getProperty(""grab-key.title""),true);
		init(binding,allBindings,debugBuffer);
	} //}}}
	//{{{ getShortcut() method
	/**
	 * Returns the shortcut, or null if the current shortcut should be
	 * removed or the dialog either has been cancelled. Use isOK()
	 * to determine if the latter is true.
	 */
	public String getShortcut()
	{
		if(isOK)
			return shortcut.getText();
		else
			return null;
	} //}}}
	//{{{ isOK() method
	/**
	 * Returns true, if the dialog has not been cancelled.
	 * @since jEdit 3.2pre9
	 */
	public boolean isOK()
	{
		return isOK;
	} //}}}
	//{{{ isManagingFocus() method
	/**
	 * Returns if this component can be traversed by pressing the
	 * Tab key. This returns false.
	 */
	public boolean isManagingFocus()
	{
		return false;
	} //}}}
	//{{{ getFocusTraversalKeysEnabled() method
	/**
	 * Makes the tab key work in Java 1.4.
	 * @since jEdit 3.2pre4
	 */
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} //}}}
	//{{{ processKeyEvent() method
	protected void processKeyEvent(KeyEvent evt)
	{
		shortcut.processKeyEvent(evt);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private InputPane shortcut; // this is a bad hack
	private JLabel assignedTo;
	private JButton ok;
	private JButton remove;
	private JButton cancel;
	private JButton clear;
	private boolean isOK;
	private KeyBinding binding;
	private Vector allBindings;
	private Buffer debugBuffer;
	//}}}
	//{{{ init() method
	private void init(KeyBinding binding, Vector allBindings, Buffer debugBuffer)
	{
		this.binding = binding;
		this.allBindings = allBindings;
		this.debugBuffer = debugBuffer;
		enableEvents(AWTEvent.KEY_EVENT_MASK);
		// create a panel with a BoxLayout. Can't use Box here
		// because Box doesn't have setBorder().
		JPanel content = new JPanel(new GridLayout(0,1,0,6))
		{
			/**
			 * Returns if this component can be traversed by pressing the
			 * Tab key. This returns false.
			 */
			public boolean isManagingFocus()
			{
				return false;
			}
			/**
			 * Makes the tab key work in Java 1.4.
			 * @since jEdit 3.2pre4
			 */
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		};
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel label = new JLabel(
			debugBuffer == null ? jEdit.getProperty(
			""grab-key.caption"",new String[] { binding.label })
			: jEdit.getProperty(""grab-key.keyboard-test""));
		Box input = Box.createHorizontalBox();
		shortcut = new InputPane();
		input.add(shortcut);
		input.add(Box.createHorizontalStrut(12));
		clear = new JButton(jEdit.getProperty(""grab-key.clear""));
		clear.addActionListener(new ActionHandler());
		input.add(clear);
		assignedTo = new JLabel();
		if(debugBuffer == null)
			updateAssignedTo(null);
		Box buttons = Box.createHorizontalBox();
		buttons.add(Box.createGlue());
		if(debugBuffer == null)
		{
			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(new ActionHandler());
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(12));
			if(binding.isAssigned()) {
				// show ""remove"" button
				remove = new JButton(jEdit.getProperty(""grab-key.remove""));
				remove.addActionListener(new ActionHandler());
				buttons.add(remove);
				buttons.add(Box.createHorizontalStrut(12));
			}
		}
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(label);
		content.add(input);
		if(debugBuffer == null)
			content.add(assignedTo);
		content.add(buttons);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(getParent());
		setResizable(false);
		setVisible(true);
	} //}}}
	//{{{ getSymbolicName() method
	private String getSymbolicName(int keyCode)
	{
		if(keyCode == KeyEvent.VK_UNDEFINED)
			return null;
		/* else if(keyCode == KeyEvent.VK_OPEN_BRACKET)
			return ""["";
		else if(keyCode == KeyEvent.VK_CLOSE_BRACKET)
			return ""]""; */
		if(keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
			return String.valueOf(Character.toLowerCase((char)keyCode));
		try
		{
			Field[] fields = KeyEvent.class.getFields();
			for(int i = 0; i < fields.length; i++)
			{
				Field field = fields[i];
				String name = field.getName();
				if(name.startsWith(""VK_"")
					&& field.getInt(null) == keyCode)
				{
					return name.substring(3);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
		return null;
	} //}}}
	//{{{ updateAssignedTo() method
	private void updateAssignedTo(String shortcut)
	{
		String text = jEdit.getProperty(""grab-key.assigned-to.none"");
		KeyBinding kb = getKeyBinding(shortcut);
		if(kb != null)
			if(kb.isPrefix)
				text = jEdit.getProperty(
					""grab-key.assigned-to.prefix"",
					new String[] { shortcut });
			else
				text = kb.label;
		if(ok != null)
			ok.setEnabled(kb == null || !kb.isPrefix);
		assignedTo.setText(
			jEdit.getProperty(""grab-key.assigned-to"",
				new String[] { text }));
	} //}}}
	//{{{ getKeyBinding() method
	private KeyBinding getKeyBinding(String shortcut)
	{
		if(shortcut == null || shortcut.length() == 0)
			return null;
		String spacedShortcut = shortcut + "" "";
		Enumeration e = allBindings.elements();
		while(e.hasMoreElements())
		{
			KeyBinding kb = (KeyBinding)e.nextElement();
			if(!kb.isAssigned())
				continue;
			String spacedKbShortcut = kb.shortcut + "" "";
			// eg, trying to bind C+n C+p if C+n already bound
			if(spacedShortcut.startsWith(spacedKbShortcut))
				return kb;
			// eg, trying to bind C+e if C+e is a prefix
			if(spacedKbShortcut.startsWith(spacedShortcut))
			{
				// create a temporary (synthetic) prefix
				// KeyBinding, that won't be saved
				return new KeyBinding(kb.name,kb.label,
					shortcut,true);
			}
		}
		return null;
	} //}}}
	//}}}
	//{{{ KeyBinding class
	/**
	 * A jEdit action or macro with its two possible shortcuts.
	 * @since jEdit 3.2pre8
	 */
	public static class KeyBinding
	{
		public KeyBinding(String name, String label,
			String shortcut, boolean isPrefix)
		{
			this.name = name;
			this.label = label;
			this.shortcut = shortcut;
			this.isPrefix = isPrefix;
		}
		public String name;
		public String label;
		public String shortcut;
		public boolean isPrefix;
		public boolean isAssigned()
		{
			return shortcut != null && shortcut.length() > 0;
		}
	} //}}}
	//{{{ InputPane class
	class InputPane extends JTextField
	{
		//{{{ getFocusTraversalKeysEnabled() method
		/**
		 * Makes the tab key work in Java 1.4.
		 * @since jEdit 3.2pre4
		 */
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		} //}}}
		//{{{ processKeyEvent() method
		protected void processKeyEvent(KeyEvent _evt)
		{
			KeyEvent evt = KeyEventWorkaround.processKeyEvent(_evt);
			if(debugBuffer != null)
			{
				debugBuffer.insert(debugBuffer.getLength(),
					""Event "" + GrabKeyDialog.toString(_evt)
					+ (evt == null ? "" filtered\n""
					: "" passed\n""));
			}
			if(evt == null)
				return;
			evt.consume();
			KeyEventTranslator.Key key = KeyEventTranslator
				.translateKeyEvent(evt);
			if(key == null)
				return;
			if(debugBuffer != null)
			{
				debugBuffer.insert(debugBuffer.getLength(),
					""==> Translated to "" + key + ""\n"");
			}
			StringBuffer keyString = new StringBuffer(getText());
			if(getDocument().getLength() != 0)
				keyString.append(' ');
			if(key.modifiers != null)
				keyString.append(key.modifiers).append('+');
			if(key.input == ' ')
				keyString.append(""SPACE"");
			else if(key.input != '\0')
				keyString.append(key.input);
			else
			{
				String symbolicName = getSymbolicName(key.key);
				if(symbolicName == null)
					return;
				keyString.append(symbolicName);
			}
			setText(keyString.toString());
			if(debugBuffer == null)
				updateAssignedTo(keyString.toString());
		} //}}}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(canClose())
					dispose();
			}
			else if(evt.getSource() == remove)
			{
				shortcut.setText(null);
				isOK = true;
				dispose();
			}
			else if(evt.getSource() == cancel)
				dispose();
			else if(evt.getSource() == clear)
			{
				shortcut.setText(null);
				if(debugBuffer == null)
					updateAssignedTo(null);
				shortcut.requestFocus();
			}
		} //}}}
		//{{{ canClose() method
		private boolean canClose()
		{
			String shortcutString = shortcut.getText();
			if(shortcutString.length() == 0
				&& binding.isAssigned())
			{
				// ask whether to remove the old shortcut
				int answer = GUIUtilities.confirm(
					GrabKeyDialog.this,
					""grab-key.remove-ask"",
					null,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.QUESTION_MESSAGE);
				if(answer == JOptionPane.YES_OPTION)
				{
					shortcut.setText(null);
					isOK = true;
				}
				else
					return false;
			}
			// check whether this shortcut already exists
			KeyBinding other = getKeyBinding(shortcutString);
			if(other == null || other == binding)
			{
				isOK = true;
				return true;
			}
			// check whether the other shortcut is the alt. shortcut
			if(other.name == binding.name)
			{
				// we don't need two identical shortcuts
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.duplicate-alt-shortcut"",
					null);
				return false;
			}
			// check whether shortcut is a prefix to others
			if(other.isPrefix)
			{
				// can't override prefix shortcuts
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.prefix-shortcut"",
					null);
				return false;
			}
			// ask whether to override that other shortcut
			int answer = GUIUtilities.confirm(GrabKeyDialog.this,
				""grab-key.duplicate-shortcut"",
				new Object[] { other.label },
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(answer == JOptionPane.YES_OPTION)
			{
				if(other.shortcut != null
					&& shortcutString.startsWith(other.shortcut))
				{
					other.shortcut = null;
				}
				isOK = true;
				return true;
			}
			else
				return false;
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.HistoryModel,"/*
 * HistoryModel.java - History list model
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.AbstractListModel;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.Log;
//}}}
/**
 * A history list. One history list can be used by several history text
 * fields. Note that the list model implementation is incomplete; no events
 * are fired when the history model changes.
 * @author Slava Pestov
 * @version $Id: HistoryModel.java,v 1.17 2004/05/29 01:55:25 spestov Exp $
 */
public class HistoryModel extends AbstractListModel
{
	//{{{ HistoryModel constructor
	/**
	 * Creates a new history list. Calling this is normally not
	 * necessary.
	 */
	public HistoryModel(String name)
	{
		this.name = name;
		data = new Vector(max);
	} //}}}
	//{{{ addItem() method
	/**
	 * Adds an item to the end of this history list, trimming the list
	 * to the maximum number of items if necessary.
	 * @param text The item
	 */
	public void addItem(String text)
	{
		if(text == null || text.length() == 0)
			return;
		modified = true;
		int index = data.indexOf(text);
		if(index != -1)
			data.removeElementAt(index);
		data.insertElementAt(text,0);
		while(getSize() > max)
			data.removeElementAt(data.size() - 1);
	} //}}}
	//{{{ getItem() method
	/**
	 * Returns an item from the history list.
	 * @param index The index
	 */
	public String getItem(int index)
	{
		return (String)data.elementAt(index);
	} //}}}
	//{{{ getElementAt() method
	/**
	 * Returns an item from the history list. This method returns the
	 * same thing as {@link #getItem(int)} and only exists so that
	 * <code>HistoryModel</code> instances can be used as list models.
	 * @param index The index
	 * @since jEdit 4.2pre2
	 */
	public Object getElementAt(int index)
	{
		return getItem(index);
	} //}}}
	//{{{ clear() method
	/**
	 * Removes all entries from this history model.
	 * @since jEdit 4.2pre2
	 */
	public void clear()
	{
		modified = true;
		data.removeAllElements();
	} //}}}
	//{{{ getSize() method
	/**
	 * Returns the number of elements in this history list.
	 */
	public int getSize()
	{
		return data.size();
	} //}}}
	//{{{ getName() method
	/**
	 * Returns the name of this history list. This can be passed
	 * to the HistoryTextField constructor.
	 */
	public String getName()
	{
		return name;
	} //}}}
	//{{{ getModel() method
	/**
	 * Returns a named model. If the specified model does not
	 * already exist, it will be created.
	 * @param name The model name
	 */
	public static HistoryModel getModel(String name)
	{
		if(models == null)
			models = new Hashtable();
		HistoryModel model = (HistoryModel)models.get(name);
		if(model == null)
		{
			model = new HistoryModel(name);
			models.put(name,model);
		}
		return model;
	} //}}}
	//{{{ loadHistory() method
	public static void loadHistory()
	{
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			return;
		history = new File(MiscUtilities.constructPath(
			settingsDirectory,""history""));
		if(!history.exists())
			return;
		historyModTime = history.lastModified();
		Log.log(Log.MESSAGE,HistoryModel.class,""Loading history"");
		if(models == null)
			models = new Hashtable();
		BufferedReader in = null;
		try
		{
			in = new BufferedReader(new FileReader(history));
			HistoryModel currentModel = null;
			String line;
			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""["") && line.endsWith(""]""))
				{
					if(currentModel != null)
					{
						models.put(currentModel.getName(),
							currentModel);
					}
					String modelName = MiscUtilities
						.escapesToChars(line.substring(
						1,line.length() - 1));
					currentModel = new HistoryModel(
						modelName);
				}
				else if(currentModel == null)
				{
					throw new IOException(""History data starts""
						+ "" before model name"");
				}
				else
				{
					currentModel.data.addElement(MiscUtilities
						.escapesToChars(line));
				}
			}
			if(currentModel != null)
			{
				models.put(currentModel.getName(),currentModel);
			}
		}
		catch(FileNotFoundException fnf)
		{
			//Log.log(Log.DEBUG,HistoryModel.class,fnf);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
			}
		}
	} //}}}
	//{{{ saveHistory() method
	public static void saveHistory()
	{
		if(!modified)
			return;
		Log.log(Log.MESSAGE,HistoryModel.class,""Saving history"");
		File file1 = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(), ""#history#save#""));
		File file2 = new File(MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(), ""history""));
		if(file2.exists() && file2.lastModified() != historyModTime)
		{
			Log.log(Log.WARNING,HistoryModel.class,file2
				+ "" changed on disk; will not save history"");
			return;
		}
		jEdit.backupSettingsFile(file2);
		String lineSep = System.getProperty(""line.separator"");
		BufferedWriter out = null;
		try
		{
			out = new BufferedWriter(new FileWriter(file1));
			if(models != null)
			{
				Enumeration modelEnum = models.elements();
				while(modelEnum.hasMoreElements())
				{
					HistoryModel model = (HistoryModel)modelEnum
						.nextElement();
					if(model.getSize() == 0)
						continue;
					out.write('[');
					out.write(MiscUtilities.charsToEscapes(
						model.getName(),TO_ESCAPE));
					out.write(']');
					out.write(lineSep);
					for(int i = 0; i < model.getSize(); i++)
					{
						out.write(MiscUtilities.charsToEscapes(
							model.getItem(i),
							TO_ESCAPE));
						out.write(lineSep);
					}
				}
			}
			out.close();
			/* to avoid data loss, only do this if the above
			 * completed successfully */
			file2.delete();
			file1.renameTo(file2);
			modified = false;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
		finally
		{
			try
			{
				if(out != null)
					out.close();
			}
			catch(IOException e)
			{
			}
		}
		historyModTime = file2.lastModified();
	} //}}}
	//{{{ propertiesChanged() method
	public static void propertiesChanged()
	{
		max = jEdit.getIntegerProperty(""history"",25);
	} //}}}
	//{{{ Private members
	private static final String TO_ESCAPE = ""\r\n\t\\\""'[]"";
	private static int max;
	private String name;
	private Vector data;
	private static Hashtable models;
	private static boolean modified;
	private static File history;
	private static long historyModTime;
	//}}}
}
"
org.gjt.sp.jedit.gui.HistoryTextField,"/*
 * HistoryTextField.java - Text field with a history
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.AbstractBorder;
import javax.swing.border.CompoundBorder;
import javax.swing.event.MouseInputAdapter;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * Text field with an arrow-key accessable history.
 * @author Slava Pestov
 * @version $Id: HistoryTextField.java,v 1.13 2004/04/19 05:59:31 spestov Exp $
 */
public class HistoryTextField extends JTextField
{
	//{{{ HistoryTextField constructor
	/**
	 * Creates a new history text field.
	 * @since jEdit 3.2pre5
	 */
	public HistoryTextField()
	{
		this(null);
	} //}}}
	//{{{ HistoryTextField constructor
	/**
	 * Creates a new history text field.
	 * @param name The history model name
	 */
	public HistoryTextField(String name)
	{
		this(name,false,true);
	} //}}}
	//{{{ HistoryTextField constructor
	/**
	 * Creates a new history text field.
	 * @param name The history model name
	 * @param instantPopups If true, selecting a value from the history
	 * popup will immediately fire an ActionEvent. If false, the user
	 * will have to press 'Enter' first
	 *
	 * @since jEdit 2.2pre5
	 */
	public HistoryTextField(String name, boolean instantPopups)
	{
		this(name,instantPopups,true);
	} //}}}
	//{{{ HistoryTextField constructor
	/**
	 * Creates a new history text field.
	 * @param name The history model name
	 * @param instantPopups If true, selecting a value from the history
	 * popup will immediately fire an ActionEvent. If false, the user
	 * will have to press 'Enter' first
	 * @param enterAddsToHistory If true, pressing the Enter key will
	 * automatically add the currently entered text to the history.
	 *
	 * @since jEdit 2.6pre5
	 */
	public HistoryTextField(String name, boolean instantPopups,
		boolean enterAddsToHistory)
	{
		setModel(name);
		MouseHandler mouseHandler = new MouseHandler();
		addMouseListener(mouseHandler);
		addMouseMotionListener(mouseHandler);
		this.instantPopups = instantPopups;
		this.enterAddsToHistory = enterAddsToHistory;
		index = -1;
	} //}}}
	//{{{ setInstantPopups() method
	/**
	 * Sets if selecting a value from the popup should immediately fire
	 * an ActionEvent.
	 * @since jEdit 4.0pre3
	 */
	public void setInstantPopups(boolean instantPopups)
	{
		this.instantPopups = instantPopups;
	} //}}}
	//{{{ getInstantPopups() method
	/**
	 * Returns if selecting a value from the popup should immediately fire
	 * an ActionEvent.
	 * @since jEdit 4.0pre3
	 */
	public boolean getInstantPopups()
	{
		return instantPopups;
	} //}}}
	//{{{ setEnterAddsToHistory() method
	/**
	 * Sets if pressing Enter should automatically add the currently
	 * entered text to the history.
	 * @since jEdit 4.0pre3
	 */
	public void setEnterAddsToHistory(boolean enterAddsToHistory)
	{
		this.enterAddsToHistory = enterAddsToHistory;
	} //}}}
	//{{{ getEnterAddsToHistory() method
	/**
	 * Returns if pressing Enter should automatically add the currently
	 * entered text to the history.
	 * @since jEdit 4.0pre3
	 */
	public boolean setEnterAddsToHistory()
	{
		return enterAddsToHistory;
	} //}}}
	//{{{ setSelectAllOnFocus() method
	/**
	 * Sets if all text should be selected when the field gets focus.
	 * @since jEdit 4.0pre3
	 */
	public void setSelectAllOnFocus(boolean selectAllOnFocus)
	{
		this.selectAllOnFocus = selectAllOnFocus;
	} //}}}
	//{{{ getSelectAllOnFocus() method
	/**
	 * Returns if all text should be selected when the field gets focus.
	 * @since jEdit 4.0pre3
	 */
	public boolean setSelectAllOnFocus()
	{
		return selectAllOnFocus;
	} //}}}
	//{{{ getModel() method
	/**
	 * Returns the underlying history model.
	 */
	public HistoryModel getModel()
	{
		return historyModel;
	} //}}}
	//{{{ setModel() method
	/**
	 * Sets the history list model.
	 * @param name The model name
	 * @since jEdit 2.3pre3
	 */
	public void setModel(String name)
	{
		Border textFieldBorder = UIManager.getBorder(""TextField.border"");
		if(name == null)
		{
			historyModel = null;
			if(textFieldBorder != null)
				setBorder(textFieldBorder);
		}
		else
		{
			historyModel = HistoryModel.getModel(name);
			if(textFieldBorder != null)
			{
				setBorder(new CompoundBorder(textFieldBorder,
					new HistoryBorder()));
			}
		}
		index = -1;
		repaint();
	} //}}}
	//{{{ addCurrentToHistory() method
	/**
	 * Adds the currently entered item to the history.
	 */
	public void addCurrentToHistory()
	{
		if(historyModel != null)
			historyModel.addItem(getText());
		index = 0;
	} //}}}
	//{{{ setText() method
	/**
	 * Sets the displayed text.
	 */
	public void setText(String text)
	{
		super.setText(text);
		index = -1;
	} //}}}
	//{{{ fireActionPerformed() method
	/**
	 * Fires an action event to all listeners. This is public so
	 * that inner classes can access it.
	 */
	public void fireActionPerformed()
	{
		super.fireActionPerformed();
	} //}}}
	//{{{ Protected members
	//{{{ processKeyEvent() method
	protected void processKeyEvent(KeyEvent evt)
	{
		if(!isEnabled())
			return;
		/*evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;*/
		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_ENTER:
				if(enterAddsToHistory)
					addCurrentToHistory();
				if(evt.getModifiers() == 0)
				{
					fireActionPerformed();
					evt.consume();
				}
				break;
			case KeyEvent.VK_UP:
				if(evt.isShiftDown())
					doBackwardSearch();
				else
					historyPrevious();
				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				if(evt.isShiftDown())
					doForwardSearch();
				else if(evt.isAltDown())
					showPopupMenu(evt.isShiftDown());
				else
					historyNext();
				evt.consume();
				break;
			case KeyEvent.VK_TAB:
				if(evt.isControlDown())
				{
					doBackwardSearch();
					evt.consume();
				}
				break;
			}
		}
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} //}}}
	//{{{ processMouseEvent() method
	protected void processMouseEvent(MouseEvent evt)
	{
		if(!isEnabled())
			return;
		switch(evt.getID())
		{
		case MouseEvent.MOUSE_PRESSED:
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);
			if(evt.getX() >= getWidth() - insets.right
				|| GUIUtilities.isPopupTrigger(evt))
			{
				showPopupMenu(evt.isShiftDown());
			}
			else
				super.processMouseEvent(evt);
			break;
		case MouseEvent.MOUSE_EXITED:
			setCursor(Cursor.getDefaultCursor());
			super.processMouseEvent(evt);
			break;
		default:
			super.processMouseEvent(evt);
			break;
		}
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private HistoryModel historyModel;
	private JPopupMenu popup;
	private boolean instantPopups;
	private boolean enterAddsToHistory;
	private boolean selectAllOnFocus;
	private String current;
	private int index;
	//}}}
	//{{{ doBackwardSearch() method
	private void doBackwardSearch()
	{
		if(historyModel == null)
			return;
		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}
		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyPrevious();
			return;
		}
		for(int i = index + 1; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}
		getToolkit().beep();
	} //}}}
	//{{{ doForwardSearch() method
	private void doForwardSearch()
	{
		if(historyModel == null)
			return;
		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}
		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyNext();
			return;
		}
		for(int i = index - 1; i >= 0; i--)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}
		getToolkit().beep();
	} //}}}
	//{{{ historyPrevious() method
	private void historyPrevious()
	{
		if(historyModel == null)
			return;
		if(index == historyModel.getSize() - 1)
			getToolkit().beep();
		else if(index == -1)
		{
			current = getText();
			setText(historyModel.getItem(0));
			index = 0;
		}
		else
		{
			// have to do this because setText() sets index to -1
			int newIndex = index + 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} //}}}
	//{{{ historyNext() method
	private void historyNext()
	{
		if(historyModel == null)
			return;
		if(index == -1)
			getToolkit().beep();
		else if(index == 0)
			setText(current);
		else
		{
			// have to do this because setText() sets index to -1
			int newIndex = index - 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} //}}}
	//{{{ showPopupMenu() method
	private void showPopupMenu(String text, int x, int y)
	{
		if(historyModel == null)
			return;
		requestFocus();
		if(popup != null && popup.isVisible())
		{
			popup.setVisible(false);
			return;
		}
		ActionHandler actionListener = new ActionHandler();
		popup = new JPopupMenu();
		JMenuItem caption = new JMenuItem(jEdit.getProperty(
			""history.caption""));
		caption.getModel().setEnabled(false);
 		popup.add(caption);
 		popup.addSeparator();
		for(int i = 0; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				JMenuItem menuItem = new JMenuItem(item);
				menuItem.setActionCommand(String.valueOf(i));
				menuItem.addActionListener(actionListener);
				popup.add(menuItem);
			}
		}
		GUIUtilities.showPopupMenu(popup,this,x,y,false);
	} //}}}
	//{{{ showPopupMenu() method
	private void showPopupMenu(boolean search)
	{
		if(search)
			showPopupMenu(getText().substring(0,
				getSelectionStart()),0,getHeight());
		else
			showPopupMenu("""",0,getHeight());
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			int ind = Integer.parseInt(evt.getActionCommand());
			if(ind == -1)
			{
				if(index != -1)
					setText(current);
			}
			else
			{
				setText(historyModel.getItem(ind));
				index = ind;
			}
			if(instantPopups)
			{
				addCurrentToHistory();
				fireActionPerformed();
			}
		}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseInputAdapter
	{
		boolean selectAll;
		//{{{ mousePressed() method
		public void mousePressed(MouseEvent evt)
		{
			selectAll = (!hasFocus() && selectAllOnFocus);
		} //}}}
		//{{{ mouseReleased() method
		public void mouseReleased(MouseEvent evt)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(selectAll)
						selectAll();
				}
			});
		} //}}}
		//{{{ mouseMoved() method
		public void mouseMoved(MouseEvent evt)
		{
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);
			if(evt.getX() >= getWidth() - insets.right)
				setCursor(Cursor.getDefaultCursor());
			else
				setCursor(Cursor.getPredefinedCursor(
					Cursor.TEXT_CURSOR));
		} //}}}
		//{{{ mouseDragged() method
		public void mouseDragged(MouseEvent evt)
		{
			selectAll = false;
		} //}}}
	} //}}}
	//{{{ HistoryBorder class
	static class HistoryBorder extends AbstractBorder
	{
		static final int WIDTH = 16;
		public void paintBorder(Component c, Graphics g,
			int x, int y, int w, int h)
		{
			g.translate(x+w-WIDTH,y-1);
			//if(c.isEnabled())
			//{
			//	// vertical separation line
			//	g.setColor(UIManager.getColor(""controlDkShadow""));
			//	g.drawLine(0,0,0,h);
			//}
			// down arrow
			int w2 = WIDTH/2;
			int h2 = h/2;
			g.setColor(UIManager.getColor(c.isEnabled()
				&& ((HistoryTextField)c).getModel() != null
				? ""TextField.foreground"" : ""TextField.disabledForeground""));
			g.drawLine(w2-5,h2-2,w2+4,h2-2);
			g.drawLine(w2-4,h2-1,w2+3,h2-1);
			g.drawLine(w2-3,h2  ,w2+2,h2  );
			g.drawLine(w2-2,h2+1,w2+1,h2+1);
			g.drawLine(w2-1,h2+2,w2  ,h2+2);
			g.translate(-(x+w-WIDTH),-(y-1));
		}
		public Insets getBorderInsets(Component c)
		{
			return new Insets(0,0,0,WIDTH);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.InputHandler,"/*
 * InputHandler.java - Manages key bindings and executes actions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.JOptionPane;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
//}}}
/**
 * An input handler converts the user's key strokes into concrete actions.
 * It also takes care of macro recording and action repetition.<p>
 *
 * This class provides all the necessary support code for an input
 * handler, but doesn't actually do any key binding logic. It is up
 * to the implementations of this class to do so.
 *
 * @author Slava Pestov
 * @version $Id: InputHandler.java,v 1.21 2004/01/14 04:36:50 spestov Exp $
 * @see org.gjt.sp.jedit.gui.DefaultInputHandler
 */
public abstract class InputHandler
{
	//{{{ InputHandler constructor
	/**
	 * Creates a new input handler.
	 * @param view The view
	 */
	public InputHandler(View view)
	{
		this.view = view;
		repeatCount = 1;
	} //}}}
	//{{{ addKeyBinding() method
	/**
	 * Adds a key binding to this input handler.
	 * @param keyBinding The key binding (the format of this is
	 * input-handler specific)
	 * @param action The action
	 */
	public abstract void addKeyBinding(String keyBinding, String action);
	//}}}
	//{{{ addKeyBinding() method
	/**
	 * Adds a key binding to this input handler.
	 * @param keyBinding The key binding (the format of this is
	 * input-handler specific)
	 * @param action The action
	 */
	public abstract void addKeyBinding(String keyBinding, EditAction action);
	//}}}
	//{{{ removeKeyBinding() method
	/**
	 * Removes a key binding from this input handler.
	 * @param keyBinding The key binding
	 */
	public abstract void removeKeyBinding(String keyBinding);
	//}}}
	//{{{ removeAllKeyBindings() method
	/**
	 * Removes all key bindings from this input handler.
	 */
	public abstract void removeAllKeyBindings();
	//}}}
	//{{{ isPrefixActive() method
	/**
	 * Returns if a prefix key has been pressed.
	 */
	public boolean isPrefixActive()
	{
		return readNextChar != null;
	} //}}}
	//{{{ handleKey() method
	/**
	 * Handles a keystroke.
	 * @param keyStroke The key stroke.
	 * @since jEdit 4.2pre5
	 */
	public abstract boolean handleKey(KeyEventTranslator.Key keyStroke);
	//}}}
	//{{{ getRepeatCount() method
	/**
	 * Returns the number of times the next action will be repeated.
	 */
	public int getRepeatCount()
	{
		return repeatCount;
	} //}}}
	//{{{ setRepeatCount() method
	/**
	 * Sets the number of times the next action will be repeated.
	 * @param repeatCount The repeat count
	 */
	public void setRepeatCount(int repeatCount)
	{
		int oldRepeatCount = this.repeatCount;
		this.repeatCount = repeatCount;
		if(oldRepeatCount != repeatCount)
			view.getStatus().setMessage(null);
	} //}}}
	//{{{ getLastAction() method
	/**
	 * Returns the last executed action.
	 * @since jEdit 2.5pre5
	 */
	public EditAction getLastAction()
	{
		return lastAction;
	} //}}}
	//{{{ getLastActionCount() method
	/**
	 * Returns the number of times the last action was executed.
	 * @since jEdit 2.5pre5
	 */
	public int getLastActionCount()
	{
		return lastActionCount;
	} //}}}
	//{{{ readNextChar() method
	/**
	 * Invokes the specified BeanShell code, replacing __char__ in the
	 * code with the next input character.
	 * @param msg The prompt to display in the status bar
	 * @param code The code
	 * @since jEdit 3.2pre2
	 */
	public void readNextChar(String msg, String code)
	{
		view.getStatus().setMessage(msg);
		readNextChar = code;
	} //}}}
	//{{{ readNextChar() method
	/**
	 * @deprecated Use the other form of this method instead
	 */
	public void readNextChar(String code)
	{
		readNextChar = code;
	} //}}}
	//{{{ resetLastActionCount() method
	/**
	 * Resets the last action count. This should be called when an
	 * editing operation that is not an action is invoked, for example
	 * a mouse click.
	 * @since jEdit 4.0pre1
	 */
	public void resetLastActionCount()
	{
		lastActionCount = 0;
	} //}}}
	//{{{ invokeAction() method
	/**
	 * Invokes the specified action, repeating and recording it as
	 * necessary.
	 * @param action The action
	 * @since jEdit 4.2pre1
	 */
	public void invokeAction(String action)
	{
		invokeAction(jEdit.getAction(action));
	} //}}}
	//{{{ invokeAction() method
	/**
	 * Invokes the specified action, repeating and recording it as
	 * necessary.
	 * @param action The action
	 */
	public void invokeAction(EditAction action)
	{
		Buffer buffer = view.getBuffer();
		/* if(buffer.insideCompoundEdit())
			buffer.endCompoundEdit(); */
		// remember the last executed action
		if(!action.noRememberLast())
		{
			HistoryModel.getModel(""action"").addItem(action.getName());
			if(lastAction == action)
				lastActionCount++;
			else
			{
				lastAction = action;
				lastActionCount = 1;
			}
		}
		// remember old values, in case action changes them
		int _repeatCount = repeatCount;
		// execute the action
		if(action.noRepeat() || _repeatCount == 1)
			action.invoke(view);
		else
		{
			// stop people doing dumb stuff like C+ENTER 100 C+n
			if(_repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				String label = action.getLabel();
				if(label == null)
					label = action.getName();
				else
					label = GUIUtilities.prettifyMenuLabel(label);
				Object[] pp = { label, new Integer(_repeatCount) };
				if(GUIUtilities.confirm(view,""large-repeat-count"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeatCount = 1;
					view.getStatus().setMessage(null);
					return;
				}
			}
			try
			{
				buffer.beginCompoundEdit();
				for(int i = 0; i < _repeatCount; i++)
					action.invoke(view);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null && !action.noRecord())
			recorder.record(_repeatCount,action.getCode());
		// If repeat was true originally, clear it
		// Otherwise it might have been set by the action, etc
		if(_repeatCount != 1)
		{
			// first of all, if this action set a
			// readNextChar, do not clear the repeat
			if(readNextChar != null)
				return;
			repeatCount = 1;
			view.getStatus().setMessage(null);
		}
	} //}}}
	//{{{ invokeLastAction() method
	public void invokeLastAction()
	{
		if(lastAction == null)
			view.getToolkit().beep();
		else
			invokeAction(lastAction);
	} //}}}
	//{{{ Protected members
	private static final int REPEAT_COUNT_THRESHOLD = 20;
	//{{{ Instance variables
	protected View view;
	protected int repeatCount;
	protected EditAction lastAction;
	protected int lastActionCount;
	protected String readNextChar;
	//}}}
	//{{{ userInput() method
	protected void userInput(char ch)
	{
		lastActionCount = 0;
		JEditTextArea textArea = view.getTextArea();
		/* Buffer buffer = view.getBuffer();
		if(!buffer.insideCompoundEdit())
			buffer.beginCompoundEdit(); */
		if(repeatCount == 1)
			textArea.userInput(ch);
		else
		{
			// stop people doing dumb stuff like C+ENTER 100 C+n
			if(repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				Object[] pp = { String.valueOf(ch),
					new Integer(repeatCount) };
				if(GUIUtilities.confirm(view,
					""large-repeat-count.user-input"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeatCount = 1;
					view.getStatus().setMessage(null);
					return;
				}
			}
			Buffer buffer = view.getBuffer();
			try
			{
				if(repeatCount != 1)
					buffer.beginCompoundEdit();
				for(int i = 0; i < repeatCount; i++)
					textArea.userInput(ch);
			}
			finally
			{
				if(repeatCount != 1)
					buffer.endCompoundEdit();
			}
		}
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
		{
			recorder.recordInput(repeatCount,ch,
				textArea.isOverwriteEnabled());
		}
		repeatCount = 1;
	} //}}}
	//{{{ invokeReadNextChar() method
	protected void invokeReadNextChar(char ch)
	{
		Buffer buffer = view.getBuffer();
		/* if(buffer.insideCompoundEdit())
			buffer.endCompoundEdit(); */
		String charStr = MiscUtilities.charsToEscapes(String.valueOf(ch));
		// this might be a bit slow if __char__ occurs a lot
		int index;
		while((index = readNextChar.indexOf(""__char__"")) != -1)
		{
			readNextChar = readNextChar.substring(0,index)
				+ '\'' + charStr + '\''
				+ readNextChar.substring(index + 8);
		}
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(getRepeatCount(),readNextChar);
		if(getRepeatCount() != 1)
		{
			try
			{
				buffer.beginCompoundEdit();
				BeanShell.eval(view,BeanShell.getNameSpace(),
					""for(int i = 1; i < ""
					+ getRepeatCount() + ""; i++)\n{\n""
					+ readNextChar + ""\n}"");
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		else
			BeanShell.eval(view,BeanShell.getNameSpace(),readNextChar);
		readNextChar = null;
		view.getStatus().setMessage(null);
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.IOProgressMonitor,"/*
 * IOProgressMonitor.java - I/O progress monitor
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
//}}}
public class IOProgressMonitor extends JPanel
{
	//{{{ IOProgressMonitor constructor
	public IOProgressMonitor()
	{
		super(new BorderLayout());
		caption = new JLabel();
		updateCaption();
		add(BorderLayout.NORTH,caption);
		threads = new ThreadProgress[VFSManager.getIOThreadPool()
			.getThreadCount()];
		Box box = new Box(BoxLayout.Y_AXIS);
		for(int i = 0; i < threads.length; i++)
		{
			if(i != 0)
				box.add(Box.createVerticalStrut(6));
			threads[i] = new ThreadProgress(i);
			box.add(threads[i]);
		}
		JPanel threadPanel = new JPanel(new BorderLayout());
		threadPanel.setBorder(new EmptyBorder(6,6,6,6));
		threadPanel.add(BorderLayout.NORTH,box);
		add(BorderLayout.CENTER,new JScrollPane(threadPanel));
		workThreadHandler = new WorkThreadHandler();
	} //}}}
	//{{{ addNotify() method
	public void addNotify()
	{
		VFSManager.getIOThreadPool().addProgressListener(workThreadHandler);
		super.addNotify();
	} //}}}
	//{{{ removeNotify() method
	public void removeNotify()
	{
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.removeNotify();
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JLabel caption;
	private ThreadProgress[] threads;
	private WorkThreadHandler workThreadHandler;
	//}}}
	//{{{ updateCaption() method
	private void updateCaption()
	{
		String[] args = { String.valueOf(VFSManager.getIOThreadPool()
			.getRequestCount()) };
		caption.setText(jEdit.getProperty(""io-progress-monitor.caption"",args));
	} //}}}
	//}}}
	//{{{ WorkThreadHandler class
	class WorkThreadHandler implements WorkThreadProgressListener
	{
		public void statusUpdate(final WorkThreadPool pool, final int index)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[index].update();
				}
			});
		}
		public void progressUpdate(final WorkThreadPool pool, final int index)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[index].update();
				}
			});
		}
	} //}}}
	//{{{ ThreadProgress class
	class ThreadProgress extends JPanel
	{
		//{{{ ThreadProgress constructor
		public ThreadProgress(int index)
		{
			super(new BorderLayout(12,12));
			this.index = index;
			Box box = new Box(BoxLayout.Y_AXIS);
			box.add(Box.createGlue());
			box.add(progress = new JProgressBar());
			progress.setStringPainted(true);
			box.add(Box.createGlue());
			ThreadProgress.this.add(BorderLayout.CENTER,box);
			abort = new JButton(jEdit.getProperty(""io-progress-monitor.abort""));
			abort.addActionListener(new ActionHandler());
			ThreadProgress.this.add(BorderLayout.EAST,abort);
			update();
		} //}}}
		//{{{ update() method
		public void update()
		{
			WorkThread thread = VFSManager.getIOThreadPool().getThread(index);
			if(thread.isRequestRunning())
			{
				abort.setEnabled(true);
				String status = thread.getStatus();
				if(status == null)
					status = """";
				progress.setString(status);
				progress.setMaximum(thread.getProgressMaximum());
				//System.err.println(""value: "" + thread.getProgressValue());
				progress.setValue(thread.getProgressValue());
			}
			else
			{
				abort.setEnabled(false);
				progress.setString(jEdit.getProperty(""io-progress-monitor""
					+ "".idle""));
				progress.setValue(0);
			}
		} //}}}
		//{{{ Private members
		private int index;
		private JProgressBar progress;
		private JButton abort;
		//}}}
		//{{{ ActionHandler class
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getSource() == abort)
				{
					int result = GUIUtilities.confirm(
						IOProgressMonitor.this,""abort"",null,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					if(result == JOptionPane.YES_OPTION)
					{
						VFSManager.getIOThreadPool().getThread(index)
							.abortCurrentRequest();
					}
				}
			}
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.JCheckBoxList,"/*
 * JCheckBoxList.java - A list, each item can be checked or unchecked
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.Component;
import java.awt.Font;
import java.util.Vector;
import javax.swing.*;
import javax.swing.table.*;
//}}}
/**
 * A list where items can be selected and checked off independently.
 * @since jEdit 3.2pre9
 */
public class JCheckBoxList extends JTable
{
	//{{{ JCheckBoxList constructor
	/**
	 * Creates a checkbox list with the given list of objects. The elements
	 * of this array can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public JCheckBoxList(Object[] items)
	{
		setModel(items);
	} //}}}
	//{{{ JCheckBoxList constructor
	/**
	 * Creates a checkbox list with the given list of objects. The elements
	 * of this vector can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public JCheckBoxList(Vector items)
	{
		setModel(items);
	} //}}}
	//{{{ setModel() method
	/**
	 * Sets the model to the given list of objects. The elements of this
	 * array can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public void setModel(Object[] items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	} //}}}
	//{{{ setModel() method
	/**
	 * Sets the model to the given list of objects. The elements of this
	 * vector can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public void setModel(Vector items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	} //}}}
	//{{{ getCheckedValues() method
	public Object[] getCheckedValues()
	{
		Vector values = new Vector();
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = (Entry)model.items.elementAt(i);
			if(entry.checked && !entry.caption)
				values.addElement(entry.value);
		}
		Object[] retVal = new Object[values.size()];
		values.copyInto(retVal);
		return retVal;
	} //}}}
	//{{{ selectAll() method
	public void selectAll()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = (Entry)model.items.elementAt(i);
			if(!entry.caption)
				entry.checked = true;
		}
		model.fireTableRowsUpdated(0,model.getRowCount());
	} //}}}
	//{{{ getValues() method
	public Entry[] getValues()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		Entry[] retVal = new Entry[model.items.size()];
		model.items.copyInto(retVal);
		return retVal;
	} //}}}
	//{{{ getSelectedValue() method
	public Object getSelectedValue()
	{
		int row = getSelectedRow();
		if(row == -1)
			return null;
		else
			return getModel().getValueAt(row,1);
	} //}}}
	//{{{ getCellRenderer() method
	public TableCellRenderer getCellRenderer(int row, int column)
	{
		if(column == 0)
		{
			Entry entry = (Entry)((CheckBoxListModel)getModel()).items.get(row);
			if(entry.caption)
				return dummy;
		}
		return super.getCellRenderer(row,column);
	} //}}}
	//{{{ Private members
	private TableCellRenderer dummy;
	//{{{ init() method
	private void init()
	{
		dummy = new DummyRenderer();
		getSelectionModel().setSelectionMode(ListSelectionModel
			.SINGLE_SELECTION);
		setShowGrid(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
		TableColumn column = getColumnModel().getColumn(0);
		int checkBoxWidth = new JCheckBox().getPreferredSize().width;
		column.setPreferredWidth(checkBoxWidth);
		column.setMinWidth(checkBoxWidth);
		column.setWidth(checkBoxWidth);
		column.setMaxWidth(checkBoxWidth);
		column.setResizable(false);
		column = getColumnModel().getColumn(1);
		column.setCellRenderer(new LabelRenderer());
	} //}}}
	//}}}
	//{{{ Entry class
	/**
	 * A check box list entry.
	 */
	public static class Entry
	{
		boolean checked;
		boolean caption;
		Object value;
		public Entry(Object value)
		{
			this.caption = true;
			this.value = value;
		}
		public Entry(boolean checked, Object value)
		{
			this.checked = checked;
			this.value = value;
		}
		public boolean isChecked()
		{
			return checked;
		}
		public Object getValue()
		{
			return value;
		}
	} //}}}
	//{{{ DummyRenderer class
	private class DummyRenderer extends DefaultTableCellRenderer
	{
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			return super.getTableCellRendererComponent(table,null /* value */,
				isSelected,false /* hasFocus */,row,column);
		}
	} //}}}
	//{{{ LabelRenderer class
	private class LabelRenderer extends DefaultTableCellRenderer
	{
		Font plainFont, boldFont;
		LabelRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = plainFont.deriveFont(Font.BOLD);
		}
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table,value,isSelected,
				hasFocus,row,column);
			Entry entry = (Entry)((CheckBoxListModel)getModel()).items.get(row);
			if(entry.caption)
				setFont(boldFont);
			else
				setFont(plainFont);
			return this;
		}
	} //}}}
}
class CheckBoxListModel extends AbstractTableModel
{
	Vector items;
	CheckBoxListModel(Vector _items)
	{
		items = new Vector(_items.size());
		for(int i = 0; i < _items.size(); i++)
		{
			items.addElement(createEntry(_items.elementAt(i)));
		}
	}
	CheckBoxListModel(Object[] _items)
	{
		items = new Vector(_items.length);
		for(int i = 0; i < _items.length; i++)
		{
			items.addElement(createEntry(_items[i]));
		}
	}
	private JCheckBoxList.Entry createEntry(Object obj)
	{
		if(obj instanceof JCheckBoxList.Entry)
			return (JCheckBoxList.Entry)obj;
		else
			return new JCheckBoxList.Entry(false,obj);
	}
	public int getRowCount()
	{
		return items.size();
	}
	public int getColumnCount()
	{
		return 2;
	}
	public String getColumnName(int col)
	{
		return null;
	}
	public Object getValueAt(int row, int col)
	{
		JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
		switch(col)
		{
		case 0:
			return new Boolean(entry.checked);
		case 1:
			return entry.value;
		default:
			throw new InternalError();
		}
	}
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return Boolean.class;
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	}
	public boolean isCellEditable(int row, int col)
	{
		JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
		return col == 0 && !entry.caption;
	}
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
		{
			JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
			if(!entry.caption)
			{
				entry.checked = (value.equals(Boolean.TRUE));
				fireTableRowsUpdated(row,row);
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.KeyEventTranslator,"/*
 * KeyEventTranslator.java - Hides some warts of AWT event API
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.event.*;
import java.awt.Toolkit;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * In conjunction with the <code>KeyEventWorkaround</code>, hides some 
 * warts in the AWT key event API.
 *
 * @author Slava Pestov
 * @version $Id: KeyEventTranslator.java,v 1.23 2004/07/12 19:25:07 spestov Exp $
 */
public class KeyEventTranslator
{
	//{{{ addTranslation() method
	/**
	 * Adds a keyboard translation.
	 * @param key1 Translate this key
	 * @param key2 Into this key
	 * @since jEdit 4.2pre3
	 */
	public static void addTranslation(Key key1, Key key2)
	{
		transMap.put(key1,key2);
	} //}}}
	//{{{ translateKeyEvent() method
	/**
	 * Pass this an event from {@link
	 * KeyEventWorkaround#processKeyEvent(java.awt.event.KeyEvent)}.
	 * @since jEdit 4.2pre3
	 */
	public static Key translateKeyEvent(KeyEvent evt)
	{
		int modifiers = evt.getModifiers();
		Key returnValue = null;
		switch(evt.getID())
		{
		case KeyEvent.KEY_PRESSED:
			int keyCode = evt.getKeyCode();
			if((keyCode >= KeyEvent.VK_0
				&& keyCode <= KeyEvent.VK_9)
				|| (keyCode >= KeyEvent.VK_A
				&& keyCode <= KeyEvent.VK_Z))
			{
				if(Debug.ALTERNATIVE_DISPATCHER)
					return null;
				else
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						'\0',Character.toLowerCase(
						(char)keyCode));
				}
			}
			else
			{
				if(keyCode == KeyEvent.VK_TAB)
				{
					evt.consume();
					returnValue = new Key(
						modifiersToString(modifiers),
						keyCode,'\0');
				}
				else if(keyCode == KeyEvent.VK_SPACE)
				{
					// for SPACE or S+SPACE we pass the
					// key typed since international
					// keyboards sometimes produce a
					// KEY_PRESSED SPACE but not a
					// KEY_TYPED SPACE, eg if you have to
					// do a ""<space> to insert "".
					if((modifiers & ~InputEvent.SHIFT_MASK) == 0)
						returnValue = null;
					else
					{
						returnValue = new Key(
							modifiersToString(modifiers),
							0,' ');
					}
				}
				else
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						keyCode,'\0');
				}
			}
			break;
		case KeyEvent.KEY_TYPED:
			char ch = evt.getKeyChar();
			switch(ch)
			{
			case '\n':
			case '\t':
			case '\b':
				return null;
			case ' ':
				if((modifiers & ~InputEvent.SHIFT_MASK) != 0)
					return null;
			}
			int ignoreMods;
			if(Debug.ALT_KEY_PRESSED_DISABLED)
			{
				/* on MacOS, A+ can be user input */
				ignoreMods = (InputEvent.SHIFT_MASK
					| InputEvent.ALT_GRAPH_MASK
					| InputEvent.ALT_MASK);
			}
			else
			{
				/* on MacOS, A+ can be user input */
				ignoreMods = (InputEvent.SHIFT_MASK
					| InputEvent.ALT_GRAPH_MASK);
			}
			if((modifiers & InputEvent.ALT_GRAPH_MASK) == 0
				&& evt.getWhen()
				-  KeyEventWorkaround.lastKeyTime < 750
				&& (KeyEventWorkaround.modifiers & ~ignoreMods)
				!= 0)
			{
				if(Debug.ALTERNATIVE_DISPATCHER)
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						0,ch);
				}
				else
					return null;
			}
			else
			{
				if(ch == ' ')
				{
					returnValue = new Key(
						modifiersToString(modifiers),
						0,ch);
				}
				else
					returnValue = new Key(null,0,ch);
			}
			break;
		default:
			return null;
		}
		/* I guess translated events do not have the 'evt' field set
		so consuming won't work. I don't think this is a problem as
		nothing uses translation anyway */
		Key trans = (Key)transMap.get(returnValue);
		if(trans == null)
			return returnValue;
		else
			return trans;
	} //}}}
	//{{{ parseKey() method
	/**
	 * Converts a string to a keystroke. The string should be of the
	 * form <i>modifiers</i>+<i>shortcut</i> where <i>modifiers</i>
	 * is any combination of A for Alt, C for Control, S for Shift
	 * or M for Meta, and <i>shortcut</i> is either a single character,
	 * or a keycode name from the <code>KeyEvent</code> class, without
	 * the <code>VK_</code> prefix.
	 * @param keyStroke A string description of the key stroke
	 * @since jEdit 4.2pre3
	 */
	public static Key parseKey(String keyStroke)
	{
		if(keyStroke == null)
			return null;
		int index = keyStroke.indexOf('+');
		int modifiers = 0;
		if(index != -1)
		{
			for(int i = 0; i < index; i++)
			{
				switch(Character.toUpperCase(keyStroke
					.charAt(i)))
				{
				case 'A':
					modifiers |= a;
					break;
				case 'C':
					modifiers |= c;
					break;
				case 'M':
					modifiers |= m;
					break;
				case 'S':
					modifiers |= s;
					break;
				}
			}
		}
		String key = keyStroke.substring(index + 1);
		if(key.length() == 1)
		{
			return new Key(modifiersToString(modifiers),0,key.charAt(0));
		}
		else if(key.length() == 0)
		{
			Log.log(Log.ERROR,DefaultInputHandler.class,
				""Invalid key stroke: "" + keyStroke);
			return null;
		}
		else if(key.equals(""SPACE""))
		{
			return new Key(modifiersToString(modifiers),0,' ');
		}
		else
		{
			int ch;
			try
			{
				ch = KeyEvent.class.getField(""VK_"".concat(key))
					.getInt(null);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,DefaultInputHandler.class,
					""Invalid key stroke: ""
					+ keyStroke);
				return null;
			}
			return new Key(modifiersToString(modifiers),ch,'\0');
		}
	} //}}}
	//{{{ setModifierMapping() method
	/**
	 * Changes the mapping between symbolic modifier key names
	 * (<code>C</code>, <code>A</code>, <code>M</code>, <code>S</code>) and
	 * Java modifier flags.
	 *
	 * You can map more than one Java modifier to a symobolic modifier, for 
	 * example :
	 * <p><code><pre>
	 *	setModifierMapping(
	 *		InputEvent.CTRL_MASK,
	 *		InputEvent.ALT_MASK | InputEvent.META_MASK,
	 *		0,
	 *		InputEvent.SHIFT_MASK);
	 *<pre></code></p>
	 *
	 * You cannot map a Java modifer to more than one symbolic modifier.
	 *
	 * @param c The modifier(s) to map the <code>C</code> modifier to
	 * @param a The modifier(s) to map the <code>A</code> modifier to
	 * @param m The modifier(s) to map the <code>M</code> modifier to
	 * @param s The modifier(s) to map the <code>S</code> modifier to
	 *
	 * @since jEdit 4.2pre3
	 */
	public static void setModifierMapping(int c, int a, int m, int s)
	{
		int duplicateMapping = 
			((c & a) | (c & m) | (c & s) | (a & m) | (a & s) | (m & s)); 
		if((duplicateMapping & InputEvent.CTRL_MASK) != 0) {
			throw new IllegalArgumentException(
				""CTRL is mapped to more than one modifier"");
		}
		if((duplicateMapping & InputEvent.ALT_MASK) != 0) {
			throw new IllegalArgumentException(
				""ALT is mapped to more than one modifier"");
		}
		if((duplicateMapping & InputEvent.META_MASK) != 0) {
			throw new IllegalArgumentException(
				""META is mapped to more than one modifier"");
		}
		if((duplicateMapping & InputEvent.SHIFT_MASK) != 0) {
			throw new IllegalArgumentException(
				""SHIFT is mapped to more than one modifier"");
		}
		KeyEventTranslator.c = c;
		KeyEventTranslator.a = a;
		KeyEventTranslator.m = m;
		KeyEventTranslator.s = s;
	} //}}}
	//{{{ getSymbolicModifierName() method
	/**
	 * Returns a the symbolic modifier name for the specified Java modifier
	 * flag.
	 *
	 * @param mod A modifier constant from <code>InputEvent</code>
	 *
	 * @since jEdit 4.2pre3
	 */
	public static char getSymbolicModifierName(int mod)
	{
		if((mod & c) != 0)
			return 'C';
		else if((mod & a) != 0)
			return 'A';
		else if((mod & m) != 0)
			return 'M';
		else if((mod & s) != 0)
			return 'S';
		else
			return '\0';
	} //}}}
	//{{{ modifiersToString() method
	public static String modifiersToString(int mods)
	{
		StringBuffer buf = null;
		if((mods & InputEvent.CTRL_MASK) != 0)
		{
			if(buf == null)
				buf = new StringBuffer();
			buf.append(getSymbolicModifierName(InputEvent.CTRL_MASK));
		}
		if((mods & InputEvent.ALT_MASK) != 0)
		{
			if(buf == null)
				buf = new StringBuffer();
			buf.append(getSymbolicModifierName(InputEvent.ALT_MASK));
		}
		if((mods & InputEvent.META_MASK) != 0)
		{
			if(buf == null)
				buf = new StringBuffer();
			buf.append(getSymbolicModifierName(InputEvent.META_MASK));
		}
		if((mods & InputEvent.SHIFT_MASK) != 0)
		{
			if(buf == null)
				buf = new StringBuffer();
			buf.append(getSymbolicModifierName(InputEvent.SHIFT_MASK));
		}
		if(buf == null)
			return null;
		else
			return buf.toString();
	} //}}}
	//{{{ getModifierString() method
	/**
	 * Returns a string containing symbolic modifier names set in the
	 * specified event.
	 *
	 * @param evt The event
	 *
	 * @since jEdit 4.2pre3
	 */
	public static String getModifierString(InputEvent evt)
	{
		StringBuffer buf = new StringBuffer();
		if(evt.isControlDown())
			buf.append(getSymbolicModifierName(InputEvent.CTRL_MASK));
		if(evt.isAltDown())
			buf.append(getSymbolicModifierName(InputEvent.ALT_MASK));
		if(evt.isMetaDown())
			buf.append(getSymbolicModifierName(InputEvent.META_MASK));
		if(evt.isShiftDown())
			buf.append(getSymbolicModifierName(InputEvent.SHIFT_MASK));
		return (buf.length() == 0 ? null : buf.toString());
	} //}}}
	static int c, a, m, s;
	//{{{ Private members
	private static Map transMap = new HashMap();
	static
	{
		if(OperatingSystem.isMacOS())
		{
			setModifierMapping(
				InputEvent.META_MASK,  /* == C+ */
				InputEvent.CTRL_MASK,  /* == A+ */
				/* M+ discarded by key event workaround! */
				InputEvent.ALT_MASK,   /* == M+ */
				InputEvent.SHIFT_MASK  /* == S+ */);
		}
		else
		{
			setModifierMapping(
				InputEvent.CTRL_MASK,
				InputEvent.ALT_MASK,
				InputEvent.META_MASK,
				InputEvent.SHIFT_MASK);
		}
	} //}}}
	//{{{ Key class
	public static class Key
	{
		public String modifiers;
		public int key;
		public char input;
		public Key(String modifiers, int key, char input)
		{
			this.modifiers = modifiers;
			this.key = key;
			this.input = input;
		}
		public int hashCode()
		{
			return key + input;
		}
		public boolean equals(Object o)
		{
			if(o instanceof Key)
			{
				Key k = (Key)o;
				if(MiscUtilities.objectsEqual(modifiers,
					k.modifiers) && key == k.key
					&& input == k.input)
				{
					return true;
				}
			}
			return false;
		}
		public String toString()
		{
			return (modifiers == null ? """" : modifiers)
				+ ""<""
				+ Integer.toString(key,16)
				+ "",""
				+ Integer.toString(input,16)
				+ "">"";
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.KeyEventWorkaround,"/*
 * KeyEventWorkaround.java - Works around bugs in Java event handling
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.event.*;
import org.gjt.sp.jedit.Debug;
//}}}
/**
 * Various hacks to get keyboard event handling to behave in a consistent manner
 * across Java implementations.
 *
 * @author Slava Pestov
 * @version $Id: KeyEventWorkaround.java,v 1.38 2004/04/22 19:09:24 spestov Exp $
 */
public class KeyEventWorkaround
{
	//{{{ processKeyEvent() method
	public static KeyEvent processKeyEvent(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		char ch = evt.getKeyChar();
		switch(evt.getID())
		{
		//{{{ KEY_PRESSED...
		case KeyEvent.KEY_PRESSED:
			lastKeyTime = evt.getWhen();
			// get rid of keys we never need to handle
			switch(keyCode)
			{
			case KeyEvent.VK_DEAD_GRAVE:
			case KeyEvent.VK_DEAD_ACUTE:
			case KeyEvent.VK_DEAD_CIRCUMFLEX:
			case KeyEvent.VK_DEAD_TILDE:
			case KeyEvent.VK_DEAD_MACRON:
			case KeyEvent.VK_DEAD_BREVE:
			case KeyEvent.VK_DEAD_ABOVEDOT:
			case KeyEvent.VK_DEAD_DIAERESIS:
			case KeyEvent.VK_DEAD_ABOVERING:
			case KeyEvent.VK_DEAD_DOUBLEACUTE:
			case KeyEvent.VK_DEAD_CARON:
			case KeyEvent.VK_DEAD_CEDILLA:
			case KeyEvent.VK_DEAD_OGONEK:
			case KeyEvent.VK_DEAD_IOTA:
			case KeyEvent.VK_DEAD_VOICED_SOUND:
			case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:
			case '\0':
				return null;
			case KeyEvent.VK_ALT:
				modifiers |= InputEvent.ALT_MASK;
				return null;
			case KeyEvent.VK_ALT_GRAPH:
				modifiers |= InputEvent.ALT_GRAPH_MASK;
				return null;
			case KeyEvent.VK_CONTROL:
				modifiers |= InputEvent.CTRL_MASK;
				return null;
			case KeyEvent.VK_SHIFT:
				modifiers |= InputEvent.SHIFT_MASK;
				return null;
			case KeyEvent.VK_META:
				modifiers |= InputEvent.META_MASK;
				return null;
			default:
				if(!evt.isMetaDown())
				{
					if(evt.isControlDown()
						&& evt.isAltDown())
					{
						lastKeyTime = 0L;
					}
					else if(!evt.isControlDown()
						&& !evt.isAltDown())
					{
						lastKeyTime = 0L;
						if(keyCode >= KeyEvent.VK_0
							&& keyCode <= KeyEvent.VK_9)
						{
							return null;
						}
						if(keyCode >= KeyEvent.VK_A
							&& keyCode <= KeyEvent.VK_Z)
						{
							return null;
						}
					}
				}
				if(Debug.ALT_KEY_PRESSED_DISABLED)
				{
					/* we don't handle key pressed A+ */
					/* they're too troublesome */
					if((modifiers & InputEvent.ALT_MASK) != 0)
						return null;
				}
				switch(keyCode)
				{
				case KeyEvent.VK_NUMPAD0:
				case KeyEvent.VK_NUMPAD1:
				case KeyEvent.VK_NUMPAD2:
				case KeyEvent.VK_NUMPAD3:
				case KeyEvent.VK_NUMPAD4:
				case KeyEvent.VK_NUMPAD5:
				case KeyEvent.VK_NUMPAD6:
				case KeyEvent.VK_NUMPAD7:
				case KeyEvent.VK_NUMPAD8:
				case KeyEvent.VK_NUMPAD9:
				case KeyEvent.VK_MULTIPLY:
				case KeyEvent.VK_ADD:
				/* case KeyEvent.VK_SEPARATOR: */
				case KeyEvent.VK_SUBTRACT:
				case KeyEvent.VK_DECIMAL:
				case KeyEvent.VK_DIVIDE:
					last = LAST_NUMKEYPAD;
					break;
				default:
					last = LAST_NOTHING;
					break;
				}
				return evt;
			}
		//}}}
		//{{{ KEY_TYPED...
		case KeyEvent.KEY_TYPED:
			// need to let \b through so that backspace will work
			// in HistoryTextFields
			if((ch < 0x20 || ch == 0x7f || ch == 0xff)
				&& ch != '\b' && ch != '\t' && ch != '\n')
			{
				return null;
			}
			if(evt.getWhen() - lastKeyTime < 750)
			{
				if(!Debug.ALTERNATIVE_DISPATCHER)
				{
					if(((modifiers & InputEvent.CTRL_MASK) != 0
						^ (modifiers & InputEvent.ALT_MASK) != 0)
						|| (modifiers & InputEvent.META_MASK) != 0)
					{
						return null;
					}
				}
				// if the last key was a numeric keypad key
				// and NumLock is off, filter it out
				if(last == LAST_NUMKEYPAD)
				{
					last = LAST_NOTHING;
					if((ch >= '0' && ch <= '9') || ch == '.'
						|| ch == '/' || ch == '*'
						|| ch == '-' || ch == '+')
					{
						return null;
					}
				}
				// Windows JDK workaround
				else if(last == LAST_ALT)
				{
					last = LAST_NOTHING;
					switch(ch)
					{
					case 'B':
					case 'M':
					case 'X':
					case 'c':
					case '!':
					case ',':
					case '?':
						return null;
					}
				}
			}
			else
			{
				if((modifiers & InputEvent.SHIFT_MASK) != 0)
				{
					switch(ch)
					{
					case '\n':
					case '\t':
						return null;
					}
				}
				modifiers = 0;
			}
			return evt;
		//}}}
		//{{{ KEY_RELEASED...
		case KeyEvent.KEY_RELEASED:
			switch(keyCode)
			{
			case KeyEvent.VK_ALT:
				modifiers &= ~InputEvent.ALT_MASK;
				lastKeyTime = evt.getWhen();
				// we consume this to work around the bug
				// where A+TAB window switching activates
				// the menu bar on Windows.
				evt.consume();
				return null;
			case KeyEvent.VK_ALT_GRAPH:
				modifiers &= ~InputEvent.ALT_GRAPH_MASK;
				return null;
			case KeyEvent.VK_CONTROL:
				modifiers &= ~InputEvent.CTRL_MASK;
				return null;
			case KeyEvent.VK_SHIFT:
				modifiers &= ~InputEvent.SHIFT_MASK;
				return null;
			case KeyEvent.VK_META:
				modifiers &= ~InputEvent.META_MASK;
				return null;
			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
			case KeyEvent.VK_PAGE_UP:
			case KeyEvent.VK_PAGE_DOWN:
			case KeyEvent.VK_END:
			case KeyEvent.VK_HOME:
				/* workaround for A+keys producing
				 * garbage on Windows */
				if(modifiers == InputEvent.ALT_MASK)
					last = LAST_ALT;
				break;
			}
			return evt;
		//}}}
		default:
			return evt;
		}
	} //}}}
	//{{{ numericKeypadKey() method
	/**
	 * A workaround for non-working NumLock status in some Java versions.
	 * @since jEdit 4.0pre8
	 */
	public static void numericKeypadKey()
	{
		last = LAST_NOTHING;
	} //}}}
	//{{{ Package-private members
	static long lastKeyTime;
	static int modifiers;
	//}}}
	//{{{ Private members
	private static int last;
	private static final int LAST_NOTHING = 0;
	private static final int LAST_NUMKEYPAD = 1;
	private static final int LAST_ALT = 2;
	//}}}
}
"
org.gjt.sp.jedit.gui.LogViewer,"/*
 * LogViewer.java
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;
//}}}
public class LogViewer extends JPanel implements DefaultFocusComponent,
	EBComponent
{
	//{{{ LogViewer constructor
	public LogViewer()
	{
		super(new BorderLayout());
		JPanel caption = new JPanel();
		caption.setLayout(new BoxLayout(caption,BoxLayout.X_AXIS));
		caption.setBorder(new EmptyBorder(6,6,6,6));
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			String[] args = { MiscUtilities.constructPath(
				settingsDirectory, ""activity.log"") };
			JLabel label = new JLabel(jEdit.getProperty(
				""log-viewer.caption"",args));
			caption.add(label);
		}
		caption.add(Box.createHorizontalGlue());
		tailIsOn = jEdit.getBooleanProperty(""log-viewer.tail"", false);
		tail = new JCheckBox(
			jEdit.getProperty(""log-viewer.tail.label""),tailIsOn);
		tail.addActionListener(new ActionHandler());
		caption.add(tail);
		caption.add(Box.createHorizontalStrut(12));
		copy = new JButton(jEdit.getProperty(""log-viewer.copy""));
		copy.addActionListener(new ActionHandler());
		caption.add(copy);
		ListModel model = Log.getLogListModel();
		model.addListDataListener(new ListHandler());
		list = new LogList(model);
		add(BorderLayout.NORTH,caption);
		JScrollPane scroller = new JScrollPane(list);
		Dimension dim = scroller.getPreferredSize();
		dim.width = Math.min(600,dim.width);
		scroller.setPreferredSize(dim);
		add(BorderLayout.CENTER,scroller);
		propertiesChanged();
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
	} //}}}
	//{{{ addNotify() method
	public void addNotify()
	{
		super.addNotify();
		if(tailIsOn)
		{
			int index = list.getModel().getSize() - 1;
			list.ensureIndexIsVisible(index);
		}
		EditBus.addToBus(this);
	} //}}}
	//{{{ removeNotify() method
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	} //}}}
	//{{{ focusOnDefaultComponent() method
	public void focusOnDefaultComponent()
	{
		list.requestFocus();
	} //}}}
	//{{{ Private members
	private JList list;
	private JButton copy;
	private JCheckBox tail;
	private boolean tailIsOn;
	//{{{ propertiesChanged() method
	private void propertiesChanged()
	{
		list.setFont(jEdit.getFontProperty(""view.font""));
		list.setFixedCellHeight(list.getFontMetrics(list.getFont())
			.getHeight());
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent e)
		{
			Object src = e.getSource();
			if(src == tail)
			{
				tailIsOn = !tailIsOn;
				jEdit.setBooleanProperty(""log-viewer.tail"",tailIsOn);
				if(tailIsOn)
				{
					int index = list.getModel().getSize();
					if(index != 0)
					{
						list.ensureIndexIsVisible(index - 1);
					}
				}
			}
			else if(src == copy)
			{
				StringBuffer buf = new StringBuffer();
				Object[] selected = list.getSelectedValues();
				if(selected != null && selected.length != 0)
				{
					for(int i = 0; i < selected.length; i++)
					{
						buf.append(selected[i]);
						buf.append('\n');
					}
				}
				else
				{
					ListModel model = list.getModel();
					for(int i = 0; i < model.getSize(); i++)
					{
						buf.append(model.getElementAt(i));
						buf.append('\n');
					}
				}
				Registers.setRegister('$',buf.toString());
			}
		}
	} //}}}
	//{{{ ListHandler class
	class ListHandler implements ListDataListener
	{
		public void intervalAdded(ListDataEvent e)
		{
			contentsChanged(e);
		}
		public void intervalRemoved(ListDataEvent e)
		{
			contentsChanged(e);
		}
		public void contentsChanged(ListDataEvent e)
		{
			if(tailIsOn)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						int index = list.getModel().getSize() - 1;
						list.ensureIndexIsVisible(index);
					}
				});
			}
		}
	} //}}}
	//{{{ LogList class
	class LogList extends JList
	{
		LogList(ListModel model)
		{
			super(model);
			setVisibleRowCount(24);
			getSelectionModel().setSelectionMode(
				ListSelectionModel.SINGLE_INTERVAL_SELECTION);
			setAutoscrolls(true);
		}
		public void processMouseEvent(MouseEvent evt)
		{
			if(evt.getID() == MouseEvent.MOUSE_PRESSED)
			{
				startIndex = list.locationToIndex(
					evt.getPoint());
			}
			super.processMouseEvent(evt);
		}
		public void processMouseMotionEvent(MouseEvent evt)
		{
			if(evt.getID() == MouseEvent.MOUSE_DRAGGED)
			{
				int row = list.locationToIndex(evt.getPoint());
				if(row != -1)
				{
					if(startIndex == -1)
					{
						list.setSelectionInterval(row,row);
						startIndex = row;
					}
					else
						list.setSelectionInterval(startIndex,row);
					list.ensureIndexIsVisible(row);
					evt.consume();
				}
			}
			else
				super.processMouseMotionEvent(evt);
		}
		private int startIndex;
	} //}}}
}
"
org.gjt.sp.jedit.gui.OptionsDialog,"/*
 * OptionsDialog.java - Tree options dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * An abstract tabbed options dialog box.
 * @author Slava Pestov
 * @version $Id: OptionsDialog.java,v 1.38 2004/06/28 06:45:27 spestov Exp $
 */
public abstract class OptionsDialog extends EnhancedDialog
	implements ActionListener, TreeSelectionListener
{
	//{{{ OptionsDialog constructor
	public OptionsDialog(Frame frame, String name, String pane)
	{
		super(frame, jEdit.getProperty(name + "".title""), true);
		init(name,pane);
	} //}}}
	//{{{ OptionsDialog constructor
	public OptionsDialog(Dialog dialog, String name, String pane)
	{
		super(dialog, jEdit.getProperty(name + "".title""), true);
		init(name,pane);
	} //}}}
	//{{{ addOptionGroup() method
	public void addOptionGroup(OptionGroup group)
	{
		getDefaultGroup().addOptionGroup(group);
	} //}}}
	//{{{ addOptionPane() method
	public void addOptionPane(OptionPane pane)
	{
		getDefaultGroup().addOptionPane(pane);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		if(currentPane != null)
			jEdit.setProperty(name + "".last"",currentPane.getName());
		ok(true);
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		if(currentPane != null)
			jEdit.setProperty(name + "".last"",currentPane.getName());
		dispose();
	} //}}}
	//{{{ ok() method
	public void ok(boolean dispose)
	{
		OptionTreeModel m = (OptionTreeModel) paneTree
			.getModel();
		save(m.getRoot());
		/* This will fire the PROPERTIES_CHANGED event */
		jEdit.propertiesChanged();
		// Save settings to disk
		jEdit.saveSettings();
		// get rid of this dialog if necessary
		if(dispose)
			dispose();
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,name);
		jEdit.setIntegerProperty(name + "".splitter"",splitter.getDividerLocation());
		super.dispose();
	} //}}}
	//{{{ actionPerformed() method
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
		{
			ok();
		}
		else if(source == cancel)
		{
			cancel();
		}
		else if(source == apply)
		{
			ok(false);
		}
	} //}}}
	//{{{ valueChanged() method
	public void valueChanged(TreeSelectionEvent evt)
	{
		TreePath path = evt.getPath();
		if(path == null)
			return;
		Object lastPathComponent = path.getLastPathComponent();
		if(!(lastPathComponent instanceof String
			|| lastPathComponent instanceof OptionPane))
		{
			return;
		}
		Object[] nodes = path.getPath();
		StringBuffer buf = new StringBuffer();
		OptionPane optionPane = null;
		int lastIdx = nodes.length - 1;
		for (int i = paneTree.isRootVisible() ? 0 : 1;
			i <= lastIdx; i++)
		{
			String label;
			Object node = nodes[i];
			if (node instanceof OptionPane)
			{
				optionPane = (OptionPane)node;
				label = jEdit.getProperty(""options.""
					+ optionPane.getName()
					+ "".label"");
			}
			else if (node instanceof OptionGroup)
			{
				label = ((OptionGroup)node).getLabel();
			}
			else if (node instanceof String)
			{
				label = jEdit.getProperty(""options.""
					+ node + "".label"");
				optionPane = (OptionPane)deferredOptionPanes
					.get((String)node);
				if(optionPane == null)
				{
					String propName = ""options."" + node + "".code"";
					String code = jEdit.getProperty(propName);
					if(code != null)
					{
						optionPane = (OptionPane)
							BeanShell.eval(
							jEdit.getActiveView(),
							BeanShell.getNameSpace(),
							code
						);
						if(optionPane != null)
						{
							deferredOptionPanes.put(
								node,optionPane);
						}
						else
							continue;
					}
					else
					{
						Log.log(Log.ERROR,this,propName
							+ "" not defined"");
						continue;
					}
				}
			}
			else
			{
				continue;
			}
			buf.append(label);
			if (i != lastIdx)
				buf.append("": "");
		}
		if(optionPane == null)
			return;
		setTitle(jEdit.getProperty(""options.title-template"",
			new Object[] { jEdit.getProperty(this.name + "".title""),
			buf.toString() }));
		try
		{
			optionPane.init();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,this,""Error initializing options:"");
			Log.log(Log.ERROR,this,t);
		}
		if(currentPane != null)
			stage.remove(currentPane.getComponent());
		currentPane = optionPane;
		stage.add(BorderLayout.CENTER,currentPane.getComponent());
		stage.revalidate();
		stage.repaint();
		if(!isShowing())
			addNotify();
		updateSize();
		currentPane = optionPane;
	} //}}}
	//{{{ Protected members
	protected abstract OptionTreeModel createOptionTreeModel();
	protected abstract OptionGroup getDefaultGroup();
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private String name;
	private JSplitPane splitter;
	private JTree paneTree;
	private JPanel stage;
	private JButton ok;
	private JButton cancel;
	private JButton apply;
	private OptionPane currentPane;
	private Map deferredOptionPanes;
	//}}}
	//{{{ init() method
	private void init(String name, String pane)
	{
		this.name = name;
		deferredOptionPanes = new HashMap();
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		stage = new JPanel(new BorderLayout());
		paneTree = new JTree(createOptionTreeModel());
		paneTree.setVisibleRowCount(1);
		paneTree.setCellRenderer(new PaneNameRenderer());
		// looks bad with the OS X L&F, apparently...
		if(!OperatingSystem.isMacOSLF())
			paneTree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		paneTree.setShowsRootHandles(true);
		paneTree.setRootVisible(false);
		JScrollPane scroller = new JScrollPane(paneTree,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
			scroller,stage);
		content.add(splitter, BorderLayout.CENTER);
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		getRootPane().setDefaultButton(ok);
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		buttons.add(cancel);
		buttons.add(Box.createHorizontalStrut(6));
		apply = new JButton(jEdit.getProperty(""common.apply""));
		apply.addActionListener(this);
		buttons.add(apply);
		buttons.add(Box.createGlue());
		content.add(buttons, BorderLayout.SOUTH);
		// register the Options dialog as a TreeSelectionListener.
		// this is done before the initial selection to ensure that the
		// first selected OptionPane is displayed on startup.
		paneTree.getSelectionModel().addTreeSelectionListener(this);
		OptionGroup rootNode = (OptionGroup)paneTree.getModel().getRoot();
		for(int i = 0; i < rootNode.getMemberCount(); i++)
		{
			paneTree.expandPath(new TreePath(
			new Object[] { rootNode, rootNode.getMember(i) }));
		}
		// returns false if no such pane exists; calling with null
		// param selects first option pane found
		if(!selectPane(rootNode,pane))
			selectPane(rootNode,null);
		splitter.setDividerLocation(paneTree.getPreferredSize().width
			+ scroller.getVerticalScrollBar().getPreferredSize()
			.width);
		GUIUtilities.loadGeometry(this,name);
		int dividerLocation = jEdit.getIntegerProperty(name + "".splitter"",-1);
		if(dividerLocation != -1)
			splitter.setDividerLocation(dividerLocation);
		// in case saved geometry is too small
		updateSize();
		setVisible(true);
	} //}}}
	//{{{ selectPane() method
	private boolean selectPane(OptionGroup node, String name)
	{
		return selectPane(node,name,new ArrayList());
	} //}}}
	//{{{ selectPane() method
	private boolean selectPane(OptionGroup node, String name, ArrayList path)
	{
		path.add(node);
		Enumeration e = node.getMembers();
		while(e.hasMoreElements())
		{
			Object obj = e.nextElement();
			if(obj instanceof OptionGroup)
			{
				OptionGroup grp = (OptionGroup)obj;
				if(grp.getName().equals(name))
				{
					path.add(grp);
					path.add(grp.getMember(0));
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
				else if(selectPane((OptionGroup)obj,name,path))
					return true;
			}
			else if(obj instanceof OptionPane)
			{
				OptionPane pane = (OptionPane)obj;
				if(pane.getName().equals(name)
					|| name == null)
				{
					path.add(pane);
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
			}
			else if(obj instanceof String)
			{
				String pane = (String)obj;
				if(pane.equals(name)
					|| name == null)
				{
					path.add(pane);
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
			}
		}
		path.remove(node);
		return false;
	} //}}}
	//{{{ save() method
	private void save(Object obj)
	{
		if(obj instanceof OptionGroup)
		{
			OptionGroup grp = (OptionGroup)obj;
			Enumeration members = grp.getMembers();
			while(members.hasMoreElements())
			{
				save(members.nextElement());
			}
		}
		else if(obj instanceof OptionPane)
		{
			try
			{
				((OptionPane)obj).save();
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error saving options:"");
				Log.log(Log.ERROR,this,t);
			}
		}
		else if(obj instanceof String)
		{
			save(deferredOptionPanes.get(obj));
		}
	} //}}}
	//{{{ updateSize() method
	private void updateSize()
	{
		Dimension currentSize = getSize();
		Dimension requestedSize = getPreferredSize();
		Dimension newSize = new Dimension(
			Math.max(currentSize.width,requestedSize.width),
			Math.max(currentSize.height,requestedSize.height)
		);
		if(newSize.width < 300)
			newSize.width = 300;
		if(newSize.height < 200)
			newSize.height = 200;
		setSize(newSize);
		validate();
	} //}}}
	//}}}
	//{{{ PaneNameRenderer class
	class PaneNameRenderer extends DefaultTreeCellRenderer
	{
		public PaneNameRenderer()
		{
			paneFont = UIManager.getFont(""Tree.font"");
			if(paneFont == null)
				paneFont = jEdit.getFontProperty(""metal.secondary.font"");
			groupFont = paneFont.deriveFont(Font.BOLD);
		}
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);
			String name = null;
			if (value instanceof OptionGroup)
			{
				setText(((OptionGroup)value).getLabel());
				this.setFont(groupFont);
			}
			else if (value instanceof OptionPane)
			{
				name = ((OptionPane)value).getName();
				this.setFont(paneFont);
			}
			else if (value instanceof String)
			{
				name = ((String)value);
				this.setFont(paneFont);
			}
			if (name != null)
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");
				if (label == null)
				{
					setText(""NO LABEL PROPERTY: "" + name);
				}
				else
				{
					setText(label);
				}
			}
			setIcon(null);
			return this;
		}
		private Font paneFont;
		private Font groupFont;
	} //}}}
	//{{{ OptionTreeModel class
	public class OptionTreeModel implements TreeModel
	{
		public void addTreeModelListener(TreeModelListener l)
		{
			listenerList.add(TreeModelListener.class, l);
		}
		public void removeTreeModelListener(TreeModelListener l)
		{
			listenerList.remove(TreeModelListener.class, l);
		}
		public Object getChild(Object parent, int index)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMember(index);
			}
			else
			{
				return null;
			}
		}
		public int getChildCount(Object parent)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMemberCount();
			}
			else
			{
				return 0;
			}
		}
		public int getIndexOfChild(Object parent, Object child)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent)
					.getMemberIndex(child);
			}
			else
			{
				return -1;
			}
		}
		public Object getRoot()
		{
			return root;
		}
		public boolean isLeaf(Object node)
		{
			return !(node instanceof OptionGroup);
		}
		public void valueForPathChanged(TreePath path, Object newValue)
		{
			// this model may not be changed by the TableCellEditor
		}
		protected void fireNodesChanged(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeNodesChanged(modelEvent);
			}
		}
		protected void fireNodesInserted(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeNodesInserted(modelEvent);
			}
		}
		protected void fireNodesRemoved(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeNodesRemoved(modelEvent);
			}
		}
		protected void fireTreeStructureChanged(Object source,
			Object[] path, int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeStructureChanged(modelEvent);
			}
		}
		private OptionGroup root = new OptionGroup(null);
		private EventListenerList listenerList = new EventListenerList();
	} //}}}
}
"
org.gjt.sp.jedit.gui.PanelWindowContainer,"/*
 * PanelWindowContainer.java - holds dockable windows
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.plaf.metal.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.AffineTransform;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * A container for dockable windows. This class should never be used
 * directly.
 * @author Slava Pestov
 * @version $Id: PanelWindowContainer.java,v 1.76 2004/03/19 22:42:21 spestov Exp $
 * @since jEdit 4.0pre1
 */
public class PanelWindowContainer implements DockableWindowContainer
{
	//{{{ PanelWindowContainer constructor
	public PanelWindowContainer(DockableWindowManager wm, String position,
		int dimension)
	{
		this.wm = wm;
		this.position = position;
		//{{{ Button box setup
		buttonPanel = new JPanel(new ButtonLayout());
		buttonPanel.setBorder(new EmptyBorder(1,1,1,1));
		closeBox = new JButton(GUIUtilities.loadIcon(""closebox.gif""));
		closeBox.setRequestFocusEnabled(false);
		closeBox.setToolTipText(jEdit.getProperty(""view.docking.close-tooltip""));
		if(OperatingSystem.isMacOSLF())
			closeBox.putClientProperty(""JButton.buttonType"",""toolbar"");
		closeBox.setMargin(new Insets(0,0,0,0));
		closeBox.addActionListener(new ActionHandler());
		menuBtn = new JButton(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
		menuBtn.setRequestFocusEnabled(false);
		menuBtn.setToolTipText(jEdit.getProperty(""view.docking.menu-tooltip""));
		if(OperatingSystem.isMacOSLF())
			menuBtn.putClientProperty(""JButton.buttonType"",""toolbar"");
		menuBtn.setMargin(new Insets(0,0,0,0));
		menuBtn.addMouseListener(new MenuMouseHandler());
		buttonGroup = new ButtonGroup();
		// JDK 1.4 workaround
		buttonGroup.add(nullButton = new JToggleButton());
		//}}}
		dockables = new ArrayList();
		buttons = new ArrayList();
		dockablePanel = new DockablePanel();
		this.dimension = dimension;
	} //}}}
	//{{{ register() method
	public void register(final DockableWindowManager.Entry entry)
	{
		dockables.add(entry);
		//{{{ Create button
		int rotation;
		if(position.equals(DockableWindowManager.TOP)
			|| position.equals(DockableWindowManager.BOTTOM))
			rotation = RotatedTextIcon.NONE;
		else if(position.equals(DockableWindowManager.LEFT))
			rotation = RotatedTextIcon.CCW;
		else if(position.equals(DockableWindowManager.RIGHT))
			rotation = RotatedTextIcon.CW;
		else
			throw new InternalError(""Invalid position: "" + position);
		JToggleButton button = new JToggleButton();
		button.setMargin(new Insets(1,1,1,1));
		button.setRequestFocusEnabled(false);
		button.setIcon(new RotatedTextIcon(rotation,button.getFont(),
			entry.title));
		button.setActionCommand(entry.factory.name);
		button.addActionListener(new ActionHandler());
		button.addMouseListener(new MenuMouseHandler());
		if(OperatingSystem.isMacOSLF())
			button.putClientProperty(""JButton.buttonType"",""toolbar"");
		//}}}
		buttonGroup.add(button);
		buttons.add(button);
		entry.btn = button;
		wm.revalidate();
	} //}}}
	//{{{ unregister() method
	public void unregister(DockableWindowManager.Entry entry)
	{
		if(entry.factory.name.equals(mostRecent))
			mostRecent = null;
		buttonPanel.remove(entry.btn);
		buttons.remove(entry.btn);
		entry.btn = null;
		dockables.remove(entry);
		if(entry.win != null)
			dockablePanel.remove(entry.win);
		if(current == entry)
		{
			current = null;
			show(null);
		}
		else
		{
			wm.revalidate();
			dockablePanel.repaint();
			buttonPanel.repaint();
		}
	} //}}}
	//{{{ remove() method
	public void remove(final DockableWindowManager.Entry entry)
	{
		if(entry.factory.name.equals(mostRecent))
			mostRecent = null;
		if(entry.win != null)
		{
			dockablePanel.remove(entry.win);
			entry.win = null;
		}
		if(current == entry)
		{
			current = null;
			show(null);
		}
		else
		{
			wm.revalidate();
			dockablePanel.repaint();
		}
	} //}}}
	//{{{ showMostRecent() method
	public void showMostRecent()
	{
		if(dockables.size() == 0)
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		if(mostRecent == null)
		{
			mostRecent = ((DockableWindowManager.Entry)
				dockables.get(0)).factory.name;
		}
		wm.showDockableWindow(mostRecent);
	} //}}}
	//{{{ show() method
	public void show(final DockableWindowManager.Entry entry)
	{
		if(current == entry)
		{
			if(entry != null)
			{
				if(entry.win instanceof DefaultFocusComponent)
				{
					((DefaultFocusComponent)entry.win)
						.focusOnDefaultComponent();
				}
				else
				{
					entry.win.requestDefaultFocus();
				}
			}
			return;
		}
		if(entry != null)
		{
			if(current == null)
			{
				// we didn't have a component previously, so
				// create a border
				dockablePanel.setBorder(new DockBorder(position));
			}
			mostRecent = entry.factory.name;
			this.current = entry;
			if(entry.win.getParent() != dockablePanel)
				dockablePanel.add(entry.factory.name,entry.win);
			dockablePanel.showDockable(entry.factory.name);
			entry.btn.setSelected(true);
			if(entry.win instanceof DefaultFocusComponent)
			{
				((DefaultFocusComponent)entry.win)
					.focusOnDefaultComponent();
			}
			else
			{
				entry.win.requestDefaultFocus();
			}
		}
		else
		{
			current = null;
			nullButton.setSelected(true);
			// removing last component, so remove border
			dockablePanel.setBorder(null);
			wm.getView().getTextArea().requestFocus();
		}
		wm.revalidate();
		dockablePanel.repaint();
	} //}}}
	//{{{ isVisible() method
	public boolean isVisible(DockableWindowManager.Entry entry)
	{
		return current == entry;
	} //}}}
	//{{{ getCurrent() method
	/**
	 * Returns the name of the dockable in this container.
	 * @since jEdit 4.2pre1
	 */
	public String getCurrent()
	{
		if(current == null)
			return null;
		else
			return current.factory.name;
	} //}}}
	//{{{ getDimension() method
	/**
	 * Returns the width or height (depending on position) of the dockable
	 * window container.
	 * @since jEdit 4.2pre1
	 */
	public int getDimension()
	{
		return dimension;
	} //}}}
	//{{{ getDockables() method
	public String[] getDockables()
	{
		String[] retVal = new String[dockables.size()];
		for(int i = 0; i < dockables.size(); i++)
		{
			DockableWindowManager.Entry entry =
				(DockableWindowManager.Entry) dockables.get(i);
			retVal[i] = entry.factory.name;
		}
		return retVal;
	} //}}}
	//{{{ Package-private members
	static final int SPLITTER_WIDTH = 10;
	DockablePanel dockablePanel;
	JPanel buttonPanel;
	//{{{ save() method
	void save()
	{
		jEdit.setIntegerProperty(""view.dock."" + position + "".dimension"",
			dimension);
		if(current == null)
			jEdit.unsetProperty(""view.dock."" + position + "".last"");
		else
		{
			jEdit.setProperty(""view.dock."" + position + "".last"",
				current.factory.name);
		}
	} //}}}
	//{{{ setDimension() method
	void setDimension(int dimension)
	{
		if(dimension != 0)
			this.dimension = dimension - SPLITTER_WIDTH;
	} //}}}
	//{{{ sortDockables() method
	void sortDockables()
	{
		buttonPanel.removeAll();
		buttonPanel.add(closeBox);
		buttonPanel.add(menuBtn);
		Collections.sort(buttons,new DockableWindowCompare());
		for(int i = 0; i < buttons.size(); i++)
		{
			buttonPanel.add((AbstractButton)buttons.get(i));
		}
	} //}}}
	//{{{ getWrappedDimension() method
	/**
	 * Returns the width or height of wrapped rows or columns.
	 */
	int getWrappedDimension(int dimension)
	{
		return ((ButtonLayout)buttonPanel.getLayout())
			.getWrappedDimension(buttonPanel,dimension);
	} //}}}
	//}}}
	//{{{ Private members
	private DockableWindowManager wm;
	private String position;
	private JButton closeBox;
	private JButton menuBtn;
	private ButtonGroup buttonGroup;
	private JToggleButton nullButton;
	private int dimension;
	private ArrayList dockables;
	private ArrayList buttons;
	private DockableWindowManager.Entry current;
	private JPopupMenu popup;
	// remember the most recent dockable
	private String mostRecent;
	//}}}
	//{{{ Inner classes
	//{{{ DockableWindowCompare class
	static class DockableWindowCompare implements Comparator
	{
		public int compare(Object o1, Object o2)
		{
			String name1 = ((AbstractButton)o1).getActionCommand();
			String name2 = ((AbstractButton)o2).getActionCommand();
			return MiscUtilities.compareStrings(
				jEdit.getProperty(name1 + "".title"",""""),
				jEdit.getProperty(name2 + "".title"",""""),
				true);
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(popup != null && popup.isVisible())
				popup.setVisible(false);
			if(evt.getSource() == closeBox)
				show(null);
			else
			{
				if(wm.isDockableWindowVisible(evt.getActionCommand()))
					show(null);
				else
					wm.showDockableWindow(evt.getActionCommand());
			}
		}
	} //}}}
	//{{{ MenuMouseHandler class
	class MenuMouseHandler extends MouseAdapter
	{
		public void mousePressed(MouseEvent evt)
		{
			if(popup != null && popup.isVisible())
			{
				popup.setVisible(false);
				return;
			}
			Component comp = (Component)evt.getSource();
			String dockable;
			if(comp instanceof JToggleButton)
				dockable = ((JToggleButton)comp).getActionCommand();
			else
				dockable = getCurrent();
			if(comp == menuBtn || GUIUtilities.isPopupTrigger(evt))
			{
				if(dockable == null)
				{
					popup = wm.createPopupMenu(PanelWindowContainer.this,null,false);
				}
				else
				{
					popup = wm.createPopupMenu(PanelWindowContainer.this,dockable,false);
				}
				int x, y;
				boolean point;
				if(comp == menuBtn)
				{
					x = 0;
					y = menuBtn.getHeight();
					point = false;
				}
				else
				{
					x = evt.getX();
					y = evt.getY();
					point = true;
				}
				GUIUtilities.showPopupMenu(popup,
					comp,x,y,point);
			}
		}
	} //}}}
	//{{{ DockBorder class
	static class DockBorder implements Border
	{
		String position;
		Insets insets;
		Color color1;
		Color color2;
		Color color3;
		//{{{ DockBorder constructor
		DockBorder(String position)
		{
			this.position = position;
			insets = new Insets(
				position.equals(DockableWindowManager.BOTTOM)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.RIGHT)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.TOP)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.LEFT)
					? SPLITTER_WIDTH : 0);
		} //}}}
		//{{{ paintBorder() method
		public void paintBorder(Component c, Graphics g,
			int x, int y, int width, int height)
		{
			updateColors();
			if(color1 == null || color2 == null || color3 == null)
				return;
			if(position.equals(DockableWindowManager.BOTTOM))
				paintHorizBorder(g,x,y,width);
			else if(position.equals(DockableWindowManager.RIGHT))
				paintVertBorder(g,x,y,height);
			else if(position.equals(DockableWindowManager.TOP))
			{
				paintHorizBorder(g,x,y + height
					- SPLITTER_WIDTH,width);
			}
			else if(position.equals(DockableWindowManager.LEFT))
			{
				paintVertBorder(g,x + width
					- SPLITTER_WIDTH,y,height);
			}
		} //}}}
		//{{{ getBorderInsets() method
		public Insets getBorderInsets(Component c)
		{
			return insets;
		} //}}}
		//{{{ isBorderOpaque() method
		public boolean isBorderOpaque()
		{
			return false;
		} //}}}
		//{{{ paintHorizBorder() method
		private void paintHorizBorder(Graphics g, int x, int y, int width)
		{
			g.setColor(color3);
			g.fillRect(x,y,width,SPLITTER_WIDTH);
			for(int i = 0; i < width / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + i * 4 + 2,y + 3,
					x + i * 4 + 2,y + 3);
				g.setColor(color2);
				g.drawLine(x + i * 4 + 3,y + 4,
					x + i * 4 + 3,y + 4);
				g.setColor(color1);
				g.drawLine(x + i * 4 + 4,y + 5,
					x + i * 4 + 4,y + 5);
				g.setColor(color2);
				g.drawLine(x + i * 4 + 5,y + 6,
					x + i * 4 + 5,y + 6);
			}
		} //}}}
		//{{{ paintVertBorder() method
		private void paintVertBorder(Graphics g, int x, int y, int height)
		{
			g.setColor(color3);
			g.fillRect(x,y,SPLITTER_WIDTH,height);
			for(int i = 0; i < height / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + 3,y + i * 4 + 2,
					x + 3,y + i * 4 + 2);
				g.setColor(color2);
				g.drawLine(x + 4,y + i * 4 + 3,
					x + 4,y + i * 4 + 3);
				g.setColor(color1);
				g.drawLine(x + 5,y + i * 4 + 4,
					x + 5,y + i * 4 + 4);
				g.setColor(color2);
				g.drawLine(x + 6,y + i * 4 + 5,
					x + 6,y + i * 4 + 5);
			}
		} //}}}
		//{{{ updateColors() method
		private void updateColors()
		{
			if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
			{
				color1 = MetalLookAndFeel.getControlHighlight();
				color2 = MetalLookAndFeel.getControlDarkShadow();
				color3 = MetalLookAndFeel.getControl();
			}
			else
			{
				color1 = color2 = color3 = null;
			}
		} //}}}
	} //}}}
	//{{{ RotatedTextIcon class
	public static class RotatedTextIcon implements Icon
	{
		public static final int NONE = 0;
		public static final int CW = 1;
		public static final int CCW = 2;
		//{{{ RotatedTextIcon constructor
		public RotatedTextIcon(int rotate, Font font, String text)
		{
			this.rotate = rotate;
			this.font = font;
			FontRenderContext fontRenderContext
				= new FontRenderContext(null,true,true);
			this.text = text;
			glyphs = font.createGlyphVector(fontRenderContext,text);
			width = (int)glyphs.getLogicalBounds().getWidth() + 4;
			//height = (int)glyphs.getLogicalBounds().getHeight();
			LineMetrics lineMetrics = font.getLineMetrics(text,fontRenderContext);
			ascent = lineMetrics.getAscent();
			height = (int)lineMetrics.getHeight();
			renderHints = new RenderingHints(
				RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
			renderHints.put(RenderingHints.KEY_FRACTIONALMETRICS,
				RenderingHints.VALUE_FRACTIONALMETRICS_ON);
			renderHints.put(RenderingHints.KEY_RENDERING,
				RenderingHints.VALUE_RENDER_QUALITY);
		} //}}}
		//{{{ getIconWidth() method
		public int getIconWidth()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? height : width);
		} //}}}
		//{{{ getIconHeight() method
		public int getIconHeight()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? width : height);
		} //}}}
		//{{{ paintIcon() method
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g;
			g2d.setFont(font);
			AffineTransform oldTransform = g2d.getTransform();
			RenderingHints oldHints = g2d.getRenderingHints();
			g2d.setRenderingHints(renderHints);
			g2d.setColor(c.getForeground());
			//{{{ No rotation
			if(rotate == RotatedTextIcon.NONE)
			{
				g2d.drawGlyphVector(glyphs,x + 2,y + ascent);
			} //}}}
			//{{{ Clockwise rotation
			else if(rotate == RotatedTextIcon.CW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y + 2);
				trans.rotate(Math.PI / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} //}}}
			//{{{ Counterclockwise rotation
			else if(rotate == RotatedTextIcon.CCW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y - 2);
				trans.rotate(Math.PI * 3 / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} //}}}
			g2d.setTransform(oldTransform);
			g2d.setRenderingHints(oldHints);
		} //}}}
		//{{{ Private members
		private int rotate;
		private Font font;
		private String text;
		private GlyphVector glyphs;
		private float width;
		private float height;
		private float ascent;
		private RenderingHints renderHints;
		//}}}
	} //}}}
	//{{{ ButtonLayout class
	class ButtonLayout implements LayoutManager
	{
		//{{{ addLayoutComponent() method
		public void addLayoutComponent(String name, Component comp) {} //}}}
		//{{{ removeLayoutComponent() method
		public void removeLayoutComponent(Component comp) {} //}}}
		//{{{ getWrappedDimension() method
		/**
		 * Returns the width or height of wrapped rows or columns.
		 */
		int getWrappedDimension(JComponent parent, int dimension)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets((JComponent)parent);
			Component[] comp = parent.getComponents();
			if(comp.length <= 2)
				return 0;
			Dimension dim = comp[2].getPreferredSize();
			if(position.equals(DockableWindowManager.TOP)
				|| position.equals(DockableWindowManager.BOTTOM))
			{
				int width = dimension - insets.right;
				int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);
				int x = rowHeight * 2 + insets.left;
				Dimension returnValue = new Dimension(0,rowHeight
					+ insets.top + insets.bottom);
				for(int i = 2; i < comp.length; i++)
				{
					int btnWidth = comp[i].getPreferredSize().width;
					if(btnWidth + x > width)
					{
						returnValue.height += rowHeight;
						x = insets.left;
					}
					x += btnWidth;
				}
				return returnValue.height;
			}
			else
			{
				int height = dimension - insets.bottom;
				int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);
				int y = colWidth * 2 + insets.top;
				Dimension returnValue = new Dimension(colWidth
					+ insets.left + insets.right,0);
				for(int i = 2; i < comp.length; i++)
				{
					int btnHeight = comp[i].getPreferredSize().height;
					if(btnHeight + y > height)
					{
						returnValue.width += colWidth;
						y = insets.top;
					}
					y += btnHeight;
				}
				return returnValue.width;
			}
		} //}}}
		//{{{ preferredLayoutSize() method
		public Dimension preferredLayoutSize(Container parent)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets((JComponent)parent);
			Component[] comp = parent.getComponents();
			if(comp.length <= 2)
			{
				// nothing 'cept close box
				return new Dimension(0,0);
			}
			Dimension dim = comp[2].getPreferredSize();
			if(position.equals(DockableWindowManager.TOP)
				|| position.equals(DockableWindowManager.BOTTOM))
			{
				int width = parent.getWidth() - insets.right;
				int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);
				int x = rowHeight * 2 + insets.left;
				Dimension returnValue = new Dimension(0,rowHeight
					+ insets.top + insets.bottom);
				for(int i = 2; i < comp.length; i++)
				{
					int btnWidth = comp[i].getPreferredSize().width;
					if(btnWidth + x > width)
					{
						returnValue.height += rowHeight;
						x = insets.left;
					}
					x += btnWidth;
				}
				return returnValue;
			}
			else
			{
				int height = parent.getHeight() - insets.bottom;
				int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);
				int y = colWidth * 2 + insets.top;
				Dimension returnValue = new Dimension(colWidth
					+ insets.left + insets.right,0);
				for(int i = 2; i < comp.length; i++)
				{
					int btnHeight = comp[i].getPreferredSize().height;
					if(btnHeight + y > height)
					{
						returnValue.width += colWidth;
						y = insets.top;
					}
					y += btnHeight;
				}
				return returnValue;
			}
		} //}}}
		//{{{ minimumLayoutSize() method
		public Dimension minimumLayoutSize(Container parent)
		{
			return preferredLayoutSize(parent);
		} //}}}
		//{{{ layoutContainer() method
		public void layoutContainer(Container parent)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets((JComponent)parent);
			Component[] comp = parent.getComponents();
			if(comp.length <= 2)
			{
				for(int i = 0; i < comp.length; i++)
				{
					comp[i].setVisible(false);
				}
				return;
			}
			comp[0].setVisible(true);
			comp[1].setVisible(true);
			Dimension dim = comp[2].getPreferredSize();
			if(position.equals(DockableWindowManager.TOP)
				|| position.equals(DockableWindowManager.BOTTOM))
			{
				int width = parent.getWidth() - insets.right;
				int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);
				int x = rowHeight * 2 + insets.left;
				int y = insets.top;
				closeBox.setBounds(insets.left,insets.top,rowHeight,rowHeight);
				menuBtn.setBounds(insets.left + rowHeight,insets.top,rowHeight,rowHeight);
				for(int i = 2; i < comp.length; i++)
				{
					int btnWidth = comp[i].getPreferredSize().width;
					if(btnWidth + x > width)
					{
						x = insets.left;
						y += rowHeight;
					}
					comp[i].setBounds(x,y,btnWidth,rowHeight);
					x += btnWidth;
				}
				/* if(y + rowHeight != parent.getHeight())
				{
					parent.setSize(
						parent.getWidth(),
						y + rowHeight);
					((JComponent)parent).revalidate();
				} */
			}
			else
			{
				int height = parent.getHeight() - insets.bottom;
				int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);
				int x = insets.left;
				int y = colWidth * 2 + insets.top;
				closeBox.setBounds(insets.left,insets.top,colWidth,colWidth);
				menuBtn.setBounds(insets.left,insets.top + colWidth,colWidth,colWidth);
				for(int i = 2; i < comp.length; i++)
				{
					int btnHeight = comp[i].getPreferredSize().height;
					if(btnHeight + y > height)
					{
						x += colWidth;
						y = insets.top;
					}
					comp[i].setBounds(x,y,colWidth,btnHeight);
					y += btnHeight;
				}
				/* if(x + colWidth != parent.getWidth())
				{
					parent.setSize(x + colWidth,
						parent.getHeight());
					((JComponent)parent).revalidate();
				} */
			}
		} //}}}
	} //}}}
	//{{{ DockablePanel class
	class DockablePanel extends JPanel
	{
		//{{{ DockablePanel constructor
		DockablePanel()
		{
			super(new CardLayout());
			ResizeMouseHandler resizeMouseHandler = new ResizeMouseHandler();
			addMouseListener(resizeMouseHandler);
			addMouseMotionListener(resizeMouseHandler);
		} //}}}
		//{{{ getWindowContainer() method
		PanelWindowContainer getWindowContainer()
		{
			return PanelWindowContainer.this;
		} //}}}
		//{{{ showDockable() method
		void showDockable(String name)
		{
			((CardLayout)getLayout()).show(this,name);
		} //}}}
		//{{{ getMinimumSize() method
		public Dimension getMinimumSize()
		{
			return new Dimension(0,0);
		} //}}}
		//{{{ getPreferredSize() method
		public Dimension getPreferredSize()
		{
			if(current == null)
				return new Dimension(0,0);
			else
			{
				if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
				{
					if(dimension <= 0)
					{
						int height = super.getPreferredSize().height;
						dimension = height - SPLITTER_WIDTH;
					}
					return new Dimension(0,
						dimension + SPLITTER_WIDTH);
				}
				else
				{
					if(dimension <= 0)
					{
						int width = super.getPreferredSize().width;
						dimension = width - SPLITTER_WIDTH;
					}
					return new Dimension(dimension + SPLITTER_WIDTH,
						0);
				}
			}
		} //}}}
		//{{{ setBounds() method
		public void setBounds(int x, int y, int width, int height)
		{
			if(position.equals(DockableWindowManager.TOP) ||
				position.equals(DockableWindowManager.BOTTOM))
			{
				if(dimension != 0 && height <= SPLITTER_WIDTH)
					PanelWindowContainer.this.show(null);
				else
					dimension = height - SPLITTER_WIDTH;
			}
			else
			{
				if(dimension != 0 && width <= SPLITTER_WIDTH)
					PanelWindowContainer.this.show(null);
				else
					dimension = width - SPLITTER_WIDTH;
			}
			super.setBounds(x,y,width,height);
		} //}}}
		//{{{ ResizeMouseHandler class
		class ResizeMouseHandler extends MouseAdapter implements MouseMotionListener
		{
			boolean canDrag;
			Point dragStart;
			//{{{ mousePressed() method
			public void mousePressed(MouseEvent evt)
			{
				if(canDrag)
				{
					wm.setResizePos(dimension,PanelWindowContainer.this);
					dragStart = evt.getPoint();
				}
			} //}}}
			//{{{ mouseReleased() method
			public void mouseReleased(MouseEvent evt)
			{
				if(canDrag)
				{
					dimension = wm.resizePos;
					wm.finishResizing();
					dragStart = null;
					wm.revalidate();
				}
			} //}}}
			//{{{ mouseMoved() method
			public void mouseMoved(MouseEvent evt)
			{
				Border border = getBorder();
				if(border == null)
				{
					// collapsed
					return;
				}
				Insets insets = border.getBorderInsets(DockablePanel.this);
				canDrag = false;
				//{{{ Top...
				if(position.equals(DockableWindowManager.TOP))
				{
					if(evt.getY() >= getHeight() - insets.bottom)
						canDrag = true;
				} //}}}
				//{{{ Left...
				else if(position.equals(DockableWindowManager.LEFT))
				{
					if(evt.getX() >= getWidth() - insets.right)
						canDrag = true;
				} //}}}
				//{{{ Bottom...
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					if(evt.getY() <= insets.top)
						canDrag = true;
				} //}}}
				//{{{ Right...
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					if(evt.getX() <= insets.left)
						canDrag = true;
				} //}}}
				if(canDrag)
				{
					wm.setCursor(Cursor.getPredefinedCursor(
						getAppropriateCursor()));
				}
				else
				{
					wm.setCursor(Cursor.getPredefinedCursor(
						Cursor.DEFAULT_CURSOR));
				}
			} //}}}
			//{{{ mouseDragged() method
			public void mouseDragged(MouseEvent evt)
			{
				if(!canDrag)
					return;
				if(dragStart == null) // can't happen?
					return;
				wm.setCursor(Cursor.getPredefinedCursor(
					getAppropriateCursor()));
				//{{{ Top...
				if(position.equals(DockableWindowManager.TOP))
				{
					wm.setResizePos(
						evt.getY() - dragStart.y
						+ dimension,
						PanelWindowContainer.this);
				} //}}}
				//{{{ Left...
				else if(position.equals(DockableWindowManager.LEFT))
				{
					wm.setResizePos(evt.getX() - dragStart.x
						+ dimension,
						PanelWindowContainer.this);
				} //}}}
				//{{{ Bottom...
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					wm.setResizePos(dimension - evt.getY()
						+ dragStart.y,
						PanelWindowContainer.this);
				} //}}}
				//{{{ Right...
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					wm.setResizePos(dimension - evt.getX()
						+ dragStart.x,
						PanelWindowContainer.this);
				} //}}}
			} //}}}
			//{{{ mouseExited() method
			public void mouseExited(MouseEvent evt)
			{
				wm.setCursor(Cursor.getPredefinedCursor(
					Cursor.DEFAULT_CURSOR));
			} //}}}
			//{{{ getCursor() method
			private int getAppropriateCursor()
			{
				if(position.equals(DockableWindowManager.TOP))
					return Cursor.N_RESIZE_CURSOR;
				else if(position.equals(DockableWindowManager.LEFT))
					return Cursor.W_RESIZE_CURSOR;
				else if(position.equals(DockableWindowManager.BOTTOM))
					return Cursor.S_RESIZE_CURSOR;
				else if(position.equals(DockableWindowManager.RIGHT))
					return Cursor.E_RESIZE_CURSOR;
				else
					throw new InternalError();
			} //}}}
		} //}}}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.PasteFromListDialog,"/*
 * PasteFromListDialog.java - Paste previous/paste deleted dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
//}}}
public class PasteFromListDialog extends EnhancedDialog
{
	//{{{ PasteFromListDialog constructor
	public PasteFromListDialog(String name, View view, ListModel model)
	{
		super(view,jEdit.getProperty(name + "".title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel center = new JPanel(new GridLayout(2,1,2,12));
		clips = new JList(model);
		clips.setCellRenderer(new Renderer());
		clips.setVisibleRowCount(12);
		clips.addMouseListener(new MouseHandler());
		clips.addListSelectionListener(new ListHandler());
		insert = new JButton(jEdit.getProperty(""common.insert""));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		JLabel label = new JLabel(jEdit.getProperty(name + "".caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);
		JScrollPane scroller = new JScrollPane(clips);
		scroller.setPreferredSize(new Dimension(500,150));
		center.add(scroller);
		clipText = new JTextArea();
		clipText.setEditable(false);
		scroller = new JScrollPane(clipText);
		scroller.setPreferredSize(new Dimension(500,150));
		center.add(scroller);
		content.add(center, BorderLayout.CENTER);
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		panel.add(insert);
		panel.add(Box.createHorizontalStrut(6));
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel, BorderLayout.SOUTH);
		if(model.getSize() >= 1)
			clips.setSelectedIndex(0);
		updateButtons();
		getRootPane().setDefaultButton(insert);
		insert.addActionListener(new ActionHandler());
		cancel.addActionListener(new ActionHandler());
		GUIUtilities.requestFocus(this,clips);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		Object[] selected = clips.getSelectedValues();
		if(selected == null || selected.length == 0)
		{
			getToolkit().beep();
			return;
		}
		view.getTextArea().setSelectedText(getSelectedClipText());
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private View view;
	private JList clips;
	private JTextArea clipText;
	private JButton insert;
	private JButton cancel;
	//}}}
	//{{{ getSelectedClipText()
	private String getSelectedClipText()
	{
		Object[] selected = clips.getSelectedValues();
		StringBuffer clip = new StringBuffer();
		for(int i = 0; i < selected.length; i++)
		{
			if(i != 0)
				clip.append('\n');
			clip.append(selected[i]);
		}
		return clip.toString();
	}
	//}}}
	//{{{ updateButtons() method
	private void updateButtons()
	{
		int selected = clips.getSelectedIndex();
		insert.setEnabled(selected != -1);
	} //}}}
	//{{{ showClipText() method
	private void showClipText()
	{
		Object[] selected = clips.getSelectedValues();
		if(selected == null || selected.length == 0)
			clipText.setText("""");
		else
			clipText.setText(getSelectedClipText());
		clipText.setCaretPosition(0);
	}
	//}}}
	//}}}
	//{{{ Renderer class
	class Renderer extends DefaultListCellRenderer
	{
		String shorten(String item)
		{
			StringBuffer buf = new StringBuffer();
			// workaround for Swing rendering labels starting
			// with <html> using the HTML engine
			if(item.toLowerCase().startsWith(""<html>""))
				buf.append(' ');
			boolean ws = true;
			for(int i = 0; i < item.length(); i++)
			{
				char ch = item.charAt(i);
				if(Character.isWhitespace(ch))
				{
					if(ws)
						/* do nothing */;
					else
					{
						buf.append(' ');
						ws = true;
					}
				}
				else
				{
					ws = false;
					buf.append(ch);
				}
			}
			if(buf.length() == 0)
				return jEdit.getProperty(""paste-from-list.whitespace"");
			return buf.toString();
		}
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			setText(shorten(value.toString()));
			return this;
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == insert)
				ok();
			else if(source == cancel)
				cancel();
		}
	} //}}}
	//{{{ ListHandler class
	class ListHandler implements ListSelectionListener
	{
		//{{{ valueChanged() method
		public void valueChanged(ListSelectionEvent evt)
		{
			showClipText();
			updateButtons();
		} //}}}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			if(evt.getClickCount() == 2)
				ok();
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.RolloverButton,"/*
 * RolloverButton.java - Class for buttons that implement rollovers
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki
 * Portions copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import java.lang.reflect.Method;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.plaf.basic.BasicButtonUI;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.util.Log;
//}}}
/**
 * If you wish to have rollovers on your buttons, use this class.
 *
 * Unlike the Swing rollover support, this class works outside of
 * <code>JToolBar</code>s, and does not require undocumented client
 * property hacks or JDK1.4-specific API calls.<p>
 *
 * Note: You should not call <code>setBorder()</code> on your buttons,
 * as they probably won't work properly.
 */
public class RolloverButton extends JButton
{
	//{{{ RolloverButton constructor
	/**
	 * Setup the border (invisible initially)
	 */
	public RolloverButton()
	{
		if(OperatingSystem.hasJava15())
			setContentAreaFilled(false);
		if(method != null)
		{
			try
			{
				method.invoke(this,new Boolean[] { Boolean.TRUE });
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
		else
		{
			addMouseListener(new MouseOverHandler());
		}
	} //}}}
	//{{{ RolloverButton constructor
	/**
	 * Setup the border (invisible initially)
	 */
	public RolloverButton(Icon icon)
	{
		this();
		setIcon(icon);
	} //}}}
	//{{{ updateUI() method
	public void updateUI()
	{
		if(OperatingSystem.isWindows())
		{
			/* Workaround for uncooperative Windows L&F */
			setUI(new BasicButtonUI());
		}
		else
			super.updateUI();
		setBorder(new EtchedBorder());
		setBorderPainted(false);
		setMargin(new Insets(1,1,1,1));
		setRequestFocusEnabled(false);
	} //}}}
	//{{{ isOpaque() method
	public boolean isOpaque()
	{
		return false;
	} //}}}
	//{{{ setEnabled() method
	public void setEnabled(boolean b)
	{
		super.setEnabled(b);
		if(method == null)
		{
			setBorderPainted(false);
			repaint();
		}
	} //}}}
	//{{{ setBorderPainted() method
	public void setBorderPainted(boolean b)
	{
		try
		{
			revalidateBlocked = true;
			super.setBorderPainted(b);
		}
		finally
		{
			revalidateBlocked = false;
		}
	} //}}}
	//{{{ revalidate() method
	/**
	 * We block calls to revalidate() from a setBorderPainted(), for
	 * performance reasons.
	 */
	public void revalidate()
	{
		if(!revalidateBlocked)
			super.revalidate();
	} //}}}
	//{{{ paint() method
	public void paint(Graphics g)
	{
		if(method != null || isEnabled())
			super.paint(g);
		else
		{
			Graphics2D g2 = (Graphics2D)g;
			g2.setComposite(c);
			super.paint(g2);
		}
	} //}}}
	//{{{ Private members
	private static AlphaComposite c = AlphaComposite.getInstance(
		AlphaComposite.SRC_OVER, 0.5f);
	private static Method method;
	private boolean revalidateBlocked;
	static
	{
		/* if(OperatingSystem.hasJava14())
		{
			try
			{
				method = RolloverButton.class
					.getMethod(""setRolloverEnabled"",new Class[]
					{ boolean.class });
				Log.log(Log.DEBUG,RolloverButton.class,
					""Java 1.4 setRolloverEnabled() method enabled"");
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,RolloverButton.class,e);
			}
		} */
	} //}}}
	//{{{ MouseHandler class
	/**
	 * Make the border visible/invisible on rollovers
	 */
	class MouseOverHandler extends MouseAdapter
	{
		public void mouseEntered(MouseEvent e)
		{
			if (isEnabled())
				setBorderPainted(true);
		}
		public void mouseExited(MouseEvent e)
		{
			setBorderPainted(false);
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.SelectLineRange,"/*
 * SelectLineRange.java - Selects a range of lines
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
//}}}
public class SelectLineRange extends EnhancedDialog implements ActionListener
{
	//{{{ SelectLineRange constructor
	public SelectLineRange(View view)
	{
		super(view,jEdit.getProperty(""selectlinerange.title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,0));
		setContentPane(content);
		JLabel label = new JLabel(jEdit.getProperty(
			""selectlinerange.caption""));
		label.setBorder(new EmptyBorder(0,0,6,12));
		content.add(BorderLayout.NORTH,label);
		JPanel panel = createFieldPanel();
		content.add(BorderLayout.CENTER,panel);
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(6,0,0,12));
		panel.add(Box.createGlue());
		panel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel,BorderLayout.SOUTH);
		GUIUtilities.requestFocus(this,startField);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		int startLine;
		int endLine;
		try
		{
			startLine = Integer.parseInt(startField.getText()) - 1;
			endLine = Integer.parseInt(endField.getText()) - 1;
		}
		catch(NumberFormatException nf)
		{
			getToolkit().beep();
			return;
		}
		Buffer buffer = view.getBuffer();
		if(startLine < 0 || endLine >= buffer.getLineCount()
			|| startLine > endLine)
		{
			getToolkit().beep();
			return;
		}
		JEditTextArea textArea = view.getTextArea();
		Selection s = new Selection.Range(
			buffer.getLineStartOffset(startLine),
			buffer.getLineEndOffset(endLine) - 1);
		if(textArea.isMultipleSelectionEnabled())
			textArea.addToSelection(s);
		else
			textArea.setSelection(s);
		textArea.moveCaretPosition(buffer.getLineEndOffset(endLine) - 1);
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ actionPerformed() method
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private View view;
	private JTextField startField;
	private JTextField endField;
	private JButton ok;
	private JButton cancel;
	//}}}
	//{{{ createFieldPanel() method
	private JPanel createFieldPanel()
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.insets = new Insets(0,0,6,12);
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		JLabel label = new JLabel(jEdit.getProperty(""selectlinerange.start""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		startField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(startField,cons);
		panel.add(startField);
		label = new JLabel(jEdit.getProperty(""selectlinerange.end""),
			SwingConstants.RIGHT);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(label,cons);
		panel.add(label);
		endField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(endField,cons);
		panel.add(endField);
		return panel;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.gui.SplashScreen,"/*
 * SplashScreen.java - Splash screen
 * Copyright (C) 1998, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;
/**
 * The splash screen displayed on startup.
 */
public class SplashScreen extends JComponent
{
	public SplashScreen()
	{
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		setBackground(Color.white);
		Font font = new Font(""Dialog"",Font.PLAIN,10);
		setFont(font);
		fm = getFontMetrics(font);
		image = getToolkit().getImage(
			getClass().getResource(""/org/gjt/sp/jedit/icons/splash.png""));
		MediaTracker tracker = new MediaTracker(this);
		tracker.addImage(image,0);
		try
		{
			tracker.waitForAll();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
		win = new JWindow();
		Dimension screen = getToolkit().getScreenSize();
		Dimension size = new Dimension(image.getWidth(this) + 2,
			image.getHeight(this) + 2 + PROGRESS_HEIGHT);
		win.setSize(size);
		win.getContentPane().add(BorderLayout.CENTER,this);
		win.setLocation((screen.width - size.width) / 2,
			(screen.height - size.height) / 2);
		win.validate();
		win.setVisible(true);
		/*synchronized(this)
		{
			try
			{
				wait();
			}
			catch(InterruptedException ie)
			{
				Log.log(Log.ERROR,this,ie);
			}
		}*/
	}
	public void dispose()
	{
		win.dispose();
	}
	public synchronized void advance()
	{
		progress++;
		repaint();
		// wait for it to be painted to ensure progress is updated
		// continuously
		try
		{
			wait();
		}
		catch(InterruptedException ie)
		{
			Log.log(Log.ERROR,this,ie);
		}
	}
	public synchronized void paintComponent(Graphics g)
	{
		Dimension size = getSize();
		g.setColor(Color.black);
		g.drawRect(0,0,size.width - 1,size.height - 1);
		g.drawImage(image,1,1,this);
		// XXX: This should not be hardcoded
		g.setColor(Color.white);
		g.fillRect(1,image.getHeight(this) + 1,
			((win.getWidth() - 2) * progress) / 5,PROGRESS_HEIGHT);
		g.setColor(Color.black);
		String str = ""VERSION "" + jEdit.getVersion();
		g.drawString(str,
			(getWidth() - fm.stringWidth(str)) / 2,
			image.getHeight(this) + (PROGRESS_HEIGHT
			+ fm.getAscent() + fm.getDescent()) / 2);
		notify();
	}
	// private members
	private FontMetrics fm;
	private JWindow win;
	private Image image;
	private int progress;
	private static final int PROGRESS_HEIGHT = 20;
}
"
org.gjt.sp.jedit.gui.StatusBar,"/*
 * StatusBar.java - The status bar displayed at the bottom of views
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 * Portions copyright (C) 2001 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.text.Segment;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import java.text.*;
import java.util.Calendar;
import java.util.Date;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
//}}}
/**
 * The status bar used to display various information to the user.<p>
 *
 * Currently, it is used for the following:
 * <ul>
 * <li>Displaying caret position information
 * <li>Displaying {@link InputHandler#readNextChar(String,String)} prompts
 * <li>Displaying {@link #setMessage(String)} messages
 * <li>Displaying I/O progress
 * <li>Displaying various editor settings
 * <li>Displaying memory status
 * </ul>
 *
 * @version $Id: StatusBar.java,v 1.65 2004/07/12 19:25:07 spestov Exp $
 * @author Slava Pestov
 * @since jEdit 3.2pre2
 */
public class StatusBar extends JPanel implements WorkThreadProgressListener
{
	//{{{ StatusBar constructor
	public StatusBar(View view)
	{
		super(new BorderLayout());
		setBorder(new CompoundBorder(new EmptyBorder(4,0,0,
			(OperatingSystem.isMacOS() ? 18 : 0)),
			UIManager.getBorder(""TextField.border"")));
		this.view = view;
		panel = new JPanel(new BorderLayout());
		box = new Box(BoxLayout.X_AXIS);
		panel.add(BorderLayout.EAST,box);
		add(BorderLayout.CENTER,panel);
		MouseHandler mouseHandler = new MouseHandler();
		caretStatus = new ToolTipLabel();
		caretStatus.setToolTipText(jEdit.getProperty(""view.status.caret-tooltip""));
		caretStatus.addMouseListener(mouseHandler);
		message = new JLabel("" "");
		setMessageComponent(message);
		mode = new ToolTipLabel();
		mode.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
		mode.addMouseListener(mouseHandler);
		wrap = new ToolTipLabel();
		wrap.setHorizontalAlignment(SwingConstants.CENTER);
		wrap.setToolTipText(jEdit.getProperty(""view.status.wrap-tooltip""));
		wrap.addMouseListener(mouseHandler);
		multiSelect = new ToolTipLabel();
		multiSelect.setHorizontalAlignment(SwingConstants.CENTER);
		multiSelect.setToolTipText(jEdit.getProperty(""view.status.multi-tooltip""));
		multiSelect.addMouseListener(mouseHandler);
		rectSelect = new ToolTipLabel();
		rectSelect.setHorizontalAlignment(SwingConstants.CENTER);
		rectSelect.setToolTipText(jEdit.getProperty(""view.status.rect-tooltip""));
		rectSelect.addMouseListener(mouseHandler);
		overwrite = new ToolTipLabel();
		overwrite.setHorizontalAlignment(SwingConstants.CENTER);
		overwrite.setToolTipText(jEdit.getProperty(""view.status.overwrite-tooltip""));
		overwrite.addMouseListener(mouseHandler);
		lineSep = new ToolTipLabel();
		lineSep.setHorizontalAlignment(SwingConstants.CENTER);
		lineSep.setToolTipText(jEdit.getProperty(""view.status.linesep-tooltip""));
		lineSep.addMouseListener(mouseHandler);
	} //}}}
	//{{{ propertiesChanged() method
	public void propertiesChanged()
	{
		Color fg = jEdit.getColorProperty(""view.status.foreground"");
		Color bg = jEdit.getColorProperty(""view.status.background"");
		showCaretStatus = jEdit.getBooleanProperty(""view.status.show-caret-status"");
		showEditMode = jEdit.getBooleanProperty(""view.status.show-edit-mode"");
		showFoldMode = jEdit.getBooleanProperty(""view.status.show-fold-mode"");
		showEncoding = jEdit.getBooleanProperty(""view.status.show-encoding"");
		showWrap = jEdit.getBooleanProperty(""view.status.show-wrap"");
		showMultiSelect = jEdit.getBooleanProperty(""view.status.show-multi-select"");
		showRectSelect = jEdit.getBooleanProperty(""view.status.show-rect-select"");
		showOverwrite = jEdit.getBooleanProperty(""view.status.show-overwrite"");
		showLineSeperator = jEdit.getBooleanProperty(""view.status.show-line-seperator"");
		boolean showMemory = jEdit.getBooleanProperty(""view.status.show-memory"");
		boolean showClock = jEdit.getBooleanProperty(""view.status.show-clock"");
		panel.setBackground(bg);
		panel.setForeground(fg);
		caretStatus.setBackground(bg);
		caretStatus.setForeground(fg);
		message.setBackground(bg);
		message.setForeground(fg);
		mode.setBackground(bg);
		mode.setForeground(fg);
		wrap.setBackground(bg);
		wrap.setForeground(fg);
		multiSelect.setBackground(bg);
		multiSelect.setForeground(fg);
		rectSelect.setBackground(bg);
		rectSelect.setForeground(fg);
		overwrite.setBackground(bg);
		overwrite.setForeground(fg);
		lineSep.setBackground(bg);
		lineSep.setForeground(fg);
		// retarded GTK look and feel!
		Font font = new JLabel().getFont();
		//UIManager.getFont(""Label.font"");
		FontMetrics fm = getFontMetrics(font);
		Dimension dim = null;
		if (showCaretStatus)
		{
			panel.add(BorderLayout.WEST,caretStatus);
			caretStatus.setFont(font);
			dim = new Dimension(fm.stringWidth(caretTestStr),
				fm.getHeight());
                        caretStatus.setPreferredSize(dim);
		}
		else
			panel.remove(caretStatus);
		box.removeAll();
		if (showEncoding || showEditMode || showFoldMode)
			box.add(mode);
		if (showWrap)
		{
			dim = new Dimension(Math.max(
				Math.max(fm.charWidth('-'),fm.charWidth('H')),
				fm.charWidth('S')) + 1,fm.getHeight());
			wrap.setPreferredSize(dim);
			wrap.setMaximumSize(dim);
			box.add(wrap);
		}
		if (showMultiSelect)
		{
			dim = new Dimension(
				Math.max(fm.charWidth('-'),fm.charWidth('M')) + 1,
				fm.getHeight());
			multiSelect.setPreferredSize(dim);
			multiSelect.setMaximumSize(dim);
			box.add(multiSelect);
		}
		if (showRectSelect)
		{
			dim = new Dimension(
				Math.max(fm.charWidth('-'),fm.charWidth('R')) + 1,
				fm.getHeight());
			rectSelect.setPreferredSize(dim);
			rectSelect.setMaximumSize(dim);
			box.add(rectSelect);
		}
		if (showOverwrite)
		{
			dim = new Dimension(
				Math.max(fm.charWidth('-'),fm.charWidth('O')) + 1,
				fm.getHeight());
			overwrite.setPreferredSize(dim);
			overwrite.setMaximumSize(dim);
			box.add(overwrite);
		}
		if (showLineSeperator)
		{
			dim = new Dimension(Math.max(
				Math.max(fm.charWidth('U'),
				fm.charWidth('W')),
				fm.charWidth('M')) + 1,
				fm.getHeight());
			lineSep.setPreferredSize(dim);
			lineSep.setMaximumSize(dim);
			box.add(lineSep);
		}
		if (showMemory)
			box.add(new MemoryStatus());
		if (showClock)
			box.add(new Clock());
		updateBufferStatus();
		updateMiscStatus();
	} //}}}
	//{{{ addNotify() method
	public void addNotify()
	{
		super.addNotify();
		VFSManager.getIOThreadPool().addProgressListener(this);
	} //}}}
	//{{{ removeNotify() method
	public void removeNotify()
	{
		super.removeNotify();
		VFSManager.getIOThreadPool().removeProgressListener(this);
	} //}}}
	//{{{ WorkThreadListener implementation
	//{{{ statusUpdate() method
	public void statusUpdate(final WorkThreadPool threadPool, int threadIndex)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				// don't obscure existing message
				if(message != null && !"""".equals(message.getText().trim())
					&& !currentMessageIsIO)
					return;
				int requestCount = threadPool.getRequestCount();
				if(requestCount == 0)
				{
					setMessageAndClear(jEdit.getProperty(
						""view.status.io.done""));
					currentMessageIsIO = true;
				}
				else if(requestCount == 1)
				{
					setMessage(jEdit.getProperty(
						""view.status.io-1""));
					currentMessageIsIO = true;
				}
				else
				{
					Object[] args = { new Integer(requestCount) };
					setMessage(jEdit.getProperty(
						""view.status.io"",args));
					currentMessageIsIO = true;
				}
			}
		});
	} //}}}
	//{{{ progressUpdate() method
	public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
	{
	} //}}}
	//}}}
	//{{{ setMessageAndClear() method
	/**
	 * Show a message for a short period of time.
	 * @param message The message
	 * @since jEdit 3.2pre5
	 */
	public void setMessageAndClear(String message)
	{
		setMessage(message);
		tempTimer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				// so if view is closed in the meantime...
				if(isShowing())
					setMessage(null);
			}
		});
		tempTimer.setInitialDelay(10000);
		tempTimer.setRepeats(false);
		tempTimer.start();
	} //}}}
	//{{{ setMessage() method
	/**
	 * Displays a status message.
	 */
	public void setMessage(String message)
	{
		if(tempTimer != null)
		{
			tempTimer.stop();
			tempTimer = null;
		}
		setMessageComponent(this.message);
		if(message == null)
		{
			if(view.getMacroRecorder() != null)
				this.message.setText(jEdit.getProperty(""view.status.recording""));
			else
				this.message.setText("" "");
		}
		else
			this.message.setText(message);
	} //}}}
	//{{{ setMessageComponent() method
	public void setMessageComponent(Component comp)
	{
		currentMessageIsIO = false;
		if (comp == null || messageComp == comp)
		{
			return;
		}
		messageComp = comp;
		panel.add(BorderLayout.CENTER, messageComp);
	} //}}}
	//{{{ updateCaretStatus() method
	public void updateCaretStatus()
	{
		//if(!isShowing())
		//	return;
		if (showCaretStatus)
		{
			Buffer buffer = view.getBuffer();
			if(!buffer.isLoaded() ||
				/* can happen when switching buffers sometimes */
				buffer != view.getTextArea().getBuffer())
			{
				caretStatus.setText("" "");
				return;
			}
			JEditTextArea textArea = view.getTextArea();
			int currLine = textArea.getCaretLine();
			// there must be a better way of fixing this...
			// the problem is that this method can sometimes
			// be called as a result of a text area scroll
			// event, in which case the caret position has
			// not been updated yet.
			if(currLine >= buffer.getLineCount())
				return; // hopefully another caret update will come?
			int start = textArea.getLineStartOffset(currLine);
			int dot = textArea.getCaretPosition() - start;
			// see above
			if(dot < 0)
				return;
			buffer.getText(start,dot,seg);
			int virtualPosition = MiscUtilities.getVirtualWidth(seg,
				buffer.getTabSize());
			buf.setLength(0);
			buf.append(Integer.toString(currLine + 1));
			buf.append(',');
			buf.append(Integer.toString(dot + 1));
			if (virtualPosition != dot)
			{
				buf.append('-');
				buf.append(Integer.toString(virtualPosition + 1));
			}
			buf.append(' ');
			int firstLine = textArea.getFirstLine();
			int visible = textArea.getVisibleLines();
			int lineCount = textArea.getDisplayManager().getScrollLineCount();
			if (visible >= lineCount)
			{
				buf.append(""All"");
			}
			else if (firstLine == 0)
			{
				buf.append(""Top"");
			}
			else if (firstLine + visible >= lineCount)
			{
				buf.append(""Bot"");
			}
			else
			{
				float percent = (float)firstLine / (float)lineCount
					* 100.0f;
				buf.append(Integer.toString((int)percent));
				buf.append('%');
			}
			caretStatus.setText(buf.toString());
		}
	} //}}}
	//{{{ updateBufferStatus() method
	public void updateBufferStatus()
	{
		//if(!isShowing())
		//	return;
		Buffer buffer = view.getBuffer();
		if (showWrap)
		{
			String wrap = buffer.getStringProperty(""wrap"");
			if(wrap.equals(""none""))
				this.wrap.setText(""-"");
			else if(wrap.equals(""hard""))
				this.wrap.setText(""H"");
			else if(wrap.equals(""soft""))
				this.wrap.setText(""S"");
		}
		if (showLineSeperator)
		{
			String lineSep = buffer.getStringProperty(""lineSeparator"");
			if(""\n"".equals(lineSep))
				this.lineSep.setText(""U"");
			else if(""\r\n"".equals(lineSep))
				this.lineSep.setText(""W"");
			else if(""\r"".equals(lineSep))
				this.lineSep.setText(""M"");
		}
		if (showEditMode || showFoldMode || showEncoding)
		{
			/* This doesn't look pretty and mode line should
			 * probably be split up into seperate
			 * components/strings
			 */
			buf.setLength(0);
			if (buffer.isLoaded())
			{
				if (showEditMode)
					buf.append(buffer.getMode().getName());
				if (showFoldMode)
				{
					if (showEditMode)
						buf.append("","");
					buf.append((String)view.getBuffer().getProperty(""folding""));
				}
				if (showEncoding)
				{
					if (showEditMode || showFoldMode)
						buf.append("","");
					buf.append(buffer.getStringProperty(""encoding""));
				}
			}
			mode.setText(""("" + buf.toString() + "")"");
		}
	} //}}}
	//{{{ updateMiscStatus() method
	public void updateMiscStatus()
	{
		//if(!isShowing())
		//	return;
		JEditTextArea textArea = view.getTextArea();
		if (showMultiSelect)
			multiSelect.setText(textArea.isMultipleSelectionEnabled()
				? ""M"" : ""-"");
		if (showRectSelect)
			rectSelect.setText(textArea.isRectangularSelectionEnabled()
				? ""R"" : ""-"");
		if (showOverwrite)
			overwrite.setText(textArea.isOverwriteEnabled()
				? ""O"" : ""-"");
	} //}}}
	//{{{ Private members
	private View view;
	private JPanel panel;
	private Box box;
	private ToolTipLabel caretStatus;
	private Component messageComp;
	private JLabel message;
	private JLabel mode;
	private JLabel wrap;
	private JLabel multiSelect;
	private JLabel rectSelect;
	private JLabel overwrite;
	private JLabel lineSep;
	/* package-private for speed */ StringBuffer buf = new StringBuffer();
	private Timer tempTimer;
	private boolean currentMessageIsIO;
	private Segment seg = new Segment();
	private boolean showCaretStatus;
	private boolean showEditMode;
	private boolean showFoldMode;
	private boolean showEncoding;
	private boolean showWrap;
	private boolean showMultiSelect;
	private boolean showRectSelect;
	private boolean showOverwrite;
	private boolean showLineSeperator;
	//}}}
	static final String caretTestStr = ""9999,999-999 99%"";
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Buffer buffer = view.getBuffer();
			Object source = evt.getSource();
			if(source == caretStatus)
			{
				if(evt.getClickCount() == 2)
					view.getTextArea().showGoToLineDialog();
			}
			else if(source == mode)
			{
				if(evt.getClickCount() == 2)
					new BufferOptions(view,view.getBuffer());
			}
			else if(source == wrap)
				buffer.toggleWordWrap(view);
			else if(source == multiSelect)
				view.getTextArea().toggleMultipleSelectionEnabled();
			else if(source == rectSelect)
				view.getTextArea().toggleRectangularSelectionEnabled();
			else if(source == overwrite)
				view.getTextArea().toggleOverwriteEnabled();
			else if(source == lineSep)
				buffer.toggleLineSeparator(view);
		}
	} //}}}
	//{{{ ToolTipLabel class
	class ToolTipLabel extends JLabel
	{
		//{{{ getToolTipLocation() method
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} //}}}
	} //}}}
	//{{{ MemoryStatus class
	class MemoryStatus extends JComponent implements ActionListener
	{
		//{{{ MemoryStatus constructor
		public MemoryStatus()
		{
			// fucking GTK look and feel
			Font font = new JLabel().getFont();
			//Font font = UIManager.getFont(""Label.font"");
			MemoryStatus.this.setFont(font);
			FontRenderContext frc = new FontRenderContext(
				null,false,false);
			Rectangle2D bounds = font.getStringBounds(		
				memoryTestStr,frc);
			Dimension dim = new Dimension((int)bounds.getWidth(),
				(int)bounds.getHeight());
			setPreferredSize(dim);
			setMaximumSize(dim);
			lm = font.getLineMetrics(memoryTestStr,frc);
			setForeground(jEdit.getColorProperty(""view.status.foreground""));
			setBackground(jEdit.getColorProperty(""view.status.background""));
			progressForeground = jEdit.getColorProperty(
				""view.status.memory.foreground"");
			progressBackground = jEdit.getColorProperty(
				""view.status.memory.background"");
			addMouseListener(new MouseHandler());
		} //}}}
		//{{{ addNotify() method
		public void addNotify()
		{
			super.addNotify();
			timer = new Timer(2000,this);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} //}}}
		//{{{ removeNotify() method
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
			super.removeNotify();
		} //}}}
		//{{{ getToolTipText() method
		public String getToolTipText()
		{
			Runtime runtime = Runtime.getRuntime();
			int freeMemory = (int)(runtime.freeMemory() / 1024);
			int totalMemory = (int)(runtime.totalMemory() / 1024);
			int usedMemory = (totalMemory - freeMemory);
			Integer[] args = { new Integer(usedMemory),
				new Integer(totalMemory) };
			return jEdit.getProperty(""view.status.memory-tooltip"",args);
		} //}}}
		//{{{ getToolTipLocation() method
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} //}}}
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			MemoryStatus.this.repaint();
		} //}}}
		//{{{ paintComponent() method
		public void paintComponent(Graphics g)
		{
			Insets insets = new Insets(0,0,0,0);//MemoryStatus.this.getBorder().getBorderInsets(this);
			Runtime runtime = Runtime.getRuntime();
			int freeMemory = (int)(runtime.freeMemory() / 1024);
			int totalMemory = (int)(runtime.totalMemory() / 1024);
			int usedMemory = (totalMemory - freeMemory);
			int width = MemoryStatus.this.getWidth()
				- insets.left - insets.right;
			int height = MemoryStatus.this.getHeight()
				- insets.top - insets.bottom - 1;
			float fraction = ((float)usedMemory) / totalMemory;
			g.setColor(progressBackground);
			g.fillRect(insets.left,insets.top,
				(int)(width * fraction),
				height);
			String str = (usedMemory / 1024) + ""/""
				+ (totalMemory / 1024) + ""Mb"";
			FontRenderContext frc = new FontRenderContext(null,false,false);
			Rectangle2D bounds = g.getFont().getStringBounds(str,frc);
			Graphics g2 = g.create();
			g2.setClip(insets.left,insets.top,
				(int)(width * fraction),
				height);
			g2.setColor(progressForeground);
			g2.drawString(str,
				insets.left + (int)(width - bounds.getWidth()) / 2,
				(int)(insets.top + lm.getAscent()));
			g2.dispose();
			g2 = g.create();
			g2.setClip(insets.left + (int)(width * fraction),
				insets.top,MemoryStatus.this.getWidth()
				- insets.left - (int)(width * fraction),
				height);
			g2.setColor(MemoryStatus.this.getForeground());
			g2.drawString(str,
				insets.left + (int)(width - bounds.getWidth()) / 2,
				(int)(insets.top + lm.getAscent()));
			g2.dispose();
		} //}}}
		//{{{ Private members
		private static final String memoryTestStr = ""999/999Mb"";
		private LineMetrics lm;
		private Color progressForeground;
		private Color progressBackground;
		private Timer timer;
		//}}}
		//{{{ MouseHandler class
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(evt.getClickCount() == 2)
				{
					jEdit.showMemoryDialog(view);
					repaint();
				}
			}
		} //}}}
	} //}}}
	//{{{ Clock class
	class Clock extends JLabel implements ActionListener
	{
		//{{{ Clock constructor
		public Clock()
		{
			/* FontRenderContext frc = new FontRenderContext(
				null,false,false);
			Rectangle2D bounds = getFont()
				.getStringBounds(getTime(),frc);
			Dimension dim = new Dimension((int)bounds.getWidth(),
				(int)bounds.getHeight());
			setPreferredSize(dim);
			setMaximumSize(dim); */
			setForeground(jEdit.getColorProperty(""view.status.foreground""));
			setBackground(jEdit.getColorProperty(""view.status.background""));
		} //}}}
		//{{{ addNotify() method
		public void addNotify()
		{
			super.addNotify();
			update();
			int millisecondsPerMinute = 1000 * 60;
			timer = new Timer(millisecondsPerMinute,this);
			timer.setInitialDelay((int)(
				millisecondsPerMinute
				- System.currentTimeMillis()
				% millisecondsPerMinute) + 500);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} //}}}
		//{{{ removeNotify() method
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
			super.removeNotify();
		} //}}}
		//{{{ getToolTipText() method
		public String getToolTipText()
		{
			return new Date().toString();
		} //}}}
		//{{{ getToolTipLocation() method
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} //}}}
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			update();
		} //}}}
		//{{{ Private members
		private Timer timer;
		//{{{ getTime() method
		private String getTime()
		{
			return DateFormat.getTimeInstance(
				DateFormat.SHORT).format(new Date());
		} //}}}
		//{{{ update() method
		private void update()
		{
			setText(getTime());
		} //}}}
		//}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.TextAreaDialog,"/*
 * TextAreaDialog.java - A dialog box with a text area
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
//}}}
public class TextAreaDialog extends EnhancedDialog
{
	//{{{ TextAreaDialog constructor
	public TextAreaDialog(Frame frame, String title, String caption,
		Icon icon, String text)
	{
		super(frame,title,true);
		init(caption,icon,text);
	} //}}}
	//{{{ TextAreaDialog constructor
	public TextAreaDialog(Frame frame, String name, Throwable t)
	{
		this(frame,jEdit.getProperty(name + "".title""),
			jEdit.getProperty(name + "".message""),
			UIManager.getIcon(""OptionPane.errorIcon""),
			MiscUtilities.throwableToString(t));
	} //}}}
	//{{{ TextAreaDialog constructor
	public TextAreaDialog(Dialog frame, String title, String caption,
		Icon icon, String text)
	{
		super(frame,title,true);
		init(caption,icon,text);
	} //}}}
	//{{{ TextAreaDialog constructor
	public TextAreaDialog(Dialog frame, String name, Throwable t)
	{
		this(frame,jEdit.getProperty(name + "".title""),
			jEdit.getProperty(name + "".message""),
			UIManager.getIcon(""OptionPane.errorIcon""),
			MiscUtilities.throwableToString(t));
	} //}}}
	//{{{ init() method
	private void init(String caption,
		Icon icon, String text)
	{
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(icon));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);
		JPanel centerPanel = new JPanel(new BorderLayout(6,6));
		centerPanel.add(BorderLayout.NORTH,
			GUIUtilities.createMultilineLabel(caption));
		JTextArea textArea = new JTextArea(10,80);
		textArea.setText(text);
		textArea.setLineWrap(true);
		textArea.setCaretPosition(0);
		centerPanel.add(BorderLayout.CENTER,new JScrollPane(textArea));
		content.add(BorderLayout.CENTER,centerPanel);
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		JButton ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		buttons.add(ok);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		getRootPane().setDefaultButton(ok);
		pack();
		setLocationRelativeTo(getParent());
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.gui.TipOfTheDay,"/*
 * TipOfTheDay.java - Tip of the day window
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import java.util.Random;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class TipOfTheDay extends EnhancedDialog
{
	//{{{ TipOfTheDay constructor
	public TipOfTheDay(View view)
	{
		super(view,jEdit.getProperty(""tip.title""),false);
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel label = new JLabel(jEdit.getProperty(""tip.caption""));
		label.setFont(new Font(""SansSerif"",Font.PLAIN,24));
		label.setForeground(UIManager.getColor(""Button.foreground""));
		content.add(BorderLayout.NORTH,label);
		tipText = new JEditorPane();
		tipText.setEditable(false);
		tipText.setContentType(""text/html"");
		nextTip();
		JScrollPane scroller = new JScrollPane(tipText);
		scroller.setPreferredSize(new Dimension(150,150));
		content.add(BorderLayout.CENTER,scroller);
		ActionHandler actionHandler = new ActionHandler();
		Box buttons = new Box(BoxLayout.X_AXIS);
		showNextTime = new JCheckBox(jEdit.getProperty(""tip.show-next-time""),
			jEdit.getBooleanProperty(""tip.show""));
		showNextTime.addActionListener(actionHandler);
		buttons.add(showNextTime);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(Box.createGlue());
		nextTip = new JButton(jEdit.getProperty(""tip.next-tip""));
		nextTip.addActionListener(actionHandler);
		buttons.add(nextTip);
		buttons.add(Box.createHorizontalStrut(6));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(actionHandler);
		buttons.add(close);
		content.getRootPane().setDefaultButton(close);
		Dimension dim = nextTip.getPreferredSize();
		dim.width = Math.max(dim.width,close.getPreferredSize().width);
		nextTip.setPreferredSize(dim);
		close.setPreferredSize(dim);
		content.add(BorderLayout.SOUTH,buttons);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JCheckBox showNextTime;
	private JButton nextTip, close;
	private JEditorPane tipText;
	private int currentTip = -1;
	//}}}
	//{{{ nextTip() method
	private void nextTip()
	{
		File[] tips = new File(MiscUtilities.constructPath(
			jEdit.getJEditHome(),""doc"",""tips"")).listFiles();
		if(tips == null || tips.length == 0)
		{
			tipText.setText(jEdit.getProperty(""tip.not-found""));
			return;
		}
		int count = tips.length;
		// so that we don't see the same tip again if the user
		// clicks 'Next Tip'
		int tipToShow = currentTip;
		while(tipToShow == currentTip || !tips[tipToShow].getName().endsWith("".html""))
			tipToShow = Math.abs(new Random().nextInt()) % count;
		try
		{
			tipText.setPage(tips[tipToShow].toURL());
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == showNextTime)
			{
				jEdit.setBooleanProperty(""tip.show"",showNextTime
					.isSelected());
			}
			else if(source == nextTip)
				nextTip();
			else if(source == close)
				dispose();
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.ToolBarManager,"/*
 * ToolBarManager.java - Handles tool bars for the View
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
//{{{ Imports
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
//}}}
public class ToolBarManager
{
	//{{{ ToolBarManager constructor
	public ToolBarManager(Container top, Container bottom)
	{
		this.top = top;
		this.bottom = bottom;
	} //}}}
	//{{{ addToolBar() method
	public void addToolBar(int group, int layer, Component toolbar)
	{
		Entry entry = new Entry(layer, toolbar);
		if (group == View.TOP_GROUP)
			addToolBar(top, topToolBars, entry);
		else if (group == View.BOTTOM_GROUP)
			addToolBar(bottom, bottomToolBars, entry);
		else
			throw new InternalError(""Invalid tool bar group"");
	} //}}}
	//{{{ removeToolBar() method
	public void removeToolBar(Component toolbar)
	{
		removeToolBar(top, topToolBars, toolbar);
		removeToolBar(bottom, bottomToolBars, toolbar);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private Container top;
	private Container bottom;
	private ArrayList topToolBars = new ArrayList();
	private ArrayList bottomToolBars = new ArrayList();
	//}}}
	//{{{ addToolBar() method
	private void addToolBar(Container group, ArrayList toolbars,
		Entry entry)
	{
		// See if we should place this toolbar before any others
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(entry.layer > ((Entry)toolbars.get(i)).layer)
			{
				toolbars.add(i,entry);
				group.add(entry.toolbar,i);
				return;
			}
		}
		// Place the toolbar at the bottom of the group
		toolbars.add(entry);
		group.add(entry.toolbar);
	} //}}}
	//{{{ removeToolBar() method
	private void removeToolBar(Container group, ArrayList toolbars,
		Component toolbar)
	{
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(toolbar == ((Entry)toolbars.get(i)).toolbar)
			{
				group.remove(toolbar);
				toolbars.remove(i);
				return;
			}
		}
	} //}}}
	//}}}
	//{{{ Entry class
	static class Entry
	{
		int layer;
		Component toolbar;
		Entry(int layer, Component toolbar)
		{
			this.layer = layer;
			this.toolbar = toolbar;
		}
	} //}}}
}
"
org.gjt.sp.jedit.gui.VariableGridLayout,"/*
 * VariableGridLayout.java - a grid layout manager with variable cell sizes
 *
 * Originally written by Dirk Moebius for the jEdit project. This work has been
 * placed into the public domain. You may use this work in any way and for any
 * purpose you wish.
 *
 * THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY OF ANY KIND, NOT EVEN THE
 * IMPLIED WARRANTY OF MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE, ASSUMES
 * _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE RESULTING FROM THE USE, MODIFICATION,
 * OR REDISTRIBUTION OF THIS SOFTWARE.
 */
package org.gjt.sp.jedit.gui;
import java.awt.*;
/**
 * The <code>VariableGridLayout</code> class is a layout manager
 * that lays out a container's components in a rectangular grid
 * with variable cell sizes.<p>
 *
 * The container is divided into rectangles, and one component is placed
 * in each rectangle. Each row is as large as the largest component in
 * that row, and each column is as wide as the widest component in
 * that column.<p>
 *
 * This behavior is basically the same as in
 * <code>java.awt.GridLayout</code>, but with different row heights and
 * column widths for each row/column.<p>
 *
 * For example, the following is an applet that lays out six buttons
 * into three rows and two columns:<p>
 *
 * <blockquote><pre>
 * import java.awt.*;
 * import java.applet.Applet;
 * public class ButtonGrid extends Applet {
 *     public void init() {
 *         setLayout(new VariableGridLayout(VariableGridLayout.FIXED_NUM_COLUMNS, 2));
 *         add(new Button(""1""));
 *         add(new Button(""2""));
 *         add(new Button(""3""));
 *         add(new Button(""4""));
 *         add(new Button(""5""));
 *         add(new Button(""6""));
 *     }
 * }
 * </pre></blockquote><p>
 *
 * <b>Programmer's remark:</b> VariableGridLayout could be faster, if it would
 * reside in the package java.awt, because then it could access some
 * package private fields of <code>Container</code> or
 * <code>Component</code>. Instead, it has to call
 * <code>Component.getSize()</code>,
 * which allocates memory on the heap.<p>
 *
 * <b>Todo:</b>
 * <ul>
 * <li>Use alignmentX/Y property if the grid cell is larger than the preferred size of the component.
 * <li>Ability to span components over more than one cell horizontally
 * </ul>
 *
 * @author Dirk Moebius
 * @version 1.0
 * @see java.awt.GridLayout
 */
public class VariableGridLayout implements LayoutManager2, java.io.Serializable
{
	public static final int FIXED_NUM_ROWS = 1;
	public static final int FIXED_NUM_COLUMNS = 2;
	public VariableGridLayout(int mode, int size, int hgap, int vgap) {
		if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS) {
			throw new IllegalArgumentException(""illegal mode; value is "" + mode);
		}
		if (size <= 0) {
			throw new IllegalArgumentException(""size cannot be zero or less; value is "" + size);
		}
		if (hgap < 0) {
			throw new IllegalArgumentException(""hgap cannot be negative; value is "" + hgap);
		}
		if (vgap < 0) {
			throw new IllegalArgumentException(""vgap cannot be negative; value is "" + vgap);
		}
		this.mode = mode;
		this.size = size;
		this.hgap = hgap;
		this.vgap = vgap;
	}
	/**
	 * Creates a variable grid layout manager with the specified mode
	 * and zero horizontal and vertical gap.
	 */
	public VariableGridLayout(int mode, int size) {
		this(mode, size, 0, 0);
	}
	/**
	 * Creates a variable grid layout manager with mode FIXED_NUM_ROWS,
	 * number of rows == 1 and zero horizontal and vertical gap.
	 */
	public VariableGridLayout() {
		this(FIXED_NUM_ROWS, 1, 0, 0);
	}
	/**
	 * Not used in this class.
	 */
	public void addLayoutComponent(String name, Component component) { }
	/**
	 * Not used in this class.
	 */
	public void addLayoutComponent(Component component, Object constraints) { }
	/**
	 * Not used in this class.
	 */
	public void removeLayoutComponent(Component component) { }
	/**
	 * Always returns 0.5.
	 */
	public float getLayoutAlignmentX(Container container) {
		return 0.5f;
	}
	/**
	 * Always returns 0.5.
	 */
	public float getLayoutAlignmentY(Container container) {
		return 0.5f;
	}
	public Dimension preferredLayoutSize(Container parent) {
		return getLayoutSize(parent, 2);
	}
	public Dimension minimumLayoutSize(Container parent) {
		return getLayoutSize(parent, 0);
	}
	public Dimension maximumLayoutSize(Container parent) {
		return getLayoutSize(parent, 1);
	}
	public void layoutContainer(Container parent) {
		synchronized (parent.getTreeLock()) {
			update(parent);
			int ncomponents = parent.getComponentCount();
			if (ncomponents == 0) {
				return;
			}
			// Pass 1: compute preferred row heights / column widths
			int total_height = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						Dimension d = parent.getComponent(i).getPreferredSize();
						row_heights[r] = Math.max(row_heights[r], d.height);
						col_widths[c] = Math.max(col_widths[c], d.width);
					} else {
						break;
					}
				}
				total_height += row_heights[r];
			}
			int total_width = 0;
			for (int c = 0; c < ncols; c++) {
				total_width += col_widths[c];
			}
			// Pass 2: redistribute free space
			Dimension parent_size = parent.getSize();
			Insets insets = parent.getInsets();
			int free_height = parent_size.height - insets.top - insets.bottom - (nrows - 1) * vgap;
			int free_width = parent_size.width - insets.left - insets.right - (ncols - 1) * hgap;
			if (total_height != free_height) {
				double dy = (double)free_height / (double)total_height;
				for (int r = 0; r < nrows; r++) {
					row_heights[r] = (int) ((double)row_heights[r] * dy);
				}
			}
			if (total_width != free_width) {
				double dx = ((double)free_width) / ((double)total_width);
				for (int c = 0; c < ncols; c++) {
					col_widths[c] = (int) ((double)col_widths[c] * dx);
				}
			}
			// Pass 3: layout components
			for (int r = 0, y = insets.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++) {
				for (int c = 0, x = insets.left; c < ncols; x += col_widths[c] + hgap, c++, i++) {
					if (i < ncomponents) {
						parent.getComponent(i).setBounds(x, y, col_widths[c], row_heights[r]);
					}
				}
			}
		} // synchronized
	}
	public void invalidateLayout(Container container) {}
	/**
	 * Returns the string representation of this variable grid layout's values.
	 * @return  a string representation of this variable grid layout.
	 */
	public String toString() {
		return getClass().getName() + ""[mode="" + mode + "",size="" + size
			   + "",hgap="" + hgap + "",vgap="" + vgap + ""]"";
	}
	/**
	 * @param  which  if 0 compute minimum layout size,
	 *				if 1 compute maximum layout size,
	 *				otherwise compute preferred layout size.
	 */
	private Dimension getLayoutSize(Container parent, int which) {
		synchronized (parent.getTreeLock()){
			update(parent);
			int ncomponents = parent.getComponentCount();
			int h = 0;
			int w = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				int row_height = 0;
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						switch (which) {
							case 0:
								row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);
								break;
							case 1:
								row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);
								break;
							default:
								row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);
								break;
						}
					} else {
						break;
					}
				}
				h += row_height;
			}
			for (int c = 0; c < ncols; c++) {
				int col_width = 0;
				for (int r = 0; r < nrows; r++) {
					int i = r * ncols + c;
					if (i < ncomponents) {
						switch (which) {
							case 0:
								col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);
								break;
							case 1:
								col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);
								break;
							default:
								col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);
								break;
						}
					} else {
						break;
					}
				}
				w += col_width;
			}
			Insets insets = parent.getInsets();
			return new Dimension(w + insets.left + insets.right + ((ncols - 1) * hgap),
								 h + insets.top + insets.bottom + ((nrows - 1) * vgap));
		}
	}
	private void update(Container container) {
		int ncomponents = container.getComponentCount();
		int old_nrows = nrows;
		int old_ncols = ncols;
		if (this.mode == FIXED_NUM_ROWS) {
			nrows = this.size;
			ncols = (ncomponents + nrows - 1) / nrows;
		} else {
			ncols = this.size;
			nrows = (ncomponents + ncols - 1) / ncols;
		}
		if (old_nrows != nrows) {
			row_heights = new int[nrows];
		}
		if (old_ncols != ncols) {
			col_widths = new int[ncols];
		}
	}
	private int mode;
	private int size;
	private int hgap;
	private int vgap;
	private transient int nrows = -1;
	private transient int ncols = -1;
	private transient int[] row_heights = null;
	private transient int[] col_widths = null;
}
"
org.gjt.sp.jedit.gui.ViewRegisters,"/*
 * ViewRegisters.java - View registers dialog
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
public class ViewRegisters extends EnhancedDialog
{
	public ViewRegisters(View view)
	{
		super(view,jEdit.getProperty(""view-registers.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));
		JLabel label = new JLabel(jEdit.getProperty(""view-registers.register""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);
		DefaultListModel registerModel = new DefaultListModel();
		registerList = new JList(registerModel);
		registerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		registerList.setCellRenderer(new Renderer());
		Registers.Register[] registers = Registers.getRegisters();
		int index = 0;
		for(int i = 0; i < registers.length; i++)
		{
			Registers.Register reg = registers[i];
			if(reg == null)
				continue;
			String value = reg.toString();
			if(value == null || value.length() == 0)
				continue;
			registerModel.addElement(new Character((char)i));
		}
		if(registerModel.getSize() == 0)
			registerModel.addElement(jEdit.getProperty(""view-registers.none""));
		panel.add(BorderLayout.CENTER,new JScrollPane(registerList));
		content.add(BorderLayout.WEST,panel);
		panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));
		label = new JLabel(jEdit.getProperty(""view-registers.contents""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);
		contentTextArea = new JTextArea(10,80);
		contentTextArea.setEditable(false);
		panel.add(BorderLayout.CENTER,new JScrollPane(contentTextArea));
		content.add(BorderLayout.CENTER,panel);
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		panel.add(Box.createGlue());
		panel.add(close);
		panel.add(Box.createGlue());
		getRootPane().setDefaultButton(close);
		content.add(BorderLayout.SOUTH,panel);
		registerList.addListSelectionListener(new ListHandler());
		registerList.setSelectedIndex(index);
		pack();
		setLocationRelativeTo(view);
		setVisible(true);
	}
	// EnhancedDialog implementation
	public void ok()
	{
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	// private members
	private JList registerList;
	private JTextArea contentTextArea;
	private JButton close;
	class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,
				index,isSelected,cellHasFocus);
			if(value instanceof Character)
			{
				char name = ((Character)value).charValue();
				String label;
				if(name == '\n')
					label = ""\n"";
				else if(name == '\t')
					label = ""\t"";
				else if(name == '$')
					label = jEdit.getProperty(""view-registers.clipboard"");
				else if(name == '%')
					label = jEdit.getProperty(""view-registers.selection"");
				else
					label = String.valueOf((char)name);
				setText(label);
			}
			return this;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == close)
				cancel();
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object value = registerList.getSelectedValue();
			if(!(value instanceof Character))
				return;
			char name = ((Character)value).charValue();
			Registers.Register reg = Registers.getRegister(name);
			if(reg == null)
				return;
			contentTextArea.setText(reg.toString());
			contentTextArea.setCaretPosition(0);
		}
	}
}
"
org.gjt.sp.jedit.help.HelpIndex,"/*
 * HelpIndex.java - Index for help searching feature
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.help;
//{{{ Imports
import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
class HelpIndex
{
	//{{{ HelpIndex constructor
	public HelpIndex()
	{
		words = new HashMap();
		files = new ArrayList();
		ignoreWord(""a"");
		ignoreWord(""an"");
		ignoreWord(""and"");
		ignoreWord(""are"");
		ignoreWord(""as"");
		ignoreWord(""be"");
		ignoreWord(""by"");
		ignoreWord(""can"");
		ignoreWord(""do"");
		ignoreWord(""for"");
		ignoreWord(""from"");
		ignoreWord(""how"");
		ignoreWord(""i"");
		ignoreWord(""if"");
		ignoreWord(""in"");
		ignoreWord(""is"");
		ignoreWord(""it"");
		ignoreWord(""not"");
		ignoreWord(""of"");
		ignoreWord(""on"");
		ignoreWord(""or"");
		ignoreWord(""s"");
		ignoreWord(""that"");
		ignoreWord(""the"");
		ignoreWord(""this"");
		ignoreWord(""to"");
		ignoreWord(""will"");
		ignoreWord(""with"");
		ignoreWord(""you"");
	} //}}}
	/* //{{{ HelpIndex constructor
	public HelpIndex(String fileListPath, String wordIndexPath)
	{
		this();
	} //}}} */
	//{{{ indexEditorHelp() method
	/**
	 * Indexes all available help, including the jEdit user's guide, FAQ,]
	 * and plugin documentation.
	 */
	public void indexEditorHelp()
	{
		try
		{
			String jEditHome = jEdit.getJEditHome();
			if(jEditHome != null)
			{
				indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""users-guide""));
				indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""FAQ""));
				indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""news42""));
			}
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,""Error indexing editor help"");
			Log.log(Log.ERROR,this,e);
		}
		PluginJAR[] jars = jEdit.getPluginJARs();
		for(int i = 0; i < jars.length; i++)
		{
			try
			{
				indexJAR(jars[i].getZipFile());
			}
			catch(Throwable e)
			{
				Log.log(Log.ERROR,this,""Error indexing JAR: ""
					+ jars[i].getPath());
				Log.log(Log.ERROR,this,e);
			}
		}
		Log.log(Log.DEBUG,this,""Indexed "" + words.size() + "" words"");
	} //}}}
	//{{{ indexDirectory() method
	/**
	 * Indexes all HTML and text files in the specified directory.
	 * @param dir The directory
	 */
	public void indexDirectory(String dir) throws Exception
	{
		String[] files = VFSManager.getFileVFS()
			._listDirectory(null,dir,""*.{html,txt}"",true,null);
		for(int i = 0; i < files.length; i++)
		{
			indexURL(files[i]);
		}
	} //}}}
	//{{{ indexJAR() method
	/**
	 * Indexes all HTML and text files in the specified JAR file.
	 * @param jar The JAR file
	 */
	public void indexJAR(ZipFile jar) throws Exception
	{
		Enumeration e = jar.entries();
		while(e.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)e.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.endsWith("".html"")/*  || lname.endsWith("".txt"") */)
			{
				// only works for jEdit plugins
				String url = ""jeditresource:/"" +
					MiscUtilities.getFileName(jar.getName())
					+ ""!/"" + name;
				Log.log(Log.DEBUG,this,url);
				indexStream(jar.getInputStream(entry),url);
			}
		}
	} //}}}
	//{{{ indexURL() method
	/**
	 * Reads the specified HTML file and adds all words defined therein to the
	 * index.
	 * @param url The HTML file's URL
	 */
	public void indexURL(String url) throws Exception
	{
		InputStream _in;
		if(MiscUtilities.isURL(url))
			_in =  new URL(url).openStream();
		else
		{
			_in = new FileInputStream(url);
			// hack since HelpViewer needs a URL...
			url = ""file:"" + url;
		}
		indexStream(_in,url);
	} //}}}
	//{{{ lookupWord() method
	public Word lookupWord(String word)
	{
		Object o = words.get(word);
		if(o == IGNORE)
			return null;
		else
			return (Word)o;
	} //}}}
	//{{{ getFile() method
	public HelpFile getFile(int index)
	{
		return (HelpFile)files.get(index);
	} //}}}
	//{{{ Private members
	// used to mark words to ignore (see constructor for the list)
	private static Object IGNORE = new Object();
	private HashMap words;
	private ArrayList files;
	//{{{ ignoreWord() method
	private void ignoreWord(String word)
	{
		words.put(word,IGNORE);
	} //}}}
	//{{{ indexStream() method
	/**
	 * Reads the specified HTML file and adds all words defined therein to the
	 * index.
	 * @param _in The input stream
	 * @param file The file
	 */
	private void indexStream(InputStream _in, String fileName)
		throws Exception
	{
		HelpFile file = new HelpFile(fileName);
		files.add(file);
		int index = files.size() - 1;
		StringBuffer titleText = new StringBuffer();
		BufferedReader in = new BufferedReader(
			new InputStreamReader(_in));
		try
		{
			StringBuffer word = new StringBuffer();
			boolean insideTag = false;
			boolean insideEntity = false;
			boolean title = false;
			int c;
			while((c = in.read()) != -1)
			{
				char ch = (char)c;
				if(insideTag)
				{
					if(ch == '>')
					{
						if(word.toString().equals(""title""))
							title = true;
						insideTag = false;
						word.setLength(0);
					}
					else
						word.append(ch);
				}
				else if(insideEntity)
				{
					if(ch == ';')
						insideEntity = false;
				}
				else if(ch == '<')
				{
					if(title)
						title = false;
					if(word.length() != 0)
					{
						addWord(word.toString(),index,title);
						word.setLength(0);
					}
					insideTag = true;
				}
				else if(ch == '&')
					insideEntity = true;
				else if(title)
					titleText.append(ch);
				else if(!Character.isLetterOrDigit(ch))
				{
					if(word.length() != 0)
					{
						addWord(word.toString(),index,title);
						word.setLength(0);
					}
				}
				else
					word.append(ch);
			}
		}
		finally
		{
			in.close();
		}
		if(titleText.length() == 0)
			file.title = fileName;
		else
			file.title = titleText.toString();
	} //}}}
	//{{{ addWord() method
	private void addWord(String word, int file, boolean title)
	{
		word = word.toLowerCase();
		Object o = words.get(word);
		if(o == IGNORE)
			return;
		if(o == null)
			words.put(word,new Word(word,file,title));
		else
			((Word)o).addOccurrence(file,title);
	} //}}}
	//}}}
	//{{{ Word class
	static class Word
	{
		// how much an occurrence in the title is worth
		static final int TITLE_OCCUR = 10;
		// the word
		String word;
		// files it occurs in
		int occurCount = 0;
		Occurrence[] occurrences;
		Word(String word, int file, boolean title)
		{
			this.word = word;
			occurrences = new Occurrence[5];
			addOccurrence(file,title);
		}
		void addOccurrence(int file, boolean title)
		{
			for(int i = 0; i < occurCount; i++)
			{
				if(occurrences[i].file == file)
				{
					occurrences[i].count += (title ? TITLE_OCCUR : 1);
					return;
				}
			}
			if(occurCount >= occurrences.length)
			{
				Occurrence[] newOccur = new Occurrence[occurrences.length * 2];
				System.arraycopy(occurrences,0,newOccur,0,occurCount);
				occurrences = newOccur;
			}
			occurrences[occurCount++] = new Occurrence(file,title);
		}
		static class Occurrence
		{
			int file;
			int count;
			Occurrence(int file, boolean title)
			{
				this.file = file;
				this.count = (title ? TITLE_OCCUR : 1);
			}
		}
	} //}}}
	//{{{ HelpFile class
	static class HelpFile
	{
		String file;
		String title;
		HelpFile(String file)
		{
			this.file = file;
		}
		public String toString()
		{
			return title;
		}
		public boolean equals(Object o)
		{
			if(o instanceof HelpFile)
				return ((HelpFile)o).file.equals(file);
			else
				return false;
		}
	} //}}}
}
"
org.gjt.sp.jedit.help.HelpSearchPanel,"/*
 * HelpSearchPanel.java - Help search GUI
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.help;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
class HelpSearchPanel extends JPanel
{
	//{{{ HelpSearchPanel constructor
	public HelpSearchPanel(HelpViewer helpViewer)
	{
		super(new BorderLayout(6,6));
		this.helpViewer = helpViewer;
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(new JLabel(jEdit.getProperty(""helpviewer.search.caption"")));
		box.add(Box.createHorizontalStrut(6));
		box.add(searchField = new HistoryTextField(""helpviewer.search""));
		searchField.addActionListener(new ActionHandler());
		add(BorderLayout.NORTH,box);
		results = new JList();
		results.addMouseListener(new MouseHandler());
		results.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		results.setCellRenderer(new ResultRenderer());
		add(BorderLayout.CENTER,new JScrollPane(results));
	} //}}}
	//{{{ Private members
	private HelpViewer helpViewer;
	private HistoryTextField searchField;
	private JList results;
	private HelpIndex index;
	private HelpIndex getHelpIndex()
	{
		if(index == null)
		{
			index = new HelpIndex();
			try
			{
				index.indexEditorHelp();
			}
			catch(Exception e)
			{
				index = null;
				Log.log(Log.ERROR,this,e);
				GUIUtilities.error(helpViewer,""helpviewer.search.error"",
					new String[] { e.toString() });
			}
		}
		return index;
	} //}}}
	//{{{ ResultIcon class
	static class ResultIcon implements Icon
	{
		private static RenderingHints renderingHints;
		static
		{
			HashMap hints = new HashMap();
			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			renderingHints = new RenderingHints(hints);
		}
		private int rank;
		ResultIcon(int rank)
		{
			this.rank = rank;
		}
		public int getIconWidth()
		{
			return 40;
		}
		public int getIconHeight()
		{
			return 9;
		}
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g.create();
			g2d.setRenderingHints(renderingHints);
			for(int i = 0; i < 4; i++)
			{
				if(rank > i)
					g2d.setColor(UIManager.getColor(""Label.foreground""));
				else
					g2d.setColor(UIManager.getColor(""Label.disabledForeground""));
				g2d.fillOval(x+i*10,y,9,9);
			}
		}
	} //}}}
	//{{{ ResultRenderer class
	class ResultRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,null,index,
				isSelected,cellHasFocus);
			if(value instanceof String)
			{
				setIcon(null);
				setText((String)value);
			}
			else
			{
				Result result = (Result)value;
				setIcon(new ResultIcon(result.rank));
				setText(result.title);
			}
			return this;
		}
	} //}}}
	//{{{ Result class
	static class Result
	{
		String file;
		String title;
		int rank;
		Result(HelpIndex.HelpFile file, int count)
		{
			this.file = file.file;
			this.title = file.title;
			rank = count;
		}
	} //}}}
	//{{{ ResultCompare class
	static class ResultCompare implements Comparator
	{
		public int compare(Object o1, Object o2)
		{
			Result r1 = (Result)o1;
			Result r2 = (Result)o2;
			if(r1.rank == r2.rank)
				return r1.title.compareTo(r2.title);
			else
				return r2.rank - r1.rank;
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			final HelpIndex index = getHelpIndex();
			if(index == null)
				return;
			results.setListData(new String[] { jEdit.getProperty(
				""helpviewer.searching"") });
			final String text = searchField.getText();
			final Vector resultModel = new Vector();
			VFSManager.runInWorkThread(new Runnable()
			{
				public void run()
				{
					StringTokenizer st = new StringTokenizer(text,"",.;:-? "");
					// we later use this to compute a relative ranking
					int maxRank = 0;
					while(st.hasMoreTokens())
					{
						String word = st.nextToken().toLowerCase();
						HelpIndex.Word lookup = index.lookupWord(word);
						if(lookup == null)
							continue;
						for(int i = 0; i < lookup.occurCount; i++)
						{
							HelpIndex.Word.Occurrence occur = lookup.occurrences[i];
							boolean ok = false;
							HelpIndex.HelpFile file = index.getFile(occur.file);
							for(int j = 0; j < resultModel.size(); j++)
							{
								Result result = (Result)resultModel.elementAt(j);
								if(result.file.equals(file.file))
								{
									result.rank += occur.count;
									result.rank += 20; // multiple files w/ word bonus
									maxRank = Math.max(result.rank,maxRank);
									ok = true;
									break;
								}
							}
							if(!ok)
							{
								maxRank = Math.max(occur.count,maxRank);
								resultModel.addElement(new Result(file,occur.count));
							}
						}
					}
					if(maxRank != 0)
					{
						// turn the rankings into relative rankings, from 1 to 4
						for(int i = 0; i < resultModel.size(); i++)
						{
							Result result = (Result)resultModel.elementAt(i);
							result.rank = (int)Math.ceil((double)result.rank * 4 / maxRank);
						}
						Collections.sort(resultModel,new ResultCompare());
					}
				}
			});
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					if(resultModel.size() == 0)
					{
						results.setListData(new String[] {
							jEdit.getProperty(
							""helpviewer.no-results"") });
						getToolkit().beep();
					}
					else
						results.setListData(resultModel);
				}
			});
		}
	} //}}}
	//{{{ MouseHandler class
	public class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			int row = results.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Result result = (Result)results.getModel()
					.getElementAt(row);
				helpViewer.gotoURL(result.file,true);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.help.HelpTOCPanel,"/*
 * HelpTOCPanel.java - Help table of contents
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.help;
//{{{ Imports
import com.microstar.xml.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.FileCellRenderer; // for icons
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
class HelpTOCPanel extends JPanel
{
	//{{{ HelpTOCPanel constructor
	HelpTOCPanel(HelpViewer helpViewer)
	{
		super(new BorderLayout());
		this.helpViewer = helpViewer;
		nodes = new Hashtable();
		toc = new TOCTree();
		// looks bad with the OS X L&F, apparently...
		if(!OperatingSystem.isMacOSLF())
			toc.putClientProperty(""JTree.lineStyle"", ""Angled"");
		toc.setCellRenderer(new TOCCellRenderer());
		toc.setEditable(false);
		toc.setShowsRootHandles(true);
		add(BorderLayout.CENTER,new JScrollPane(toc));
		load();
	} //}}}
	//{{{ selectNode() method
	void selectNode(String shortURL)
	{
		if(tocModel == null)
			return;
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.get(shortURL);
		if(node == null)
			return;
		TreePath path = new TreePath(tocModel.getPathToRoot(node));
		toc.expandPath(path);
		toc.setSelectionPath(path);
		toc.scrollPathToVisible(path);
	} //}}}
	//{{{ load() method
	void load()
	{
		DefaultTreeModel empty = new DefaultTreeModel(
			new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.loading"")));
		toc.setModel(empty);
		toc.setRootVisible(true);
		VFSManager.runInWorkThread(new Runnable()
		{
			public void run()
			{
				createTOC();
				tocModel.reload(tocRoot);
				toc.setModel(tocModel);
				toc.setRootVisible(false);
				for(int i = 0; i <tocRoot.getChildCount(); i++)
				{
					DefaultMutableTreeNode node =
						(DefaultMutableTreeNode)
						tocRoot.getChildAt(i);
					toc.expandPath(new TreePath(
						node.getPath()));
				}
				if(helpViewer.getShortURL() != null)
					selectNode(helpViewer.getShortURL());
			}
		});
	} //}}}
	//{{{ Private members
	private HelpViewer helpViewer;
	private DefaultTreeModel tocModel;
	private DefaultMutableTreeNode tocRoot;
	private JTree toc;
	private Hashtable nodes;
	//{{{ createNode() method
	private DefaultMutableTreeNode createNode(String href, String title)
	{
		DefaultMutableTreeNode node = new DefaultMutableTreeNode(
			new HelpNode(href,title),true);
		nodes.put(href,node);
		return node;
	} //}}}
	//{{{ createTOC() method
	private void createTOC()
	{
		EditPlugin[] plugins = jEdit.getPlugins();
		Arrays.sort(plugins,new PluginCompare());
		tocRoot = new DefaultMutableTreeNode();
		tocRoot.add(createNode(""welcome.html"",
			jEdit.getProperty(""helpviewer.toc.welcome"")));
		tocRoot.add(createNode(""README.txt"",
			jEdit.getProperty(""helpviewer.toc.readme"")));
		tocRoot.add(createNode(""CHANGES.txt"",
			jEdit.getProperty(""helpviewer.toc.changes"")));
		tocRoot.add(createNode(""TODO.txt"",
			jEdit.getProperty(""helpviewer.toc.todo"")));
		tocRoot.add(createNode(""COPYING.txt"",
			jEdit.getProperty(""helpviewer.toc.copying"")));
		tocRoot.add(createNode(""COPYING.DOC.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-doc"")));
		tocRoot.add(createNode(""Apache.LICENSE.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-apache"")));
		tocRoot.add(createNode(""COPYING.PLUGINS.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-plugins"")));
		loadTOC(tocRoot,""news42/toc.xml"");
		loadTOC(tocRoot,""users-guide/toc.xml"");
		loadTOC(tocRoot,""FAQ/toc.xml"");
		loadTOC(tocRoot,""api/toc.xml"");
		DefaultMutableTreeNode pluginTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.plugins""),true);
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			String name = plugin.getClassName();
			String docs = jEdit.getProperty(""plugin."" + name + "".docs"");
			String label = jEdit.getProperty(""plugin."" + name + "".name"");
			if(docs != null)
			{
				if(label != null && docs != null)
				{
					String path = plugin.getPluginJAR()
						.getClassLoader()
						.getResourceAsPath(docs);
					pluginTree.add(createNode(
						path,label));
				}
			}
		}
		if(pluginTree.getChildCount() != 0)
			tocRoot.add(pluginTree);
		else
		{
			// so that HelpViewer constructor doesn't try to expand
			pluginTree = null;
		}
		tocModel = new DefaultTreeModel(tocRoot);
	} //}}}
	//{{{ loadTOC() method
	private void loadTOC(DefaultMutableTreeNode root, String path)
	{
		TOCHandler h = new TOCHandler(root,MiscUtilities.getParentOfPath(path));
		XmlParser parser = new XmlParser();
		Reader in = null;
		parser.setHandler(h);
		try
		{
			in = new InputStreamReader(
				new URL(helpViewer.getBaseURL()
				+ '/' + path).openStream());
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,this,path + ':' + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
		finally
		{
			try
			{
				if(in != null)
					in.close();
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
			}
		}
	} //}}}
	//}}}
	//{{{ HelpNode class
	static class HelpNode
	{
		String href, title;
		//{{{ HelpNode constructor
		HelpNode(String href, String title)
		{
			this.href = href;
			this.title = title;
		} //}}}
		//{{{ toString() method
		public String toString()
		{
			return title;
		} //}}}
	} //}}}
	//{{{ TOCHandler class
	class TOCHandler extends HandlerBase
	{
		String dir;
		//{{{ TOCHandler constructor
		TOCHandler(DefaultMutableTreeNode root, String dir)
		{
			nodes = new Stack();
			node = root;
			this.dir = dir;
		} //}}}
		//{{{ attribute() method
		public void attribute(String aname, String value, boolean isSpecified)
		{
			if(aname.equals(""HREF""))
				href = value;
		} //}}}
		//{{{ charData() method
		public void charData(char[] c, int off, int len)
		{
			if(tag.equals(""TITLE""))
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < len; i++)
				{
					char ch = c[off + i];
					if(ch == ' ' || !Character.isWhitespace(ch))
						buf.append(ch);
				}
				title = buf.toString();
			}
		} //}}}
		//{{{ startElement() method
		public void startElement(String name)
		{
			tag = name;
		} //}}}
		//{{{ endElement() method
		public void endElement(String name)
		{
			if(name == null)
				return;
			if(name.equals(""TITLE""))
			{
				DefaultMutableTreeNode newNode = createNode(
					dir + href,title);
				node.add(newNode);
				nodes.push(node);
				node = newNode;
			}
			else if(name.equals(""ENTRY""))
				node = (DefaultMutableTreeNode)nodes.pop();
		} //}}}
		//{{{ Private members
		private String tag;
		private String title;
		private String href;
		private DefaultMutableTreeNode node;
		private Stack nodes;
		//}}}
	} //}}}
	//{{{ TOCTree class
	class TOCTree extends JTree
	{
		//{{{ TOCTree constructor
		TOCTree()
		{
			ToolTipManager.sharedInstance().registerComponent(this);
		} //}}}
		//{{{ getToolTipText() method
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		} //}}}
		//{{{ getToolTipLocation() method
		/* public final Point getToolTipLocation(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
				{
					return new Point(cellRect.x + 14, cellRect.y);
				}
			}
			return null;
		} */ //}}}
		//{{{ processMouseEvent() method
		protected void processMouseEvent(MouseEvent evt)
		{
			//ToolTipManager ttm = ToolTipManager.sharedInstance();
			switch(evt.getID())
			{
			/* case MouseEvent.MOUSE_ENTERED:
				toolTipInitialDelay = ttm.getInitialDelay();
				toolTipReshowDelay = ttm.getReshowDelay();
				ttm.setInitialDelay(200);
				ttm.setReshowDelay(0);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_EXITED:
				ttm.setInitialDelay(toolTipInitialDelay);
				ttm.setReshowDelay(toolTipReshowDelay);
				super.processMouseEvent(evt);
				break; */
			case MouseEvent.MOUSE_CLICKED:
				TreePath path = getPathForLocation(evt.getX(),evt.getY());
				if(path != null)
				{
					if(!isPathSelected(path))
						setSelectionPath(path);
					Object obj = ((DefaultMutableTreeNode)
						path.getLastPathComponent())
						.getUserObject();
					if(!(obj instanceof HelpNode))
					{
						this.expandPath(path);
						return;
					}
					HelpNode node = (HelpNode)obj;
					helpViewer.gotoURL(node.href,true);
				}
				super.processMouseEvent(evt);
				break;
			default:
				super.processMouseEvent(evt);
				break;
			}
		} //}}}
		//{{{ cellRectIsVisible() method
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = TOCTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		} //}}}
	} //}}}
	//{{{ TOCCellRenderer class
	class TOCCellRenderer extends DefaultTreeCellRenderer
	{
		EmptyBorder border = new EmptyBorder(1,0,1,1);
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean focus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,focus);
			setIcon(leaf ? FileCellRenderer.fileIcon
				: (expanded ? FileCellRenderer.openDirIcon
				: FileCellRenderer.dirIcon));
			setBorder(border);
			return this;
		}
	} //}}}
	//{{{ PluginCompare class
	static class PluginCompare implements Comparator
	{
		public int compare(Object o1, Object o2)
		{
			EditPlugin p1 = (EditPlugin)o1;
			EditPlugin p2 = (EditPlugin)o2;
			return MiscUtilities.compareStrings(
				jEdit.getProperty(""plugin."" + p1.getClassName() + "".name""),
				jEdit.getProperty(""plugin."" + p2.getClassName() + "".name""),
				true);
		}
	} //}}}
}
"
org.gjt.sp.jedit.help.HelpViewer,"/*
 * HelpViewer.java - HTML Help viewer
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.help;
//{{{ Imports
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.html.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.msg.PluginUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * jEdit's searchable help viewer. It uses a Swing JEditorPane to display the HTML,
 * and implements a URL history.
 * @author Slava Pestov
 * @version $Id: HelpViewer.java,v 1.14 2004/06/28 06:45:27 spestov Exp $
 */
public class HelpViewer extends JFrame implements EBComponent
{
	//{{{ HelpViewer constructor
	/**
	 * Creates a new help viewer with the default help page.
	 * @since jEdit 4.0pre4
	 */
	public HelpViewer()
	{
		this(""welcome.html"");
	} //}}}
	//{{{ HelpViewer constructor
	/**
	 * Creates a new help viewer for the specified URL.
	 * @param url The URL
	 */
	public HelpViewer(URL url)
	{
		this(url.toString());
	} //}}}
	//{{{ HelpViewer constructor
	/**
	 * Creates a new help viewer for the specified URL.
	 * @param url The URL
	 */
	public HelpViewer(String url)
	{
		super(jEdit.getProperty(""helpviewer.title""));
		setIconImage(GUIUtilities.getEditorIcon());
		try
		{
			baseURL = new File(MiscUtilities.constructPath(
				jEdit.getJEditHome(),""doc"")).toURL().toString();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			// what to do?
		}
		history = new String[25];
		ActionHandler actionListener = new ActionHandler();
		JTabbedPane tabs = new JTabbedPane();
		tabs.addTab(jEdit.getProperty(""helpviewer.toc.label""),
			toc = new HelpTOCPanel(this));
		tabs.addTab(jEdit.getProperty(""helpviewer.search.label""),
			new HelpSearchPanel(this));
		tabs.setMinimumSize(new Dimension(0,0));
		JPanel rightPanel = new JPanel(new BorderLayout());
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.add(title = new JLabel());
		toolBar.add(Box.createGlue());
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(0,12,0,0));
		back = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(""helpviewer.back.icon"")));
		back.setToolTipText(jEdit.getProperty(""helpviewer.back.label""));
		back.addActionListener(actionListener);
		toolBar.add(back);
		forward = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(""helpviewer.forward.icon"")));
		forward.addActionListener(actionListener);
		forward.setToolTipText(jEdit.getProperty(""helpviewer.forward.label""));
		toolBar.add(forward);
		back.setPreferredSize(forward.getPreferredSize());
		rightPanel.add(BorderLayout.NORTH,toolBar);
		viewer = new JEditorPane();
		viewer.setEditable(false);
		viewer.addHyperlinkListener(new LinkHandler());
		viewer.setFont(new Font(""Monospaced"",Font.PLAIN,12));
		viewer.addPropertyChangeListener(new PropertyChangeHandler());
		rightPanel.add(BorderLayout.CENTER,new JScrollPane(viewer));
		splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
			tabs,rightPanel);
		splitter.setBorder(null);
		getContentPane().add(BorderLayout.CENTER,splitter);
		gotoURL(url,true);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		getRootPane().setPreferredSize(new Dimension(750,500));
		pack();
		GUIUtilities.loadGeometry(this,""helpviewer"");
		EditBus.addToBus(this);
		setVisible(true);
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				splitter.setDividerLocation(jEdit.getIntegerProperty(
					""helpviewer.splitter"",250));
				viewer.requestFocus();
			}
		});
	} //}}}
	//{{{ gotoURL() method
	/**
	 * Displays the specified URL in the HTML component.
	 * @param url The URL
	 * @param addToHistory Should the URL be added to the back/forward
	 * history?
	 */
	public void gotoURL(String url, boolean addToHistory)
	{
		// the TOC pane looks up user's guide URLs relative to the
		// doc directory...
		String shortURL;
		if(MiscUtilities.isURL(url))
		{
			if(url.startsWith(baseURL))
			{
				shortURL = url.substring(baseURL.length());
				if(shortURL.startsWith(""/""))
					shortURL = shortURL.substring(1);
			}
			else
			{
				shortURL = url;
			}
		}
		else
		{
			shortURL = url;
			if(baseURL.endsWith(""/""))
				url = baseURL + url;
			else
				url = baseURL + '/' + url;
		}
		// reset default cursor so that the hand cursor doesn't
		// stick around
		viewer.setCursor(Cursor.getDefaultCursor());
		URL _url = null;
		try
		{
			_url = new URL(url);
			if(!_url.equals(viewer.getPage()))
				title.setText(jEdit.getProperty(""helpviewer.loading""));
			else
			{
				/* don't show loading msg because we won't
				   receive a propertyChanged */
			}
			viewer.setPage(_url);
			if(addToHistory)
			{
				history[historyPos] = url;
				if(historyPos + 1 == history.length)
				{
					System.arraycopy(history,1,history,
						0,history.length - 1);
					history[historyPos] = null;
				}
				else
					historyPos++;
			}
		}
		catch(MalformedURLException mf)
		{
			Log.log(Log.ERROR,this,mf);
			String[] args = { url, mf.getMessage() };
			GUIUtilities.error(this,""badurl"",args);
			return;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			String[] args = { url, io.toString() };
			GUIUtilities.error(this,""read-error"",args);
			return;
		}
		this.shortURL = shortURL;
		// select the appropriate tree node.
		if(shortURL != null)
			toc.selectNode(shortURL);
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		EditBus.removeFromBus(this);
		jEdit.setIntegerProperty(""helpviewer.splitter"",
			splitter.getDividerLocation());
		GUIUtilities.saveGeometry(this,""helpviewer"");
		super.dispose();
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PluginUpdate)
		{
			PluginUpdate pmsg = (PluginUpdate)msg;
			if(pmsg.getWhat() == PluginUpdate.LOADED
				|| pmsg.getWhat() == PluginUpdate.UNLOADED)
			{
				if(!pmsg.isExiting())
				{
					if(!queuedTOCReload)
						queueTOCReload();
					queuedTOCReload = true;
				}
			}
		}
	} //}}}
	//{{{ getBaseURL() method
	public String getBaseURL()
	{
		return baseURL;
	} //}}}
	//{{{ getShortURL() method
	String getShortURL()
	{
		return shortURL;
	} //}}}
	//{{{ Private members
	//{{{ Instance members
	private String baseURL;
	private String shortURL;
	private JButton back;
	private JButton forward;
	private JEditorPane viewer;
	private JLabel title;
	private JSplitPane splitter;
	private String[] history;
	private int historyPos;
	private HelpTOCPanel toc;
	private boolean queuedTOCReload;
	//}}}
	//{{{ queueTOCReload() method
	public void queueTOCReload()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				queuedTOCReload = false;
				toc.load();
			}
		});
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		//{{{ actionPerformed() class
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == back)
			{
				if(historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[--historyPos - 1];
					gotoURL(url,false);
				}
			}
			else if(source == forward)
			{
				if(history.length - historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[historyPos];
					if(url == null)
						getToolkit().beep();
					else
					{
						historyPos++;
						gotoURL(url,false);
					}
				}
			}
		} //}}}
	} //}}}
	//{{{ LinkHandler class
	class LinkHandler implements HyperlinkListener
	{
		//{{{ hyperlinkUpdate() method
		public void hyperlinkUpdate(HyperlinkEvent evt)
		{
			if(evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
			{
				if(evt instanceof HTMLFrameHyperlinkEvent)
				{
					((HTMLDocument)viewer.getDocument())
						.processHTMLFrameHyperlinkEvent(
						(HTMLFrameHyperlinkEvent)evt);
				}
				else
				{
					URL url = evt.getURL();
					if(url != null)
						gotoURL(url.toString(),true);
				}
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED) {
				viewer.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.EXITED) {
				viewer.setCursor(Cursor.getDefaultCursor());
			}
		} //}}}
	} //}}}
	//{{{ PropertyChangeHandler class
	class PropertyChangeHandler implements PropertyChangeListener
	{
		public void propertyChange(PropertyChangeEvent evt)
		{
			if(""page"".equals(evt.getPropertyName()))
			{
				String titleStr = (String)viewer.getDocument()
					.getProperty(""title"");
				if(titleStr == null)
				{
					titleStr = MiscUtilities.getFileName(
						viewer.getPage().toString());
				}
				title.setText(titleStr);
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.io.FavoritesVFS,"/*
 * FavoritesVFS.java - Stores frequently-visited directory locations
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
//{{{ Imports
import java.awt.Component;
import java.util.*;
import org.gjt.sp.jedit.msg.DynamicMenuChanged;
import org.gjt.sp.jedit.*;
//}}}
/**
 * A VFS used for remembering frequently-visited directories. Listing it
 * returns the favorites list. The deletePath of each entry is the
 * directory prefixed with ""favorites:"" so that right-clicking on a
 * favorite and clicking 'delete' in the browser just deletes the
 * favorite, and not the directory itself.
 * @author Slava Pestov
 * @version $Id: FavoritesVFS.java,v 1.11 2004/02/23 00:15:21 spestov Exp $
 */
public class FavoritesVFS extends VFS
{
	public static final String PROTOCOL = ""favorites"";
	//{{{ FavoritesVFS constructor
	public FavoritesVFS()
	{
		super(""favorites"",DELETE_CAP | LOW_LATENCY_CAP,
			new String[] { EA_TYPE });
		/* addToFavorites(), which is a static method
		 * (for convinience) needs an instance of the
		 * VFS to pass to VFSManager.sendVFSUpdate(),
		 * hence this hack. */
		instance = this;
	} //}}}
	//{{{ getParentOfPath() method
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} //}}}
	//{{{ _listDirectory() method
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		return getFavorites();
	} //}}}
	//{{{ _getDirectoryEntry() method
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		// does it matter that this doesn't set the type correctly?
		return new FavoritesEntry(path,VFS.DirectoryEntry.DIRECTORY);
	} //}}}
	//{{{ _delete() method
	public boolean _delete(Object session, String path, Component comp)
	{
		synchronized(lock)
		{
			path = path.substring(PROTOCOL.length() + 1);
			Iterator iter = favorites.iterator();
			while(iter.hasNext())
			{
				if(((FavoritesEntry)iter.next()).path.equals(path))
				{
					iter.remove();
					VFSManager.sendVFSUpdate(this,PROTOCOL
						+ "":"",false);
					EditBus.send(new DynamicMenuChanged(
						""favorites""));
					return true;
				}
			}
		}
		return false;
	} //}}}
	//{{{ loadFavorites() method
	public static void loadFavorites()
	{
		synchronized(lock)
		{
			favorites = new LinkedList();
			String favorite;
			int i = 0;
			while((favorite = jEdit.getProperty(""vfs.favorite."" + i)) != null)
			{
				favorites.add(new FavoritesEntry(favorite,
					jEdit.getIntegerProperty(""vfs.favorite.""
					+ i + "".type"",
					VFS.DirectoryEntry.DIRECTORY)));
				i++;
			}
		}
	} //}}}
	//{{{ addToFavorites() method
	public static void addToFavorites(String path, int type)
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();
			Iterator iter = favorites.iterator();
			while(iter.hasNext())
			{
				if(((FavoritesEntry)iter.next()).path.equals(path))
					return;
			}
			favorites.add(new FavoritesEntry(path,type));
			VFSManager.sendVFSUpdate(instance,PROTOCOL + "":"",false);
			EditBus.send(new DynamicMenuChanged(""favorites""));
		}
	} //}}}
	//{{{ saveFavorites() method
	public static void saveFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				return;
			int i = 0;
			Iterator iter = favorites.iterator();
			while(iter.hasNext())
			{
				FavoritesEntry e = ((FavoritesEntry)
					iter.next());
				jEdit.setProperty(""vfs.favorite."" + i,
					e.path);
				jEdit.setIntegerProperty(""vfs.favorite."" + i
					+ "".type"",e.type);
				i++;
			}
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size());
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size()
				+ "".type"");
		}
	} //}}}
	//{{{ getFavorites() method
	public static VFS.DirectoryEntry[] getFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();
			return (VFS.DirectoryEntry[])favorites.toArray(
				new VFS.DirectoryEntry[favorites.size()]);
		}
	} //}}}
	//{{{ Private members
	private static FavoritesVFS instance;
	private static Object lock = new Object();
	private static List favorites;
	//}}}
	//{{{ FavoritesEntry class
	static class FavoritesEntry extends VFS.DirectoryEntry
	{
		FavoritesEntry(String path, int type)
		{
			super(path,path,PROTOCOL + "":"" + path,type,0,false);
		}
		public String getExtendedAttribute(String name)
		{
			if(name.equals(EA_TYPE))
				return super.getExtendedAttribute(name);
			else
			{
				// don't want it to show ""0 bytes"" for size,
				// etc.
				return null;
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.io.FileRootsVFS,"/*
 * FileRootsVFS.java - Local root filesystems VFS
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 * Portions copyright (C) 2002 Kris Kopicki
 * Portions copyright (C) 2002 Carmine Lucarelli
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
//{{{ Imports
import javax.swing.filechooser.FileSystemView;
import java.awt.Component;
import java.lang.reflect.*;
import java.io.File;
import java.util.LinkedList;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.util.Log;
//}}}
/**
 * A VFS that lists local root filesystems.
 * @author Slava Pestov
 * @version $Id: FileRootsVFS.java,v 1.18 2004/07/12 19:25:07 spestov Exp $
 */
public class FileRootsVFS extends VFS
{
	public static final String PROTOCOL = ""roots"";
	//{{{ FileRootsVFS constructor
	public FileRootsVFS()
	{
		super(""roots"",LOW_LATENCY_CAP,new String[] {
			EA_TYPE });
		// JDK 1.4 adds methods to obtain a drive letter label and
		// list the desktop on Windows
		if(OperatingSystem.hasJava14())
		{
			try
			{
				getSystemDisplayName = FileSystemView.class.getMethod(""getSystemDisplayName"",
					new Class[] { java.io.File.class });
				getRoots = FileSystemView.class.getMethod(""getRoots"",
					new Class[0]);
				isFileSystemRoot = FileSystemView.class.getMethod(""isFileSystemRoot"",
					new Class[] { java.io.File.class });
				isFloppyDrive = FileSystemView.class.getMethod(""isFloppyDrive"",
					new Class[] { java.io.File.class });
				isDrive = FileSystemView.class.getMethod(""isDrive"",
					new Class[] { java.io.File.class });
				fsView = FileSystemView.getFileSystemView();
				Log.log(Log.DEBUG,this,""Java 1.4 FileSystemView detected"");
			}
			catch(Exception e)
			{
				Log.log(Log.DEBUG,this,""Java 1.4 FileSystemView not detected"");
			}
		}
	} //}}}
	//{{{ getParentOfPath() method
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} //}}}
	//{{{ _listDirectory() method
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		File[] roots = listRoots();
		if(roots == null)
			return null;
		VFS.DirectoryEntry[] rootDE = new VFS.DirectoryEntry[roots.length];
		for(int i = 0; i < roots.length; i++)
			rootDE[i] = new RootsEntry(roots[i]);
		return rootDE;
	} //}}}
	//{{{ _getDirectoryEntry() method
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		return new RootsEntry(new File(path));
	} //}}}
	//{{{ Private members
	private static FileSystemView fsView;
	private static Method getSystemDisplayName;
	private static Method getRoots;
	private static Method isFileSystemRoot;
	private static Method isFloppyDrive;
	private static Method isDrive;
	//{{{ listRoots() method
	private static File[] listRoots()
	{
		if (OperatingSystem.isMacOS())
		{
			// Nasty hardcoded values
			File[] volumes = new File(""/Volumes"").listFiles();
			LinkedList roots = new LinkedList();
			roots.add(new File(""/""));
			for (int i=0; i<volumes.length; i++)
			{
				// Make sure people don't do stupid things like putting files in /Volumes
				if (volumes[i].isDirectory())
					roots.add(volumes[i]);
			}
			return (File[])roots.toArray(new File[0]);
		}
		else
		{
			File[] roots = File.listRoots();
			File[] desktop = null;
			if(getRoots != null)
			{
				try
				{
					desktop = (File[])getRoots.invoke(fsView,
						new Object[0]);
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR, FileRootsVFS.class, ""Error getting Desktop: "" + e.getMessage());
					desktop = null;
				}
			}
			if(desktop == null)
				return roots;
			File[] rootsPlus = new File[roots.length + desktop.length];
			System.arraycopy(desktop, 0, rootsPlus, 0, desktop.length);
			System.arraycopy(roots, 0, rootsPlus, 1, roots.length);
			return rootsPlus;
		}
	} //}}}
	//}}}
	//{{{ RootsEntry class
	static class RootsEntry extends VFS.DirectoryEntry
	{
		RootsEntry(File file)
		{
			// REMIND: calling isDirectory() on a floppy drive
			// displays stupid I/O error dialog box on Windows
			this.path = this.deletePath = this.symlinkPath
				= file.getPath();
			if(isFloppy(file))
			{
				type = VFS.DirectoryEntry.FILESYSTEM;
				name = path;
			}
			else if(isDrive(file))
			{
				type = VFS.DirectoryEntry.FILESYSTEM;
				if(getSystemDisplayName != null)
				{
					try
					{
						name = path + "" "" + (String)getSystemDisplayName
							.invoke(fsView,new Object[] { file });
					}
					catch(Exception e)
					{
						Log.log(Log.ERROR,this,e);
						name = path;
					}
				}
			}
			else if(file.isDirectory())
			{
				type = VFS.DirectoryEntry.FILESYSTEM;
				if(isFileSystemRoot != null)
				{
					try
					{
						if(Boolean.FALSE.equals(isFileSystemRoot
							.invoke(fsView,new Object[] { file })))
						{
							type = VFS.DirectoryEntry.DIRECTORY;
						}
					}
					catch(Exception e) {}
				}
				if(OperatingSystem.isMacOS())
					name = MiscUtilities.getFileName(path);
				else
					name = path;
			}
			else
				type = VFS.DirectoryEntry.FILE;
		}
		public String getExtendedAttribute(String name)
		{
			if(name.equals(EA_TYPE))
				return super.getExtendedAttribute(name);
			else
			{
				// don't want it to show ""0 bytes"" for size,
				// etc.
				return null;
			}
		}
		private boolean isFloppy(File file)
		{
			// to prevent windows looking for a disk in the floppy drive
			if(isFloppyDrive != null)
			{
				try
				{
					return Boolean.TRUE.equals(isFloppyDrive.
						invoke(fsView, new Object[] { file }));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,e);
					return false;
				}
			}
			else
				return path.startsWith(""A:"") || path.startsWith(""B:"");
		}
		private boolean isDrive(File file)
		{
			// so an empty cd drive is not reported as a file
			if(isDrive != null)
			{
				try
				{
					return Boolean.TRUE.equals(isDrive.
						invoke(fsView, new Object[] { file }));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,e);
					return false;
				}
			}
			else
				return true;
		}
	} //}}}
}
"
org.gjt.sp.jedit.io.FileVFS,"/*
 * FileVFS.java - Local filesystem VFS
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000, 2001, 2002 Slava Pestov
 * Portions copyright (C) 1998, 1999, 2000 Peter Graves
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
//{{{ Imports
import java.awt.Component;
import java.io.*;
import java.text.*;
import java.util.Date;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Local filesystem VFS.
 * @author Slava Pestov
 * @version $Id: FileVFS.java,v 1.47 2004/06/09 16:48:40 spestov Exp $
 */
public class FileVFS extends VFS
{
	public static final String PERMISSIONS_PROPERTY = ""FileVFS__perms"";
	//{{{ FileVFS method
	public FileVFS()
	{
		super(""file"",READ_CAP | WRITE_CAP | DELETE_CAP
			| RENAME_CAP | MKDIR_CAP | LOW_LATENCY_CAP
			| ((OperatingSystem.isMacOS()
			|| OperatingSystem.isDOSDerived())
			? CASE_INSENSITIVE_CAP : 0),
			new String[] { EA_TYPE, EA_SIZE, EA_STATUS,
			EA_MODIFIED });
	} //}}}
	//{{{ getParentOfPath() method
	public String getParentOfPath(String path)
	{
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.length() == 3 && path.endsWith("":\\""))
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.startsWith(""\\\\"") && path.indexOf('\\',2) == -1)
				return path;
		}
		return super.getParentOfPath(path);
	} //}}}
	//{{{ constructPath() method
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(File.separator)
			|| parent.endsWith(""/""))
			return parent + path;
		else
			return parent + File.separator + path;
	} //}}}
	//{{{ getFileSeparator() method
	public char getFileSeparator()
	{
		return File.separatorChar;
	} //}}}
	//{{{ save() method
	public boolean save(View view, Buffer buffer, String path)
	{
		if(OperatingSystem.isUnix())
		{
			int permissions = getPermissions(buffer.getPath());
			Log.log(Log.DEBUG,this,buffer.getPath() + "" has permissions 0""
				+ Integer.toString(permissions,8));
			buffer.setIntegerProperty(PERMISSIONS_PROPERTY,permissions);
		}
		return super.save(view,buffer,path);
	} //}}}
	//{{{ insert() method
	public boolean insert(View view, Buffer buffer, String path)
	{
		File file = new File(path);
		//{{{ Check if file is valid
		if(!file.exists())
			return false;
		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.open-directory"",null);
			return false;
		}
		if(!file.canRead())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-read"",null);
			return false;
		} //}}}
		return super.insert(view,buffer,path);
	} //}}}
	//{{{ _canonPath() method
	/**
	 * Returns the canonical form if the specified path name. For example,
	 * <code>~</code> might be expanded to the user's home directory.
	 * @param session The session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 4.0pre2
	 */
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return MiscUtilities.canonPath(path);
	} //}}}
	//{{{ LocalDirectoryEntry class
	public static class LocalDirectoryEntry extends VFS.DirectoryEntry
	{
		// use system default short format
		public static DateFormat DATE_FORMAT
			= DateFormat.getInstance();
		public long modified;
		public LocalDirectoryEntry(File file)
		{
			super(file.getName(),file.getPath(),
				file.getPath(),file.isDirectory() ? DIRECTORY : FILE,file.length(),file.isHidden());
			this.modified = file.lastModified();
			this.canRead = file.canRead();
			this.canWrite = file.canWrite();
			this.symlinkPath = MiscUtilities.resolveSymlinks(path);
		}
		public String getExtendedAttribute(String name)
		{
			if(name.equals(EA_MODIFIED))
				return DATE_FORMAT.format(new Date(modified));
			else
				return super.getExtendedAttribute(name);
		}
	} //}}}
	//{{{ _listDirectory() method
	public VFS.DirectoryEntry[] _listDirectory(Object session, String path,
		Component comp)
	{
		//{{{ Windows work around
		/* On Windows, paths of the form X: list the last *working
		 * directory* on that drive. To list the root of the drive,
		 * you must use X:\.
		 *
		 * However, the VFS browser and friends strip off trailing
		 * path separators, for various reasons. So to work around
		 * that, we add a '\' to drive letter paths on Windows.
		 */
		if(OperatingSystem.isWindows())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				path = path.concat(File.separator);
		} //}}}
		File directory = new File(path);
		File[] list = directory.listFiles();
		if(list == null)
		{
			VFSManager.error(comp,path,""ioerror.directory-error-nomsg"",null);
			return null;
		}
		VFS.DirectoryEntry[] list2 = new VFS.DirectoryEntry[list.length];
		for(int i = 0; i < list.length; i++)
			list2[i] = new LocalDirectoryEntry(list[i]);
		return list2;
	} //}}}
	//{{{ _getDirectoryEntry() method
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		if(path.equals(""/"") && OperatingSystem.isUnix())
		{
			return new VFS.DirectoryEntry(path,path,path,
				VFS.DirectoryEntry.DIRECTORY,0L,false);
		}
		File file = new File(path);
		if(!file.exists())
			return null;
		return new LocalDirectoryEntry(file);
	} //}}}
	//{{{ _delete() method
	public boolean _delete(Object session, String path, Component comp)
	{
		File file = new File(path);
		// do some platforms throw exceptions if the file does not exist
		// when we ask for the canonical path?
		String canonPath;
		try
		{
			canonPath = file.getCanonicalPath();
		}
		catch(IOException io)
		{
			canonPath = path;
		}
		boolean retVal = file.delete();
		if(retVal)
			VFSManager.sendVFSUpdate(this,canonPath,true);
		return retVal;
	} //}}}
	//{{{ _rename() method
	public boolean _rename(Object session, String from, String to,
		Component comp)
	{
		File _to = new File(to);
		String toCanonPath;
		try
		{
			toCanonPath = _to.getCanonicalPath();
		}
		catch(IOException io)
		{
			toCanonPath = to;
		}
		// this is needed because on OS X renaming to a non-existent
		// directory causes problems
		File parent = new File(_to.getParent());
		if(parent.exists())
		{
			if(!parent.isDirectory())
				return false;
		}
		else
		{
			parent.mkdirs();
			if(!parent.exists())
				return false;
		}
		File _from = new File(from);
		String fromCanonPath;
		try
		{
			fromCanonPath = _from.getCanonicalPath();
		}
		catch(IOException io)
		{
			fromCanonPath = from;
		}
		// Case-insensitive fs workaround
		if(!fromCanonPath.equalsIgnoreCase(toCanonPath))
			_to.delete();
		boolean retVal = _from.renameTo(_to);
		VFSManager.sendVFSUpdate(this,fromCanonPath,true);
		VFSManager.sendVFSUpdate(this,toCanonPath,true);
		return retVal;
	} //}}}
	//{{{ _mkdir() method
	public boolean _mkdir(Object session, String directory, Component comp)
	{
		String parent = getParentOfPath(directory);
		if(!new File(parent).exists())
		{
			if(!_mkdir(session,parent,comp))
				return false;
		}
		File file = new File(directory);
		boolean retVal = file.mkdir();
		String canonPath;
		try
		{
			canonPath = file.getCanonicalPath();
		}
		catch(IOException io)
		{
			canonPath = directory;
		}
		VFSManager.sendVFSUpdate(this,canonPath,true);
		return retVal;
	} //}}}
	//{{{ _backup() method
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
		// Fetch properties
		int backups = jEdit.getIntegerProperty(""backups"",1);
		if(backups == 0)
			return;
		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");
		String backupDirectory = jEdit.getProperty(""backup.directory"");
		int backupTimeDistance = jEdit.getIntegerProperty(""backup.minTime"",0);
		File file = new File(path);
		// Check for backup.directory, and create that
		// directory if it doesn't exist
		if(backupDirectory == null || backupDirectory.length() == 0)
			backupDirectory = file.getParent();
		else
		{
			backupDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),backupDirectory);
			// Perhaps here we would want to guard with
			// a property for parallel backups or not.
			backupDirectory = MiscUtilities.concatPath(
				backupDirectory,file.getParent());
			File dir = new File(backupDirectory);
			if (!dir.exists())
				dir.mkdirs();
		}
		MiscUtilities.saveBackup(file,backups,backupPrefix,
			backupSuffix,backupDirectory,backupTimeDistance);
	} //}}}
	//{{{ _createInputStream() method
	public InputStream _createInputStream(Object session, String path,
		boolean ignoreErrors, Component comp) throws IOException
	{
		try
		{
			return new FileInputStream(path);
		}
		catch(IOException io)
		{
			if(ignoreErrors)
				return null;
			else
				throw io;
		}
	} //}}}
	//{{{ _createOutputStream() method
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		return new FileOutputStream(path);
	} //}}}
	//{{{ _saveComplete() method
	public void _saveComplete(Object session, Buffer buffer, String path,
		Component comp)
	{
		int permissions = buffer.getIntegerProperty(PERMISSIONS_PROPERTY,0);
		setPermissions(path,permissions);
	} //}}}
	//{{{ Permission preservation code
	/** Code borrowed from j text editor (http://www.armedbear.org) */
	/** I made some changes to make it support suid, sgid and sticky files */
	//{{{ getPermissions() method
	/**
	 * Returns numeric permissions of a file. On non-Unix systems, always
	 * returns zero.
	 * @since jEdit 3.2pre9
	 */
	public static int getPermissions(String path)
	{
		int permissions = 0;
		if(jEdit.getBooleanProperty(""chmodDisabled""))
			return permissions;
		if(OperatingSystem.isUnix())
		{
			String[] cmdarray = { ""ls"", ""-ld"", path };
			try
			{
				Process process = Runtime.getRuntime().exec(cmdarray);
				BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
				String output = reader.readLine();
				if(output != null)
				{
					String s = output.substring(1, 10);
					permissions = MiscUtilities
						.parsePermissions(s);
				}
			}
			// Feb 4 2000 5:30 PM
			// Catch Throwable here rather than Exception.
			// Kaffe's implementation of Runtime.exec throws java.lang.InternalError.
			catch (Throwable t)
			{
			}
		}
		return permissions;
	} //}}}
	//{{{ setPermissions() method
	/**
	 * Sets numeric permissions of a file. On non-Unix platforms,
	 * does nothing.
	 * @since jEdit 3.2pre9
	 */
	public static void setPermissions(String path, int permissions)
	{
		if(jEdit.getBooleanProperty(""chmodDisabled""))
			return;
		if(permissions != 0)
		{
			if(OperatingSystem.isUnix())
			{
				String[] cmdarray = { ""chmod"", Integer.toString(permissions, 8), path };
				try
				{
					Process process = Runtime.getRuntime().exec(cmdarray);
					process.getInputStream().close();
					process.getOutputStream().close();
					process.getErrorStream().close();
					// Jun 9 2004 12:40 PM
					// waitFor() hangs on some Java
					// implementations.
					/* int exitCode = process.waitFor();
					if(exitCode != 0)
						Log.log(Log.NOTICE,FileVFS.class,""chmod exited with code "" + exitCode); */
				}
				// Feb 4 2000 5:30 PM
				// Catch Throwable here rather than Exception.
				// Kaffe's implementation of Runtime.exec throws java.lang.InternalError.
				catch (Throwable t)
				{
				}
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.io.UrlVFS,"/*
 * UrlVFS.java - URL VFS
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
//{{{ Imports
import java.awt.Component;
import java.io.*;
import java.net.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * URL VFS.
 * @author Slava Pestov
 * @version $Id: UrlVFS.java,v 1.6 2003/01/12 03:08:24 spestov Exp $
 */
public class UrlVFS extends VFS
{
	//{{{ UrlVFS constructor
	public UrlVFS()
	{
		super(""url"",READ_CAP | WRITE_CAP);
	} //}}}
	//{{{ constructPath() method
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(""/""))
			return parent + path;
		else
			return parent + '/' + path;
	} //}}}
	//{{{ _createInputStream() method
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		try
		{
			return new URL(path).openStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} //}}}
	//{{{ _createOutputStream() method
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		try
		{
			return new URL(path).openConnection()
				.getOutputStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} //}}}
}
"
org.gjt.sp.jedit.io.VFS,"/*
 * VFS.java - Virtual filesystem implementation
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
//{{{ Imports
import gnu.regexp.*;
import java.awt.Color;
import java.awt.Component;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.buffer.BufferIORequest;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * A virtual filesystem implementation.<p>
 *
 * Plugins can provide virtual file systems by defining entries in their
 * <code>services.xml</code> files like so:
 *
 * <pre>&lt;SERVICE CLASS=""org.gjt.sp.jedit.io.VFS"" NAME=""<i>name</i>""&gt;
 *    new <i>MyVFS</i>();
 *&lt;/SERVICE&gt;</pre>
 *
 * URLs of the form <code><i>name</i>:<i>path</i></code> will then be handled
 * by the VFS named <code><i>name</i></code>.<p>
 *
 * See {@link org.gjt.sp.jedit.ServiceManager} for details.<p>
 *
 * <h3>Session objects:</h3>
 *
 * A session is used to persist things like login information, any network
 * sockets, etc. File system implementations that do not need this kind of
 * persistence return a dummy object as a session.<p>
 *
 * Methods whose names are prefixed with ""_"" expect to be given a
 * previously-obtained session object. A session must be obtained from the AWT
 * thread in one of two ways:
 *
 * <ul>
 * <li>{@link #createVFSSession(String,Component)}</li>
 * <li>{@link #showBrowseDialog(Object[],Component)}</li>
 * </ul>
 *
 * When done, the session must be disposed of using
 * {@link #_endVFSSession(Object,Component)}.<p>
 *
 * <h3>Thread safety:</h3>
 *
 * The following methods cannot be called from an I/O thread:
 *
 * <ul>
 * <li>{@link #createVFSSession(String,Component)}</li>
 * <li>{@link #insert(View,Buffer,String)}</li>
 * <li>{@link #load(View,Buffer,String)}</li>
 * <li>{@link #save(View,Buffer,String)}</li>
 * <li>{@link #showBrowseDialog(Object[],Component)}</li>
 * </ul>
 *
 * All remaining methods are required to be thread-safe in subclasses.
 *
 * <h3>Implementing a VFS</h3>
 *
 * You can override as many or as few methods as you want. Make sure
 * {@link #getCapabilities()} returns a value reflecting the functionality
 * implemented by your VFS.
 *
 * @see VFSManager#getVFSForPath(String)
 * @see VFSManager#getVFSForProtocol(String)
 *
 * @author Slava Pestov
 * @author $Id: VFS.java,v 1.39 2003/09/08 01:24:11 spestov Exp $
 */
public abstract class VFS
{
	//{{{ Capabilities
	/**
	 * Read capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int READ_CAP = 1 << 0;
	/**
	 * Write capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int WRITE_CAP = 1 << 1;
	/**
	 * @deprecated Do not define this capability.<p>
	 *
	 * This was the official API for adding items to a file
	 * system browser's <b>Plugins</b> menu in jEdit 4.1 and earlier. In
	 * jEdit 4.2, there is a different way of doing this, you must provide
	 * a <code>browser.actions.xml</code> file in your plugin JAR, and
	 * define <code>plugin.<i>class</i>.browser-menu-item</code>
	 * or <code>plugin.<i>class</i>.browser-menu</code> properties.
	 * See {@link org.gjt.sp.jedit.EditPlugin} for details.
	 */
	public static final int BROWSE_CAP = 1 << 2;
	/**
	 * Delete file capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int DELETE_CAP = 1 << 3;
	/**
	 * Rename file capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int RENAME_CAP = 1 << 4;
	/**
	 * Make directory capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int MKDIR_CAP = 1 << 5;
	/**
	 * Low latency capability. If this is not set, then a confirm dialog
	 * will be shown before doing a directory search in this VFS.
	 * @since jEdit 4.1pre1
	 */
	public static final int LOW_LATENCY_CAP = 1 << 6;
	/**
	 * Case insensitive file system capability.
	 * @since jEdit 4.1pre1
	 */
	public static final int CASE_INSENSITIVE_CAP = 1 << 7;
	//}}}
	//{{{ Extended attributes
	/**
	 * File type.
	 * @since jEdit 4.2pre1
	 */
	public static final String EA_TYPE = ""type"";
	/**
	 * File status (read only, read write, etc).
	 * @since jEdit 4.2pre1
	 */
	public static final String EA_STATUS = ""status"";
	/**
	 * File size.
	 * @since jEdit 4.2pre1
	 */
	public static final String EA_SIZE = ""size"";
	/**
	 * File last modified date.
	 * @since jEdit 4.2pre1
	 */
	public static final String EA_MODIFIED = ""modified"";
	//}}}
	//{{{ VFS constructor
	/**
	 * @deprecated Use the form where the constructor takes a capability
	 * list.
	 */
	public VFS(String name)
	{
		this(name,0);
	} //}}}
	//{{{ VFS constructor
	/**
	 * Creates a new virtual filesystem.
	 * @param name The name
	 * @param caps The capabilities
	 */
	public VFS(String name, int caps)
	{
		this.name = name;
		this.caps = caps;
		// reasonable defaults (?)
		this.extAttrs = new String[] { EA_SIZE, EA_TYPE };
	} //}}}
	//{{{ VFS constructor
	/**
	 * Creates a new virtual filesystem.
	 * @param name The name
	 * @param caps The capabilities
	 * @param extAttrs The extended attributes
	 * @since jEdit 4.2pre1
	 */
	public VFS(String name, int caps, String[] extAttrs)
	{
		this.name = name;
		this.caps = caps;
		this.extAttrs = extAttrs;
	} //}}}
	//{{{ getName() method
	/**
	 * Returns this VFS's name. The name is used to obtain the
	 * label stored in the <code>vfs.<i>name</i>.label</code>
	 * property.
	 */
	public String getName()
	{
		return name;
	} //}}}
	//{{{ getCapabilities() method
	/**
	 * Returns the capabilities of this VFS.
	 * @since jEdit 2.6pre2
	 */
	public int getCapabilities()
	{
		return caps;
	} //}}}
	//{{{ getExtendedAttributes() method
	/**
	 * Returns the extended attributes supported by this VFS.
	 * @since jEdit 4.2pre1
	 */
	public String[] getExtendedAttributes()
	{
		return extAttrs;
	} //}}}
	//{{{ showBrowseDialog() method
	/**
	 * Displays a dialog box that should set up a session and return
	 * the initial URL to browse.
	 * @param session Where the VFS session will be stored
	 * @param comp The component that will parent error dialog boxes
	 * @return The URL
	 * @since jEdit 2.7pre1
	 */
	public String showBrowseDialog(Object[] session, Component comp)
	{
		return null;
	} //}}}
	//{{{ getFileName() method
	/**
	 * Returns the file name component of the specified path.
	 * @param path The path
	 * @since jEdit 3.1pre4
	 */
	public String getFileName(String path)
	{
		if(path.equals(""/""))
			return path;
		if(path.endsWith(""/"") || path.endsWith(File.separator))
			path = path.substring(0,path.length() - 1);
		int index = Math.max(path.lastIndexOf('/'),
			path.lastIndexOf(File.separatorChar));
		if(index == -1)
			index = path.indexOf(':');
		// don't want getFileName(""roots:"") to return """"
		if(index == -1 || index == path.length() - 1)
			return path;
		return path.substring(index + 1);
	} //}}}
	//{{{ getParentOfPath() method
	/**
	 * Returns the parent of the specified path. This must be
	 * overridden to return a non-null value for browsing of this
	 * filesystem to work.
	 * @param path The path
	 * @since jEdit 2.6pre5
	 */
	public String getParentOfPath(String path)
	{
		// ignore last character of path to properly handle
		// paths like /foo/bar/
		int count = Math.max(0,path.length() - 2);
		int index = path.lastIndexOf(File.separatorChar,count);
		if(index == -1)
			index = path.lastIndexOf('/',count);
		if(index == -1)
		{
			// this ensures that getFileParent(""protocol:""), for
			// example, is ""protocol:"" and not """".
			index = path.lastIndexOf(':');
		}
		return path.substring(0,index + 1);
	} //}}}
	//{{{ constructPath() method
	/**
	 * Constructs a path from the specified directory and
	 * file name component. This must be overridden to return a
	 * non-null value, otherwise browsing this filesystem will
	 * not work.<p>
	 *
	 * Unless you are writing a VFS, this method should not be called
	 * directly. To ensure correct behavior, you <b>must</b> call
	 * {@link org.gjt.sp.jedit.MiscUtilities#constructPath(String,String)}
	 * instead.
	 *
	 * @param parent The parent directory
	 * @param path The path
	 * @since jEdit 2.6pre2
	 */
	public String constructPath(String parent, String path)
	{
		return parent + path;
	} //}}}
	//{{{ getFileSeparator() method
	/**
	 * Returns the file separator used by this VFS.
	 * @since jEdit 2.6pre9
	 */
	public char getFileSeparator()
	{
		return '/';
	} //}}}
	//{{{ getTwoStageSaveName() method
	/**
	 * Returns a temporary file name based on the given path.
	 *
	 * By default jEdit first saves a file to <code>#<i>name</i>#save#</code>
	 * and then renames it to the original file. However some virtual file
	 * systems might not support the <code>#</code> character in filenames,
	 * so this method permits the VFS to override this behavior.
	 *
	 * @param path The path name
	 * @since jEdit 4.1pre7
	 */
	public String getTwoStageSaveName(String path)
	{
		return MiscUtilities.constructPath(getParentOfPath(path),
			'#' + getFileName(path) + ""#save#"");
	} //}}}
	//{{{ reloadDirectory() method
	/**
	 * Called before a directory is reloaded by the file system browser.
	 * Can be used to flush a cache, etc.
	 * @since jEdit 4.0pre3
	 */
	public void reloadDirectory(String path) {} //}}}
	//{{{ createVFSSession() method
	/**
	 * Creates a VFS session. This method is called from the AWT thread,
	 * so it should not do any I/O. It could, however, prompt for
	 * a login name and password, for example.
	 * @param path The path in question
	 * @param comp The component that will parent any dialog boxes shown
	 * @return The session
	 * @since jEdit 2.6pre3
	 */
	public Object createVFSSession(String path, Component comp)
	{
		return new Object();
	} //}}}
	//{{{ load() method
	/**
	 * Loads the specified buffer. The default implementation posts
	 * an I/O request to the I/O thread.
	 * @param view The view
	 * @param buffer The buffer
	 * @param path The path
	 */
	public boolean load(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}
		Object session = createVFSSession(path,view);
		if(session == null)
			return false;
		if((getCapabilities() & WRITE_CAP) == 0)
			buffer.setReadOnly(true);
		BufferIORequest request = new BufferIORequest(
			BufferIORequest.LOAD,view,buffer,session,this,path);
		if(buffer.isTemporary())
			// this makes HyperSearch much faster
			request.run();
		else
			VFSManager.runInWorkThread(request);
		return true;
	} //}}}
	//{{{ save() method
	/**
	 * Saves the specifies buffer. The default implementation posts
	 * an I/O request to the I/O thread.
	 * @param view The view
	 * @param buffer The buffer
	 * @param path The path
	 */
	public boolean save(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & WRITE_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.save"",new String[] { name });
			return false;
		}
		Object session = createVFSSession(path,view);
		if(session == null)
			return false;
		/* When doing a 'save as', the path to save to (path)
		 * will not be the same as the buffer's previous path
		 * (buffer.getPath()). In that case, we want to create
		 * a backup of the new path, even if the old path was
		 * backed up as well (BACKED_UP property set) */
		if(!path.equals(buffer.getPath()))
			buffer.unsetProperty(Buffer.BACKED_UP);
		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.SAVE,view,buffer,session,this,path));
		return true;
	} //}}}
	//{{{ insert() method
	/**
	 * Inserts a file into the specified buffer. The default implementation
	 * posts an I/O request to the I/O thread.
	 * @param view The view
	 * @param buffer The buffer
	 * @param path The path
	 */
	public boolean insert(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}
		Object session = createVFSSession(path,view);
		if(session == null)
			return false;
		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.INSERT,view,buffer,session,this,path));
		return true;
	} //}}}
	// A method name that starts with _ requires a session object
	//{{{ _canonPath() method
	/**
	 * Returns the canonical form of the specified path name. For example,
	 * <code>~</code> might be expanded to the user's home directory.
	 * @param session The session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 4.0pre2
	 */
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return path;
	} //}}}
	//{{{ _listDirectory() method
	/**
	 * A convinience method that matches file names against globs, and can
	 * optionally list the directory recursively.
	 * @param session The session
	 * @param directory The directory. Note that this must be a full
	 * URL, including the host name, path name, and so on. The
	 * username and password (if needed by the VFS) is obtained from the
	 * session instance.
	 * @param glob Only file names matching this glob will be returned
	 * @param recursive If true, subdirectories will also be listed.
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 4.1pre1
	 */
	public String[] _listDirectory(Object session, String directory,
		String glob, boolean recursive, Component comp)
		throws IOException
	{
		Log.log(Log.DEBUG,this,""Listing "" + directory);
		ArrayList files = new ArrayList(100);
		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob),
				RE.REG_ICASE);
		}
		catch(REException e)
		{
			Log.log(Log.ERROR,this,e);
			return null;
		}
		_listDirectory(session,new ArrayList(),files,directory,filter,
			recursive,comp);
		String[] retVal = (String[])files.toArray(new String[files.size()]);
		Arrays.sort(retVal,new MiscUtilities.StringICaseCompare());
		return retVal;
	} //}}}
	//{{{ _listDirectory() method
	/**
	 * Lists the specified directory. 
	 * @param session The session
	 * @param directory The directory. Note that this must be a full
	 * URL, including the host name, path name, and so on. The
	 * username and password (if needed by the VFS) is obtained from the
	 * session instance.
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 2.7pre1
	 */
	public DirectoryEntry[] _listDirectory(Object session, String directory,
		Component comp)
		throws IOException
	{
		VFSManager.error(comp,directory,""vfs.not-supported.list"",new String[] { name });
		return null;
	} //}}}
	//{{{ _getDirectoryEntry() method
	/**
	 * Returns the specified directory entry.
	 * @param session The session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @return The specified directory entry, or null if it doesn't exist.
	 * @since jEdit 2.7pre1
	 */
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
		throws IOException
	{
		return null;
	} //}}}
	//{{{ DirectoryEntry class
	/**
	 * A directory entry.
	 * @since jEdit 2.6pre2
	 */
	public static class DirectoryEntry implements Serializable
	{
		//{{{ File types
		public static final int FILE = 0;
		public static final int DIRECTORY = 1;
		public static final int FILESYSTEM = 2;
		//}}}
		//{{{ Instance variables
		public String name;
		public String path;
		/**
		 * @since jEdit 4.2pre5
		 */
		public String symlinkPath;
		public String deletePath;
		public int type;
		public long length;
		public boolean hidden;
		public boolean canRead;
		public boolean canWrite;
		//}}}
		//{{{ DirectoryEntry constructor
		/**
		 * @since jEdit 4.2pre2
		 */
		public DirectoryEntry()
		{
		} //}}}
		//{{{ DirectoryEntry constructor
		public DirectoryEntry(String name, String path, String deletePath,
			int type, long length, boolean hidden)
		{
			this.name = name;
			this.path = path;
			this.deletePath = deletePath;
			this.symlinkPath = path;
			this.type = type;
			this.length = length;
			this.hidden = hidden;
			if(path != null)
			{
				// maintain backwards compatibility
				VFS vfs = VFSManager.getVFSForPath(path);
				canRead = ((vfs.getCapabilities() & READ_CAP) != 0);
				canWrite = ((vfs.getCapabilities() & WRITE_CAP) != 0);
			}
		} //}}}
		protected boolean colorCalculated;
		protected Color color;
		//{{{ getExtendedAttribute() method
		/**
		 * Returns the value of an extended attribute. Note that this
		 * returns formatted strings (eg, ""10 Mb"" for a file size of
		 * 1048576 bytes). If you need access to the raw data, access
		 * fields and methods of this class.
		 * @param name The extended attribute name
		 * @since jEdit 4.2pre1
		 */
		public String getExtendedAttribute(String name)
		{
			if(name.equals(EA_TYPE))
			{
				switch(type)
				{
				case FILE:
					return jEdit.getProperty(""vfs.browser.type.file"");
				case DIRECTORY:
					return jEdit.getProperty(""vfs.browser.type.directory"");
				case FILESYSTEM:
					return jEdit.getProperty(""vfs.browser.type.filesystem"");
				default:
					throw new IllegalArgumentException();
				}
			}
			else if(name.equals(EA_STATUS))
			{
				if(canRead)
				{
					if(canWrite)
						return jEdit.getProperty(""vfs.browser.status.rw"");
					else
						return jEdit.getProperty(""vfs.browser.status.ro"");
				}
				else
				{
					if(canWrite)
						return jEdit.getProperty(""vfs.browser.status.append"");
					else
						return jEdit.getProperty(""vfs.browser.status.no"");
				}
			}
			else if(name.equals(EA_SIZE))
			{
				if(type != FILE)
					return null;
				else
					return MiscUtilities.formatFileSize(length);
			}
			else
				return null;
		} //}}}
		//{{{ getColor() method
		public Color getColor()
		{
			if(!colorCalculated)
			{
				colorCalculated = true;
				color = getDefaultColorFor(name);
			}
			return color;
		} //}}}
		//{{{ toString() method
		public String toString()
		{
			return name;
		} //}}}
	} //}}}
	//{{{ _delete() method
	/**
	 * Deletes the specified URL.
	 * @param session The VFS session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public boolean _delete(Object session, String path, Component comp)
		throws IOException
	{
		return false;
	} //}}}
	//{{{ _rename() method
	/**
	 * Renames the specified URL. Some filesystems might support moving
	 * URLs between directories, however others may not. Do not rely on
	 * this behavior.
	 * @param session The VFS session
	 * @param from The old path
	 * @param to The new path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public boolean _rename(Object session, String from, String to,
		Component comp) throws IOException
	{
		return false;
	} //}}}
	//{{{ _mkdir() method
	/**
	 * Creates a new directory with the specified URL.
	 * @param session The VFS session
	 * @param directory The directory
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public boolean _mkdir(Object session, String directory, Component comp)
		throws IOException
	{
		return false;
	} //}}}
	//{{{ _backup() method
	/**
	 * Backs up the specified file. This should only be overriden by
	 * the local filesystem VFS.
	 * @param session The VFS session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 3.2pre2
	 */
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
	} //}}}
	//{{{ _createInputStream() method
	/**
	 * Creates an input stream. This method is called from the I/O
	 * thread.
	 * @param session the VFS session
	 * @param path The path
	 * @param ignoreErrors If true, file not found errors should be
	 * ignored
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException If an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.load"",new String[] { name });
		return null;
	} //}}}
	//{{{ _createOutputStream() method
	/**
	 * Creates an output stream. This method is called from the I/O
	 * thread.
	 * @param session the VFS session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException If an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public OutputStream _createOutputStream(Object session,
		String path, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.save"",new String[] { name });
		return null;
	} //}}}
	//{{{ _saveComplete() method
	/**
	 * Called after a file has been saved.
	 * @param session The VFS session
	 * @param buffer The buffer
	 * @param path The path the buffer was saved to (can be different from
	 * {@link org.gjt.sp.jedit.Buffer#getPath()} if the user invoked the
	 * <b>Save a Copy As</b> command, for example).
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException If an I/O error occurs
	 * @since jEdit 4.1pre9
	 */
	public void _saveComplete(Object session, Buffer buffer, String path,
		Component comp) throws IOException {} //}}}
	//{{{ _endVFSSession() method
	/**
	 * Finishes the specified VFS session. This must be called
	 * after all I/O with this VFS is complete, to avoid leaving
	 * stale network connections and such.
	 * @param session The VFS session
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 2.7pre1
	 */
	public void _endVFSSession(Object session, Component comp)
		throws IOException
	{
	} //}}}
	//{{{ getDefaultColorFor() method
	/**
	 * Returns color of the specified file name, by matching it against
	 * user-specified regular expressions.
	 * @since jEdit 4.0pre1
	 */
	public static Color getDefaultColorFor(String name)
	{
		synchronized(lock)
		{
			if(colors == null)
				loadColors();
			for(int i = 0; i < colors.size(); i++)
			{
				ColorEntry entry = (ColorEntry)colors.elementAt(i);
				if(entry.re.isMatch(name))
					return entry.color;
			}
			return null;
		}
	} //}}}
	//{{{ DirectoryEntryCompare class
	/**
	 * Implementation of {@link org.gjt.sp.jedit.MiscUtilities.Compare}
	 * interface that compares {@link VFS.DirectoryEntry} instances.
	 * @since jEdit 4.2pre1
	 */
	public static class DirectoryEntryCompare implements MiscUtilities.Compare
	{
		private boolean sortIgnoreCase, sortMixFilesAndDirs;
		/**
		 * Creates a new <code>DirectoryEntryCompare</code>.
		 * @param sortMixFilesAndDirs If false, directories are
		 * put at the top of the listing.
		 * @param sortIgnoreCase If false, upper case comes before
		 * lower case.
		 */
		public DirectoryEntryCompare(boolean sortMixFilesAndDirs,
			boolean sortIgnoreCase)
		{
			this.sortMixFilesAndDirs = sortMixFilesAndDirs;
			this.sortIgnoreCase = sortIgnoreCase;
		}
		public int compare(Object obj1, Object obj2)
		{
			VFS.DirectoryEntry file1 = (VFS.DirectoryEntry)obj1;
			VFS.DirectoryEntry file2 = (VFS.DirectoryEntry)obj2;
			if(!sortMixFilesAndDirs)
			{
				if(file1.type != file2.type)
					return file2.type - file1.type;
			}
			return MiscUtilities.compareStrings(file1.name,
				file2.name,sortIgnoreCase);
		}
	} //}}}
	//{{{ Private members
	private String name;
	private int caps;
	private String[] extAttrs;
	private static Vector colors;
	private static Object lock = new Object();
	//{{{ Class initializer
	static
	{
		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof PropertiesChanged)
				{
					synchronized(lock)
					{
						colors = null;
					}
				}
			}
		});
	} //}}}
	//{{{ _listDirectory() method
	private void _listDirectory(Object session, ArrayList stack,
		ArrayList files, String directory, RE glob, boolean recursive,
		Component comp) throws IOException
	{
		if(stack.contains(directory))
		{
			Log.log(Log.ERROR,this,
				""Recursion in _listDirectory(): ""
				+ directory);
			return;
		}
		else
			stack.add(directory);
		VFS.DirectoryEntry[] _files = _listDirectory(session,directory,
			comp);
		if(_files == null || _files.length == 0)
			return;
		for(int i = 0; i < _files.length; i++)
		{
			VFS.DirectoryEntry file = _files[i];
			if(file.type == VFS.DirectoryEntry.DIRECTORY
				|| file.type == VFS.DirectoryEntry.FILESYSTEM)
			{
				if(recursive)
				{
					// resolve symlinks to avoid loops
					String canonPath = _canonPath(session,file.path,comp);
					if(!MiscUtilities.isURL(canonPath))
						canonPath = MiscUtilities.resolveSymlinks(canonPath);
					_listDirectory(session,stack,files,
						canonPath,glob,recursive,
						comp);
				}
			}
			else
			{
				if(!glob.isMatch(file.name))
					continue;
				Log.log(Log.DEBUG,this,file.path);
				files.add(file.path);
			}
		}
	} //}}}
	//{{{ loadColors() method
	private static void loadColors()
	{
		synchronized(lock)
		{
			colors = new Vector();
			if(!jEdit.getBooleanProperty(""vfs.browser.colorize""))
				return;
			String glob;
			int i = 0;
			while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
			{
				try
				{
					colors.addElement(new ColorEntry(
						new RE(MiscUtilities.globToRE(glob)),
						jEdit.getColorProperty(
						""vfs.browser.colors."" + i + "".color"",
						Color.black)));
				}
				catch(REException e)
				{
					Log.log(Log.ERROR,VFS.class,""Invalid regular expression: ""
						+ glob);
					Log.log(Log.ERROR,VFS.class,e);
				}
				i++;
			}
		}
	} //}}}
	//{{{ ColorEntry class
	static class ColorEntry
	{
		RE re;
		Color color;
		ColorEntry(RE re, Color color)
		{
			this.re = re;
			this.color = color;
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.io.VFSManager,"/*
 * VFSManager.java - Main class of virtual filesystem
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
//{{{ Imports
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.awt.Frame;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.gjt.sp.jedit.gui.ErrorListDialog;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkThreadPool;
//}}}
/**
 * jEdit's virtual filesystem allows it to transparently edit files
 * stored elsewhere than the local filesystem, for example on an FTP
 * site. See the {@link VFS} class for implementation details.<p>
 *
 * Note that most of the jEdit API is not thread-safe, so special care
 * must be taken when making jEdit API calls. Also, it is not safe to
 * call <code>SwingUtilities.invokeAndWait()</code> from a work request;
 * it can cause a deadlock if the given runnable then later calls
 * {@link #waitForRequests()}.
 *
 * @author Slava Pestov
 * @version $Id: VFSManager.java,v 1.15 2004/05/10 03:21:11 spestov Exp $
 */
public class VFSManager
{
	/**
	 * The service type. See {@link org.gjt.sp.jedit.ServiceManager}.
	 * @since jEdit 4.2pre1
	 */
	public static final String SERVICE = ""org.gjt.sp.jedit.io.VFS"";
	//{{{ init() method
	/**
	 * Do not call.
	 */
	public static void init()
	{
		int count = jEdit.getIntegerProperty(""ioThreadCount"",4);
		ioThreadPool = new WorkThreadPool(""jEdit I/O"",count);
		JARClassLoader classLoader = new JARClassLoader();
		for(int i = 0; i < ioThreadPool.getThreadCount(); i++)
		{
			ioThreadPool.getThread(i).setContextClassLoader(
				classLoader);
		}
	} //}}}
	//{{{ start() method
	/**
	 * Do not call.
	 */
	public static void start()
	{
		ioThreadPool.start();
	} //}}}
	//{{{ VFS methods
	//{{{ getFileVFS() method
	/**
	 * Returns the local filesystem VFS.
	 * @since jEdit 2.5pre1
	 */
	public static VFS getFileVFS()
	{
		return fileVFS;
	} //}}}
	//{{{ getUrlVFS() method
	/**
	 * Returns the URL VFS.
	 * @since jEdit 2.5pre1
	 */
	public static VFS getUrlVFS()
	{
		return urlVFS;
	} //}}}
	//{{{ getVFSByName() method
	/**
	 * @deprecated Use <code>getVFSForProtocol()</code> instead.
	 */
	public static VFS getVFSByName(String name)
	{
		// in new api, protocol always equals name
		VFS vfs = (VFS)ServiceManager.getService(SERVICE,name);
		if(vfs == null)
			return (VFS)vfsHash.get(name);
		else
			return vfs;
	} //}}}
	//{{{ getVFSForProtocol() method
	/**
	 * Returns the VFS for the specified protocol.
	 * @param protocol The protocol
	 * @since jEdit 2.5pre1
	 */
	public static VFS getVFSForProtocol(String protocol)
	{
		if(protocol.equals(""file""))
			return fileVFS;
		else
		{
			VFS vfs = (VFS)ServiceManager.getService(SERVICE,protocol);
			if(vfs == null)
				vfs = (VFS)protocolHash.get(protocol);
			if(vfs != null)
				return vfs;
			else
				return urlVFS;
		}
	} //}}}
	//{{{ getVFSForPath() method
	/**
	 * Returns the VFS for the specified path.
	 * @param path The path
	 * @since jEdit 2.6pre4
	 */
	public static VFS getVFSForPath(String path)
	{
		if(MiscUtilities.isURL(path))
			return getVFSForProtocol(MiscUtilities.getProtocolOfURL(path));
		else
			return fileVFS;
	} //}}}
	//{{{ registerVFS() method
	/**
	 * @deprecated Write a <code>services.xml</code> file instead;
	 * see {@link org.gjt.sp.jedit.ServiceManager}.
	 */
	public static void registerVFS(String protocol, VFS vfs)
	{
		Log.log(Log.DEBUG,VFSManager.class,""Registered ""
			+ vfs.getName() + "" filesystem for ""
			+ protocol + "" protocol"");
		vfsHash.put(vfs.getName(),vfs);
		protocolHash.put(protocol,vfs);
	} //}}}
	//{{{ getFilesystems() method
	/**
	 * @deprecated Use <code>getVFSs()</code> instead.
	 */
	public static Enumeration getFilesystems()
	{
		return vfsHash.elements();
	} //}}}
	//{{{ getVFSs() method
	/**
	 * Returns a list of all registered filesystems.
	 * @since jEdit 4.2pre1
	 */
	public static String[] getVFSs()
	{
		// the sooner ppl move to the new api, the less we'll need
		// crap like this
		List returnValue = new LinkedList();
		String[] newAPI = ServiceManager.getServiceNames(SERVICE);
		if(newAPI != null)
		{
			for(int i = 0; i < newAPI.length; i++)
			{
				returnValue.add(newAPI[i]);
			}
		}
		Enumeration oldAPI = vfsHash.keys();
		while(oldAPI.hasMoreElements())
			returnValue.add(oldAPI.nextElement());
		return (String[])returnValue.toArray(new String[
			returnValue.size()]);
	} //}}}
	//}}}
	//{{{ I/O request methods
	//{{{ getIOThreadPool() method
	/**
	 * Returns the I/O thread pool.
	 */
	public static WorkThreadPool getIOThreadPool()
	{
		return ioThreadPool;
	} //}}}
	//{{{ waitForRequests() method
	/**
	 * Returns when all pending requests are complete.
	 * @since jEdit 2.5pre1
	 */
	public static void waitForRequests()
	{
		ioThreadPool.waitForRequests();
	} //}}}
	//{{{ errorOccurred() method
	/**
	 * Returns if the last request caused an error.
	 */
	public static boolean errorOccurred()
	{
		return error;
	} //}}}
	//{{{ getRequestCount() method
	/**
	 * Returns the number of pending I/O requests.
	 */
	public static int getRequestCount()
	{
		return ioThreadPool.getRequestCount();
	} //}}}
	//{{{ runInAWTThread() method
	/**
	 * Executes the specified runnable in the AWT thread once all
	 * pending I/O requests are complete.
	 * @since jEdit 2.5pre1
	 */
	public static void runInAWTThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,true);
	} //}}}
	//{{{ runInWorkThread() method
	/**
	 * Executes the specified runnable in one of the I/O threads.
	 * @since jEdit 2.6pre2
	 */
	public static void runInWorkThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,false);
	} //}}}
	//}}}
	//{{{ error() method
	/**
	 * @deprecated Call the other <code>error()</code> method instead.
	 */
	public static void error(final Component comp, final String error, final Object[] args)
	{
		// if we are already in the AWT thread, take a shortcut
		if(SwingUtilities.isEventDispatchThread())
		{
			GUIUtilities.error(comp,error,args);
			return;
		}
		// the 'error' chicanery ensures that stuff like:
		// VFSManager.waitForRequests()
		// if(VFSManager.errorOccurred())
		//         ...
		// will work (because the below runnable will only be
		// executed in the next event)
		VFSManager.error = true;
		runInAWTThread(new Runnable()
		{
			public void run()
			{
				VFSManager.error = false;
				if(comp == null || !comp.isShowing())
					GUIUtilities.error(null,error,args);
				else
					GUIUtilities.error(comp,error,args);
			}
		});
	} //}}}
	//{{{ error() method
	/**
	 * Reports an I/O error.
	 *
	 * @param comp The component
	 * @param path The path name that caused the error
	 * @param messageProp The error message property name
	 * @param args Positional parameters
	 * @since jEdit 4.0pre3
	 */
	public static void error(Component comp,
		final String path,
		String messageProp,
		Object[] args)
	{
		final Frame frame = JOptionPane.getFrameForComponent(comp);
		synchronized(errorLock)
		{
			error = true;
			errors.addElement(new ErrorListDialog.ErrorEntry(
				path,messageProp,args));
			if(errors.size() == 1)
			{
				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						String caption = jEdit.getProperty(
							""ioerror.caption"" + (errors.size() == 1
							? ""-1"" : """"),new Integer[] {
							new Integer(errors.size()) });
						new ErrorListDialog(
							frame.isShowing()
							? frame
							: jEdit.getFirstView(),
							jEdit.getProperty(""ioerror.title""),
							caption,errors,false);
						errors.removeAllElements();
						error = false;
					}
				});
			}
		}
	} //}}}
	//{{{ sendVFSUpdate() method
	/**
	 * Sends a VFS update message.
	 * @param vfs The VFS
	 * @param path The path that changed
	 * @param parent True if an update should be sent for the path's
	 * parent too
	 * @since jEdit 2.6pre4
	 */
	public static void sendVFSUpdate(VFS vfs, String path, boolean parent)
	{
		if(parent)
		{
			sendVFSUpdate(vfs,vfs.getParentOfPath(path),false);
			sendVFSUpdate(vfs,path,false);
		}
		else
		{
			// have to do this hack until VFSPath class is written
			if(path.length() != 1 && (path.endsWith(""/"")
				|| path.endsWith(java.io.File.separator)))
				path = path.substring(0,path.length() - 1);
			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					VFSUpdate msg = (VFSUpdate)vfsUpdates
						.get(i);
					if(msg.getPath().equals(path))
					{
						// don't send two updates
						// for the same path
						return;
					}
				}
				vfsUpdates.add(new VFSUpdate(path));
				if(vfsUpdates.size() == 1)
				{
					// we were the first to add an update;
					// add update sending runnable to AWT
					// thread
					VFSManager.runInAWTThread(new SendVFSUpdatesSafely());
				}
			}
		}
	} //}}}
	//{{{ SendVFSUpdatesSafely class
	static class SendVFSUpdatesSafely implements Runnable
	{
		public void run()
		{
			synchronized(vfsUpdateLock)
			{
				// the vfs browser has what you might call
				// a design flaw, it doesn't update properly
				// unless the vfs update for a parent arrives
				// before any updates for the children. sorting
				// the list alphanumerically guarantees this.
				Collections.sort(vfsUpdates,
					new MiscUtilities.StringCompare()
				);
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					EditBus.send((VFSUpdate)vfsUpdates.get(i));
				}
				vfsUpdates.clear();
			}
		}
	} //}}}
	//{{{ Private members
	//{{{ Static variables
	private static WorkThreadPool ioThreadPool;
	private static VFS fileVFS;
	private static VFS urlVFS;
	private static Hashtable vfsHash;
	private static Hashtable protocolHash;
	private static boolean error;
	private static Object errorLock;
	private static Vector errors;
	private static Object vfsUpdateLock;
	private static List vfsUpdates;
	//}}}
	//{{{ Class initializer
	static
	{
		errorLock = new Object();
		errors = new Vector();
		fileVFS = new FileVFS();
		urlVFS = new UrlVFS();
		vfsHash = new Hashtable();
		protocolHash = new Hashtable();
		vfsUpdateLock = new Object();
		vfsUpdates = new ArrayList(10);
	} //}}}
	private VFSManager() {}
	//}}}
}
"
org.gjt.sp.jedit.menu.DirectoryProvider,"/*
 * DirectoryProvider.java - File list menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.io.File;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.*;
//}}}
public class DirectoryProvider implements DynamicMenuProvider
{
	//{{{ DirectoryProvider constructor
	public DirectoryProvider(String dir)
	{
		this.dir = dir;
	} //}}}
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return true;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);
		final String path;
		if(dir == null)
		{
			path = view.getBuffer().getDirectory();
		}
		else
			path = dir;
		JMenuItem mi = new JMenuItem(path + "":"");
		mi.setActionCommand(path);
		mi.setIcon(FileCellRenderer.openDirIcon);
		//{{{ ActionListeners
		ActionListener fileListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
			}
		};
		ActionListener dirListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,
					evt.getActionCommand());
			}
		}; //}}}
		mi.addActionListener(dirListener);
		menu.add(mi);
		menu.addSeparator();
		if(dir == null && !(view.getBuffer().getVFS() instanceof FileVFS))
		{
			mi = new JMenuItem(jEdit.getProperty(
				""directory.not-local""));
			mi.setEnabled(false);
			menu.add(mi);
			return;
		}
		File directory = new File(path);
		JMenu current = menu;
		// for filtering out backups
		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");
		File[] list = directory.listFiles();
		if(list == null || list.length == 0)
		{
			mi = new JMenuItem(jEdit.getProperty(
				""directory.no-files""));
			mi.setEnabled(false);
			menu.add(mi);
		}
		else
		{
			int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);
			MiscUtilities.quicksort(list,
				new MiscUtilities.StringICaseCompare());
			for(int i = 0; i < list.length; i++)
			{
				File file = list[i];
				String name = file.getName();
				// skip marker files
				if(name.endsWith("".marks""))
					continue;
				// skip autosave files
				if(name.startsWith(""#"") && name.endsWith(""#""))
					continue;
				// skip backup files
				if((backupPrefix.length() != 0
					&& name.startsWith(backupPrefix))
					|| (backupSuffix.length() != 0
					&& name.endsWith(backupSuffix)))
					continue;
				// skip directories
				//if(file.isDirectory())
				//	continue;
				mi = new JMenuItem(name);
				mi.setActionCommand(file.getPath());
				mi.addActionListener(file.isDirectory()
					? dirListener
					: fileListener);
				mi.setIcon(file.isDirectory()
					? FileCellRenderer.dirIcon
					: FileCellRenderer.fileIcon);
				if(current.getItemCount() >= maxItems && i != list.length - 1)
				{
					//current.addSeparator();
					JMenu newCurrent = new JMenu(
						jEdit.getProperty(
						""common.more""));
					current.add(newCurrent);
					current = newCurrent;
				}
				current.add(mi);
			}
		}
	} //}}}
	//{{{ Private members
	private String dir;
	//}}}
}
"
org.gjt.sp.jedit.menu.DynamicMenuProvider,"/*
 * DynamicMenuProvider.java - API for dynamic plugin menus
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
import javax.swing.JMenu;
/**
 * Interface for a menu whose contents are determined at runtime.<p>
 *
 * See {@link org.gjt.sp.jedit.EditPlugin} for properties you need to define to
 * have your plugin provide a dynamic menu.
 *
 * @since jEdit 4.2pre2
 * @author Slava Pestov
 * @version $Id: DynamicMenuProvider.java,v 1.2 2003/05/02 23:14:17 spestov Exp $
 */
public interface DynamicMenuProvider
{
	/**
	 * Returns true if the menu should be updated each time it is shown.
	 * Otherwise, it will only be updated when the menu is first created,
	 * and if the menu receives a {@link
	 * org.gjt.sp.jedit.msg.DynamicMenuChanged} message.
	 */
	boolean updateEveryTime();
	/**
	 * Adds the menu items to the given menu.
	 * @param menu The menu
	 */
	void update(JMenu menu);
}
"
org.gjt.sp.jedit.menu.EnhancedCheckBoxMenuItem,"/*
 * EnhancedCheckBoxMenuItem.java - Check box menu item
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * jEdit's custom menu item. It adds support for multi-key shortcuts.
 */
public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem
{
	//{{{ EnhancedCheckBoxMenuItem constructor
	/**
	 * Creates a new menu item. Most plugins should call
	 * GUIUtilities.loadMenuItem() instead.
	 * @param label The menu item label
	 * @param action The edit action
	 * @param context An action context
	 * @since jEdit 4.2pre1
	 */
	public EnhancedCheckBoxMenuItem(String label, String action,
		ActionContext context)
	{
		this.context = context;
		this.action = action;
		this.shortcut = getShortcut();
		if(OperatingSystem.hasScreenMenuBar() && shortcut != null)
		{
			setText(label + "" ("" + shortcut + "")"");
			shortcut = null;
		}
		else
			setText(label);
		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(context,action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);
		setModel(new Model());
	} //}}}
	//{{{ getPreferredSize() method
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();
		if(shortcut != null)
		{
			d.width += (getFontMetrics(EnhancedMenuItem.acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} //}}}
	//{{{ paint() method
	public void paint(Graphics g)
	{
		super.paint(g);
		if(shortcut != null)
		{
			g.setFont(EnhancedMenuItem.acceleratorFont);
			g.setColor(getModel().isArmed() ?
				EnhancedMenuItem.acceleratorSelectionForeground :
				EnhancedMenuItem.acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 
				(OperatingSystem.isMacOSLF() ? 0 : 1))
				/* XXX magic number */);
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private ActionContext context;
	private String shortcut;
	private String action;
	//}}}
	//{{{ getShortcut() method
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(action + "".shortcut"");
			String shortcut2 = jEdit.getProperty(action + "".shortcut2"");
			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} //}}}
	//}}}
	//{{{ Model class
	class Model extends DefaultButtonModel
	{
		public boolean isSelected()
		{
			if(!isShowing())
				return false;
			EditAction a = context.getAction(action);
			if(a == null)
			{
				Log.log(Log.WARNING,this,""Unknown action: ""
					+ action);
				return false;
			}
			try
			{
				return a.isSelected(EnhancedCheckBoxMenuItem.this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);
				return false;
			}
		}
		public void setSelected(boolean b) {}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		boolean msgSet = false;
		public void mouseReleased(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
		public void mouseEntered(MouseEvent evt)
		{
			String msg = jEdit.getProperty(action + "".mouse-over"");
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
				msgSet = true;
			}
		}
		public void mouseExited(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.menu.EnhancedMenu,"/*
 * EnhancedMenu.java - jEdit menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.*;
//}}}
public class EnhancedMenu extends JMenu implements MenuListener
{
	//{{{ EnhancedMenu constructor
	public EnhancedMenu(String name)
	{
		this(name,jEdit.getProperty(name.concat("".label"")),
			jEdit.getActionContext());
	} //}}}
	//{{{ EnhancedMenu constructor
	public EnhancedMenu(String name, String label)
	{
		this(name,label,jEdit.getActionContext());
	} //}}}
	//{{{ EnhancedMenu constructor
	public EnhancedMenu(String name, String label, ActionContext context)
	{
		this.context = context;
		if(label == null)
			label = name;
		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';
		setText(label);
		if(!OperatingSystem.isMacOS())
			setMnemonic(mnemonic);
		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					addSeparator();
				else
					add(GUIUtilities.loadMenuItem(context,menuItemName,true));
			}
		}
		initialComponentCount = getMenuComponentCount();
		providerCode = jEdit.getProperty(name + "".code"");
		ebStub = new EditBusStub(name);
		ebStub.menuOutOfDate = true;
		addMenuListener(this);
		if(providerCode != null)
			EditBus.addToBus(ebStub);
	} //}}}
	//{{{ menuSelected() method
	public void menuSelected(MenuEvent evt)
	{
		init();
	} //}}}
	public void menuDeselected(MenuEvent e) {}
	public void menuCanceled(MenuEvent e) {}
	//{{{ init() method
	public void init()
	{
		if(providerCode == null)
			return;
		if(provider == null)
		{
			Object obj = BeanShell.eval(null,
				BeanShell.getNameSpace(),
				providerCode);
			provider = (DynamicMenuProvider)obj;
		}
		if(provider == null)
		{
			// error
			providerCode = null;
			return;
		}
		if(ebStub.menuOutOfDate || provider.updateEveryTime())
		{
			ebStub.menuOutOfDate = false;
			while(getMenuComponentCount() != initialComponentCount)
				remove(getMenuComponentCount() - 1);
			if(provider != null)
				provider.update(this);
		}
	} //}}}
	//{{{ Protected members
	protected int initialComponentCount;
	protected ActionContext context;
	protected String providerCode;
	protected DynamicMenuProvider provider;
	protected EditBusStub ebStub;
	//{{{ finalize() method
	protected void finalize() throws Exception
	{
		if(ebStub != null)
			EditBus.removeFromBus(ebStub);
	} //}}}
	//}}}
	//{{{ EditBusStub class
	/* EnhancedMenu has a reference to EditBusStub, but not the other
	 * way around. So when the EnhancedMenu is being garbage collected
	 * its finalize() method removes the EditBusStub from the edit bus. */
	static class EditBusStub implements EBComponent
	{
		String name;
		boolean menuOutOfDate;
		EditBusStub(String name)
		{
			this.name = name;
			menuOutOfDate = true;
		}
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof DynamicMenuChanged
				&& name.equals(((DynamicMenuChanged)msg)
				.getMenuName()))
			{
				menuOutOfDate = true;
			}
			else if(msg instanceof PropertiesChanged)
			{
				// while this might be questionable, some
				// menus depend on properties
				menuOutOfDate = true;
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.menu.EnhancedMenuItem,"/*
 * EnhancedMenuItem.java - Menu item with user-specified accelerator string
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * jEdit's custom menu item. It adds support for multi-key shortcuts.
 */
public class EnhancedMenuItem extends JMenuItem
{
	//{{{ EnhancedMenuItem constructor
	/**
	 * Creates a new menu item. Most plugins should call
	 * GUIUtilities.loadMenuItem() instead.
	 * @param label The menu item label
	 * @param action The edit action
	 * @param context An action context
	 * @since jEdit 4.2pre1
	 */
	public EnhancedMenuItem(String label, String action, ActionContext context)
	{
		this.action = action;
		this.shortcut = getShortcut();
		if(OperatingSystem.hasScreenMenuBar() && shortcut != null)
		{
			setText(label + "" ("" + shortcut + "")"");
			shortcut = null;
		}
		else
			setText(label);
		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(context,action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);
	} //}}}
	//{{{ getPreferredSize() method
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();
		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} //}}}
	//{{{ paint() method
	public void paint(Graphics g)
	{
		super.paint(g);
		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 
				(OperatingSystem.isMacOSLF() ? 0 : 1))
				/* XXX magic number */);
		}
	} //}}}
	//{{{ Package-private members
	static Font acceleratorFont;
	static Color acceleratorForeground;
	static Color acceleratorSelectionForeground;
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private String shortcut;
	private String action;
	//}}}
	//{{{ getShortcut() method
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(action + "".shortcut"");
			String shortcut2 = jEdit.getProperty(action + "".shortcut2"");
			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} //}}}
	//{{{ Class initializer
	static
	{
		String shortcutFont;
		if (OperatingSystem.isMacOSLF())
			shortcutFont = ""Lucida Grande"";
		else
			shortcutFont = ""Monospaced"";
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		if(acceleratorFont == null)
			acceleratorFont = new Font(shortcutFont,Font.PLAIN,12);
		else
		{
			acceleratorFont = new Font(shortcutFont,
				acceleratorFont.getStyle(),
				acceleratorFont.getSize());
		}
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		if(acceleratorForeground == null)
			acceleratorForeground = Color.black;
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
		if(acceleratorSelectionForeground == null)
			acceleratorSelectionForeground = Color.black;
	} //}}}
	//}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		boolean msgSet = false;
		public void mouseReleased(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
		public void mouseEntered(MouseEvent evt)
		{
			String msg = jEdit.getProperty(action + "".mouse-over"");
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
				msgSet = true;
			}
		}
		public void mouseExited(MouseEvent evt)
		{
			if(msgSet)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(null);
				msgSet = false;
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.menu.FavoritesProvider,"/*
 * FavoritesProvider.java - Favorites list menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
//}}}
public class FavoritesProvider implements DynamicMenuProvider
{
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return false;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);
		//{{{ ActionListeners
		ActionListener fileListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
			}
		};
		ActionListener dirListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,
					evt.getActionCommand());
			}
		}; //}}}
		VFS.DirectoryEntry[] favorites
			= FavoritesVFS.getFavorites();
		if(favorites.length == 0)
		{
			JMenuItem mi = new JMenuItem(
				jEdit.getProperty(
				""vfs.browser.favorites""
				+ "".no-favorites.label""));
			mi.setEnabled(false);
			menu.add(mi);
		}
		else
		{
			MiscUtilities.quicksort(favorites,
				new VFS.DirectoryEntryCompare(
				jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs""),
				jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"")));
			for(int i = 0; i < favorites.length; i++)
			{
				VFS.DirectoryEntry favorite
					= favorites[i];
				JMenuItem mi = new JMenuItem(favorite.path);
				mi.setIcon(FileCellRenderer
					.getIconForFile(
					favorite,false));
				if(favorite.type ==
					VFS.DirectoryEntry.FILE)
				{
					mi.addActionListener(fileListener);
				}
				else
				{
					mi.addActionListener(dirListener);
				}
				menu.add(mi);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.menu.MacrosProvider,"/*
 * MacrosProvider.java - Macros menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.*;
import java.util.Collections;
import java.util.Vector;
import org.gjt.sp.jedit.*;
//}}}
public class MacrosProvider implements DynamicMenuProvider
{
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return false;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		Vector macroVector = Macros.getMacroHierarchy();
		int count = menu.getMenuComponentCount();
		createMacrosMenu(menu,macroVector,0);
		if(count == menu.getMenuComponentCount())
		{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""no-macros.label""));
			mi.setEnabled(false);
			menu.add(mi);
		}
	} //}}}
	//{{{ createMacrosMenu() method
	private void createMacrosMenu(JMenu menu, Vector vector, int start)
	{
		Vector menuItems = new Vector();
		for(int i = start; i < vector.size(); i++)
		{
			Object obj = vector.elementAt(i);
			if(obj instanceof String)
			{
				menuItems.add(new EnhancedMenuItem(
					jEdit.getProperty(obj + "".label""),
					(String)obj,jEdit.getActionContext()));
			}
			else if(obj instanceof Vector)
			{
				Vector subvector = (Vector)obj;
				String name = (String)subvector.elementAt(0);
				JMenu submenu = new JMenu(name);
				createMacrosMenu(submenu,subvector,1);
				if(submenu.getMenuComponentCount() != 0)
					menuItems.add(submenu);
			}
		}
		Collections.sort(menuItems,new MiscUtilities.MenuItemCompare());
		for(int i = 0; i < menuItems.size(); i++)
		{
			menu.add((JMenuItem)menuItems.get(i));
		}
	} //}}}
}
"
org.gjt.sp.jedit.menu.MarkersProvider,"/*
 * MarkersProvider.java - Markers menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
//}}}
public class MarkersProvider implements DynamicMenuProvider
{
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return true;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);
		Buffer buffer = view.getBuffer();
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""no-markers.label""));
			mi.setEnabled(false);
			menu.add(mi);
			return;
		}
		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);
		JMenu current = menu;
		for(int i = 0; i < markers.size(); i++)
		{
			final Marker marker = (Marker)markers.elementAt(i);
			int lineNo = buffer.getLineOfOffset(marker.getPosition());
			if(current.getItemCount() >= maxItems && i != markers.size() - 1)
			{
				//current.addSeparator();
				JMenu newCurrent = new JMenu(
					jEdit.getProperty(
					""common.more""));
				current.add(newCurrent);
				current = newCurrent;
			}
			JMenuItem mi = new MarkersMenuItem(buffer,
				lineNo,marker.getShortcut());
			mi.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					view.getTextArea().setCaretPosition(
						marker.getPosition());
				}
			});
			current.add(mi);
		}
	} //}}}
	//{{{ MarkersMenuItem class
	static class MarkersMenuItem extends JMenuItem
	{
		//{{{ MarkersMenuItem constructor
		MarkersMenuItem(Buffer buffer, int lineNo, char shortcut)
		{
			String text = buffer.getLineText(lineNo).trim();
			if(text.length() == 0)
				text = jEdit.getProperty(""markers.blank-line"");
			setText((lineNo + 1) + "": "" + text);
			shortcutProp = ""goto-marker.shortcut"";
			MarkersMenuItem.this.shortcut = shortcut;
		} //}}}
		//{{{ getPreferredSize() method
		public Dimension getPreferredSize()
		{
			Dimension d = super.getPreferredSize();
			String shortcut = getShortcut();
			if(shortcut != null)
			{
				d.width += (getFontMetrics(acceleratorFont)
					.stringWidth(shortcut) + 15);
			}
			return d;
		} //}}}
		//{{{ paint() method
		public void paint(Graphics g)
		{
			super.paint(g);
			String shortcut = getShortcut();
			if(shortcut != null)
			{
				g.setFont(acceleratorFont);
				g.setColor(getModel().isArmed() ?
					acceleratorSelectionForeground :
					acceleratorForeground);
				FontMetrics fm = g.getFontMetrics();
				Insets insets = getInsets();
				g.drawString(shortcut,getWidth() - (fm.stringWidth(
					shortcut) + insets.right + insets.left + 5),
					getFont().getSize() + (insets.top - 1)
					/* XXX magic number */);
			}
		} //}}}
		//{{{ Private members
		private String shortcutProp;
		private char shortcut;
		private static Font acceleratorFont;
		private static Color acceleratorForeground;
		private static Color acceleratorSelectionForeground;
		//{{{ getShortcut() method
		private String getShortcut()
		{
			if(shortcut == '\0')
				return null;
			else
			{
				String shortcutPrefix = jEdit.getProperty(shortcutProp);
				if(shortcutPrefix == null)
					return null;
				else
				{
					return shortcutPrefix + "" "" + shortcut;
				}
			}
		} //}}}
		//{{{ Class initializer
		static
		{
			acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
			acceleratorFont = new Font(""Monospaced"",
				acceleratorFont.getStyle(),
				acceleratorFont.getSize());
			acceleratorForeground = UIManager
				.getColor(""MenuItem.acceleratorForeground"");
			acceleratorSelectionForeground = UIManager
				.getColor(""MenuItem.acceleratorSelectionForeground"");
		} //}}}
		//}}}
	} //}}}
}
"
org.gjt.sp.jedit.menu.PluginsProvider,"/*
 * PluginsProvider.java - Plugins menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
import javax.swing.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class PluginsProvider implements DynamicMenuProvider
{
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return false;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		// We build a set of lists, each list contains plugin menu
		// items that begin with a given letter.
		int count = 0;
		List[] letters = new List[26];
		for(int i = 0; i < letters.length; i++)
		{
			letters[i] = new ArrayList();
		}
		Vector pluginMenuItems = new Vector();
		PluginJAR[] pluginArray = jEdit.getPluginJARs();
		for(int i = 0; i < pluginArray.length; i++)
		{
			PluginJAR jar = pluginArray[i];
			EditPlugin plugin = jar.getPlugin();
			if(plugin == null)
				continue;
			JMenuItem menuItem = plugin.createMenuItems();
			if(menuItem != null)
			{
				addToLetterMap(letters,menuItem);
				count++;
			}
			//{{{ old API
			else if(jEdit.getProperty(""plugin.""
				+ plugin.getClassName()
				+ "".activate"") == null)
			{
				try
				{
					pluginMenuItems.clear();
					plugin.createMenuItems(pluginMenuItems);
					Iterator iter = pluginMenuItems.iterator();
					while(iter.hasNext())
					{
						addToLetterMap(letters,
							(JMenuItem)iter.next());
						count++;
					}
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,
						""Error creating menu items""
						+ "" for plugin"");
					Log.log(Log.ERROR,this,t);
				}
			} //}}}
		}
		if(count == 0)
		{
			JMenuItem menuItem = new JMenuItem(
				jEdit.getProperty(""no-plugins.label""));
			menuItem.setEnabled(false);
			menu.add(menuItem);
			return;
		}
		// Sort each letter
		for(int i = 0; i < letters.length; i++)
		{
			List list = letters[i];
			Collections.sort(list,new MiscUtilities
				.MenuItemCompare());
		}
		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);
		// if less than 20 items, put them directly in the menu
		if(count <= maxItems)
		{
			for(int i = 0; i < letters.length; i++)
			{
				Iterator iter = letters[i].iterator();
				while(iter.hasNext())
				{
					menu.add((JMenuItem)iter.next());
				}
			}
			return;
		}
		// Collect blocks of up to maxItems of consecutive letters
		count = 0;
		char first = 'A';
		JMenu submenu = new JMenu();
		menu.add(submenu);
		for(int i = 0; i < letters.length; i++)
		{
			List letter = letters[i];
			if(count + letter.size() > maxItems && count != 0)
			{
				char last = (char)(i + 'A' - 1);
				if(last == first)
					submenu.setText(String.valueOf(first));
				else
					submenu.setText(first + "" - "" + last);
				first = (char)(char)(i + 'A');
				count = 0;
				submenu = null;
			}
			Iterator iter = letter.iterator();
			while(iter.hasNext())
			{
				if(submenu == null)
				{
					submenu = new JMenu();
					menu.add(submenu);
				}
				submenu.add((JMenuItem)iter.next());
			}
			count += letter.size();
		}
		if(submenu != null)
		{
			char last = 'Z';
			if(last == first)
				submenu.setText(String.valueOf(first));
			else
				submenu.setText(first + "" - "" + last);
		}
	} //}}}
	//{{{ addToLetterMap() method
	private void addToLetterMap(List[] letters, JMenuItem item)
	{
		char ch = item.getText().charAt(0);
		ch = Character.toUpperCase(ch);
		if(ch < 'A' || ch > 'Z')
		{
			Log.log(Log.ERROR,this,""Plugin menu item label must ""
				+ ""begin with A - Z, or a - z: ""
				+ item.getText());
		}
		else
			letters[ch - 'A'].add(item);
	} //}}}
}
"
org.gjt.sp.jedit.menu.RecentDirectoriesProvider,"/*
 * RecentDirectoriesProvider.java - Recent directory list menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.HistoryModel;
import org.gjt.sp.jedit.*;
//}}}
public class RecentDirectoriesProvider implements DynamicMenuProvider
{
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return true;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);
		//{{{ ActionListener...
		ActionListener actionListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,evt.getActionCommand());
				view.getStatus().setMessage(null);
			}
		}; //}}}
		//{{{ MouseListener...
		MouseListener mouseListener = new MouseAdapter()
		{
			public void mouseEntered(MouseEvent evt)
			{
				view.getStatus().setMessage(
					((JMenuItem)evt.getSource())
					.getActionCommand());
			}
			public void mouseExited(MouseEvent evt)
			{
				view.getStatus().setMessage(null);
			}
		}; //}}}
		HistoryModel model = HistoryModel.getModel(""vfs.browser.path"");
		if(model.getSize() == 0)
		{
			JMenuItem menuItem = new JMenuItem(
				jEdit.getProperty(""no-recent-dirs.label""));
			menuItem.setEnabled(false);
			menu.add(menuItem);
			return;
		}
		boolean sort = jEdit.getBooleanProperty(""sortRecent"");
		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);
		Vector menuItems = new Vector();
		for(int i = 0; i < model.getSize(); i++)
		{
			String path = model.getItem(i);
			JMenuItem menuItem = new JMenuItem(MiscUtilities.getFileName(path));
			menuItem.setActionCommand(path);
			menuItem.addActionListener(actionListener);
			menuItem.addMouseListener(mouseListener);
			menuItem.setIcon(FileCellRenderer.dirIcon);
			if(sort)
				menuItems.addElement(menuItem);
			else
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& i != model.getSize() - 1)
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}
				menu.add(menuItem);
			}
		}
		if(sort)
		{
			MiscUtilities.quicksort(menuItems,
				new MiscUtilities.MenuItemCompare());
			for(int i = 0; i < menuItems.size(); i++)
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& i != 0)
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}
				menu.add((JMenuItem)menuItems.elementAt(i));
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.menu.RecentFilesProvider,"/*
 * RecentFilesProvider.java - Recent file list menu
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.menu;
//{{{ Imports
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
import org.gjt.sp.jedit.browser.FileCellRenderer;
import org.gjt.sp.jedit.*;
//}}}
public class RecentFilesProvider implements DynamicMenuProvider
{
	//{{{ updateEveryTime() method
	public boolean updateEveryTime()
	{
		return false;
	} //}}}
	//{{{ update() method
	public void update(JMenu menu)
	{
		final View view = GUIUtilities.getView(menu);
		//{{{ ActionListener...
		ActionListener actionListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
				view.getStatus().setMessage(null);
			}
		}; //}}}
		//{{{ MouseListener...
		MouseListener mouseListener = new MouseAdapter()
		{
			public void mouseEntered(MouseEvent evt)
			{
				view.getStatus().setMessage(
					((JMenuItem)evt.getSource())
					.getActionCommand());
			}
			public void mouseExited(MouseEvent evt)
			{
				view.getStatus().setMessage(null);
			}
		}; //}}}
		List recentVector = BufferHistory.getHistory();
		if(recentVector.size() == 0)
		{
			JMenuItem menuItem = new JMenuItem(
				jEdit.getProperty(""no-recent-files.label""));
			menuItem.setEnabled(false);
			menu.add(menuItem);
			return;
		}
		Vector menuItems = new Vector();
		boolean sort = jEdit.getBooleanProperty(""sortRecent"");
		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);
		Iterator iter = recentVector.iterator();
		while(iter.hasNext())
		{
			String path = ((BufferHistory.Entry)iter.next()).path;
			JMenuItem menuItem = new JMenuItem(MiscUtilities
				.getFileName(path));
			menuItem.setActionCommand(path);
			menuItem.addActionListener(actionListener);
			menuItem.addMouseListener(mouseListener);
			menuItem.setIcon(FileCellRenderer.fileIcon);
			if(sort)
				menuItems.addElement(menuItem);
			else
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& iter.hasNext())
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}
				menu.add(menuItem);
			}
		}
		if(sort)
		{
			MiscUtilities.quicksort(menuItems,
				new MiscUtilities.MenuItemCompare());
			for(int i = 0; i < menuItems.size(); i++)
			{
				if(menu.getMenuComponentCount() >= maxItems
					&& i != 0)
				{
					JMenu newMenu = new JMenu(
						jEdit.getProperty(""common.more""));
					menu.add(newMenu);
					menu = newMenu;
				}
				menu.add((JMenuItem)menuItems.elementAt(i));
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.msg.BufferUpdate,"/*
 * BufferUpdate.java - Buffer update message
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when a buffer-related change occurs.
 * @author Slava Pestov
 * @version $Id: BufferUpdate.java,v 1.8 2002/12/24 17:35:23 spestov Exp $
 *
 * @since jEdit 2.2pre6
 */
public class BufferUpdate extends EBMessage
{
	//{{{ Message types
	/**
	 * Buffer created.
	 */
	public static final Object CREATED = ""CREATED"";
	/**
	 * Buffer load started.
	 * @since jEdit 2.6pre1
	 */
	public static final Object LOAD_STARTED = ""LOAD_STARTED"";
	/**
	 * Buffer loaded.
	 */
	public static final Object LOADED = ""LOADED"";
	/**
	 * Buffer closed.
	 */
	public static final Object CLOSED = ""CLOSED"";
	/**
	 * Buffer dirty changed.
	 */
	public static final Object DIRTY_CHANGED = ""DIRTY_CHANGED"";
	/**
	 * Buffer markers changed.
	 */
	public static final Object MARKERS_CHANGED = ""MARKERS_CHANGED"";
	/**
	 * Buffer saving.
	 */
	public static final Object SAVING = ""SAVING"";
	/**
	 * Buffer saved.
	 * @since jEdit 4.0pre4
	 */
	public static final Object SAVED = ""SAVED"";
	/**
	 * Properties changed.
	 * @since jEdit 4.1pre1
	 */
	public static final Object PROPERTIES_CHANGED = ""PROPERTIES_CHANGED"";
	/**
	 * @deprecated No longer sent. Listen for PROPERTIES_CHANGED instead.
	 */
	public static final Object MODE_CHANGED = ""MODE_CHANGED"";
	//}}}
	//{{{ BufferUpdate constructor
	/**
	 * Creates a new buffer update message.
	 * @param buffer The buffer
	 * @param what What happened
	 */
	public BufferUpdate(Buffer buffer, View view, Object what)
	{
		super(buffer);
		this.view = view;
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
	} //}}}
	//{{{ getWhat() method
	/**
	 * Returns what caused this buffer update.
	 */
	public Object getWhat()
	{
		return what;
	} //}}}
	//{{{ getBuffer() method
	/**
	 * Returns the buffer involved.
	 */
	public Buffer getBuffer()
	{
		return (Buffer)getSource();
	} //}}}
	//{{{ getView() method
	/**
	 * Returns the view involved, which may be null.
	 */
	public View getView()
	{
		return view;
	} //}}}
	//{{{ paramString() method
	public String paramString()
	{
		return ""what="" + what + "",view="" + view + "",""
			+ super.paramString();
	} //}}}
	//{{{ Private members
	private Object what;
	private View view;
	//}}}
}
"
org.gjt.sp.jedit.msg.DockableWindowUpdate,"/*
 * DockableWindowUpdate.java - Dockable window update message
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.jedit.*;
/**
 * Message sent when dockable window state changes.
 * @author Slava Pestov
 * @version $Id: DockableWindowUpdate.java,v 1.2 2004/03/28 00:07:26 spestov Exp $
 *
 * @since jEdit 4.2pre1
 */
public class DockableWindowUpdate extends EBMessage
{
	//{{{ Message types
	/**
	 * Properties changed. Fired instead of global
	 * <code>PropertiesChanged</code> for improved performance.
	 * @since jEdit 4.2pre1
	 */
	public static final Object PROPERTIES_CHANGED = ""PROPERTIES_CHANGED"";
	/**
	 * Dockable activated. This is sent when the dockable is made visible.
	 * @since jEdit 4.2pre1
	 */
	public static final Object ACTIVATED = ""ACTIVATED"";
	/**
	 * Dockable deactivated. This is sent when the dockable is hidden.
	 * @since jEdit 4.2pre1
	 */
	public static final Object DEACTIVATED = ""DEACTIVATED"";
	//}}}
	//{{{ DockableWindowUpdate constructor
	/**
	 * Creates a new dockable window update message.
	 * @param wm The dockable window manager
	 * @param what What happened
	 * @param dockable The dockable window in question
	 */
	public DockableWindowUpdate(DockableWindowManager wm, Object what,
		String dockable)
	{
		super(wm);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
		this.dockable = dockable;
	} //}}}
	//{{{ getWhat() method
	/**
	 * Returns what caused this dockable update.
	 */
	public Object getWhat()
	{
		return what;
	} //}}}
	//{{{ getDockable() method
	/**
	 * Returns the dockable in question, or null if the message type is
	 * <code>PROPERTIES_CHANGED</code>.
	 */
	public String getDockable()
	{
		return dockable;
	} //}}}
	//{{{ paramString() method
	public String paramString()
	{
		return ""what="" + what
			+ "",dockable="" + dockable
			+ "","" + super.paramString();
	} //}}}
	//{{{ Private members
	private Object what;
	private String dockable;
	//}}}
}
"
org.gjt.sp.jedit.msg.DynamicMenuChanged,"/*
 * DynamicMenuChanged.java - Message that causes dynamic menus to be
 * reconstructed
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Sending this message will cause the specified dynamic menu to be recreated.
 *
 * @author Slava Pestov
 * @version $Id: DynamicMenuChanged.java,v 1.3 2004/03/28 00:07:26 spestov Exp $
 *
 * @since jEdit 4.2pre2
 */
public class DynamicMenuChanged extends EBMessage
{
	//{{{ DynamicMenuChanged constructor
	/**
	 * Creates a new dynamic menu changed message.
	 * @param name The menu name. All dynamic menus with this name will be
	 * recreated next time they are displayed.
	 */
	public DynamicMenuChanged(String name)
	{
		super(null);
		this.name = name;
	} //}}}
	//{{{ getMenuName() method
	/**
	 * Returns the name of the menu in question.
	 */
	public String getMenuName()
	{
		return name;
	} //}}}
	//{{{ paramString() method
	public String paramString()
	{
		return ""menu="" + name + "","" + super.paramString();
	} //}}}
	//{{{ Private members
	private String name;
	//}}}
}
"
org.gjt.sp.jedit.msg.EditorExiting,"/*
 * EditorExiting.java - Message sent before the editor exits
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent just before jEdit exits.
 * @author Slava Pestov
 * @version $Id: EditorExiting.java,v 1.2 2002/05/14 07:55:48 spestov Exp $
 *
 * @since jEdit 2.3pre2
 */
public class EditorExiting extends EBMessage
{
	/**
	 * Creates a new editor exiting message.
	 * @param source The message source
	 */
	public EditorExiting(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.EditorExitRequested,"/*
 * EditorExitRequested.java - Message sent before jEdit starts exiting
 * Copyright (C) 2000 Dirk Moebius
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.View;
/**
 * Message sent when jEdit starts the exit process. It is send before
 * the settings are saved and the buffers are closed. Listeners of this
 * message should be aware that jEdit might not exit truely, maybe because
 * of errors, or the user cancelled the ""Save unsaved changed"" dialog, or
 * jEdit is in background mode.
 *
 * @author Dirk Moebius
 * @version $Id: EditorExitRequested.java,v 1.2 2002/05/14 07:55:48 spestov Exp $
 *
 * @since jEdit 3.1pre4
 */
public class EditorExitRequested extends EBMessage
{
	/**
	 * Creates a new editor exiting started message.
	 * @param view The view from which this exit was called
	 */
	public EditorExitRequested(View view)
	{
		super(view);
	}
	/**
	 * Returns the view involved.
	 */
	public View getView()
	{
		return (View)getSource();
	}
}
"
org.gjt.sp.jedit.msg.EditorStarted,"/*
 * EditorStarted.java - Message sent after editor is started, but before
 * initial view is created
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent after jEdit has finished starting up, but before the initial
 * view is created.
 * @author Slava Pestov
 * @version $Id: EditorStarted.java,v 1.2 2002/05/14 07:55:48 spestov Exp $
 *
 * @since jEdit 2.3pre2
 */
public class EditorStarted extends EBMessage
{
	/**
	 * Creates a new editor started message.
	 * @param source The message source
	 */
	public EditorStarted(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.EditPaneUpdate,"/*
 * EditPaneUpdate.java - Edit pane update message
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when an edit pane-related change occurs.
 * @author Slava Pestov
 * @version $Id: EditPaneUpdate.java,v 1.4 2003/01/12 03:08:24 spestov Exp $
 *
 * @since jEdit 2.5pre1
 */
public class EditPaneUpdate extends EBMessage
{
	/**
	 * Edit pane created.
	 */
	public static final Object CREATED = ""CREATED"";
	/**
	 * Edit pane destroyed.
	 */
	public static final Object DESTROYED = ""DESTROYED"";
	/**
	 * Edit pane buffer changed.
	 */
	public static final Object BUFFER_CHANGED = ""BUFFER_CHANGED"";
	/**
	 * Creates a new edit pane update message.
	 * @param editPane The edit pane
	 * @param what What happened
	 */
	public EditPaneUpdate(EditPane editPane, Object what)
	{
		super(editPane);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
	}
	/**
	 * Returns what caused this edit pane update.
	 */
	public Object getWhat()
	{
		return what;
	}
	/**
	 * Returns the edit pane involved.
	 */
	public EditPane getEditPane()
	{
		return (EditPane)getSource();
	}
	public String paramString()
	{
		return ""what="" + what + "","" + super.paramString();
	}
	// private members
	private Object what;
}
"
org.gjt.sp.jedit.msg.PluginUpdate,"/*
 * PluginUpdate.java - Plugin update message
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when plugins are loaded and unloaded.
 * @author Slava Pestov
 * @version $Id: PluginUpdate.java,v 1.4 2004/03/28 00:07:26 spestov Exp $
 *
 * @since jEdit 4.2pre1
 */
public class PluginUpdate extends EBMessage
{
	//{{{ Message types
	/**
	 * Plugin loaded. This is sent after a JAR file is added to the
	 * list and scanned.
	 * @since jEdit 4.2pre1
	 */
	public static final Object LOADED = ""LOADED"";
	/**
	 * Plugin activated. This is sent after the plugin core class
	 * is loaded and its <code>start()</code> method is called.
	 * @since jEdit 4.2pre1
	 */
	public static final Object ACTIVATED = ""ACTIVATED"";
	/**
	 * Plugin activated. This is sent after the plugin core class
	 * <code>stop()</code> method is called.
	 * @since jEdit 4.2pre2
	 */
	public static final Object DEACTIVATED = ""DEACTIVATED"";
	/**
	 * Plugin unloaded.
	 * @since jEdit 4.2pre1
	 */
	public static final Object UNLOADED = ""UNLOADED"";
	//}}}
	//{{{ PluginUpdate constructor
	/**
	 * Creates a new plugin update message.
	 * @param jar The plugin
	 * @param what What happened
	 * @param exit Is the editor exiting?
	 * @since jEdit 4.2pre3
	 */
	public PluginUpdate(PluginJAR jar, Object what, boolean exit)
	{
		super(jar);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
		this.exit = exit;
	} //}}}
	//{{{ getWhat() method
	/**
	 * Returns what caused this plugin update.
	 */
	public Object getWhat()
	{
		return what;
	} //}}}
	//{{{ isExiting() method
	/**
	 * Returns true if this plugin is being unloaded as part of the
	 * shutdown process, in which case some components like the help
	 * viewer and plugin manager ignore the event.
	 * @since jEdit 4.2pre3
	 */
	public boolean isExiting()
	{
		return exit;
	} //}}}
	//{{{ getPluginJAR() method
	/**
	 * Returns the plugin involved.
	 */
	public PluginJAR getPluginJAR()
	{
		return (PluginJAR)getSource();
	} //}}}
	//{{{ paramString() method
	public String paramString()
	{
		return ""what="" + what + "",exit="" + exit + "",""
			+ super.paramString();
	} //}}}
	//{{{ Private members
	private Object what;
	private boolean exit;
	//}}}
}
"
org.gjt.sp.jedit.msg.PropertiesChanged,"/*
 * PropertiesChanged.java - Properties changed message
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent when properties are changed using the global options or
 * plugin options dialog box.
 * @author Slava Pestov
 * @version $Id: PropertiesChanged.java,v 1.2 2002/05/14 07:55:49 spestov Exp $
 *
 * @since jEdit 2.2pre6
 */
public class PropertiesChanged extends EBMessage
{
	/**
	 * Creates a new properties changed message.
	 * @param source The message source
	 */
	public PropertiesChanged(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.SearchSettingsChanged,"/*
 * SearchSettingsChanged.java - Search and replace settings changed message
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent when search and replace settings change.
 * @author Slava Pestov
 * @version $Id: SearchSettingsChanged.java,v 1.2 2002/05/14 07:55:49 spestov Exp $
 *
 * @since jEdit 2.3pre1
 */
public class SearchSettingsChanged extends EBMessage
{
	/**
	 * Creates a new search and replace settings changed message.
	 * @param source The message source
	 */
	public SearchSettingsChanged(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.VFSUpdate,"/*
 * VFSUpdate.java - A path has changed
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when a file or directory changes.
 * @author Slava Pestov
 * @version $Id: VFSUpdate.java,v 1.3 2002/05/14 07:34:55 spestov Exp $
 *
 * @since jEdit 2.6pre4
 */
public class VFSUpdate extends EBMessage
{
	/**
	 * Creates a VFS update message.
	 * @param path The path in question
	 */
	public VFSUpdate(String path)
	{
		super(null);
		if(path == null)
			throw new NullPointerException(""Path must be non-null"");
		this.path = path;
	}
	/**
	 * Returns the path that changed.
	 */
	public String getPath()
	{
		return path;
	}
	public String paramString()
	{
		return ""path="" + path + "","" + super.paramString();
	}
	// private members
	private String path;
}
"
org.gjt.sp.jedit.msg.ViewUpdate,"/*
 * ViewUpdate.java - View update message
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when a view-related change occurs.
 * @author Slava Pestov
 * @version $Id: ViewUpdate.java,v 1.4 2003/01/12 03:08:24 spestov Exp $
 *
 * @since jEdit 2.2pre6
 */
public class ViewUpdate extends EBMessage
{
	/**
	 * View created.
	 */
	public static final Object CREATED = ""CREATED"";
	/**
	 * View closed.
	 */
	public static final Object CLOSED = ""CLOSED"";
	/**
	 * Active edit pane changed.
	 * @since jEdit 4.1pre1
	 */
	public static final Object EDIT_PANE_CHANGED = ""EDIT_PANE_CHANGED"";
	//{{{ ViewUpdate constructor
	/**
	 * Creates a new view update message.
	 * @param view The view
	 * @param what What happened
	 */
	public ViewUpdate(View view, Object what)
	{
		super(view);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
	} //}}}
	//{{{ getWhat() method
	/**
	 * Returns what caused this view update.
	 */
	public Object getWhat()
	{
		return what;
	} //}}}
	//{{{ getView() method
	/**
	 * Returns the view involved.
	 */
	public View getView()
	{
		return (View)getSource();
	} //}}}
	//{{{ paramString() method
	public String paramString()
	{
		return ""what="" + what + "","" + super.paramString();
	} //}}}
	//{{{ Private members
	private Object what;
	//}}}
}
"
org.gjt.sp.jedit.options.AbbrevsOptionPane,"/*
 * AbbrevsOptionPane.java - Abbrevs options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
//}}}
//{{{ AbbrevsOptionPane class
/**
 * Abbrev editor.
 * @author Slava Pestov
 * @version $Id: AbbrevsOptionPane.java,v 1.12 2003/11/02 21:16:38 spestov Exp $
 */
public class AbbrevsOptionPane extends AbstractOptionPane
{
	//{{{ AbbrevsOptionPane constructor
	public AbbrevsOptionPane()
	{
		super(""abbrevs"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		setLayout(new BorderLayout());
		JPanel panel = new JPanel(new BorderLayout(6,6));
		expandOnInput = new JCheckBox(jEdit.getProperty(""options.abbrevs""
			+ "".expandOnInput""),Abbrevs.getExpandOnInput());
		panel.add(expandOnInput,BorderLayout.NORTH);
		JPanel panel2 = new JPanel();
		panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));
		panel2.setBorder(new EmptyBorder(0,0,6,0));
		panel2.add(Box.createGlue());
		JLabel label = new JLabel(jEdit.getProperty(""options.abbrevs.set""));
		label.setBorder(new EmptyBorder(0,0,0,12));
		panel2.add(label);
		Hashtable _modeAbbrevs = Abbrevs.getModeAbbrevs();
		modeAbbrevs = new Hashtable();
		Mode[] modes = jEdit.getModes();
		Arrays.sort(modes,new MiscUtilities.StringICaseCompare());
		String[] sets = new String[modes.length + 1];
		sets[0] = ""global"";
		for(int i = 0; i < modes.length; i++)
		{
			String name = modes[i].getName();
			sets[i+1] = name;
			modeAbbrevs.put(name,new AbbrevsModel((Hashtable)_modeAbbrevs.get(name)));
		}
		setsComboBox = new JComboBox(sets);
		ActionHandler actionHandler = new ActionHandler();
		setsComboBox.addActionListener(actionHandler);
		panel2.add(setsComboBox);
		panel2.add(Box.createGlue());
		panel.add(panel2,BorderLayout.SOUTH);
		add(BorderLayout.NORTH,panel);
		globalAbbrevs = new AbbrevsModel(Abbrevs.getGlobalAbbrevs());
		abbrevsTable = new JTable(globalAbbrevs);
		abbrevsTable.getColumnModel().getColumn(1).setCellRenderer(
			new Renderer());
		abbrevsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		abbrevsTable.getTableHeader().setReorderingAllowed(false);
		abbrevsTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		abbrevsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		abbrevsTable.getSelectionModel().setSelectionMode(
			ListSelectionModel.SINGLE_SELECTION);
		abbrevsTable.addMouseListener(new TableMouseHandler());
		Dimension d = abbrevsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(abbrevsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(6,0,0,0));
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.abbrevs.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.abbrevs.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		edit = new RolloverButton(GUIUtilities.loadIcon(""ButtonProperties.png""));
		edit.setToolTipText(jEdit.getProperty(""options.abbrevs.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());
		add(BorderLayout.SOUTH,buttons);
		updateEnabled();
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		if(abbrevsTable.getCellEditor() != null)
			abbrevsTable.getCellEditor().stopCellEditing();
		Abbrevs.setExpandOnInput(expandOnInput.isSelected());
		Abbrevs.setGlobalAbbrevs(globalAbbrevs.toHashtable());
		Hashtable modeHash = new Hashtable();
		Enumeration keys = modeAbbrevs.keys();
		Enumeration values = modeAbbrevs.elements();
		while(keys.hasMoreElements())
		{
			modeHash.put(keys.nextElement(),((AbbrevsModel)values.nextElement())
				.toHashtable());
		}
		Abbrevs.setModeAbbrevs(modeHash);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JComboBox setsComboBox;
	private JCheckBox expandOnInput;
	private JTable abbrevsTable;
	private AbbrevsModel globalAbbrevs;
	private Hashtable modeAbbrevs;
	private JButton add;
	private JButton edit;
	private JButton remove;
	//}}}
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		int selectedRow = abbrevsTable.getSelectedRow();
		edit.setEnabled(selectedRow != -1);
		remove.setEnabled(selectedRow != -1);
	} //}}}
	//{{{ edit() method
	private void edit()
	{
		AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();
		int row = abbrevsTable.getSelectedRow();
		String abbrev = (String)abbrevsModel.getValueAt(row,0);
		String expansion = (String)abbrevsModel.getValueAt(row,1);
		String oldAbbrev = abbrev;
		EditAbbrevDialog dialog = new EditAbbrevDialog(
			GUIUtilities.getParentDialog(AbbrevsOptionPane.this),
			abbrev,expansion,abbrevsModel.toHashtable());
		abbrev = dialog.getAbbrev();
		expansion = dialog.getExpansion();
		if(abbrev != null && expansion != null)
		{
			for(int i = 0; i < abbrevsModel.getRowCount(); i++)
			{
				if(abbrevsModel.getValueAt(i,0).equals(oldAbbrev))
				{
					abbrevsModel.remove(i);
					break;
				}
			}
			add(abbrevsModel,abbrev,expansion);
		}
	} //}}}
	//{{{ add() method
	private void add(AbbrevsModel abbrevsModel, String abbrev,
		String expansion)
	{
		for(int i = 0; i < abbrevsModel.getRowCount(); i++)
		{
			if(abbrevsModel.getValueAt(i,0).equals(abbrev))
			{
				abbrevsModel.remove(i);
				break;
			}
		}
		abbrevsModel.add(abbrev,expansion);
		updateEnabled();
	} //}}}
	//}}}
	//{{{ HeaderMouseHandler class
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(abbrevsTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				((AbbrevsModel)abbrevsTable.getModel()).sort(0);
				break;
			case 1:
				((AbbrevsModel)abbrevsTable.getModel()).sort(1);
				break;
			}
		}
	} //}}}
	//{{{ TableMouseHandler class
	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			if(evt.getClickCount() == 2)
				edit();
		}
	} //}}}
	//{{{ SelectionHandler class
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();
			Object source = evt.getSource();
			if(source == setsComboBox)
			{
				String selected = (String)setsComboBox.getSelectedItem();
				if(selected.equals(""global""))
				{
					abbrevsTable.setModel(globalAbbrevs);
				}
				else
				{
					abbrevsTable.setModel((AbbrevsModel)
						modeAbbrevs.get(selected));
				}
				updateEnabled();
			}
			else if(source == add)
			{
				EditAbbrevDialog dialog = new EditAbbrevDialog(
					GUIUtilities.getParentDialog(AbbrevsOptionPane.this),
					null,null,abbrevsModel.toHashtable());
				String abbrev = dialog.getAbbrev();
				String expansion = dialog.getExpansion();
				if(abbrev != null && abbrev.length() != 0
					&& expansion != null
					&& expansion.length() != 0)
				{
					add(abbrevsModel,abbrev,expansion);
				}
			}
			else if(source == edit)
			{
				edit();
			}
			else if(source == remove)
			{
				int selectedRow = abbrevsTable.getSelectedRow();
				abbrevsModel.remove(selectedRow);
				updateEnabled();
			}
		}
	} //}}}
	//{{{ Renderer class
	static class Renderer extends DefaultTableCellRenderer
	{
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			String valueStr = value.toString();
			// workaround for Swing's annoying processing of
			// labels starting with <html>, which often breaks
			if(valueStr.toLowerCase().startsWith(""<html>""))
				valueStr = "" "" + valueStr;
			return super.getTableCellRendererComponent(table,valueStr,
				isSelected,cellHasFocus,row,col);
		}
	} //}}}
} //}}}
//{{{ AbbrevsModel class
class AbbrevsModel extends AbstractTableModel
{
	Vector abbrevs;
	int lastSort;
	//{{{ AbbrevsModel constructor
	AbbrevsModel(Hashtable abbrevHash)
	{
		abbrevs = new Vector();
		if(abbrevHash != null)
		{
			Enumeration abbrevEnum = abbrevHash.keys();
			Enumeration expandEnum = abbrevHash.elements();
			while(abbrevEnum.hasMoreElements())
			{
				abbrevs.addElement(new Abbrev((String)abbrevEnum.nextElement(),
					(String)expandEnum.nextElement()));
			}
			sort(0);
		}
	} //}}}
	//{{{ sort() method
	void sort(int col)
	{
		lastSort = col;
		MiscUtilities.quicksort(abbrevs,new AbbrevCompare(col));
		fireTableDataChanged();
	} //}}}
	//{{{ add() method
	void add(String abbrev, String expansion)
	{
		abbrevs.addElement(new Abbrev(abbrev,expansion));
		sort(lastSort);
	} //}}}
	//{{{ remove() method
	void remove(int index)
	{
		abbrevs.removeElementAt(index);
		fireTableStructureChanged();
	} //}}}
	//{{{ toHashtable() method
	public Hashtable toHashtable()
	{
		Hashtable hash = new Hashtable();
		for(int i = 0; i < abbrevs.size(); i++)
		{
			Abbrev abbrev = (Abbrev)abbrevs.elementAt(i);
			if(abbrev.abbrev.length() > 0
				&& abbrev.expand.length() > 0)
			{
				hash.put(abbrev.abbrev,abbrev.expand);
			}
		}
		return hash;
	} //}}}
	//{{{ getColumnCount() method
	public int getColumnCount()
	{
		return 2;
	} //}}}
	//{{{ getRowCount() method
	public int getRowCount()
	{
		return abbrevs.size();
	} //}}}
	//{{{ getValueAt() method
	public Object getValueAt(int row, int col)
	{
		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);
		switch(col)
		{
		case 0:
			return abbrev.abbrev;
		case 1:
			return abbrev.expand;
		default:
			return null;
		}
	} //}}}
	//{{{ isCellEditable() method
	public boolean isCellEditable(int row, int col)
	{
		return false;
	} //}}}
	//{{{ setValueAt() method
	public void setValueAt(Object value, int row, int col)
	{
		if(value == null)
			value = """";
		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);
		if(col == 0)
			abbrev.abbrev = (String)value;
		else
			abbrev.expand = (String)value;
		fireTableRowsUpdated(row,row);
	} //}}}
	//{{{ getColumnName() method
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.abbrevs.abbrev"");
		case 1:
			return jEdit.getProperty(""options.abbrevs.expand"");
		default:
			return null;
		}
	} //}}}
	//{{{ AbbrevCompare class
	class AbbrevCompare implements MiscUtilities.Compare
	{
		int col;
		AbbrevCompare(int col)
		{
			this.col = col;
		}
		public int compare(Object obj1, Object obj2)
		{
			Abbrev a1 = (Abbrev)obj1;
			Abbrev a2 = (Abbrev)obj2;
			if(col == 0)
			{
				String abbrev1 = a1.abbrev.toLowerCase();
				String abbrev2 = a2.abbrev.toLowerCase();
				return MiscUtilities.compareStrings(
					abbrev1,abbrev2,true);
			}
			else
			{
				String expand1 = a1.expand.toLowerCase();
				String expand2 = a2.expand.toLowerCase();
				return MiscUtilities.compareStrings(
					expand1,expand2,true);
			}
		}
	} //}}}
} //}}}
//{{{ Abbrev class
class Abbrev
{
	Abbrev() {}
	Abbrev(String abbrev, String expand)
	{
		this.abbrev = abbrev;
		this.expand = expand;
	}
	String abbrev;
	String expand;
} //}}}
"
org.gjt.sp.jedit.options.AppearanceOptionPane,"/*
 * AppearanceOptionPane.java - Appearance options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class AppearanceOptionPane extends AbstractOptionPane
{
	//{{{ AppearanceOptionPane constructor
	public AppearanceOptionPane()
	{
		super(""appearance"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* Look and feel */
		addComponent(new JLabel(jEdit.getProperty(""options.appearance.lf.note"")));
		lfs = UIManager.getInstalledLookAndFeels();
		String[] names = new String[lfs.length];
		String lf = UIManager.getLookAndFeel().getClass().getName();
		int index = 0;
		for(int i = 0; i < names.length; i++)
		{
			names[i] = lfs[i].getName();
			if(lf.equals(lfs[i].getClassName()))
				index = i;
		}
		lookAndFeel = new JComboBox(names);
		lookAndFeel.setSelectedIndex(index);
		lookAndFeel.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				updateEnabled();
			}
		});
		addComponent(jEdit.getProperty(""options.appearance.lf""),
			lookAndFeel);
		/* Primary Metal L&F font */
		primaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.primary.font""));
		addComponent(jEdit.getProperty(""options.appearance.primaryFont""),
			primaryFont);
		/* Secondary Metal L&F font */
		secondaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.secondary.font""));
		addComponent(jEdit.getProperty(""options.appearance.secondaryFont""),
			secondaryFont);
		updateEnabled();
		/* History count */
		history = new JTextField(jEdit.getProperty(""history""));
		addComponent(jEdit.getProperty(""options.appearance.history""),history);
		/* Menu spillover count */
		menuSpillover = new JTextField(jEdit.getProperty(""menu.spillover""));
		addComponent(jEdit.getProperty(""options.appearance.menuSpillover""),menuSpillover);
		addSeparator(""options.appearance.startup.label"");
		/* Show splash screen */
		showSplash = new JCheckBox(jEdit.getProperty(
			""options.appearance.showSplash""));
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			showSplash.setSelected(true);
		else
			showSplash.setSelected(!new File(settingsDirectory,""nosplash"").exists());
		addComponent(showSplash);
		/* Show tip of the day */
		showTips = new JCheckBox(jEdit.getProperty(
			""options.appearance.showTips""));
		showTips.setSelected(jEdit.getBooleanProperty(""tip.show""));
		addComponent(showTips);
		addSeparator(""options.appearance.experimental.label"");
		addComponent(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""options.appearance.experimental.caption"")));
		/* Use jEdit colors in all text components */
		textColors = new JCheckBox(jEdit.getProperty(
			""options.appearance.textColors""));
		textColors.setSelected(jEdit.getBooleanProperty(""textColors""));
		addComponent(textColors);
		/* Decorate frames with look and feel (JDK 1.4 only) */
		decorateFrames = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateFrames""));
		decorateFrames.setSelected(jEdit.getBooleanProperty(""decorate.frames""));
		/* Decorate dialogs with look and feel (JDK 1.4 only) */
		decorateDialogs = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateDialogs""));
		decorateDialogs.setSelected(jEdit.getBooleanProperty(""decorate.dialogs""));
		if(OperatingSystem.hasJava14())
		{
			addComponent(decorateFrames);
			addComponent(decorateDialogs);
		}
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		String lf = lfs[lookAndFeel.getSelectedIndex()].getClassName();
		jEdit.setProperty(""lookAndFeel"",lf);
		jEdit.setFontProperty(""metal.primary.font"",primaryFont.getFont());
		jEdit.setFontProperty(""metal.secondary.font"",secondaryFont.getFont());
		jEdit.setProperty(""history"",history.getText());
		jEdit.setProperty(""menu.spillover"",menuSpillover.getText());
		jEdit.setBooleanProperty(""tip.show"",showTips.isSelected());
		// this is handled a little differently from other jEdit settings
		// as the splash screen flag needs to be known very early in the
		// startup sequence, before the user properties have been loaded
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			File file = new File(settingsDirectory,""nosplash"");
			if(showSplash.isSelected())
				file.delete();
			else
			{
				FileOutputStream out = null;
				try
				{
					out = new FileOutputStream(file);
					out.write('\n');
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}
				finally
				{
					try
					{
						if(out != null)
							out.close();
					}
					catch(IOException e)
					{
					}
				}
			}
		}
		jEdit.setBooleanProperty(""textColors"",textColors.isSelected());
		jEdit.setBooleanProperty(""decorate.frames"",decorateFrames.isSelected());
		jEdit.setBooleanProperty(""decorate.dialogs"",decorateDialogs.isSelected());
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private UIManager.LookAndFeelInfo[] lfs;
	private JComboBox lookAndFeel;
	private FontSelector primaryFont;
	private FontSelector secondaryFont;
	private JTextField history;
	private JTextField menuSpillover;
	private JCheckBox showTips;
	private JCheckBox showSplash;
	private JCheckBox textColors;
	private JCheckBox decorateFrames;
	private JCheckBox decorateDialogs;
	//}}}
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		String className = lfs[lookAndFeel.getSelectedIndex()]
			.getClassName();
		if(className.equals(""javax.swing.plaf.metal.MetalLookAndFeel"")
			|| className.equals(""com.incors.plaf.kunststoff.KunststoffLookAndFeel""))
		{
			primaryFont.setEnabled(true);
			secondaryFont.setEnabled(true);
		}
		else
		{
			primaryFont.setEnabled(false);
			secondaryFont.setEnabled(false);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.options.AutosaveBackupOptionPane,"/*
 * AutosaveBackupOptionPane.java - Autosave & backup options
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
//}}}
public class AutosaveBackupOptionPane extends AbstractOptionPane
{
	//{{{ AutosaveBackupOptionPane constructor
	public AutosaveBackupOptionPane()
	{
		super(""auto-back"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* Autosave interval */
		autosave = new JTextField(jEdit.getProperty(""autosave""));
		addComponent(jEdit.getProperty(""options.auto-back.autosave""),autosave);
		/* Backup count */
		backups = new JTextField(jEdit.getProperty(""backups""));
		addComponent(jEdit.getProperty(""options.auto-back.backups""),backups);
		/* Backup directory */
		backupDirectory = new JTextField(jEdit.getProperty(
			""backup.directory""));
		addComponent(jEdit.getProperty(""options.auto-back.backupDirectory""),
			backupDirectory);
		/* Backup filename prefix */
		backupPrefix = new JTextField(jEdit.getProperty(""backup.prefix""));
		addComponent(jEdit.getProperty(""options.auto-back.backupPrefix""),
			backupPrefix);
		/* Backup suffix */
		backupSuffix = new JTextField(jEdit.getProperty(
			""backup.suffix""));
		addComponent(jEdit.getProperty(""options.auto-back.backupSuffix""),
			backupSuffix);
		/* Backup on every save */
		backupEverySave = new JCheckBox(jEdit.getProperty(
			""options.auto-back.backupEverySave""));
		backupEverySave.setSelected(jEdit.getBooleanProperty(""backupEverySave""));
		addComponent(backupEverySave);
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setProperty(""autosave"",autosave.getText());
		jEdit.setProperty(""backups"",backups.getText());
		jEdit.setProperty(""backup.directory"",backupDirectory.getText());
		jEdit.setProperty(""backup.prefix"",backupPrefix.getText());
		jEdit.setProperty(""backup.suffix"",backupSuffix.getText());
		jEdit.setBooleanProperty(""backupEverySave"", backupEverySave.isSelected());
	} //}}}
	//{{{ Private members
	private JTextField autosave;
	private JTextField backups;
	private JTextField backupDirectory;
	private JTextField backupPrefix;
	private JTextField backupSuffix;
	private JCheckBox backupEverySave;
	//}}}
}
"
org.gjt.sp.jedit.options.BrowserColorsOptionPane,"/*
 * BrowserColorsOptionPane.java - Browser colors options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.*;
//}}}
//{{{ BrowserColorsOptionPane class
/**
 * Browser color editor.
 * @author Slava Pestov
 * @version $Id: BrowserColorsOptionPane.java,v 1.6 2003/10/11 02:21:37 spestov Exp $
 */
public class BrowserColorsOptionPane extends AbstractOptionPane
{
	//{{{ BrowserColorsOptionPane constructor
	public BrowserColorsOptionPane()
	{
		super(""browser.colors"");
	} //}}}
	//{{{ Protected members
	//{{{ _init() method
	protected void _init()
	{
		setLayout(new BorderLayout());
		colorsModel = new BrowserColorsModel();
		colorsTable = new JTable(colorsModel);
		colorsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		colorsTable.getTableHeader().setReorderingAllowed(false);
		colorsTable.addMouseListener(new MouseHandler());
		colorsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		TableColumnModel tcm = colorsTable.getColumnModel();
		tcm.getColumn(1).setCellRenderer(new BrowserColorsModel.ColorRenderer());
		Dimension d = colorsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(colorsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""common.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""common.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""common.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""common.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());
		add(BorderLayout.SOUTH,buttons);
		updateEnabled();
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		colorsModel.save();
	} //}}}
	//}}}
	//{{{ Private members
	private BrowserColorsModel colorsModel;
	private JTable colorsTable;
	private JButton add;
	private JButton remove;
	private JButton moveUp;
	private JButton moveDown;
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		int selectedRow = colorsTable.getSelectedRow();
		remove.setEnabled(selectedRow != -1);
		moveUp.setEnabled(selectedRow > 0);
		moveUp.setEnabled(selectedRow != -1 && selectedRow !=
			colorsModel.getRowCount());
	} //}}}
	//{{{ setSelectedRow() method
	private void setSelectedRow(int row)
	{
		colorsTable.getSelectionModel().setSelectionInterval(row,row);
		colorsTable.scrollRectToVisible(colorsTable.getCellRect(row,0,true));
	} //}}}
	//}}}
	//{{{ SelectionHandler class
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				colorsModel.add();
			}
			else if(source == remove)
			{
				int selectedRow = colorsTable.getSelectedRow();
				colorsModel.remove(selectedRow);
				updateEnabled();
			}
			else if(source == moveUp)
			{
				int selectedRow = colorsTable.getSelectedRow();
				if(selectedRow != 0)
				{
					colorsModel.moveUp(selectedRow);
					setSelectedRow(selectedRow - 1);
				}
				updateEnabled();
			}
			else if(source == moveDown)
			{
				int selectedRow = colorsTable.getSelectedRow();
				if(selectedRow != colorsTable.getRowCount() - 1)
				{
					colorsModel.moveDown(selectedRow);
					setSelectedRow(selectedRow + 1);
				}
				updateEnabled();
			}
		}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Point p = evt.getPoint();
			int row = colorsTable.rowAtPoint(p);
			int column = colorsTable.columnAtPoint(p);
			if(row == -1 || column != 1)
				return;
			Color color = JColorChooser.showDialog(
				BrowserColorsOptionPane.this,
				jEdit.getProperty(""colorChooser.title""),
				(Color)colorsModel.getValueAt(row,1));
			if(color != null)
				colorsModel.setValueAt(color,row,1);
		}
	} //}}}
} //}}}
//{{{ BrowserColorsModel class
class BrowserColorsModel extends AbstractTableModel
{
	//{{{ BrowserColorsModel constructor
	BrowserColorsModel()
	{
		entries = new ArrayList();
		int i = 0;
		String glob;
		while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
		{
			entries.add(new Entry(glob,
				jEdit.getColorProperty(
				""vfs.browser.colors."" + i + "".color"",
				Color.black)));
			i++;
		}
	} //}}}
	//{{{ add() method
	void add()
	{
		entries.add(new Entry("""",UIManager.getColor(""Tree.foreground"")));
		fireTableRowsInserted(entries.size() - 1,entries.size() - 1);
	} //}}}
	//{{{ remove() method
	void remove(int index)
	{
		entries.remove(index);
		fireTableRowsDeleted(entries.size(),entries.size());
	} //}}}
	//{{{ moveUp() method
	public void moveUp(int index)
	{
		Object obj = entries.get(index);
		entries.remove(index);
		entries.add(index - 1,obj);
		fireTableRowsUpdated(index - 1,index);
	} //}}}
	//{{{ moveDown() method
	public void moveDown(int index)
	{
		Object obj = entries.get(index);
		entries.remove(index);
		entries.add(index + 1,obj);
		fireTableRowsUpdated(index,index + 1);
	} //}}}
	//{{{ save() method
	void save()
	{
		int i;
		for(i = 0; i < entries.size(); i++)
		{
			Entry entry = (Entry)entries.get(i);
			jEdit.setProperty(""vfs.browser.colors."" + i + "".glob"",
				entry.glob);
			jEdit.setColorProperty(""vfs.browser.colors."" + i + "".color"",
				entry.color);
		}
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".glob"");
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".color"");
	} //}}}
	//{{{ getColumnCount() method
	public int getColumnCount()
	{
		return 2;
	} //}}}
	//{{{ getRowCount() method
	public int getRowCount()
	{
		return entries.size();
	} //}}}
	//{{{ getValueAt() method
	public Object getValueAt(int row, int col)
	{
		Entry entry = (Entry)entries.get(row);
		switch(col)
		{
		case 0:
			return entry.glob;
		case 1:
			return entry.color;
		default:
			return null;
		}
	} //}}}
	//{{{ isCellEditable() method
	public boolean isCellEditable(int row, int col)
	{
		return (col == 0);
	} //}}}
	//{{{ setValueAt() method
	public void setValueAt(Object value, int row, int col)
	{
		Entry entry = (Entry)entries.get(row);
		if(col == 0)
			entry.glob = (String)value;
		else
			entry.color = (Color)value;
		fireTableRowsUpdated(row,row);
	} //}}}
	//{{{ getColumnName() method
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.browser.colors.glob"");
		case 1:
			return jEdit.getProperty(""options.browser.colors.color"");
		default:
			return null;
		}
	} //}}}
	//{{{ getColumnClass() method
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return String.class;
		case 1:
			return Color.class;
		default:
			throw new InternalError();
		}
	} //}}}
	private ArrayList entries;
	//{{{ Entry class
	static class Entry
	{
		String glob;
		Color color;
		Entry(String glob, Color color)
		{
			this.glob = glob;
			this.color = color;
		}
	} //}}}
	//{{{ ColorRenderer class
	static class ColorRenderer extends JLabel
		implements TableCellRenderer
	{
		//{{{ ColorRenderer constructor
		public ColorRenderer()
		{
			setOpaque(true);
			setBorder(SyntaxHiliteOptionPane.noFocusBorder);
		} //}}}
		//{{{ getTableCellRendererComponent() method
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (isSelected)
			{
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			}
			else
			{
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}
			if (value != null)
				setBackground((Color)value);
			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: SyntaxHiliteOptionPane.noFocusBorder);
			return this;
		} //}}}
	} //}}}
} //}}}
"
org.gjt.sp.jedit.options.BrowserOptionPane,"/*
 * BrowserOptionPane.java - Browser options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import org.gjt.sp.jedit.*;
//}}}
//{{{ BrowserOptionPane class
public class BrowserOptionPane extends AbstractOptionPane
{
	//{{{ BrowserOptionPane constructor
	public BrowserOptionPane()
	{
		super(""browser.general"");
	} //}}}
	//{{{ _init() method
	public void _init()
	{
		/* Default directory */
		String[] dirs = {
			jEdit.getProperty(""options.browser.general.defaultPath.favorites""),
			jEdit.getProperty(""options.browser.general.defaultPath.home""),
			jEdit.getProperty(""options.browser.general.defaultPath.last""),
			jEdit.getProperty(""options.browser.general.defaultPath.buffer""),
			jEdit.getProperty(""options.browser.general.defaultPath.working"")
		};
		defaultDirectory = new JComboBox(dirs);
		String defaultDir = jEdit.getProperty(""vfs.browser.defaultPath"");
		if(""favorites"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(0);
		else if(""home"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(1);
		else if(""last"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(2);
		else if(""buffer"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(3);
		else if(""working"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(4);
		addComponent(jEdit.getProperty(""options.browser.general.defaultPath""),
			defaultDirectory);
		/* Show tool bar */
		showToolbar = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showToolbar""));
		addComponent(showToolbar);
		/* Show menu bar */
		showMenubar = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showMenubar""));
		showMenubar.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showMenubar""));
		addComponent(showMenubar);
		/* Show icons */
		showIcons = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showIcons""));
		showIcons.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showIcons""));
		addComponent(showIcons);
		/* Show hidden files */
		showHiddenFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showHiddenFiles""));
		showHiddenFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showHiddenFiles""));
		addComponent(showHiddenFiles);
		/* Ignore case when sorting */
		sortIgnoreCase = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortIgnoreCase""));
		sortIgnoreCase.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortIgnoreCase""));
		addComponent(sortIgnoreCase);
		/* Mix files and directories */
		sortMixFilesAndDirs = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortMixFilesAndDirs""));
		sortMixFilesAndDirs.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortMixFilesAndDirs""));
		addComponent(sortMixFilesAndDirs);
		/* Double-click close */
		doubleClickClose = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.doubleClickClose""));
		doubleClickClose.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".doubleClickClose""));
		addComponent(doubleClickClose);
		/* split VFSFileDialog horizontally */
		currentBufferFilter = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.currentBufferFilter""));
		currentBufferFilter.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".currentBufferFilter""));
		addComponent(currentBufferFilter);
	} //}}}
	//{{{ _save() method
	public void _save()
	{
		String[] dirs = { ""favorites"", ""home"", ""last"", ""buffer"", ""working""};
		jEdit.setProperty(""vfs.browser.defaultPath"",dirs[defaultDirectory
			.getSelectedIndex()]);
		jEdit.setBooleanProperty(""vfs.browser.showToolbar"",
			showToolbar.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showMenubar"",
			showMenubar.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showIcons"",
			showIcons.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showHiddenFiles"",
			showHiddenFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortIgnoreCase"",
			sortIgnoreCase.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortMixFilesAndDirs"",
			sortMixFilesAndDirs.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.doubleClickClose"",
			doubleClickClose.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.currentBufferFilter"",
			currentBufferFilter.isSelected());
	} //}}}
	//{{{ Private members
	private JComboBox defaultDirectory;
	private JCheckBox showToolbar;
	private JCheckBox showMenubar;
	private JCheckBox showIcons;
	private JCheckBox showHiddenFiles;
	private JCheckBox sortIgnoreCase;
	private JCheckBox sortMixFilesAndDirs;
	private JCheckBox doubleClickClose;
	private JCheckBox currentBufferFilter;
	//}}}
} //}}}
"
org.gjt.sp.jedit.options.ContextOptionPane,"/*
 * ContextOptionPane.java - Context menu options panel
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
/**
 * Right-click context menu editor.
 * @author Slava Pestov
 * @version $Id: ContextOptionPane.java,v 1.11 2004/06/28 06:45:27 spestov Exp $
 */
public class ContextOptionPane extends AbstractOptionPane
{
	public ContextOptionPane()
	{
		super(""context"");
	}
	// protected members
	protected void _init()
	{
		setLayout(new BorderLayout());
		JLabel caption = new JLabel(jEdit.getProperty(
			""options.context.caption""));
		add(BorderLayout.NORTH,caption);
		String contextMenu = jEdit.getProperty(""view.context"");
		StringTokenizer st = new StringTokenizer(contextMenu);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ContextOptionPane.MenuItem(""-"",""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;
				listModel.addElement(new ContextOptionPane.MenuItem(actionName,label));
			}
		}
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		add(BorderLayout.CENTER,new JScrollPane(list));
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""common.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""common.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""common.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""common.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());
		updateButtons();
		add(BorderLayout.SOUTH,buttons);
	}
	static class MenuItemCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return MiscUtilities.compareStrings(
				((MenuItem)obj1).label,
				((MenuItem)obj2).label,
				true);
		}
	}
	protected void _save()
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			buf.append(((MenuItem)listModel.elementAt(i)).actionName);
		}
		jEdit.setProperty(""view.context"",buf.toString());
	}
	// private members
	private DefaultListModel listModel;
	private JList list;
	private JButton add;
	private JButton remove;
	private JButton moveUp, moveDown;
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
	}
	static class MenuItem
	{
		String actionName;
		String label;
		MenuItem(String actionName, String label)
		{
			this.actionName = actionName;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}
		public String toString()
		{
			return label;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				ContextAddDialog dialog = new ContextAddDialog(
					ContextOptionPane.this);
				String selection = dialog.getSelection();
				if(selection == null)
					return;
				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;
				MenuItem menuItem;
				if(selection.equals(""-""))
					menuItem = new ContextOptionPane.MenuItem(""-"",""-"");
				else
				{
					menuItem = new ContextOptionPane.MenuItem(selection,
						jEdit.getAction(selection)
						.getLabel());
				}
				listModel.insertElementAt(menuItem,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				if(listModel.getSize() != 0)
				{
					list.setSelectedIndex(
						Math.min(listModel.getSize()-1,
						index));
				}
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index - 1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	}
}
class ContextAddDialog extends EnhancedDialog
{
	public ContextAddDialog(Component comp)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""options.context.add.title""),
			true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();
		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.context.add.caption"")));
		separator = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);
		action = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		action.setSelected(true);
		typePanel.add(action);
		content.add(BorderLayout.NORTH,typePanel);
		JPanel actionPanel = new JPanel(new BorderLayout(6,6));
		ActionSet[] actionsList = jEdit.getActionSets();
		Vector vec = new Vector(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				vec.addElement(actionSet);
		}
		combo = new JComboBox(vec);
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);
		list = new JList();
		list.setVisibleRowCount(8);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));
		content.add(BorderLayout.CENTER,actionPanel);
		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,southPanel);
		updateList();
		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		setVisible(true);
	}
	public void ok()
	{
		isOK = true;
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	public String getSelection()
	{
		if(!isOK)
			return null;
		if(separator.isSelected())
			return ""-"";
		else if(action.isSelected())
		{
			return ((ContextOptionPane.MenuItem)list.getSelectedValue())
				.actionName;
		}
		else
			throw new InternalError();
	}
	// private members
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JButton ok, cancel;
	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;
			listModel.addElement(new ContextOptionPane.MenuItem(
				action.getName(),label));
		}
		MiscUtilities.quicksort(listModel,new ContextOptionPane.MenuItemCompare());
		list.setListData(listModel);
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
			{
				combo.setEnabled(action.isSelected());
				list.setEnabled(action.isSelected());
			}
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
		}
	}
}
"
org.gjt.sp.jedit.options.DockingOptionPane,"/*
 * DockingOptionPane.java - Dockable window options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.DockableWindowUpdate;
import org.gjt.sp.jedit.*;
//}}}
//{{{ DockingOptionPane class
public class DockingOptionPane extends AbstractOptionPane
{
	//{{{ DockingOptionPane constructor
	public DockingOptionPane()
	{
		super(""docking"");
	} //}}}
	//{{{ _init() method
	public void _init()
	{
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER,createWindowTableScroller());
	} //}}}
	//{{{ _save() method
	public void _save()
	{
		windowModel.save();
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JTable windowTable;
	private WindowTableModel windowModel;
	//}}}
	//{{{ createWindowTableScroller() method
	private JScrollPane createWindowTableScroller()
	{
		windowModel = createWindowModel();
		windowTable = new JTable(windowModel);
		windowTable.getTableHeader().setReorderingAllowed(false);
		windowTable.setColumnSelectionAllowed(false);
		windowTable.setRowSelectionAllowed(false);
		windowTable.setCellSelectionEnabled(false);
		DockPositionCellRenderer comboBox = new DockPositionCellRenderer();
		windowTable.setRowHeight(comboBox.getPreferredSize().height);
		TableColumn column = windowTable.getColumnModel().getColumn(1);
		column.setCellRenderer(comboBox);
		column.setCellEditor(new DefaultCellEditor(new DockPositionCellRenderer()));
		Dimension d = windowTable.getPreferredSize();
		d.height = Math.min(d.height,50);
		JScrollPane scroller = new JScrollPane(windowTable);
		scroller.setPreferredSize(d);
		return scroller;
	} //}}}
	//{{{ createWindowModel() method
	private WindowTableModel createWindowModel()
	{
		return new WindowTableModel();
	} //}}}
	//}}}
	//{{{ DockPositionCellRenderer class
	class DockPositionCellRenderer extends JComboBox
		implements TableCellRenderer
	{
		DockPositionCellRenderer()
		{
			super(new String[] {
				DockableWindowManager.FLOATING,
				DockableWindowManager.TOP,
				DockableWindowManager.LEFT,
				DockableWindowManager.BOTTOM,
				DockableWindowManager.RIGHT
			});
			DockPositionCellRenderer.this.setRequestFocusEnabled(false);
		}
		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus,
			int row, int column)
		{
			setSelectedItem(value);
			return this;
		}
	} //}}}
} //}}}
//{{{ WindowTableModel class
class WindowTableModel extends AbstractTableModel
{
	private Vector windows;
	//{{{ WindowTableModel constructor
	WindowTableModel()
	{
		windows = new Vector();
		String[] dockables = DockableWindowManager.getRegisteredDockableWindows();
		for(int i = 0; i < dockables.length; i++)
		{
			windows.addElement(new Entry(dockables[i]));
		}
		sort();
	} //}}}
	//{{{ sort() method
	public void sort()
	{
		MiscUtilities.quicksort(windows,new WindowCompare());
		fireTableDataChanged();
	} //}}}
	//{{{ getColumnCount() method
	public int getColumnCount()
	{
		return 2;
	} //}}}
	//{{{ getRowCount() method
	public int getRowCount()
	{
		return windows.size();
	} //}}}
	//{{{ getColumnClass() method
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	} //}}}
	//{{{ getValueAt() method
	public Object getValueAt(int row, int col)
	{
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 0:
			return window.title;
		case 1:
			return window.dockPosition;
		default:
			throw new InternalError();
		}
	} //}}}
	//{{{ isCellEditable() method
	public boolean isCellEditable(int row, int col)
	{
		return (col != 0);
	} //}}}
	//{{{ setValueAt() method
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
			return;
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 1:
			window.dockPosition = (String)value;
			break;
		default:
			throw new InternalError();
		}
		fireTableRowsUpdated(row,row);
	} //}}}
	//{{{ getColumnName() method
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.docking.title"");
		case 1:
			return jEdit.getProperty(""options.docking.dockPosition"");
		default:
			throw new InternalError();
		}
	} //}}}
	//{{{ save() method
	public void save()
	{
		for(int i = 0; i < windows.size(); i++)
		{
			((Entry)windows.elementAt(i)).save();
		}
	} //}}}
	//{{{ Entry class
	class Entry
	{
		String name;
		String title;
		String dockPosition;
		Entry(String name)
		{
			this.name = name;
			title = jEdit.getProperty(name + "".title"");
			if(title == null)
				title = name;
			dockPosition = jEdit.getProperty(name + "".dock-position"");
			if(dockPosition == null)
				dockPosition = DockableWindowManager.FLOATING;
		}
		void save()
		{
			jEdit.setProperty(name + "".dock-position"",dockPosition);
		}
	} //}}}
	//{{{ WindowCompare class
	class WindowCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			Entry e1 = (Entry)obj1;
			Entry e2 = (Entry)obj2;
			return MiscUtilities.compareStrings(
				e1.title,e2.title,true);
		}
	} //}}}
} //}}}
"
org.gjt.sp.jedit.options.EditingOptionPane,"/*
 * EditingOptionPane.java - Mode-specific options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.FoldHandler;
//}}}
public class EditingOptionPane extends AbstractOptionPane
{
	//{{{ EditingOptionPane constructor
	public EditingOptionPane()
	{
		super(""editing"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		Mode[] modes = jEdit.getModes();
		MiscUtilities.quicksort(modes,new MiscUtilities.StringICaseCompare());
		global = new ModeProperties();
		modeProps = new ModeProperties[modes.length];
		String[] modeNames = new String[modes.length + 1];
		modeNames[0] = jEdit.getProperty(""options.editing.global"");
		for(int i = 0; i < modes.length; i++)
		{
			modeProps[i] = new ModeProperties(modes[i]);
			modeNames[i + 1] = modes[i].getName();
		}
		mode = new JComboBox(modeNames);
		mode.addActionListener(new ActionHandler());
		captionBox = new Box(BoxLayout.X_AXIS);
		addComponent(captionBox);
		addComponent(jEdit.getProperty(""options.editing.mode""),mode);
		useDefaults = new JCheckBox(jEdit.getProperty(""options.editing.useDefaults""));
		useDefaults.addActionListener(new ActionHandler());
		addComponent(useDefaults);
		addComponent(jEdit.getProperty(""options.editing.noWordSep""),
			noWordSep = new JTextField());
		String[] foldModes = FoldHandler.getFoldModes();
		addComponent(jEdit.getProperty(""options.editing.folding""),
			folding = new JComboBox(foldModes));
		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),
			collapseFolds = new JTextField());
		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};
		addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap = new JComboBox(wrapModes));
		wrap.addActionListener(new ActionHandler());
		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen = new JComboBox(lineLens));
		maxLineLen.setEditable(true);
		maxLineLen.addActionListener(new ActionHandler());
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		addComponent(jEdit.getProperty(""options.editing.tabSize""),
			tabSize = new JComboBox(tabSizes));
		tabSize.setEditable(true);
		addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize = new JComboBox(tabSizes));
		indentSize.setEditable(true);
		addComponent(noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs"")));
		addComponent(deepIndent = new JCheckBox(jEdit.getProperty(
			""options.editing.deepIndent"")));
		addComponent(jEdit.getProperty(""options.editing.filenameGlob""),
			filenameGlob = new JTextField());
		addComponent(jEdit.getProperty(""options.editing.firstlineGlob""),
			firstlineGlob = new JTextField());
		selectMode();
		addSeparator();
		defaultMode = new JComboBox(modes);
		defaultMode.setSelectedItem(jEdit.getMode(
			jEdit.getProperty(""buffer.defaultMode"")));
		addComponent(jEdit.getProperty(""options.editing.defaultMode""),
			defaultMode);
		undoCount = new JTextField(jEdit.getProperty(""buffer.undoCount""));
		addComponent(jEdit.getProperty(""options.editing.undoCount""),undoCount);
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setProperty(""buffer.defaultMode"",
			((Mode)defaultMode.getSelectedItem()).getName());
		jEdit.setProperty(""buffer.undoCount"",undoCount.getText());
		saveMode();
		global.save();
		for(int i = 0; i < modeProps.length; i++)
		{
			modeProps[i].save();
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JComboBox defaultMode;
	private JTextField undoCount;
	private ModeProperties global;
	private ModeProperties[] modeProps;
	private ModeProperties current;
	private Box captionBox;
	private JComboBox mode;
	private JCheckBox useDefaults;
	private JTextField filenameGlob;
	private JTextField firstlineGlob;
	private JTextField noWordSep;
	private JComboBox folding;
	private JTextField collapseFolds;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	private JCheckBox deepIndent;
	//}}}
	//{{{ saveMode() method
	private void saveMode()
	{
		current.useDefaults = useDefaults.isSelected();
		current.filenameGlob = filenameGlob.getText();
		current.firstlineGlob = firstlineGlob.getText();
		current.noWordSep = noWordSep.getText();
		current.folding = (String)folding.getSelectedItem();
		current.collapseFolds = collapseFolds.getText();
		current.wrap = (String)wrap.getSelectedItem();
		current.maxLineLen = (String)maxLineLen.getSelectedItem();
		current.tabSize = (String)tabSize.getSelectedItem();
		current.indentSize = (String)indentSize.getSelectedItem();
		current.noTabs = noTabs.isSelected();
		current.deepIndent = deepIndent.isSelected();
	} //}}}
	//{{{ selectMode() method
	private void selectMode()
	{
		int index = mode.getSelectedIndex();
		current = (index == 0 ? global : modeProps[index - 1]);
		current.edited = true;
		current.load();
		captionBox.removeAll();
		captionBox.add(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""options.editing.caption-""
			+ (index == 0 ? ""0"" : ""1""))));
		useDefaults.setSelected(current.useDefaults);
		filenameGlob.setText(current.filenameGlob);
		firstlineGlob.setText(current.firstlineGlob);
		noWordSep.setText(current.noWordSep);
		folding.setSelectedItem(current.folding);
		collapseFolds.setText(current.collapseFolds);
		wrap.setSelectedItem(current.wrap);
		maxLineLen.setSelectedItem(current.maxLineLen);
		tabSize.setSelectedItem(current.tabSize);
		indentSize.setSelectedItem(current.indentSize);
		noTabs.setSelected(current.noTabs);
		deepIndent.setSelected(current.deepIndent);
		updateEnabled();
		revalidate();
	} //}}}
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		boolean enabled;
		if(current == global)
		{
			enabled = true;
			useDefaults.setEnabled(false);
			filenameGlob.setEnabled(false);
			firstlineGlob.setEnabled(false);
		}
		else
		{
			enabled = !modeProps[mode.getSelectedIndex() - 1]
				.useDefaults;
			useDefaults.setEnabled(true);
			filenameGlob.setEnabled(enabled);
			firstlineGlob.setEnabled(enabled);
		}
		noWordSep.setEnabled(enabled);
		folding.setEnabled(enabled);
		collapseFolds.setEnabled(enabled);
		wrap.setEnabled(enabled);
		maxLineLen.setEnabled(enabled);
		tabSize.setEnabled(enabled);
		indentSize.setEnabled(enabled);
		noTabs.setEnabled(enabled);
		deepIndent.setEnabled(enabled);
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == mode)
			{
				saveMode();
				selectMode();
			}
			else if(source == useDefaults)
			{
				modeProps[mode.getSelectedIndex() - 1].useDefaults =
					useDefaults.isSelected();
				updateEnabled();
			}
			else if(source == wrap)
			{
				if(!wrap.getSelectedItem().equals(""none""))
				{
					if(maxLineLen.getSelectedItem()
						.equals(""0""))
					{
						maxLineLen.setSelectedItem(""80"");
					}
				}
			}
			else if(source == maxLineLen)
			{
				if(!wrap.getSelectedItem().equals(""none""))
				{
					if(maxLineLen.getSelectedItem()
						.equals(""0""))
					{
						wrap.setSelectedItem(""none"");
					}
				}
			}
		}
	} //}}}
	//{{{ ModeProperties class
	class ModeProperties
	{
		//{{{ Instance variables
		Mode mode;
		boolean edited;
		boolean loaded;
		boolean useDefaults;
		String filenameGlob;
		String firstlineGlob;
		String noWordSep;
		String folding;
		String collapseFolds;
		String wrap;
		String maxLineLen;
		String tabSize;
		String indentSize;
		boolean noTabs;
		boolean deepIndent;
		//}}}
		//{{{ ModeProperties constructor
		ModeProperties()
		{
		} //}}}
		//{{{ ModeProperties constructor
		ModeProperties(Mode mode)
		{
			this.mode = mode;
		} //}}}
		//{{{ load() method
		void load()
		{
			if(loaded)
				return;
			loaded = true;
			if(mode != null)
			{
				mode.loadIfNecessary();
				useDefaults = !jEdit.getBooleanProperty(""mode.""
					+ mode.getName() + "".customSettings"");
				filenameGlob = (String)mode.getProperty(""filenameGlob"");
				firstlineGlob = (String)mode.getProperty(""firstlineGlob"");
				noWordSep = (String)mode.getProperty(""noWordSep"");
				folding = mode.getProperty(""folding"").toString();
				collapseFolds = mode.getProperty(""collapseFolds"").toString();
				wrap = mode.getProperty(""wrap"").toString();
				maxLineLen = mode.getProperty(""maxLineLen"").toString();
				tabSize = mode.getProperty(""tabSize"").toString();
				indentSize = mode.getProperty(""indentSize"").toString();
				noTabs = mode.getBooleanProperty(""noTabs"");
				deepIndent = mode.getBooleanProperty(""deepIndent"");
			}
			else
			{
				noWordSep = jEdit.getProperty(""buffer.noWordSep"");
				folding = jEdit.getProperty(""buffer.folding"");
				collapseFolds = jEdit.getProperty(""buffer.collapseFolds"");
				wrap = jEdit.getProperty(""buffer.wrap"");
				maxLineLen = jEdit.getProperty(""buffer.maxLineLen"");
				tabSize = jEdit.getProperty(""buffer.tabSize"");
				indentSize = jEdit.getProperty(""buffer.indentSize"");
				noTabs = jEdit.getBooleanProperty(""buffer.noTabs"");
				deepIndent = jEdit.getBooleanProperty(""buffer.deepIndent"");
			}
		} //}}}
		//{{{ save() method
		void save()
		{
			// don't do anything if the user didn't change
			// any settings
			if(!edited)
				return;
			String prefix;
			if(mode != null)
			{
				prefix = ""mode."" + mode.getName() + ""."";
				jEdit.setBooleanProperty(prefix + ""customSettings"",!useDefaults);
				// need to call Mode.init() if the file name or first line
				// globs change
				String oldFilenameGlob = (String)mode.getProperty(""filenameGlob"");
				String oldFirstlineGlob = (String)mode.getProperty(""firstlineGlob"");
				if(useDefaults)
				{
					jEdit.resetProperty(prefix + ""filenameGlob"");
					jEdit.resetProperty(prefix + ""firstlineGlob"");
					jEdit.resetProperty(prefix + ""noWordSep"");
					jEdit.resetProperty(prefix + ""folding"");
					jEdit.resetProperty(prefix + ""collapseFolds"");
					jEdit.resetProperty(prefix + ""wrap"");
					jEdit.resetProperty(prefix + ""maxLineLen"");
					jEdit.resetProperty(prefix + ""tabSize"");
					jEdit.resetProperty(prefix + ""indentSize"");
					jEdit.resetProperty(prefix + ""noTabs"");
					jEdit.resetProperty(prefix + ""deepIndent"");
					if(!(MiscUtilities.objectsEqual(oldFilenameGlob,
						(String)mode.getProperty(""filenameGlob""))
						&& MiscUtilities.objectsEqual(oldFirstlineGlob,
						(String)mode.getProperty(""firstlineGlob""))))
					{
						mode.init();
					}
					return;
				}
				else
				{
					jEdit.setProperty(prefix + ""filenameGlob"",filenameGlob);
					jEdit.setProperty(prefix + ""firstlineGlob"",firstlineGlob);
					if(!(MiscUtilities.objectsEqual(oldFilenameGlob,
						filenameGlob)
						&& MiscUtilities.objectsEqual(oldFirstlineGlob,
						firstlineGlob)))
					{
						mode.init();
					}
				}
			}
			else
			{
				prefix = ""buffer."";
			}
			jEdit.setProperty(prefix + ""noWordSep"",noWordSep);
			jEdit.setProperty(prefix + ""folding"",folding);
			jEdit.setProperty(prefix + ""collapseFolds"",collapseFolds);
			jEdit.setProperty(prefix + ""wrap"",wrap);
			jEdit.setProperty(prefix + ""maxLineLen"",maxLineLen);
			jEdit.setProperty(prefix + ""tabSize"",tabSize);
			jEdit.setProperty(prefix + ""indentSize"",indentSize);
			jEdit.setBooleanProperty(prefix + ""noTabs"",noTabs);
			jEdit.setBooleanProperty(prefix + ""deepIndent"",deepIndent);
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.options.FirewallOptionPane,"/*
 * FirewallOptionPane.java - Firewall options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999 Dirk Moebius
 * Portions copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
 //{{{ Imports
import java.awt.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
//}}}
public class FirewallOptionPane extends AbstractOptionPane {
	//{{{ FirewallOptionPane constructor
	public FirewallOptionPane()
	{
		super(""firewall"");
	} //}}}
	//{{{ _init() method
	public void _init()
	{
		// checkbox
		addComponent(httpEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.http.enabled"")));
		// proxy host
		addComponent(jEdit.getProperty(""options.firewall.http.host""), 
			httpHost = new JTextField(jEdit.getProperty(""firewall.host""), 15));
		// proxy port
		addComponent(jEdit.getProperty(""options.firewall.http.port""), 
			httpPort = new JTextField(jEdit.getProperty(""firewall.port""), 15));
		// proxy username
		addComponent(jEdit.getProperty(""options.firewall.http.user""),
			httpUser = new JTextField(jEdit.getProperty(""firewall.user""), 15));
		// proxy password
		addComponent(jEdit.getProperty(""options.firewall.http.password""),
			httpPass = new JPasswordField(jEdit.getProperty(""firewall.password""), 15));
		// no proxy for
		addComponent(jEdit.getProperty(""options.firewall.http.nonProxy""),
			httpNonProxy = new JTextField(jEdit.getProperty(""firewall.nonProxyHosts""), 15));
		boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
		httpEnabled.setSelected(enabled);
		httpHost.setEnabled(enabled);
		httpPort.setEnabled(enabled);
		httpUser.setEnabled(enabled);
		httpPass.setEnabled(enabled);
		httpNonProxy.setEnabled(enabled);
		httpEnabled.addActionListener(new ActionHandler());
		// checkbox
		addComponent(socksEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.socks.enabled"")));
		// proxy host
		addComponent(jEdit.getProperty(""options.firewall.socks.host""), 
			socksHost = new JTextField(jEdit.getProperty(""firewall.socks.host""), 15));
		// proxy port
		addComponent(jEdit.getProperty(""options.firewall.socks.port""), 
			socksPort = new JTextField(jEdit.getProperty(""firewall.socks.port""), 15));
		enabled = jEdit.getBooleanProperty(""firewall.socks.enabled"");
		socksEnabled.setSelected(enabled);
		socksHost.setEnabled(enabled);
		socksPort.setEnabled(enabled);
		socksEnabled.addActionListener(new ActionHandler());
	} //}}}
	//{{{ _save() method
	public void _save() {
		jEdit.setBooleanProperty(""firewall.enabled"", httpEnabled.isSelected());
		jEdit.setProperty(""firewall.host"", httpHost.getText());
		jEdit.setProperty(""firewall.port"", httpPort.getText());
		jEdit.setProperty(""firewall.user"", httpUser.getText());
		jEdit.setProperty(""firewall.password"", new String(httpPass.getPassword()));
		jEdit.setProperty(""firewall.nonProxyHosts"", httpNonProxy.getText());
		jEdit.setBooleanProperty(""firewall.socks.enabled"", socksEnabled.isSelected());
		jEdit.setProperty(""firewall.socks.host"", socksHost.getText());
		jEdit.setProperty(""firewall.socks.port"", socksPort.getText());
	} //}}}
	//{{{ Private members
	private JCheckBox httpEnabled;
	private JTextField httpHost;
	private JTextField httpPort;
	private JTextField httpUser;
	private JPasswordField httpPass;
	private JTextField httpNonProxy;
	private JCheckBox socksEnabled;
	private JTextField socksHost;
	private JTextField socksPort;
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			httpHost.setEnabled(httpEnabled.isSelected());
			httpPort.setEnabled(httpEnabled.isSelected());
			httpUser.setEnabled(httpEnabled.isSelected());
			httpPass.setEnabled(httpEnabled.isSelected());
			httpNonProxy.setEnabled(httpEnabled.isSelected());
			socksHost.setEnabled(socksEnabled.isSelected());
			socksPort.setEnabled(socksEnabled.isSelected());
		}
	}
}
"
org.gjt.sp.jedit.options.GeneralOptionPane,"/*
 * GeneralOptionPane.java - General options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.util.Arrays;
import org.gjt.sp.jedit.*;
//}}}
public class GeneralOptionPane extends AbstractOptionPane
{
	//{{{ GeneralOptionPane constructor
	public GeneralOptionPane()
	{
		super(""general"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* Line separator */
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = jEdit.getProperty(""buffer.lineSeparator"",
			System.getProperty(""line.separator""));
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		addComponent(jEdit.getProperty(""options.general.lineSeparator""),
			lineSeparator);
		/* Default file encoding */
		String[] encodings = MiscUtilities.getEncodings();
		Arrays.sort(encodings,new MiscUtilities.StringICaseCompare());
		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding"")));
		addComponent(jEdit.getProperty(""options.general.encoding""),encoding);
		/* Auto detect encoding */
		encodingAutodetect = new JCheckBox(jEdit.getProperty(
			""options.general.encodingAutodetect""));
		encodingAutodetect.setSelected(jEdit.getBooleanProperty(""buffer.encodingAutodetect""));
		addComponent(encodingAutodetect);
		/* Check mod status on focus */
		String[] modCheckOptions = {
			jEdit.getProperty(""options.general.checkModStatus.nothing""),
			jEdit.getProperty(""options.general.checkModStatus.prompt""),
			jEdit.getProperty(""options.general.checkModStatus.reload"")
		};
		checkModStatus = new JComboBox(modCheckOptions);
		if(jEdit.getBooleanProperty(""autoReload""))
			checkModStatus.setSelectedIndex(2);
		else if(jEdit.getBooleanProperty(""autoReloadDialog""))
			checkModStatus.setSelectedIndex(1);
		else
			checkModStatus.setSelectedIndex(0);
		addComponent(jEdit.getProperty(""options.general.checkModStatus""),
			checkModStatus);
		/* Recent file list size */
		recentFiles = new JTextField(jEdit.getProperty(
			""options.general.recentFiles""));
		recentFiles.setText(jEdit.getProperty(""recentFiles""));
		addComponent(jEdit.getProperty(""options.general.recentFiles""),
			recentFiles);
		/* Sort recent file list */
		sortRecent = new JCheckBox(jEdit.getProperty(
			""options.general.sortRecent""));
		sortRecent.setSelected(jEdit.getBooleanProperty(""sortRecent""));
		addComponent(sortRecent);
		/* Save caret positions */
		saveCaret = new JCheckBox(jEdit.getProperty(
			""options.general.saveCaret""));
		saveCaret.setSelected(jEdit.getBooleanProperty(""saveCaret""));
		addComponent(saveCaret);
		/* Persistent markers */
		persistentMarkers = new JCheckBox(jEdit.getProperty(
			""options.general.persistentMarkers""));
		persistentMarkers.setSelected(jEdit.getBooleanProperty(
			""persistentMarkers""));
		addComponent(persistentMarkers);
		/* Session management */
		restore = new JCheckBox(jEdit.getProperty(
			""options.general.restore""));
		restore.setSelected(jEdit.getBooleanProperty(""restore""));
		restore.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				restoreCLI.setEnabled(restore.isSelected());
			}
		});
		addComponent(restore);
		restoreCLI = new JCheckBox(jEdit.getProperty(
			""options.general.restore.cli""));
		restoreCLI.setSelected(jEdit.getBooleanProperty(""restore.cli""));
		restoreCLI.setEnabled(restore.isSelected());
		addComponent(restoreCLI);
		/* Sort buffers */
		sortBuffers = new JCheckBox(jEdit.getProperty(
			""options.general.sortBuffers""));
		sortBuffers.setSelected(jEdit.getBooleanProperty(""sortBuffers""));
		sortBuffers.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				sortByName.setEnabled(sortBuffers.isSelected());
			}
		});
		addComponent(sortBuffers);
		/* Sort buffers by names */
		sortByName = new JCheckBox(jEdit.getProperty(
			""options.general.sortByName""));
		sortByName.setSelected(jEdit.getBooleanProperty(""sortByName""));
		sortByName.setEnabled(sortBuffers.isSelected());
		addComponent(sortByName);
		/* Two-stage save */
		twoStageSave = new JCheckBox(jEdit.getProperty(
			""options.general.twoStageSave""));
		twoStageSave.setSelected(jEdit.getBooleanProperty(
			""twoStageSave""));
		addComponent(twoStageSave);
		/* Confirm save all */
		confirmSaveAll = new JCheckBox(jEdit.getProperty(
			""options.general.confirmSaveAll""));
		confirmSaveAll.setSelected(jEdit.getBooleanProperty(
			""confirmSaveAll""));
		addComponent(confirmSaveAll);
		/* Strip trailing EOL */
		stripTrailingEOL = new JCheckBox(jEdit.getProperty(
			""options.general.stripTrailingEOL""));
		stripTrailingEOL.setSelected(jEdit.getBooleanProperty(""stripTrailingEOL""));
		addComponent(stripTrailingEOL);
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		String lineSep = null;
		switch(lineSeparator.getSelectedIndex())
		{
		case 0:
			lineSep = ""\n"";
			break;
		case 1:
			lineSep = ""\r\n"";
			break;
		case 2:
			lineSep = ""\r"";
			break;
		}
		jEdit.setProperty(""buffer.lineSeparator"",lineSep);
		jEdit.setProperty(""buffer.encoding"",(String)
			encoding.getSelectedItem());
		jEdit.setBooleanProperty(""buffer.encodingAutodetect"",
			encodingAutodetect.isSelected());
		switch(checkModStatus.getSelectedIndex())
		{
		case 0:
			jEdit.setBooleanProperty(""autoReloadDialog"",false);
			jEdit.setBooleanProperty(""autoReload"",false);
			break;
		case 1:
			jEdit.setBooleanProperty(""autoReloadDialog"",true);
			jEdit.setBooleanProperty(""autoReload"",false);
			break;
		case 2:
			jEdit.setBooleanProperty(""autoReloadDialog"",true);
			jEdit.setBooleanProperty(""autoReload"",true);
			break;
		}
		jEdit.setProperty(""recentFiles"",recentFiles.getText());
		jEdit.setBooleanProperty(""sortRecent"",sortRecent.isSelected());
		jEdit.setBooleanProperty(""saveCaret"",saveCaret.isSelected());
		jEdit.setBooleanProperty(""persistentMarkers"",
			persistentMarkers.isSelected());
		jEdit.setBooleanProperty(""restore"",restore.isSelected());
		jEdit.setBooleanProperty(""restore.cli"",restoreCLI.isSelected());
		jEdit.setBooleanProperty(""sortBuffers"",sortBuffers.isSelected());
		jEdit.setBooleanProperty(""sortByName"",sortByName.isSelected());
		jEdit.setBooleanProperty(""twoStageSave"",twoStageSave.isSelected());
		jEdit.setBooleanProperty(""confirmSaveAll"",confirmSaveAll.isSelected());
		jEdit.setBooleanProperty(""stripTrailingEOL"", stripTrailingEOL.isSelected());
	} //}}}
	//{{{ Private members
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JCheckBox encodingAutodetect;
	private JComboBox checkModStatus;
	private JTextField recentFiles;
	private JCheckBox saveCaret;
	private JCheckBox sortRecent;
	private JCheckBox persistentMarkers;
	private JCheckBox restore;
	private JCheckBox restoreCLI;
	private JCheckBox sortBuffers;
	private JCheckBox sortByName;
	private JCheckBox twoStageSave;
	private JCheckBox confirmSaveAll;
	private JCheckBox stripTrailingEOL;
	//}}}
}
"
org.gjt.sp.jedit.options.GlobalOptions,"/*
 * GlobalOptions.java - Global options dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import java.awt.Dialog;
import java.awt.Frame;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class GlobalOptions extends OptionsDialog
{
	//{{{ GlobalOptions constructor
	public GlobalOptions(Frame frame)
	{
		super(frame,""options"",jEdit.getProperty(""options.last""));
	} //}}}
	//{{{ GlobalOptions constructor
	public GlobalOptions(Frame frame, String pane)
	{
		super(frame,""options"",pane);
	} //}}}
	//{{{ GlobalOptions constructor
	public GlobalOptions(Dialog dialog)
	{
		super(dialog,""options"",jEdit.getProperty(""options.last""));
	} //}}}
	//{{{ GlobalOptions constructor
	public GlobalOptions(Dialog dialog, String pane)
	{
		super(dialog,""options"",pane);
	} //}}}
	//{{{ createOptionTreeModel() method
	protected OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();
		// initialize the jEdit branch of the options tree
		jEditGroup = new OptionGroup(""jedit"");
		jEditGroup.addOptionPane(""abbrevs"");
		jEditGroup.addOptionPane(""appearance"");
		jEditGroup.addOptionPane(""auto-back"");
		jEditGroup.addOptionPane(""context"");
		jEditGroup.addOptionPane(""docking"");
		jEditGroup.addOptionPane(""editing"");
		jEditGroup.addOptionPane(""general"");
		jEditGroup.addOptionPane(""gutter"");
		jEditGroup.addOptionPane(""mouse"");
		jEditGroup.addOptionPane(""print"");
		jEditGroup.addOptionPane(""plugin-manager"");
		jEditGroup.addOptionPane(""firewall"");
		jEditGroup.addOptionPane(""shortcuts"");
		jEditGroup.addOptionPane(""status"");
		jEditGroup.addOptionPane(""syntax"");
		jEditGroup.addOptionPane(""textarea"");
		jEditGroup.addOptionPane(""toolbar"");
		jEditGroup.addOptionPane(""view"");
		rootGroup.addOptionGroup(jEditGroup);
		browserGroup = new OptionGroup(""browser"");
		browserGroup.addOptionPane(""browser.general"");
		browserGroup.addOptionPane(""browser.colors"");
		rootGroup.addOptionGroup(browserGroup);
		return paneTreeModel;
	} //}}}
	//{{{ getDefaultGroup() method
	protected OptionGroup getDefaultGroup()
	{
		return null;
	} //}}}
	//{{{ Private members
	private OptionGroup jEditGroup;
	private OptionGroup browserGroup;
	//}}}
}
"
org.gjt.sp.jedit.options.GutterOptionPane,"/*
 * GutterOptionPane.java - Gutter options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000 mike dillon
 * Portions copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
//}}}
public class GutterOptionPane extends AbstractOptionPane
{
	//{{{ GutterOptionPane constructor
	public GutterOptionPane()
	{
		super(""gutter"");
	} //}}}
	//{{{ _init() method
	public void _init()
	{
		/* Line numbering */
		lineNumbersEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.lineNumbers""));
		lineNumbersEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		addComponent(lineNumbersEnabled);
		/* Text font */
		gutterFont = new FontSelector(
			jEdit.getFontProperty(""view.gutter.font"",
			new Font(""Monospaced"",Font.PLAIN,10)));
		addComponent(jEdit.getProperty(""options.gutter.font""),gutterFont);
		/* Text color */
		addComponent(jEdit.getProperty(""options.gutter.foreground""),
			gutterForeground = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.fgColor"")),
			GridBagConstraints.VERTICAL);
		/* Background color */
		addComponent(jEdit.getProperty(""options.gutter.background""),
			gutterBackground = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.bgColor"")),
			GridBagConstraints.VERTICAL);
		/* Border width */
		/* gutterBorderWidth = new JTextField(jEdit.getProperty(
			""view.gutter.borderWidth""));
		addComponent(jEdit.getProperty(""options.gutter.borderWidth""),
			gutterBorderWidth); */
		/* Number alignment */
		/* String[] alignments = new String[] {
			""Left"", ""Center"", ""Right""
		};
		gutterNumberAlignment = new JComboBox(alignments);
		String alignment = jEdit.getProperty(""view.gutter.numberAlignment"");
		if(""right"".equals(alignment))
			gutterNumberAlignment.setSelectedIndex(2);
		else if(""center"".equals(alignment))
			gutterNumberAlignment.setSelectedIndex(1);
		else
			gutterNumberAlignment.setSelectedIndex(0);
		addComponent(jEdit.getProperty(""options.gutter.numberAlignment""),
			gutterNumberAlignment); */
		/* Current line highlight */
		gutterCurrentLineHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.currentLineHighlight""));
		gutterCurrentLineHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		addComponent(gutterCurrentLineHighlightEnabled,
			gutterCurrentLineHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.currentLineColor"")),
			GridBagConstraints.VERTICAL);
		/* Highlight interval and color */
		gutterHighlightInterval = new JTextField(jEdit.getProperty(
			""view.gutter.highlightInterval""),3);
		Box gutterHighlightBox = new Box(BoxLayout.X_AXIS);
		gutterHighlightBox.add(new JLabel(jEdit.getProperty(
			""options.gutter.interval-1"")));
		gutterHighlightBox.add(Box.createHorizontalStrut(3));
		gutterHighlightBox.add(gutterHighlightInterval);
		gutterHighlightBox.add(Box.createHorizontalStrut(3));
		gutterHighlightBox.add(new JLabel(jEdit.getProperty(
			""options.gutter.interval-2"")));
		gutterHighlightBox.add(Box.createHorizontalStrut(12));
		addComponent(gutterHighlightBox,gutterHighlightColor
			= new ColorWellButton(jEdit.getColorProperty(
			""view.gutter.highlightColor"")),
			GridBagConstraints.VERTICAL);
		/* Structure highlight */
		gutterStructureHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.structureHighlight""));
		gutterStructureHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.structureHighlight""));
		addComponent(gutterStructureHighlightEnabled,
			gutterStructureHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.structureHighlightColor"")),
			GridBagConstraints.VERTICAL);
		/* Marker highlight */
		gutterMarkerHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.markerHighlight""));
		gutterMarkerHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		addComponent(gutterMarkerHighlightEnabled,
			gutterMarkerHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.markerColor"")),
			GridBagConstraints.VERTICAL);
		/* Fold marker color */
		addComponent(jEdit.getProperty(""options.gutter.foldColor""),
			gutterFoldMarkers = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.foldColor"")),
			GridBagConstraints.VERTICAL);
		/* Focused border color */
		addComponent(jEdit.getProperty(""options.gutter.focusBorderColor""),
			gutterFocusBorder = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.focusBorderColor"")),
			GridBagConstraints.VERTICAL);
		/* unfocused border color */
		addComponent(jEdit.getProperty(""options.gutter.noFocusBorderColor""),
			gutterNoFocusBorder = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor"")),
			GridBagConstraints.VERTICAL);
	} //}}}
	//{{{ _save() method
	public void _save()
	{
		jEdit.setBooleanProperty(""view.gutter.lineNumbers"", lineNumbersEnabled
			.isSelected());
		jEdit.setFontProperty(""view.gutter.font"",gutterFont.getFont());
		jEdit.setColorProperty(""view.gutter.fgColor"",gutterForeground
			.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.bgColor"",gutterBackground
			.getSelectedColor());
		/* jEdit.setProperty(""view.gutter.borderWidth"",
			gutterBorderWidth.getText());
		String alignment = null;
		switch(gutterNumberAlignment.getSelectedIndex())
		{
		case 2:
			alignment = ""right"";
			break;
		case 1:
			alignment = ""center"";
			break;
		case 0: default:
			alignment = ""left"";
		}
		jEdit.setProperty(""view.gutter.numberAlignment"", alignment); */
		jEdit.setBooleanProperty(""view.gutter.highlightCurrentLine"",
			gutterCurrentLineHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.currentLineColor"",
			gutterCurrentLineHighlight.getSelectedColor());
		jEdit.setProperty(""view.gutter.highlightInterval"",
			gutterHighlightInterval.getText());
		jEdit.setColorProperty(""view.gutter.highlightColor"",
			gutterHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.gutter.structureHighlight"",
			gutterStructureHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.structureHighlightColor"",
			gutterStructureHighlight.getSelectedColor());
		jEdit.setBooleanProperty(""view.gutter.markerHighlight"",
			gutterMarkerHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.markerColor"",
			gutterMarkerHighlight.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.foldColor"",
			gutterFoldMarkers.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.focusBorderColor"",
			gutterFocusBorder.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.noFocusBorderColor"",
			gutterNoFocusBorder.getSelectedColor());
	} //}}}
	//{{{ Private members
	private FontSelector gutterFont;
	private ColorWellButton gutterForeground;
	private ColorWellButton gutterBackground;
	private JTextField gutterHighlightInterval;
	private ColorWellButton gutterHighlightColor;
	private JCheckBox lineNumbersEnabled;
	private JCheckBox gutterCurrentLineHighlightEnabled;
	private ColorWellButton gutterCurrentLineHighlight;
	private JCheckBox gutterStructureHighlightEnabled;
	private ColorWellButton gutterStructureHighlight;
	private JCheckBox gutterMarkerHighlightEnabled;
	private ColorWellButton gutterMarkerHighlight;
	private ColorWellButton gutterFoldMarkers;
	private ColorWellButton gutterFocusBorder;
	private ColorWellButton gutterNoFocusBorder;
	//}}}
}
"
org.gjt.sp.jedit.options.MouseOptionPane,"/*
 * MouseOptionPane.java - Editor window options
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class MouseOptionPane extends AbstractOptionPane
{
	//{{{ MouseOptionPane constructor
	public MouseOptionPane()
	{
		super(""mouse"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* Text drag and drop */
		dragAndDrop = new JCheckBox(jEdit.getProperty(
			""options.mouse.dragAndDrop""));
		dragAndDrop.setSelected(jEdit.getBooleanProperty(
			""view.dragAndDrop""));
		addComponent(dragAndDrop);
		/* Non word character selection behavior */
		joinNonWordChars = new JCheckBox(jEdit.getProperty(
			""options.mouse.joinNonWordChars""));
		joinNonWordChars.setSelected(jEdit.getBooleanProperty(
			""view.joinNonWordChars""));
		addComponent(joinNonWordChars);
		/* Middle mouse button click pastes % register */
		middleMousePaste = new JCheckBox(jEdit.getProperty(""options.mouse""
			+ "".middleMousePaste""));
		middleMousePaste.setSelected(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
		addComponent(middleMousePaste);
		/* Gutter mouse actions */
		int c = clickActionKeys.length;
		String[] clickActionNames = new String[c];
		for(int i = 0; i < c; i++)
		{
			clickActionNames[i] = jEdit.getProperty(
				""options.mouse.gutter.""+clickActionKeys[i]);
		}
		c = clickModifierKeys.length;
		String[] clickModifierNames = new String[c];
		for(int i = 0; i < c; i++)
		{
			clickModifierNames[i] = jEdit.getProperty(
				""options.mouse.gutter.""+clickModifierKeys[i]);
		}
		gutterClickActions = new JComboBox[c];
		for(int i = 0; i < c; i++)
		{
			JComboBox cb = new JComboBox(clickActionNames);
			gutterClickActions[i] = cb;
			String val = jEdit.getProperty(""view.gutter.""+clickModifierKeys[i]);
			for(int j = 0; j < clickActionKeys.length; j++)
			{
				if(val.equals(clickActionKeys[j]))
				{
					cb.setSelectedIndex(j);
				}
			}
			addComponent(clickModifierNames[i],cb);
		}
	} //}}}
	//{{{ _save() method
	public void _save()
	{
		jEdit.setBooleanProperty(""view.dragAndDrop"",dragAndDrop.isSelected());
		jEdit.setBooleanProperty(""view.joinNonWordChars"",joinNonWordChars.isSelected());
		jEdit.setBooleanProperty(""view.middleMousePaste"",
			middleMousePaste.isSelected());
		int c = clickModifierKeys.length;
		for(int i = 0; i < c; i++)
		{
			int idx = gutterClickActions[i].getSelectedIndex();
			jEdit.setProperty(""view.gutter.""+clickModifierKeys[i],
				clickActionKeys[idx]);
		}
	} //}}}
	//{{{ Private members
	private JCheckBox dragAndDrop;
	private JCheckBox middleMousePaste;
	private JCheckBox joinNonWordChars;
	private JComboBox[] gutterClickActions;
	// simplified these settings a little...
	private static final String[] clickActionKeys = new String[] {
		""toggle-fold"",
		""toggle-fold-fully""
	};
	private static final String[] clickModifierKeys = new String[] {
		""foldClick"",
		""SfoldClick""
	}; //}}}
}
"
org.gjt.sp.jedit.options.PluginManagerOptionPane,"/*
 * PluginManagerOptionPane.java - Plugin options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.pluginmgr.*;
import org.gjt.sp.util.*;
public class PluginManagerOptionPane extends AbstractOptionPane
{
	//{{{ Constructor
	public PluginManagerOptionPane()
	{
		super(""plugin-manager"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		setLayout(new BorderLayout());
		locationLabel = new JLabel(jEdit.getProperty(
			""options.plugin-manager.location""));
		mirrorLabel = new JLabel(jEdit.getProperty(
			""options.plugin-manager.mirror""));
		if(jEdit.getSettingsDirectory() != null)
		{
			settingsDir = new JRadioButton(jEdit.getProperty(
				""options.plugin-manager.settings-dir""));
			settingsDir.setToolTipText(MiscUtilities.constructPath(
				jEdit.getSettingsDirectory(),""jars""));
		}
		appDir = new JRadioButton(jEdit.getProperty(
			""options.plugin-manager.app-dir""));
		appDir.setToolTipText(MiscUtilities.constructPath(
			jEdit.getJEditHome(),""jars""));
		miraList = new JList(miraModel = new MirrorModel());
		miraList.setSelectionModel(new SingleSelectionModel());
		/* Download mirror */
		add(BorderLayout.NORTH,mirrorLabel);
		add(BorderLayout.CENTER,new JScrollPane(miraList));
		JPanel buttonPanel = new JPanel();
		buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.Y_AXIS));
		buttonPanel.add(Box.createVerticalStrut(6));
		/* Update mirror list */
		JButton updateMirrors = new JButton(jEdit.getProperty(
			""options.plugin-manager.updateMirrors""));
		updateMirrors.addActionListener(new ActionHandler());
		buttonPanel.add(updateMirrors);
		buttonPanel.add(Box.createVerticalStrut(6));
		/* Download source */
		downloadSource = new JCheckBox(jEdit.getProperty(
			""options.plugin-manager.downloadSource""));
		downloadSource.setSelected(jEdit.getBooleanProperty(""plugin-manager.downloadSource""));
		buttonPanel.add(downloadSource);
		buttonPanel.add(Box.createVerticalStrut(6));
		/* Delete downloaded files */
		deleteDownloads = new JCheckBox(jEdit.getProperty(
			""options.plugin-manager.deleteDownloads""));
		deleteDownloads.setSelected(jEdit.getBooleanProperty(""plugin-manager.deleteDownloads""));
		buttonPanel.add(deleteDownloads);
		buttonPanel.add(Box.createVerticalStrut(6));
		/* Install location */
		locGrp = new ButtonGroup();
		if(jEdit.getSettingsDirectory() != null)
			locGrp.add(settingsDir);
		locGrp.add(appDir);
		JPanel locPanel = new JPanel();
		locPanel.setBorder(new EmptyBorder(3,12,0,0));
		locPanel.setLayout(new BoxLayout(locPanel,BoxLayout.Y_AXIS));
		if(jEdit.getSettingsDirectory() != null)
		{
			locPanel.add(settingsDir);
			locPanel.add(Box.createVerticalStrut(3));
		}
		locPanel.add(appDir);
		buttonPanel.add(locationLabel);
		buttonPanel.add(locPanel);
		buttonPanel.add(Box.createGlue());
		add(BorderLayout.SOUTH,buttonPanel);
		if (jEdit.getBooleanProperty(""plugin-manager.installUser"")
			&& jEdit.getSettingsDirectory() != null)
			settingsDir.setSelected(true);
		else
			appDir.setSelected(true);
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setBooleanProperty(""plugin-manager.installUser"",
			settingsDir != null && settingsDir.isSelected());
		jEdit.setBooleanProperty(""plugin-manager.downloadSource"",downloadSource.isSelected());
		jEdit.setBooleanProperty(""plugin-manager.deleteDownloads"",deleteDownloads.isSelected());
		if(miraList.getSelectedIndex() != -1)
		{
			String currentMirror = miraModel.getID(miraList.getSelectedIndex());
			String previousMirror = jEdit.getProperty(""plugin-manager.mirror.id"");
			if (!previousMirror.equals(currentMirror))
			{
				jEdit.setProperty(""plugin-manager.mirror.id"",currentMirror);
				// Insert code to update the plugin managers list here later
			}
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JLabel locationLabel;
	private JLabel mirrorLabel;
	private ButtonGroup locGrp;
	private JRadioButton settingsDir;
	private JRadioButton appDir;
	private JCheckBox downloadSource;
	private JCheckBox deleteDownloads;
	private MirrorModel miraModel;
	private JList miraList;
	//}}}
	//}}}
	//{{{ MirrorModel class
	class MirrorModel extends AbstractListModel
	{
		private ArrayList mirrors;
		public MirrorModel()
		{
			mirrors = new ArrayList();
		}
		public String getID(int index)
		{
			return ((MirrorList.Mirror)mirrors.get(index)).id;
		}
		public int getSize()
		{
			return mirrors.size();
		}
		public Object getElementAt(int index)
		{
			MirrorList.Mirror mirror = (MirrorList.Mirror)mirrors.get(index);
			if(mirror.id.equals(MirrorList.Mirror.NONE))
				return jEdit.getProperty(""options.plugin-manager.none"");
			else
				return mirror.continent+"": ""+mirror.description+"" (""+mirror.location+"")"";
		}
		public void setList(ArrayList mirrors)
		{
			this.mirrors = mirrors;
			fireContentsChanged(this,0,mirrors.size() - 1);
		}
	} //}}}
	//{{{ SingleSelectionModel class
	class SingleSelectionModel extends DefaultListSelectionModel
	{
		public SingleSelectionModel()
		{
			super();
			setSelectionMode(SINGLE_SELECTION);
		}
		public void removeSelectionInterval(int index0, int index1) {}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			VFSManager.runInWorkThread(new DownloadMirrorsThread());
		}
	} //}}}
	//{{{ DownloadMirrorsThread class
	class DownloadMirrorsThread extends WorkRequest
	{
		public void run()
		{
			setStatus(jEdit.getProperty(""options.plugin-manager.workthread""));
			setProgressMaximum(1);
			setProgressValue(0);
			final ArrayList mirrors = new ArrayList();
			try
			{
				mirrors.addAll(new MirrorList().mirrors);
			}
			catch (Exception ex)
			{
				Log.log(Log.ERROR,this,ex);
				GUIUtilities.error(PluginManagerOptionPane.this,
					""ioerror"",new String[] { ex.toString() });
			}
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					miraModel.setList(mirrors);
					String id = jEdit.getProperty(""plugin-manager.mirror.id"");
					int size = miraModel.getSize();
					for (int i=0; i < size; i++)
					{
						if (size == 1 || miraModel.getID(i).equals(id))
						{
							miraList.setSelectedIndex(i);
							break;
						}
					}
				}
			});
			setProgressValue(1);
		}
	} //}}}
}
"
org.gjt.sp.jedit.options.PluginOptions,"/*
 * PluginOptions.java - Plugin options dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import java.awt.Dialog;
import java.awt.Frame;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class PluginOptions extends OptionsDialog
{
	//{{{ PluginOptions constructor
	public PluginOptions(Frame frame)
	{
		super(frame,""plugin-options"",jEdit.getProperty(""plugin-options.last""));
	} //}}}
	//{{{ PluginOptions constructor
	public PluginOptions(Frame frame, String pane)
	{
		super(frame,""plugin-options"",pane);
	} //}}}
	//{{{ PluginOptions constructor
	public PluginOptions(Dialog dialog)
	{
		super(dialog,""plugin-options"",jEdit.getProperty(""plugin-options.last""));
	} //}}}
	//{{{ PluginOptions constructor
	public PluginOptions(Dialog dialog, String pane)
	{
		super(dialog,""plugin-options"",pane);
	} //}}}
	//{{{ createOptionTreeModel() method
	protected OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();
		// initialize the Plugins branch of the options tree
		pluginsGroup = new OptionGroup(""plugins"");
		pluginsGroup.setSort(true);
		// Query plugins for option panes
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin ep = plugins[i];
			if(ep instanceof EditPlugin.Broken)
				continue;
			String className = ep.getClassName();
			if(jEdit.getProperty(""plugin."" + className + "".activate"") == null)
			{
				// Old API
				try
				{
					ep.createOptionPanes(this);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR, ep,
						""Error creating option pane"");
					Log.log(Log.ERROR, ep, t);
				}
			}
			else
			{
				String optionPane = jEdit.getProperty(
					""plugin."" + className + "".option-pane"");
				if(optionPane != null)
					pluginsGroup.addOptionPane(optionPane);
				else
				{
					String options = jEdit.getProperty(
						""plugin."" + className
						+ "".option-group"");
					if(options != null)
					{
						pluginsGroup.addOptionGroup(
							new OptionGroup(
							""plugin."" + className,
							jEdit.getProperty(""plugin.""
							+ className + "".name""),
							options)
						);
					}
				}
			}
		}
		// only add the Plugins branch if there are OptionPanes
		if (pluginsGroup.getMemberCount() == 0)
			pluginsGroup.addOptionPane(new NoPluginsPane());
		rootGroup.addOptionGroup(pluginsGroup);
		return paneTreeModel;
	} //}}}
	//{{{ getDefaultGroup() method
	protected OptionGroup getDefaultGroup()
	{
		return pluginsGroup;
	} //}}}
	//{{{ Private members
	private OptionGroup pluginsGroup;
	//}}}
	//{{{ NoPluginsPane class
	static class NoPluginsPane extends AbstractOptionPane
	{
		public NoPluginsPane()
		{
			super(""no-plugins"");
		}
	} //}}}
}
"
org.gjt.sp.jedit.options.PrintOptionPane,"/*
 * PrintOptionPane.java - Printing options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;
//}}}
public class PrintOptionPane extends AbstractOptionPane
{
	//{{{ PrintOptionPane constructor
	public PrintOptionPane()
	{
		super(""print"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* Font */
		font = new FontSelector(jEdit.getFontProperty(""print.font""));
		addComponent(jEdit.getProperty(""options.print.font""),font);
		/* Header */
		printHeader = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".header""));
		printHeader.setSelected(jEdit.getBooleanProperty(""print.header""));
		addComponent(printHeader);
		/* Footer */
		printFooter = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".footer""));
		printFooter.setSelected(jEdit.getBooleanProperty(""print.footer""));
		addComponent(printFooter);
		/* Line numbering */
		printLineNumbers = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".lineNumbers""));
		printLineNumbers.setSelected(jEdit.getBooleanProperty(""print.lineNumbers""));
		addComponent(printLineNumbers);
		/* Color */
		color = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".color""));
		color.setSelected(jEdit.getBooleanProperty(""print.color""));
		addComponent(color);
		/* Tab size */
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(jEdit.getProperty(""print.tabSize""));
		addComponent(jEdit.getProperty(""options.print.tabSize""),tabSize);
		addSeparator(""options.print.workarounds"");
		/* Spacing workaround */
		glyphVector = new JCheckBox(jEdit.getProperty(
			""options.print.glyphVector""));
		glyphVector.setSelected(jEdit.getBooleanProperty(""print.glyphVector""));
		addComponent(glyphVector);
		/* Force 1.3 print dialog */
		force13 = new JCheckBox(jEdit.getProperty(
			""options.print.force13""));
		force13.setSelected(jEdit.getBooleanProperty(""print.force13""));
		if(OperatingSystem.hasJava14())
			addComponent(force13);
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setFontProperty(""print.font"",font.getFont());
		jEdit.setBooleanProperty(""print.header"",printHeader.isSelected());
		jEdit.setBooleanProperty(""print.footer"",printFooter.isSelected());
		jEdit.setBooleanProperty(""print.lineNumbers"",printLineNumbers.isSelected());
		jEdit.setBooleanProperty(""print.color"",color.isSelected());
		jEdit.setProperty(""print.tabSize"",(String)tabSize.getSelectedItem());
		jEdit.setBooleanProperty(""print.glyphVector"",glyphVector.isSelected());
		jEdit.setBooleanProperty(""print.force13"",force13.isSelected());
	} //}}}
	//{{{ Private members
	private FontSelector font;
	private JCheckBox printHeader;
	private JCheckBox printFooter;
	private JCheckBox printLineNumbers;
	private JCheckBox color;
	private JComboBox tabSize;
	private JCheckBox glyphVector;
	private JCheckBox force13;
	//}}}
}
"
org.gjt.sp.jedit.options.ShortcutsOptionPane,"/*
 * ShortcutsOptionPane.java - Shortcuts options panel
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 * Copyright (C) 2001 Dirk Moebius
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.GrabKeyDialog;
import org.gjt.sp.jedit.*;
/**
 * Key binding editor.
 * @author Slava Pestov
 * @version $Id: ShortcutsOptionPane.java,v 1.10 2004/05/12 20:44:17 spestov Exp $
 */
public class ShortcutsOptionPane extends AbstractOptionPane
{
	public ShortcutsOptionPane()
	{
		super(""shortcuts"");
	}
	// protected members
	protected void _init()
	{
		allBindings = new Vector();
		setLayout(new BorderLayout(12,12));
		initModels();
		selectModel = new JComboBox(models);
		selectModel.addActionListener(new ActionHandler());
		Box north = Box.createHorizontalBox();
		north.add(new JLabel(jEdit.getProperty(
			""options.shortcuts.select.label"")));
		north.add(Box.createHorizontalStrut(6));
		north.add(selectModel);
		keyTable = new JTable(currentModel);
		keyTable.getTableHeader().setReorderingAllowed(false);
		keyTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		keyTable.addMouseListener(new TableMouseHandler());
		Dimension d = keyTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(keyTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.NORTH,north);
		add(BorderLayout.CENTER,scroller);
	}
	protected void _save()
	{
		if(keyTable.getCellEditor() != null)
			keyTable.getCellEditor().stopCellEditing();
		Enumeration e = models.elements();
		while(e.hasMoreElements())
			((ShortcutsModel)e.nextElement()).save();
		Macros.loadMacros();
	}
	private void initModels()
	{
		models = new Vector();
		ActionSet[] actionSets = jEdit.getActionSets();
		for(int i = 0; i < actionSets.length; i++)
		{
			ActionSet actionSet = actionSets[i];
			if(actionSet.getActionCount() != 0)
			{
				String modelLabel = actionSet.getLabel();
				if(modelLabel == null)
				{
					System.err.println(""Empty action set: ""
						+ actionSet.getPluginJAR());
				}
				models.addElement(createModel(modelLabel,
					actionSet.getActionNames()));
			}
		}
		Collections.sort(models,new MiscUtilities.StringICaseCompare());
		currentModel = (ShortcutsModel)models.elementAt(0);
	}
	private ShortcutsModel createModel(String modelLabel, String[] actions)
	{
		Vector bindings = new Vector(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			String name = actions[i];
			String label = jEdit.getProperty(actions[i] + "".label"");
			// Skip certain actions this way
			if(label == null)
				continue;
			label = GUIUtilities.prettifyMenuLabel(label);
			addBindings(name,label,bindings);
		}
		return new ShortcutsModel(modelLabel,bindings);
	}
	private void addBindings(String name, String label, Vector bindings)
	{
		GrabKeyDialog.KeyBinding b[] = new GrabKeyDialog.KeyBinding[2];
		b[0] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut""));
		b[1] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut2""));
		bindings.addElement(b);
	}
	private GrabKeyDialog.KeyBinding createBinding(String name,
		String label, String shortcut)
	{
		if(shortcut != null && shortcut.length() == 0)
			shortcut = null;
		GrabKeyDialog.KeyBinding binding
			= new GrabKeyDialog.KeyBinding(name,label,shortcut,false);
		allBindings.addElement(binding);
		return binding;
	}
	// private members
	private JTable keyTable;
	private Vector models;
	private ShortcutsModel currentModel;
	private JComboBox selectModel;
	private Vector allBindings;
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(keyTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				currentModel.sort(0);
				break;
			case 1:
				currentModel.sort(1);
				break;
			case 2:
				currentModel.sort(2);
				break;
			}
		}
	}
	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = keyTable.getSelectedRow();
			int col = keyTable.getSelectedColumn();
			if(col != 0 && row != -1)
			{
				 GrabKeyDialog gkd = new GrabKeyDialog(
					GUIUtilities.getParentDialog(
					ShortcutsOptionPane.this),
					currentModel.getBindingAt(row,col-1),
					allBindings,null);
				if(gkd.isOK())
					currentModel.setValueAt(
						gkd.getShortcut(),row,col);
			}
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			ShortcutsModel newModel
				= (ShortcutsModel)selectModel.getSelectedItem();
			if(currentModel != newModel)
			{
				currentModel = newModel;
				keyTable.setModel(currentModel);
			}
		}
	}
	class ShortcutsModel extends AbstractTableModel
	{
		private Vector bindings;
		private String name;
		ShortcutsModel(String name, Vector bindings)
		{
			this.name = name;
			this.bindings = bindings;
			sort(0);
		}
		public void sort(int col)
		{
			MiscUtilities.quicksort(bindings,new KeyCompare(col));
			fireTableDataChanged();
		}
		public int getColumnCount()
		{
			return 3;
		}
		public int getRowCount()
		{
			return bindings.size();
		}
		public Object getValueAt(int row, int col)
		{
			switch(col)
			{
			case 0:
				return getBindingAt(row,0).label;
			case 1:
				return getBindingAt(row,0).shortcut;
			case 2:
				return getBindingAt(row,1).shortcut;
			default:
				return null;
			}
		}
		public void setValueAt(Object value, int row, int col)
		{
			if(col == 0)
				return;
			getBindingAt(row,col-1).shortcut = (String)value;
			// redraw the whole table because a second shortcut
			// might have changed, too
			fireTableDataChanged();
		}
		public String getColumnName(int index)
		{
			switch(index)
			{
			case 0:
				return jEdit.getProperty(""options.shortcuts.name"");
			case 1:
				return jEdit.getProperty(""options.shortcuts.shortcut1"");
			case 2:
				return jEdit.getProperty(""options.shortcuts.shortcut2"");
			default:
				return null;
			}
		}
		public void save()
		{
			Enumeration e = bindings.elements();
			while(e.hasMoreElements())
			{
				GrabKeyDialog.KeyBinding binding[]
					= (GrabKeyDialog.KeyBinding[])
						e.nextElement();
				jEdit.setProperty(
					binding[0].name + "".shortcut"",
					binding[0].shortcut);
				jEdit.setProperty(
					binding[1].name + "".shortcut2"",
					binding[1].shortcut);
			}
		}
		public GrabKeyDialog.KeyBinding getBindingAt(int row, int nr)
		{
			GrabKeyDialog.KeyBinding binding[]
				= (GrabKeyDialog.KeyBinding[])
					bindings.elementAt(row);
			return binding[nr];
		}
		public String toString()
		{
			return name;
		}
		class KeyCompare implements MiscUtilities.Compare
		{
			int col;
			KeyCompare(int col)
			{
				this.col = col;
			}
			public int compare(Object obj1, Object obj2)
			{
				GrabKeyDialog.KeyBinding[] k1
					= (GrabKeyDialog.KeyBinding[])obj1;
				GrabKeyDialog.KeyBinding[] k2
					= (GrabKeyDialog.KeyBinding[])obj2;
				String label1 = k1[0].label.toLowerCase();
				String label2 = k2[0].label.toLowerCase();
				if(col == 0)
					return MiscUtilities.compareStrings(
						label1,label2,true);
				else
				{
					String shortcut1, shortcut2;
					if(col == 1)
					{
						shortcut1 = k1[0].shortcut;
						shortcut2 = k2[0].shortcut;
					}
					else
					{
						shortcut1 = k1[1].shortcut;
						shortcut2 = k2[1].shortcut;
					}
					if(shortcut1 == null && shortcut2 != null)
						return 1;
					else if(shortcut2 == null && shortcut1 != null)
						return -1;
					else if(shortcut1 == null && shortcut2 == null)
						return MiscUtilities.compareStrings(label1,label2,true);
					else
						return MiscUtilities.compareStrings(shortcut1,shortcut2,true);
				}
			}
		}
	}
}
"
org.gjt.sp.jedit.options.StatusBarOptionPane,"/*
 * StatusBarOptionPane.java - Status Bar options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 * Copyright (C) 2002 Kenrick Drew
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.ColorWellButton;
import org.gjt.sp.jedit.*;
//}}}
public class StatusBarOptionPane extends AbstractOptionPane
{
	//{{{ StatusBarOptionPane constructor
	public StatusBarOptionPane()
	{
		super(""status"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* Status bar visible */
		statusVisible = new JCheckBox(jEdit.getProperty(
			""options.status.visible""));
		statusVisible.setSelected(jEdit.getBooleanProperty(
			""view.status.visible""));
		statusVisible.addActionListener(new ActionHandler());
		addComponent(statusVisible);
		/* Foreground color */
		addComponent(jEdit.getProperty(""options.status.foreground""),
			foregroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.foreground"")),
			GridBagConstraints.VERTICAL);
		/* Background color */
		addComponent(jEdit.getProperty(""options.status.background""),
			backgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.background"")),
			GridBagConstraints.VERTICAL);
		/* Caret status */
		showCaretStatus = new JCheckBox(jEdit.getProperty(
			""options.status.show-caret-status""));
		showCaretStatus.setSelected(jEdit.getBooleanProperty(
			""view.status.show-caret-status""));
		addComponent(showCaretStatus);
		/* Edit mode */
		showEditMode = new JCheckBox(jEdit.getProperty(
			""options.status.show-edit-mode""));
		showEditMode.setSelected(jEdit.getBooleanProperty(
			""view.status.show-edit-mode""));
		addComponent(showEditMode);
		/* Fold mode */
		showFoldMode = new JCheckBox(jEdit.getProperty(
			""options.status.show-fold-mode""));
		showFoldMode.setSelected(jEdit.getBooleanProperty(
			""view.status.show-fold-mode""));
		addComponent(showFoldMode);
		/* Encoding */
		showEncoding = new JCheckBox(jEdit.getProperty(
			""options.status.show-encoding""));
		showEncoding.setSelected(jEdit.getBooleanProperty(
			""view.status.show-encoding""));
		addComponent(showEncoding);
		/* Wrap */
		showWrap = new JCheckBox(jEdit.getProperty(
			""options.status.show-wrap""));
		showWrap.setSelected(jEdit.getBooleanProperty(
			""view.status.show-wrap""));
		addComponent(showWrap);
		/* Multi select */
		showMultiSelect = new JCheckBox(jEdit.getProperty(
			""options.status.show-multi-select""));
		showMultiSelect.setSelected(jEdit.getBooleanProperty(
			""view.status.show-multi-select""));
		addComponent(showMultiSelect);
		/* Rect select */
		showRectSelect = new JCheckBox(jEdit.getProperty(
			""options.status.show-rect-select""));
		showRectSelect.setSelected(jEdit.getBooleanProperty(
			""view.status.show-rect-select""));
		addComponent(showRectSelect);
		/* Overwrite */
		showOverwrite = new JCheckBox(jEdit.getProperty(
			""options.status.show-overwrite""));
		showOverwrite.setSelected(jEdit.getBooleanProperty(
			""view.status.show-overwrite""));
		addComponent(showOverwrite);
		/* Line seperator */
		showLineSeperator = new JCheckBox(jEdit.getProperty(
			""options.status.show-line-seperator""));
		showLineSeperator.setSelected(jEdit.getBooleanProperty(
			""view.status.show-line-seperator""));
		addComponent(showLineSeperator);
		/* Memory status */
		showMemory = new JCheckBox(jEdit.getProperty(
			""options.status.show-memory""));
		showMemory.setSelected(jEdit.getBooleanProperty(
			""view.status.show-memory""));
		showMemory.addActionListener(new ActionHandler());
		addComponent(showMemory);
		/* Memory foreground color */
		addComponent(jEdit.getProperty(""options.status.memory.foreground""),
			memForegroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.memory.foreground"")),
			GridBagConstraints.VERTICAL);
		/* Memory background color */
		addComponent(jEdit.getProperty(""options.status.memory.background""),
			memBackgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.memory.background"")),
			GridBagConstraints.VERTICAL);
		/* Clock */
		showClock = new JCheckBox(jEdit.getProperty(
			""options.status.show-clock""));
		showClock.setSelected(jEdit.getBooleanProperty(
			""view.status.show-clock""));
		showClock.addActionListener(new ActionHandler());
		addComponent(showClock);
		updateEnabled();
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.status.visible"",
			statusVisible.isSelected());
		jEdit.setColorProperty(""view.status.foreground"",foregroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.status.background"",backgroundColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.status.show-caret-status"",
			showCaretStatus.isSelected());
		jEdit.setBooleanProperty(""view.status.show-edit-mode"",
			showEditMode.isSelected());
		jEdit.setBooleanProperty(""view.status.show-fold-mode"",
			showFoldMode.isSelected());
		jEdit.setBooleanProperty(""view.status.show-encoding"",
			showEncoding.isSelected());
		jEdit.setBooleanProperty(""view.status.show-wrap"",
			showWrap.isSelected());
		jEdit.setBooleanProperty(""view.status.show-multi-select"",
			showMultiSelect.isSelected());
		jEdit.setBooleanProperty(""view.status.show-rect-select"",
			showRectSelect.isSelected());
		jEdit.setBooleanProperty(""view.status.show-overwrite"",
			showOverwrite.isSelected());
		jEdit.setBooleanProperty(""view.status.show-line-seperator"",
			showLineSeperator.isSelected());
		jEdit.setBooleanProperty(""view.status.show-memory"",
			showMemory.isSelected());
		jEdit.setColorProperty(""view.status.memory.foreground"",memForegroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.status.memory.background"",memBackgroundColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.status.show-clock"",
			showClock.isSelected());
	} //}}}
	//{{{ Private members
	private JCheckBox statusVisible;
	private ColorWellButton foregroundColor;
	private ColorWellButton backgroundColor;
	private JCheckBox showCaretStatus;
	private JCheckBox showEditMode;
	private JCheckBox showFoldMode;
	private JCheckBox showEncoding;
	private JCheckBox showWrap;
	private JCheckBox showMultiSelect;
	private JCheckBox showRectSelect;
	private JCheckBox showOverwrite;
	private JCheckBox showLineSeperator;
	private JCheckBox showMemory;
	private ColorWellButton memForegroundColor;
	private ColorWellButton memBackgroundColor;
	private JCheckBox showClock;
	private void updateEnabled()
	{
		boolean enabled = statusVisible.isSelected();
		showCaretStatus.setEnabled(enabled);
		showEditMode.setEnabled(enabled);
		showFoldMode.setEnabled(enabled);
		showEncoding.setEnabled(enabled);
		showWrap.setEnabled(enabled);
		showMultiSelect.setEnabled(enabled);
		showRectSelect.setEnabled(enabled);
		showOverwrite.setEnabled(enabled);
		showLineSeperator.setEnabled(enabled);
		showMemory.setEnabled(enabled);
		memForegroundColor.setEnabled(enabled && showMemory.isSelected());
		memBackgroundColor.setEnabled(enabled && showMemory.isSelected());
		showClock.setEnabled(enabled);
	}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			updateEnabled();
		}
	} //}}}
}
"
org.gjt.sp.jedit.options.SyntaxHiliteOptionPane,"/*
 * SyntaxHiliteOptionPane.java - Syntax highlighting option pane
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.border.EmptyBorder;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.gui.ColorWellButton;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.*;
//}}}
//{{{ SyntaxHiliteOptionPane class
/**
 * Style option pane.
 * @author Slava Pestov
 * @version $Id: SyntaxHiliteOptionPane.java,v 1.9 2004/06/28 06:45:27 spestov Exp $
 */
public class SyntaxHiliteOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);
	//{{{ StyleOptionPane constructor
	public SyntaxHiliteOptionPane()
	{
		super(""syntax"");
	}
	//}}}
	//{{{ Protected members
	//{{{ _init() method
	protected void _init()
	{
		setLayout(new BorderLayout(6,6));
		add(BorderLayout.CENTER,createStyleTableScroller());
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		styleModel.save();
	} //}}}
	//}}}
	//{{{ Private members
	private StyleTableModel styleModel;
	private JTable styleTable;
	//{{{ createStyleTableScroller() method
	private JScrollPane createStyleTableScroller()
	{
		styleModel = createStyleTableModel();
		styleTable = new JTable(styleModel);
		styleTable.setRowSelectionAllowed(false);
		styleTable.setColumnSelectionAllowed(false);
		styleTable.setCellSelectionEnabled(false);
		styleTable.getTableHeader().setReorderingAllowed(false);
		styleTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = styleTable.getColumnModel();
 		TableColumn styleColumn = tcm.getColumn(1);
		styleColumn.setCellRenderer(new StyleTableModel.StyleRenderer());
		Dimension d = styleTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(styleTable);
		scroller.setPreferredSize(d);
		return scroller;
	} //}}}
	//{{{ createStyleTableModel() method
	private StyleTableModel createStyleTableModel()
	{
		return new StyleTableModel();
	} //}}}
	//}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = styleTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;
			SyntaxStyle style = new StyleEditor(
				SyntaxHiliteOptionPane.this,
				(SyntaxStyle)styleModel.getValueAt(
				row,1)).getStyle();
			if(style != null)
				styleModel.setValueAt(style,row,1);
		}
	} //}}}
} //}}}
//{{{ StyleTableModel class
class StyleTableModel extends AbstractTableModel
{
	private Vector styleChoices;
	//{{{ StyleTableModel constructor
	StyleTableModel()
	{
		styleChoices = new Vector(Token.ID_COUNT + 4);
		// start at 1 not 0 to skip Token.NULL
		for(int i = 1; i < Token.ID_COUNT; i++)
		{
			String tokenName = Token.tokenToString((byte)i);
			addStyleChoice(tokenName,""view.style."" + tokenName.toLowerCase());
		}
		addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.1""),
			""view.style.foldLine.1"");
		addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.2""),
			""view.style.foldLine.2"");
		addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.3""),
			""view.style.foldLine.3"");
		addStyleChoice(jEdit.getProperty(""options.syntax.foldLine.0""),
			""view.style.foldLine.0"");
		MiscUtilities.quicksort(styleChoices,new MiscUtilities.StringICaseCompare());
	} //}}}
	//{{{ getColumnCount() method
	public int getColumnCount()
	{
		return 2;
	} //}}}
	//{{{ getRowCount() method
	public int getRowCount()
	{
		return styleChoices.size();
	} //}}}
	//{{{ getValueAt() method
	public Object getValueAt(int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		switch(col)
		{
		case 0:
			return ch.label;
		case 1:
			return ch.style;
		default:
			return null;
		}
	} //}}}
	//{{{ setValueAt() method
	public void setValueAt(Object value, int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		if(col == 1)
			ch.style = (SyntaxStyle)value;
		fireTableRowsUpdated(row,row);
	} //}}}
	//{{{ getColumnName() method
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.syntax.object"");
		case 1:
			return jEdit.getProperty(""options.syntax.style"");
		default:
			return null;
		}
	} //}}}
	//{{{ save() method
	public void save()
	{
		for(int i = 0; i < styleChoices.size(); i++)
		{
			StyleChoice ch = (StyleChoice)styleChoices
				.elementAt(i);
			jEdit.setProperty(ch.property,
				GUIUtilities.getStyleString(ch.style));
		}
	} //}}}
	//{{{ addStyleChoice() method
	private void addStyleChoice(String label, String property)
	{
		styleChoices.addElement(new StyleChoice(label,
			property,
			GUIUtilities.parseStyle(jEdit.getProperty(property),
			""Dialog"",12)));
	} //}}}
	//{{{ StyleChoice class
	static class StyleChoice
	{
		String label;
		String property;
		SyntaxStyle style;
		StyleChoice(String label, String property, SyntaxStyle style)
		{
			this.label = label;
			this.property = property;
			this.style = style;
		}
		// for sorting
		public String toString()
		{
			return label;
		}
	} //}}}
	//{{{ StyleRenderer class
	static class StyleRenderer extends JLabel
		implements TableCellRenderer
	{
		//{{{ StyleRenderer constructor
		public StyleRenderer()
		{
			setOpaque(true);
			setBorder(SyntaxHiliteOptionPane.noFocusBorder);
			setText(""Hello World"");
		} //}}}
		//{{{ getTableCellRendererComponent() method
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (value != null)
			{
				SyntaxStyle style = (SyntaxStyle)value;
				setForeground(style.getForegroundColor());
				if (style.getBackgroundColor() != null) 
					setBackground(style.getBackgroundColor());
				else
				{
					// this part sucks
					setBackground(jEdit.getColorProperty(
						""view.bgColor""));
				}
				setFont(style.getFont());
			}
			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: SyntaxHiliteOptionPane.noFocusBorder);
			return this;
		} //}}}
	} //}}}
} //}}}
//{{{ StyleEditor class
class StyleEditor extends EnhancedDialog implements ActionListener
{
	//{{{ StyleEditor constructor
	StyleEditor(Component comp, SyntaxStyle style)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""style-editor.title""),true);
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel panel = new JPanel(new GridLayout(4,2,12,12));
		italics = new JCheckBox(jEdit.getProperty(""style-editor.italics""));
		italics.setSelected(style.getFont().isItalic());
		panel.add(italics);
		panel.add(new JLabel());
		bold = new JCheckBox(jEdit.getProperty(""style-editor.bold""));
		bold.setSelected(style.getFont().isBold());
		panel.add(bold);
		panel.add(new JLabel());
		Color fg = style.getForegroundColor();
		fgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.fgColor""));
		fgColorCheckBox.setSelected(fg != null);
		fgColorCheckBox.addActionListener(this);
		panel.add(fgColorCheckBox);
		fgColor = new ColorWellButton(fg);
		fgColor.setEnabled(fg != null);
		panel.add(fgColor);
		Color bg = style.getBackgroundColor();
		bgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.bgColor""));
		bgColorCheckBox.setSelected(bg != null);
		bgColorCheckBox.addActionListener(this);
		panel.add(bgColorCheckBox);
		bgColor = new ColorWellButton(bg);
		bgColor.setEnabled(bg != null);
		panel.add(bgColor);
		content.add(BorderLayout.CENTER,panel);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		box.add(ok = new JButton(jEdit.getProperty(""common.ok"")));
		getRootPane().setDefaultButton(ok);
		ok.addActionListener(this);
		box.add(Box.createHorizontalStrut(6));
		box.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(this);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		setResizable(false);
		setVisible(true);
	} //}}}
	//{{{ actionPerformed() method
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
		else if(source == fgColorCheckBox)
			fgColor.setEnabled(fgColorCheckBox.isSelected());
		else if(source == bgColorCheckBox)
			bgColor.setEnabled(bgColorCheckBox.isSelected());
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		okClicked = true;
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ getStyle() method
	public SyntaxStyle getStyle()
	{
		if(!okClicked)
			return null;
		Color foreground = (fgColorCheckBox.isSelected()
			? fgColor.getSelectedColor()
			: null);
		Color background = (bgColorCheckBox.isSelected()
			? bgColor.getSelectedColor()
			: null);
		return new SyntaxStyle(foreground,background,
				new Font(""Dialog"",
				(italics.isSelected() ? Font.ITALIC : 0)
				| (bold.isSelected() ? Font.BOLD : 0),
				12));
	} //}}}
	//{{{ Private members
	private JCheckBox italics;
	private JCheckBox bold;
	private JCheckBox fgColorCheckBox;
	private ColorWellButton fgColor;
	private JCheckBox bgColorCheckBox;
	private ColorWellButton bgColor;
	private JButton ok;
	private JButton cancel;
	private boolean okClicked;
	//}}}
} //}}}
"
org.gjt.sp.jedit.options.TextAreaOptionPane,"/*
 * TextAreaOptionPane.java - Text area options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
//}}}
public class TextAreaOptionPane extends AbstractOptionPane
{
	//{{{ TextAreaOptionPane constructor
	public TextAreaOptionPane()
	{
		super(""textarea"");
	} //}}}
	//{{{ _init() method
	public void _init()
	{
		/* Font */
		font = new FontSelector(jEdit.getFontProperty(""view.font""));
		addComponent(jEdit.getProperty(""options.textarea.font""),font);
		/* Text color */
		addComponent(jEdit.getProperty(""options.textarea.foreground""),
			foregroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.fgColor"")),
			GridBagConstraints.VERTICAL);
		/* Background color */
		addComponent(jEdit.getProperty(""options.textarea.background""),
			backgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.bgColor"")),
			GridBagConstraints.VERTICAL);
		/* Caret color, caret blink, block caret */
		blinkCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blinkCaret""));
		blinkCaret.setSelected(jEdit.getBooleanProperty(""view.caretBlink""));
		blockCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blockCaret""));
		blockCaret.setSelected(jEdit.getBooleanProperty(""view.blockCaret""));
		Box caretSettings = new Box(BoxLayout.X_AXIS);
		caretSettings.add(new JLabel(jEdit.getProperty(
			""options.textarea.caret"")));
		caretSettings.add(Box.createHorizontalStrut(6));
		caretSettings.add(blinkCaret);
		caretSettings.add(blockCaret);
		addComponent(caretSettings,caretColor = new ColorWellButton(
			jEdit.getColorProperty(""view.caretColor"")),
			GridBagConstraints.VERTICAL);
		/* Selection color */
		addComponent(jEdit.getProperty(""options.textarea.selection""),
			selectionColor = new ColorWellButton(
			jEdit.getColorProperty(""view.selectionColor"")),
			GridBagConstraints.VERTICAL);
		/* Multiple selection color */
		addComponent(jEdit.getProperty(""options.textarea.multipleSelection""),
			multipleSelectionColor = new ColorWellButton(
			jEdit.getColorProperty(""view.multipleSelectionColor"")),
			GridBagConstraints.VERTICAL);
		/* Line highlight */
		lineHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".lineHighlight""));
		lineHighlight.setSelected(jEdit.getBooleanProperty(""view.lineHighlight""));
		addComponent(lineHighlight,lineHighlightColor = new ColorWellButton(
			jEdit.getColorProperty(""view.lineHighlightColor"")),
			GridBagConstraints.VERTICAL);
		/* Structure highlight */
		structureHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".structureHighlight""));
		structureHighlight.setSelected(jEdit.getBooleanProperty(
			""view.structureHighlight""));
		addComponent(structureHighlight,structureHighlightColor = new ColorWellButton(
			jEdit.getColorProperty(""view.structureHighlightColor"")),
			GridBagConstraints.VERTICAL);
		/* EOL markers */
		eolMarkers = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".eolMarkers""));
		eolMarkers.setSelected(jEdit.getBooleanProperty(""view.eolMarkers""));
		addComponent(eolMarkers,eolMarkerColor =new ColorWellButton(
			jEdit.getColorProperty(""view.eolMarkerColor"")),
			GridBagConstraints.VERTICAL);
		/* Wrap guide */
		wrapGuide = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".wrapGuide""));
		wrapGuide.setSelected(jEdit.getBooleanProperty(""view.wrapGuide""));
		addComponent(wrapGuide,wrapGuideColor = new ColorWellButton(
			jEdit.getColorProperty(""view.wrapGuideColor"")),
			GridBagConstraints.VERTICAL);
		/* Electric borders */
		electricBorders = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".electricBorders""));
		electricBorders.setSelected(!""0"".equals(jEdit.getProperty(
			""view.electricBorders"")));
		addComponent(electricBorders);
		/* Anti-aliasing */
		antiAlias = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".antiAlias""));
		boolean antiAliasEnabled = jEdit.getBooleanProperty(
			""view.antiAlias"");
		font.setAntiAliasEnabled(antiAliasEnabled);
		antiAlias.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				font.setAntiAliasEnabled(
					antiAlias.isSelected());
				font.repaint();
			}
		});
		antiAlias.setSelected(antiAliasEnabled);
		addComponent(antiAlias);
		/* Fractional font metrics */
		fracFontMetrics = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".fracFontMetrics""));
		fracFontMetrics.setSelected(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		addComponent(fracFontMetrics);
	} //}}}
	//{{{ _save() method
	public void _save()
	{
		jEdit.setFontProperty(""view.font"",font.getFont());
		jEdit.setColorProperty(""view.fgColor"",foregroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.bgColor"",backgroundColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.caretBlink"",blinkCaret.isSelected());
		jEdit.setBooleanProperty(""view.blockCaret"",blockCaret.isSelected());
		jEdit.setColorProperty(""view.caretColor"",caretColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.selectionColor"",selectionColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.multipleSelectionColor"",multipleSelectionColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.lineHighlight"",lineHighlight
			.isSelected());
		jEdit.setColorProperty(""view.lineHighlightColor"",
			lineHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.structureHighlight"",structureHighlight
			.isSelected());
		jEdit.setColorProperty(""view.structureHighlightColor"",
			structureHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.eolMarkers"",eolMarkers
			.isSelected());
		jEdit.setColorProperty(""view.eolMarkerColor"",
			eolMarkerColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.wrapGuide"",wrapGuide
			.isSelected());
		jEdit.setColorProperty(""view.wrapGuideColor"",
			wrapGuideColor.getSelectedColor());
		jEdit.setIntegerProperty(""view.electricBorders"",electricBorders
			.isSelected() ? 3 : 0);
		jEdit.setBooleanProperty(""view.antiAlias"",antiAlias.isSelected());
		jEdit.setBooleanProperty(""view.fracFontMetrics"",fracFontMetrics.isSelected());
	} //}}}
	//{{{ Private members
	private FontSelector font;
	private ColorWellButton foregroundColor;
	private ColorWellButton backgroundColor;
	private JCheckBox blinkCaret;
	private JCheckBox blockCaret;
	private ColorWellButton caretColor;
	private ColorWellButton selectionColor;
	private ColorWellButton multipleSelectionColor;
	private JCheckBox lineHighlight;
	private ColorWellButton lineHighlightColor;
	private JCheckBox structureHighlight;
	private ColorWellButton structureHighlightColor;
	private JCheckBox eolMarkers;
	private ColorWellButton eolMarkerColor;
	private JCheckBox wrapGuide;
	private ColorWellButton wrapGuideColor;
	private JCheckBox electricBorders;
	private JCheckBox antiAlias;
	private JCheckBox fracFontMetrics;
	//}}}
}
"
org.gjt.sp.jedit.options.ToolBarOptionPane,"/*
 * ToolBarOptionPane.java - Tool bar options panel
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
//{{{ ToolBarOptionPane class
/**
 * Tool bar editor.
 * @author Slava Pestov
 * @version $Id: ToolBarOptionPane.java,v 1.14 2004/06/28 06:45:27 spestov Exp $
 */
public class ToolBarOptionPane extends AbstractOptionPane
{
	//{{{ ToolBarOptionPane constructor
	public ToolBarOptionPane()
	{
		super(""toolbar"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		setLayout(new BorderLayout());
		JPanel panel = new JPanel(new GridLayout(2,1));
		/* Show toolbar */
		showToolbar = new JCheckBox(jEdit.getProperty(
			""options.toolbar.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""view.showToolbar""));
		panel.add(showToolbar);
		panel.add(new JLabel(jEdit.getProperty(
			""options.toolbar.caption"")));
		add(BorderLayout.NORTH,panel);
		String toolbar = jEdit.getProperty(""view.toolbar"");
		StringTokenizer st = new StringTokenizer(toolbar);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ToolBarOptionPane.Button(""-"",null,null,""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;
				Icon icon;
				String iconName;
				if(actionName.equals(""-""))
				{
					iconName = null;
					icon = null;
				}
				else
				{
					iconName = jEdit.getProperty(actionName + "".icon"");
					if(iconName == null)
						icon = GUIUtilities.loadIcon(""BrokenImage.png"");
					else
					{
						icon = GUIUtilities.loadIcon(iconName);
						if(icon == null)
							icon = GUIUtilities.loadIcon(""BrokenImage.png"");
					}
				}
				listModel.addElement(new Button(actionName,iconName,icon,label));
			}
		}
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		list.setCellRenderer(new ButtonCellRenderer());
		add(BorderLayout.CENTER,new JScrollPane(list));
		//{{{ Create buttons
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.toolbar.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.toolbar.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""options.toolbar.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""options.toolbar.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createHorizontalStrut(6));
		edit = new RolloverButton(GUIUtilities.loadIcon(""ButtonProperties.png""));
		edit.setToolTipText(jEdit.getProperty(""options.toolbar.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());
		//}}}
		updateButtons();
		add(BorderLayout.SOUTH,buttons);
		//{{{ Ceate icons list
		iconList = new DefaultComboBoxModel();
		st = new StringTokenizer(jEdit.getProperty(""icons""));
		while(st.hasMoreElements())
		{
			String icon = st.nextToken();
			iconList.addElement(new IconListEntry(
				GUIUtilities.loadIcon(icon),icon));
		} //}}}
	} ///}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.showToolbar"",showToolbar
			.isSelected());
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			Button button = (Button)listModel.elementAt(i);
			buf.append(button.actionName);
			jEdit.setProperty(button.actionName + "".icon"",button.iconName);
		}
		jEdit.setProperty(""view.toolbar"",buf.toString());
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JCheckBox showToolbar;
	private DefaultListModel listModel;
	private JList list;
	private RolloverButton add;
	private RolloverButton remove;
	private RolloverButton moveUp, moveDown;
	private RolloverButton edit;
	private DefaultComboBoxModel iconList;
	//}}}
	//{{{ updateButtons() method
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
		edit.setEnabled(index != -1);
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ButtonCompare class
	static class ButtonCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return MiscUtilities.compareStrings(
				((Button)obj1).label,
				((Button)obj2).label,
				true);
		}
	} //}}}
	//{{{ Button class
	static class Button
	{
		String actionName;
		String iconName;
		Icon icon;
		String label;
		Button(String actionName, String iconName, Icon icon, String label)
		{
			this.actionName = actionName;
			this.iconName = iconName;
			this.icon = icon;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}
		public String toString()
		{
			return label;
		}
		public boolean equals(Object o)
		{
			if(o instanceof Button)
				return ((Button)o).actionName.equals(actionName);
			else
				return false;
		}
	} //}}}
	//{{{ IconListEntry class
	static class IconListEntry
	{
		Icon icon;
		String name;
		IconListEntry(Icon icon, String name)
		{
			this.icon = icon;
			this.name = name;
		}
		public String toString()
		{
			return name;
		}
	} //}}}
	//{{{ ButtonCellRenderer class
	static class ButtonCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Button button = (Button)value;
			setIcon(button.icon);
			return this;
		}
	} //}}}
	//{{{ IconCellRenderer class
	static class IconCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			IconListEntry icon = (IconListEntry)value;
			setIcon(icon.icon);
			return this;
		}
	} //}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,null);
				Button selection = dialog.getSelection();
				if(selection == null)
					return;
				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;
				listModel.insertElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				if(listModel.getSize() != 0)
				{
					if(listModel.getSize() == index)
						list.setSelectedIndex(index-1);
					else
						list.setSelectedIndex(index);
				}
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
			else if(source == edit)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,
					(Button)list.getSelectedValue());
				Button selection = dialog.getSelection();
				if(selection == null)
					return;
				int index = list.getSelectedIndex();
				listModel.setElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
		}
	} //}}}
	//{{{ ListHandler class
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	} //}}}
	//}}}
} //}}}
//{{{ ToolBarEditDialog class
class ToolBarEditDialog extends EnhancedDialog
{
	//{{{ ToolBarEditDialog constructor
	public ToolBarEditDialog(Component comp,
		DefaultComboBoxModel iconListModel,
		ToolBarOptionPane.Button current)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""options.toolbar.edit.title""),
			true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();
		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.toolbar.edit.caption"")));
		separator = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);
		action = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		typePanel.add(action);
		content.add(BorderLayout.NORTH,typePanel);
		JPanel actionPanel = new JPanel(new BorderLayout(6,6));
		ActionSet[] actionsList = jEdit.getActionSets();
		Vector vec = new Vector(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				vec.addElement(actionSet);
		}
		combo = new JComboBox(vec);
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);
		list = new JList();
		list.setVisibleRowCount(8);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));
		// Icon selection
		JPanel iconPanel = new JPanel(new BorderLayout(0,3));
		JPanel labelPanel = new JPanel(new GridLayout(2,1));
		labelPanel.setBorder(new EmptyBorder(0,0,0,12));
		JPanel compPanel = new JPanel(new GridLayout(2,1));
		grp = new ButtonGroup();
		labelPanel.add(builtin = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.builtin"")));
		builtin.addActionListener(actionHandler);
		grp.add(builtin);
		labelPanel.add(file = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.file"")));
		grp.add(file);
		file.addActionListener(actionHandler);
		iconPanel.add(BorderLayout.WEST,labelPanel);
		builtinCombo = new JComboBox(iconListModel);
		builtinCombo.setRenderer(new ToolBarOptionPane.IconCellRenderer());
		compPanel.add(builtinCombo);
		fileButton = new JButton(jEdit.getProperty(""options.toolbar.edit.no-icon""));
		fileButton.setMargin(new Insets(1,1,1,1));
		fileButton.setIcon(GUIUtilities.loadIcon(""Blank24.gif""));
		fileButton.setHorizontalAlignment(SwingConstants.LEFT);
		fileButton.addActionListener(actionHandler);
		compPanel.add(fileButton);
		iconPanel.add(BorderLayout.CENTER,compPanel);
		actionPanel.add(BorderLayout.SOUTH,iconPanel);
		content.add(BorderLayout.CENTER,actionPanel);
		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,southPanel);
		if(current == null)
		{
			action.setSelected(true);
			builtin.setSelected(true);
			updateList();
		}
		else
		{
			if(current.actionName.equals(""-""))
			{
				separator.setSelected(true);
				builtin.setSelected(true);
			}
			else
			{
				action.setSelected(true);
				ActionSet set = jEdit.getActionSetForAction(
					current.actionName);
				combo.setSelectedItem(set);
				updateList();
				list.setSelectedValue(current,true);
				if(MiscUtilities.isURL(current.iconName))
				{
					file.setSelected(true);
					fileIcon = current.iconName;
					try
					{
						fileButton.setIcon(new ImageIcon(new URL(
							fileIcon)));
					}
					catch(MalformedURLException mf)
					{
						Log.log(Log.ERROR,this,mf);
					}
					fileButton.setText(MiscUtilities.getFileName(fileIcon));
				}
				else
				{
					String iconName = MiscUtilities.getFileName(current.iconName);
					builtin.setSelected(true);
					ListModel model = builtinCombo.getModel();
					for(int i = 0; i < model.getSize(); i++)
					{
						ToolBarOptionPane.IconListEntry entry
							= (ToolBarOptionPane.IconListEntry)
							model.getElementAt(i);
						if(entry.name.equals(iconName))
						{
							builtinCombo.setSelectedIndex(i);
							break;
						}
					}
				}
			}
		}
		updateEnabled();
		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		setVisible(true);
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		isOK = true;
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ getSelection() method
	public ToolBarOptionPane.Button getSelection()
	{
		if(!isOK)
			return null;
		if(separator.isSelected())
			return new ToolBarOptionPane.Button(""-"",null,null,""-"");
		else
		{
			Icon icon;
			String iconName;
			if(builtin.isSelected())
			{
				ToolBarOptionPane.IconListEntry selectedIcon =
					(ToolBarOptionPane.IconListEntry)
					builtinCombo.getSelectedItem();
				icon = selectedIcon.icon;
				iconName = selectedIcon.name;
			}
			else
			{
				icon = fileButton.getIcon();
				iconName = fileIcon;
				if(iconName == null)
					iconName = ""Blank24.gif"";
			}
			String label;
			String actionName;
			if(action.isSelected())
			{
				ToolBarOptionPane.Button button =
					(ToolBarOptionPane.Button)list
					.getSelectedValue();
				label = button.label;
				actionName = button.actionName;
			}
			else
				throw new InternalError();
			return new ToolBarOptionPane.Button(actionName,
				iconName,icon,label);
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JRadioButton builtin;
	private JComboBox builtinCombo;
	private JRadioButton file;
	private JButton fileButton;
	private String fileIcon;
	private JButton ok, cancel;
	//}}}
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		combo.setEnabled(action.isSelected());
		list.setEnabled(action.isSelected());
		boolean iconControlsEnabled = !separator.isSelected();
		builtin.setEnabled(iconControlsEnabled);
		file.setEnabled(iconControlsEnabled);
		builtinCombo.setEnabled(iconControlsEnabled && builtin.isSelected());
		fileButton.setEnabled(iconControlsEnabled && file.isSelected());
	} //}}}
	//{{{ updateList() method
	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;
			listModel.addElement(new ToolBarOptionPane.Button(
				action.getName(),null,null,label));
		}
		MiscUtilities.quicksort(listModel,new ToolBarOptionPane.ButtonCompare());
		list.setListData(listModel);
	} //}}}
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
				updateEnabled();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
			else if(source == fileButton)
			{
				String directory;
				if(fileIcon == null)
					directory = null;
				else
					directory = MiscUtilities.getParentOfPath(fileIcon);
				String paths[] = GUIUtilities.showVFSFileDialog(null,directory,
					VFSBrowser.OPEN_DIALOG,false);
				if(paths == null)
					return;
				fileIcon = ""file:"" + paths[0];
				try
				{
					fileButton.setIcon(new ImageIcon(new URL(
						fileIcon)));
				}
				catch(MalformedURLException mf)
				{
					Log.log(Log.ERROR,this,mf);
				}
				fileButton.setText(MiscUtilities.getFileName(fileIcon));
			}
		}
	} //}}}
} //}}}
"
org.gjt.sp.jedit.options.ViewOptionPane,"/*
 * ViewOptionPane.java - Editor window options
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class ViewOptionPane extends AbstractOptionPane
{
	//{{{ ViewOptionPane constructor
	public ViewOptionPane()
	{
		super(""view"");
	} //}}}
	//{{{ _init() method
	protected void _init()
	{
		/* View dock layout */
		layoutIcon1 = GUIUtilities.loadIcon(""dock_layout1.png"");
		layoutIcon2 = GUIUtilities.loadIcon(""dock_layout2.png"");
		layoutIcon3 = GUIUtilities.loadIcon(""dock_layout3.png"");
		layoutIcon4 = GUIUtilities.loadIcon(""dock_layout4.png"");
		JPanel layoutPanel = new JPanel(new BorderLayout(12,12));
		if(jEdit.getBooleanProperty(""view.docking.alternateLayout""))
		{
			layout = new JLabel(jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"")
				? layoutIcon4 : layoutIcon2);
		}
		else
		{
			layout = new JLabel(jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"")
				? layoutIcon3 : layoutIcon1);
		}
		layout.setBorder(new EmptyBorder(12,12,12,12));
		layoutPanel.add(BorderLayout.CENTER,layout);
		JPanel buttons = new JPanel(new GridLayout(2,1,12,12));
		buttons.setBorder(new EmptyBorder(0,12,12,12));
		buttons.add(alternateDockingLayout = new JButton(jEdit.getProperty(
			""options.view.alternateDockingLayout"")));
		alternateDockingLayout.addActionListener(new ActionHandler());
		buttons.add(alternateToolBarLayout = new JButton(jEdit.getProperty(
			""options.view.alternateToolBarLayout"")));
		alternateToolBarLayout.addActionListener(new ActionHandler());
		layoutPanel.add(BorderLayout.SOUTH,buttons);
		TitledBorder border = new TitledBorder(jEdit.getProperty(
			""options.view.viewLayout""));
		border.setTitleJustification(TitledBorder.CENTER);
		layoutPanel.setBorder(border);
		addComponent(layoutPanel);
		/* Show full path */
		showFullPath = new JCheckBox(jEdit.getProperty(
			""options.view.showFullPath""));
		showFullPath.setSelected(jEdit.getBooleanProperty(
			""view.showFullPath""));
		addComponent(showFullPath);
		/* Show search bar */
		showSearchbar = new JCheckBox(jEdit.getProperty(
			""options.view.showSearchbar""));
		showSearchbar.setSelected(jEdit.getBooleanProperty(
			""view.showSearchbar""));
		addComponent(showSearchbar);
		/* Beep on search auto wrap */
		beepOnSearchAutoWrap = new JCheckBox(jEdit.getProperty(
			""options.view.beepOnSearchAutoWrap""));
		beepOnSearchAutoWrap.setSelected(jEdit.getBooleanProperty(
			""search.beepOnSearchAutoWrap""));
		addComponent(beepOnSearchAutoWrap);
		/* Show buffer switcher */
		showBufferSwitcher = new JCheckBox(jEdit.getProperty(
			""options.view.showBufferSwitcher""));
		showBufferSwitcher.setSelected(jEdit.getBooleanProperty(
			""view.showBufferSwitcher""));
		addComponent(showBufferSwitcher);
	} //}}}
	//{{{ _save() method
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.docking.alternateLayout"",
			layout.getIcon() == layoutIcon2
			|| layout.getIcon() == layoutIcon4);
		jEdit.setBooleanProperty(""view.toolbar.alternateLayout"",
			layout.getIcon() == layoutIcon3
			|| layout.getIcon() == layoutIcon4);
		jEdit.setBooleanProperty(""view.showFullPath"",showFullPath
			.isSelected());
		jEdit.setBooleanProperty(""view.showSearchbar"",showSearchbar
			.isSelected());
		jEdit.setBooleanProperty(""search.beepOnSearchAutoWrap"",beepOnSearchAutoWrap
			.isSelected());
		jEdit.setBooleanProperty(""view.showBufferSwitcher"",
			showBufferSwitcher.isSelected());
	} //}}}
	//{{{ Private members
	private JLabel layout;
	private Icon layoutIcon1, layoutIcon2, layoutIcon3, layoutIcon4;
	private JButton alternateDockingLayout, alternateToolBarLayout;
	private JCheckBox showFullPath;
	private JCheckBox showSearchbar;
	private JCheckBox beepOnSearchAutoWrap;
	private JCheckBox showBufferSwitcher;
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == alternateDockingLayout)
			{
				if(layout.getIcon() == layoutIcon1)
					layout.setIcon(layoutIcon2);
				else if(layout.getIcon() == layoutIcon2)
					layout.setIcon(layoutIcon1);
				else if(layout.getIcon() == layoutIcon3)
					layout.setIcon(layoutIcon4);
				else if(layout.getIcon() == layoutIcon4)
					layout.setIcon(layoutIcon3);
			}
			else if(evt.getSource() == alternateToolBarLayout)
			{
				if(layout.getIcon() == layoutIcon1)
					layout.setIcon(layoutIcon3);
				else if(layout.getIcon() == layoutIcon3)
					layout.setIcon(layoutIcon1);
				else if(layout.getIcon() == layoutIcon2)
					layout.setIcon(layoutIcon4);
				else if(layout.getIcon() == layoutIcon4)
					layout.setIcon(layoutIcon2);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.pluginmgr.InstallPanel,"/*
 * InstallPanel.java - For installing plugins
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.text.NumberFormat;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
class InstallPanel extends JPanel
{
	//{{{ InstallPanel constructor
	InstallPanel(PluginManager window, boolean updates)
	{
		super(new BorderLayout(12,12));
		this.window = window;
		this.updates = updates;
		setBorder(new EmptyBorder(12,12,12,12));
		final JSplitPane split = new JSplitPane(
			JSplitPane.VERTICAL_SPLIT,true);
		/* Setup the table */
		table = new JTable(pluginModel = new PluginTableModel());
		table.setShowGrid(false);
		table.setIntercellSpacing(new Dimension(0,0));
		table.setRowHeight(table.getRowHeight() + 2);
		table.setPreferredScrollableViewportSize(new Dimension(500,200));
		table.setRequestFocusEnabled(false);
		table.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		table.setDefaultRenderer(Object.class, new TextRenderer(
			(DefaultTableCellRenderer)table.getDefaultRenderer(Object.class)));
		TableColumn col1 = table.getColumnModel().getColumn(0);
		TableColumn col2 = table.getColumnModel().getColumn(1);
		TableColumn col3 = table.getColumnModel().getColumn(2);
		TableColumn col4 = table.getColumnModel().getColumn(3);
		TableColumn col5 = table.getColumnModel().getColumn(4);
		col1.setPreferredWidth(30);
		col1.setMinWidth(30);
		col1.setMaxWidth(30);
		col1.setResizable(false);
		col2.setPreferredWidth(180);
		col3.setPreferredWidth(130);
		col4.setPreferredWidth(70);
		col5.setPreferredWidth(70);
		JTableHeader header = table.getTableHeader();
		header.setReorderingAllowed(false);
		header.addMouseListener(new HeaderMouseHandler());
		JScrollPane scrollpane = new JScrollPane(table);
		scrollpane.getViewport().setBackground(table.getBackground());
		split.setTopComponent(scrollpane);
		/* Create description */
		JScrollPane infoPane = new JScrollPane(
			infoBox = new PluginInfoBox());
		infoPane.setPreferredSize(new Dimension(500,100));
		split.setBottomComponent(infoPane);
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				split.setDividerLocation(0.75);
			}
		});
		add(BorderLayout.CENTER,split);
		/* Create buttons */
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(new InstallButton());
		buttons.add(Box.createHorizontalStrut(12));
		buttons.add(new SelectallButton());
		buttons.add(Box.createGlue());
		buttons.add(new SizeLabel());
		add(BorderLayout.SOUTH,buttons);
	} //}}}
	//{{{ updateModel() method
	public void updateModel()
	{
		pluginModel.clear();
		infoBox.setText(jEdit.getProperty(""plugin-manager.list-download""));
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				infoBox.setText(null);
				pluginModel.update();
			}
		});
	} //}}}
	//{{{ Private members
	//{{{ Variables
	private JTable table;
	private PluginTableModel pluginModel;
	private PluginManager window;
	private PluginInfoBox infoBox;
	private boolean updates;
	//}}}
	//{{{ formatSize() method
	private String formatSize(int size)
	{
		NumberFormat df = NumberFormat.getInstance();
		df.setMaximumFractionDigits(1);
		df.setMinimumFractionDigits(0);
		String sizeText;
		if (size < 1048576)
			sizeText = size/1024 + ""KB"";
		else
			sizeText = df.format(size/1048576d) + ""MB"";
		return sizeText;
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ PluginTableModel class
	class PluginTableModel extends AbstractTableModel
	{
		private ArrayList entries = new ArrayList();
		private int sortType = EntryCompare.CATEGORY;
		//{{{ getColumnClass() method
		public Class getColumnClass(int columnIndex)
		{
			switch (columnIndex)
			{
				case 0: return Boolean.class;
				case 1:
				case 2:
				case 3:
				case 4: return Object.class;
				default: throw new Error(""Column out of range"");
			}
		} //}}}
		//{{{ getColumnCount() method
		public int getColumnCount()
		{
			return 5;
		} //}}}
		//{{{ getColumnName() method
		public String getColumnName(int column)
		{
			switch (column)
			{
				case 0: return "" "";
				case 1: return "" ""+jEdit.getProperty(""install-plugins.info.name"");
				case 2: return "" ""+jEdit.getProperty(""install-plugins.info.category"");
				case 3: return "" ""+jEdit.getProperty(""install-plugins.info.version"");
				case 4: return "" ""+jEdit.getProperty(""install-plugins.info.size"");
				default: throw new Error(""Column out of range"");
			}
		} //}}}
		//{{{ getRowCount() method
		public int getRowCount()
		{
			return entries.size();
		} //}}}
		//{{{ getValueAt() method
		public Object getValueAt(int rowIndex,int columnIndex)
		{
			Object obj = entries.get(rowIndex);
			if(obj instanceof String)
			{
				if(columnIndex == 1)
					return obj;
				else
					return null;
			}
			else
			{
				Entry entry = (Entry)obj;
				switch (columnIndex)
				{
					case 0:
						return new Boolean(
							entry.install);
					case 1:
						return entry.name;
					case 2:
						return entry.set;
					case 3:
						return entry.version;
					case 4:
						return formatSize(entry.size);
					default:
						throw new Error(""Column out of range"");
				}
			}
		} //}}}
		//{{{ isCellEditable() method
		public boolean isCellEditable(int rowIndex, int columnIndex)
		{
			return (columnIndex == 0);
		} //}}}
		//{{{ setSelectAll() method
		public void setSelectAll(boolean b)
		{
			if(isDownloadingList())
				return;
			int length = getRowCount();
			for (int i = 0; i < length; i++)
			{
				if (b)
					setValueAt(Boolean.TRUE,i,0);
				else
				{
					Entry entry = (Entry)entries.get(i);
					entry.parents = new LinkedList();
					entry.install = false;
				}
			}
			fireTableChanged(new TableModelEvent(this));
		} //}}}
		//{{{ setSortType() method
		public void setSortType(int type)
		{
			sortType = type;
			sort(type);
		} //}}}
		//{{{ setValueAt() method
		public void setValueAt(Object aValue, int row, int column)
		{
			if (column != 0) return;
			Object obj = entries.get(row);
			if(obj instanceof String)
				return;
			Entry entry = (Entry)obj;
			Vector deps = entry.plugin.getCompatibleBranch().deps;
			boolean value = ((Boolean)aValue).booleanValue();
			if (!value)
			{
				if (entry.parents.size() > 0)
				{
					String[] args = {
						entry.name,
						entry.getParentString()
					};
					int result = GUIUtilities.confirm(
						window,""plugin-manager.dependency"",
						args,JOptionPane.OK_CANCEL_OPTION,
						JOptionPane.WARNING_MESSAGE);
					if (result != JOptionPane.OK_OPTION)
						return;
					Iterator parentsIter = entry.parents.iterator();
					while(parentsIter.hasNext())
					{
						((Entry)parentsIter.next()).install = false;
					}
					fireTableRowsUpdated(0,getRowCount() - 1);
				}
			}
			for (int i = 0; i < deps.size(); i++)
			{
				PluginList.Dependency dep = (PluginList.Dependency)deps.elementAt(i);
				if (dep.what.equals(""plugin""))
				{
					for (int j = 0; j < entries.size(); j++)
					{
						Entry temp = (Entry)entries.get(j);
						if (temp.plugin == dep.plugin)
						{
							if (value)
							{
								temp.parents.add(entry);
								setValueAt(Boolean.TRUE,j,0);
							}
							else
								temp.parents.remove(entry);
						}
					}
				}
			}
			entry.install = Boolean.TRUE.equals(aValue);
			fireTableCellUpdated(row,column);
		} //}}}
		//{{{ sort() method
		public void sort(int type)
		{
			this.sortType = type;
			if(isDownloadingList())
				return;
			Collections.sort(entries,new EntryCompare(type));
			fireTableChanged(new TableModelEvent(this));
		}
		//}}}
		//{{{ isDownloadingList() method
		private boolean isDownloadingList()
		{
			return (entries.size() == 1 && entries.get(0) instanceof String);
		} //}}}
		//{{{ clear() method
		public void clear()
		{
			entries = new ArrayList();
			fireTableChanged(new TableModelEvent(this));
		} //}}}
		//{{{ update() method
		public void update()
		{
			PluginList pluginList = window.getPluginList();
			if (pluginList == null) return;
			entries = new ArrayList();
			for(int i = 0; i < pluginList.pluginSets.size(); i++)
			{
				PluginList.PluginSet set = (PluginList.PluginSet)
					pluginList.pluginSets.get(i);
				for(int j = 0; j < set.plugins.size(); j++)
				{
					PluginList.Plugin plugin = (PluginList.Plugin)
						pluginList.pluginHash.get(set.plugins.get(j));
					PluginList.Branch branch = plugin.getCompatibleBranch();
					String installedVersion =
						plugin.getInstalledVersion();
					if (updates)
					{
						if(branch != null
							&& branch.canSatisfyDependencies()
							&& installedVersion != null
							&& MiscUtilities.compareStrings(branch.version,
							installedVersion,false) > 0)
						{
							entries.add(new Entry(plugin,set.name));
						}
					}
					else
					{
						if(installedVersion == null && plugin.canBeInstalled())
							entries.add(new Entry(plugin,set.name));
					}
				}
			}
			sort(sortType);
			fireTableChanged(new TableModelEvent(this));
		} //}}}
	} //}}}
	//{{{ Entry class
	class Entry
	{
		String name, version, author, date, description, set;
		int size;
		boolean install;
		PluginList.Plugin plugin;
		LinkedList parents = new LinkedList();
		Entry(PluginList.Plugin plugin, String set)
		{
			PluginList.Branch branch = plugin.getCompatibleBranch();
			boolean downloadSource = jEdit.getBooleanProperty(""plugin-manager.downloadSource"");
			int size = (downloadSource) ? branch.downloadSourceSize : branch.downloadSize;
			this.name = plugin.name;
			this.author = plugin.author;
			this.version = branch.version;
			this.size = size;
			this.date = branch.date;
			this.description = plugin.description;
			this.set = set;
			this.install = false;
			this.plugin = plugin;
		}
		String getParentString()
		{
			StringBuffer buf = new StringBuffer();
			Iterator iter = parents.iterator();
			while(iter.hasNext())
			{
				buf.append(((Entry)iter.next()).name);
				if(iter.hasNext())
					buf.append('\n');
			}
			return buf.toString();
		}
	} //}}}
	//{{{ PluginInfoBox class
	class PluginInfoBox extends JTextArea implements ListSelectionListener
	{
		public PluginInfoBox()
		{
			setEditable(false);
			setLineWrap(true);
			setWrapStyleWord(true);
			table.getSelectionModel().addListSelectionListener(this);
		}
		public void valueChanged(ListSelectionEvent e)
		{
			String text = """";
			if (table.getSelectedRowCount() == 1)
			{
				Entry entry = (Entry)pluginModel.entries
					.get(table.getSelectedRow());
				text = jEdit.getProperty(""install-plugins.info"",
					new String[] {entry.author,entry.date,entry.description});
			}
			setText(text);
			setCaretPosition(0);
		}
	} //}}}
	//{{{ SizeLabel class
	class SizeLabel extends JLabel implements TableModelListener
	{
		private int size;
		public SizeLabel()
		{
			size = 0;
			setText(jEdit.getProperty(""install-plugins.totalSize"")+formatSize(size));
			pluginModel.addTableModelListener(this);
		}
		public void tableChanged(TableModelEvent e)
		{
			if (e.getType() == TableModelEvent.UPDATE)
			{
				if(pluginModel.isDownloadingList())
					return;
				size = 0;
				int length = pluginModel.getRowCount();
				for (int i = 0; i < length; i++)
				{
					Entry entry = (Entry)pluginModel
						.entries.get(i);
					if (entry.install)
						size += entry.size;
				}
				setText(jEdit.getProperty(""install-plugins.totalSize"")+formatSize(size));
			}
		}
	} //}}}
	//{{{ SelectallButton class
	class SelectallButton extends JCheckBox implements ActionListener, TableModelListener
	{
		public SelectallButton()
		{
			super(jEdit.getProperty(""install-plugins.select-all""));
			addActionListener(this);
			pluginModel.addTableModelListener(this);
			setEnabled(false);
		}
		public void actionPerformed(ActionEvent evt)
		{
			pluginModel.setSelectAll(isSelected());
		}
		public void tableChanged(TableModelEvent e)
		{
			if(pluginModel.isDownloadingList())
				return;
			setEnabled(pluginModel.getRowCount() != 0);
			if (e.getType() == TableModelEvent.UPDATE)
			{
				int length = pluginModel.getRowCount();
				for (int i = 0; i < length; i++)
					if (!((Boolean)pluginModel.getValueAt(i,0)).booleanValue())
					{
						setSelected(false);
						return;
					}
				if (length > 0)
					setSelected(true);
			}
		}
	} //}}}
	//{{{ InstallButton class
	class InstallButton extends JButton implements ActionListener, TableModelListener
	{
		public InstallButton()
		{
			super(jEdit.getProperty(""install-plugins.install""));
			pluginModel.addTableModelListener(this);
			addActionListener(this);
			setEnabled(false);
		}
		public void actionPerformed(ActionEvent evt)
		{
			if(pluginModel.isDownloadingList())
				return;
			boolean downloadSource = jEdit.getBooleanProperty(
				""plugin-manager.downloadSource"");
			boolean installUser = jEdit.getBooleanProperty(
				""plugin-manager.installUser"");
			Roster roster = new Roster();
			String installDirectory;
			if(installUser)
			{
				installDirectory = MiscUtilities.constructPath(
					jEdit.getSettingsDirectory(),""jars"");
			}
			else
			{
				installDirectory = MiscUtilities.constructPath(
					jEdit.getJEditHome(),""jars"");
			}
			int length = pluginModel.getRowCount();
			int instcount = 0;
			for (int i = 0; i < length; i++)
			{
				Entry entry = (Entry)pluginModel.entries.get(i);
				if (entry.install)
				{
					entry.plugin.install(roster,installDirectory,downloadSource);
					if (updates)
						entry.plugin.getCompatibleBranch().satisfyDependencies(
						roster,installDirectory,downloadSource);
					instcount++;
				}
			}
			if(roster.isEmpty())
				return;
			boolean cancel = false;
			if (updates && roster.getOperationCount() > instcount)
				if (GUIUtilities.confirm(window,
					""install-plugins.depend"",
					null,
					JOptionPane.OK_CANCEL_OPTION,
					JOptionPane.WARNING_MESSAGE) == JOptionPane.CANCEL_OPTION)
					cancel = true;
			if (!cancel)
			{
				new PluginManagerProgress(window,roster);
				roster.performOperationsInAWTThread(window);
				pluginModel.update();
			}
		}
		public void tableChanged(TableModelEvent e)
		{
			if(pluginModel.isDownloadingList())
				return;
			if (e.getType() == TableModelEvent.UPDATE)
			{
				int length = pluginModel.getRowCount();
				for (int i = 0; i < length; i++)
					if (((Boolean)pluginModel.getValueAt(i,0)).booleanValue())
					{
						setEnabled(true);
						return;
					}
				setEnabled(false);
			}
		}
	} //}}}
	//{{{ EntryCompare class
	static class EntryCompare implements Comparator
	{
		public static final int NAME = 0;
		public static final int CATEGORY = 1;
		private int type;
		public EntryCompare(int type)
		{
			this.type = type;
		}
		public int compare(Object o1, Object o2)
		{
			InstallPanel.Entry e1 = (InstallPanel.Entry)o1;
			InstallPanel.Entry e2 = (InstallPanel.Entry)o2;
			if (type == NAME)
				return e1.name.compareToIgnoreCase(e2.name);
			else
			{
				int result;
				if ((result = e1.set.compareToIgnoreCase(e2.set)) == 0)
					return e1.name.compareToIgnoreCase(e2.name);
				return result;
			}
		}
	} //}}}
	//{{{ HeaderMouseHandler class
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(table.getTableHeader().columnAtPoint(evt.getPoint()))
			{
				case 1:
					pluginModel.sort(EntryCompare.NAME);
					break;
				case 2:
					pluginModel.sort(EntryCompare.CATEGORY);
					break;
				default:
			}
		}
	} //}}}
	//{{{ TextRenderer
	class TextRenderer extends DefaultTableCellRenderer
	{
		private DefaultTableCellRenderer tcr;
		public TextRenderer(DefaultTableCellRenderer tcr)
		{
			this.tcr = tcr;
		}
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			return tcr.getTableCellRendererComponent(table,value,isSelected,false,row,column);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.pluginmgr.ManagePanel,"/*
 * ManagePanel.java - Manages plugins
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.io.File;
import java.net.URL;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.help.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class ManagePanel extends JPanel
{
	//{{{ ManagePanel constructor
	public ManagePanel(PluginManager window)
	{
		super(new BorderLayout(12,12));
		this.window = window;
		setBorder(new EmptyBorder(12,12,12,12));
		Box topBox = new Box(BoxLayout.X_AXIS);
		topBox.add(hideLibraries = new HideLibrariesButton());
		add(BorderLayout.NORTH,topBox);
		/* Create the plugin table */
		table = new JTable(pluginModel = new PluginTableModel());
		table.setShowGrid(false);
		table.setIntercellSpacing(new Dimension(0,0));
		table.setRowHeight(table.getRowHeight() + 2);
		table.setPreferredScrollableViewportSize(new Dimension(500,300));
		table.setRequestFocusEnabled(false);
		table.setDefaultRenderer(Object.class, new TextRenderer(
			(DefaultTableCellRenderer)table.getDefaultRenderer(Object.class)));
		TableColumn col1 = table.getColumnModel().getColumn(0);
		TableColumn col2 = table.getColumnModel().getColumn(1);
		TableColumn col3 = table.getColumnModel().getColumn(2);
		TableColumn col4 = table.getColumnModel().getColumn(3);
		col1.setPreferredWidth(30);
		col1.setMinWidth(30);
		col1.setMaxWidth(30);
		col1.setResizable(false);
		col2.setPreferredWidth(300);
		col3.setPreferredWidth(100);
		col4.setPreferredWidth(100);
		JTableHeader header = table.getTableHeader();
		header.setReorderingAllowed(false);
		header.addMouseListener(new HeaderMouseHandler());
		JScrollPane scrollpane = new JScrollPane(table);
		scrollpane.getViewport().setBackground(table.getBackground());
		add(BorderLayout.CENTER,scrollpane);
		/* Create button panel */
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(new RemoveButton());
		buttons.add(Box.createGlue());
		buttons.add(new HelpButton());
		add(BorderLayout.SOUTH,buttons);
	} //}}}
	//{{{ update() method
	public void update()
	{
		pluginModel.update();
	} //}}}
	//{{{ Private members
	private JCheckBox hideLibraries;
	private JTable table;
	private PluginTableModel pluginModel;
	private PluginManager window;
	//{{{ showListConfirm() method
	private int showListConfirm(String name, String[] args,
		Vector listModel)
	{
		JList list = new JList(listModel);
		list.setVisibleRowCount(8);
		Object[] message = {
			jEdit.getProperty(name + "".message"",args),
			new JScrollPane(list)
		};
		return JOptionPane.showConfirmDialog(window,
			message,
			jEdit.getProperty(name + "".title""),
			JOptionPane.YES_NO_OPTION,
			JOptionPane.QUESTION_MESSAGE);
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ Entry class
	class Entry
	{
		static final String ERROR = ""error"";
		static final String LOADED = ""loaded"";
		static final String NOT_LOADED = ""not-loaded"";
		String status;
		String jar;
		String clazz, name, version, author, docs;
		List jars;
		Entry(String jar)
		{
			jars = new LinkedList();
			this.jar = jar;
			jars.add(this.jar);
			status = NOT_LOADED;
		}
		Entry(PluginJAR jar)
		{
			jars = new LinkedList();
			this.jar = jar.getPath();
			jars.add(this.jar);
			EditPlugin plugin = jar.getPlugin();
			if(plugin != null)
			{
				status = (plugin instanceof EditPlugin.Broken
					? ERROR : LOADED);
				clazz = plugin.getClassName();
				name = jEdit.getProperty(""plugin.""+clazz+"".name"");
				version = jEdit.getProperty(""plugin.""+clazz+"".version"");
				author = jEdit.getProperty(""plugin.""+clazz+"".author"");
				docs = jEdit.getProperty(""plugin.""+clazz+"".docs"");
				String jarsProp = jEdit.getProperty(""plugin.""+clazz+"".jars"");
				if(jarsProp != null)
				{
					String directory = MiscUtilities.getParentOfPath(this.jar);
					StringTokenizer st = new StringTokenizer(jarsProp);
					while(st.hasMoreElements())
					{
						jars.add(MiscUtilities.constructPath(
							directory,st.nextToken()));
					}
				}
			}
			else
				status = LOADED;
		}
	} //}}}
	//{{{ PluginTableModel class
	class PluginTableModel extends AbstractTableModel
	{
		private List entries;
		private int sortType = EntryCompare.NAME;
		//{{{ Constructor
		public PluginTableModel()
		{
			entries = new ArrayList();
			update();
		} //}}}
		//{{{ getColumnCount() method
		public int getColumnCount()
		{
			return 4;
		} //}}}
		//{{{ getColumnClass() method
		public Class getColumnClass(int columnIndex)
		{
			switch (columnIndex)
			{
				case 0: return Boolean.class;
				default: return Object.class;
			}
		} //}}}
		//{{{ getColumnName() method
		public String getColumnName(int column)
		{
			switch (column)
			{
				case 0:
					return "" "";
				case 1:
					return jEdit.getProperty(""manage-plugins.info.name"");
				case 2:
					return jEdit.getProperty(""manage-plugins.info.version"");
				case 3:
					return jEdit.getProperty(""manage-plugins.info.status"");
				default:
					throw new Error(""Column out of range"");
			}
		} //}}}
		//{{{ getEntry() method
		public Entry getEntry(int rowIndex)
		{
			return (Entry)entries.get(rowIndex);
		} //}}}
		//{{{ getRowCount() method
		public int getRowCount()
		{
			return entries.size();
		} //}}}
		//{{{ getValueAt() method
		public Object getValueAt(int rowIndex,int columnIndex)
		{
			Entry entry = (Entry)entries.get(rowIndex);
			switch (columnIndex)
			{
				case 0:
					return new Boolean(
						!entry.status.equals(
						Entry.NOT_LOADED));
				case 1:
					if(entry.name == null)
					{
						return MiscUtilities.getFileName(entry.jar);
					}
					else
						return entry.name;
				case 2:
					return entry.version;
				case 3:
					return jEdit.getProperty(""plugin-manager.status.""
						+ entry.status);
				default:
					throw new Error(""Column out of range"");
			}
		} //}}}
		//{{{ isCellEditable() method
		public boolean isCellEditable(int rowIndex, int columnIndex)
		{
			return columnIndex == 0;
		} //}}}
		//{{{ setValueAt() method
		public void setValueAt(Object value, int rowIndex,
			int columnIndex)
		{
			Entry entry = (Entry)entries.get(rowIndex);
			if(columnIndex == 0)
			{
				PluginJAR jar = jEdit.getPluginJAR(entry.jar);
				if(jar == null)
				{
					if(value.equals(Boolean.FALSE))
						return;
					loadPluginJAR(entry.jar);
				}
				else
				{
					if(value.equals(Boolean.TRUE))
						return;
					unloadPluginJARWithDialog(jar);
				}
			}
			update();
		} //}}}
		//{{{ setSortType() method
		public void setSortType(int type)
		{
			sortType = type;
			sort(type);
		} //}}}
		//{{{ sort() method
		public void sort(int type)
		{
			Collections.sort(entries,new EntryCompare(type));
			fireTableChanged(new TableModelEvent(this));
		}
		//}}}
		//{{{ update() method
		public void update()
		{
			entries.clear();
			String systemJarDir = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""jars"");
			String userJarDir;
			if(jEdit.getSettingsDirectory() == null)
				userJarDir = null;
			else
			{
				userJarDir = MiscUtilities.constructPath(
					jEdit.getSettingsDirectory(),""jars"");
			}
			PluginJAR[] plugins = jEdit.getPluginJARs();
			for(int i = 0; i < plugins.length; i++)
			{
				String path = plugins[i].getPath();
				if(path.startsWith(systemJarDir)
					|| (userJarDir != null
					&& path.startsWith(userJarDir)))
				{
					Entry e = new Entry(plugins[i]);
					if(!hideLibraries.isSelected()
						|| e.clazz != null)
					{
						entries.add(e);
					}
				}
			}
			String[] newPlugins = jEdit.getNotLoadedPluginJARs();
			for(int i = 0; i < newPlugins.length; i++)
			{
				Entry e = new Entry(newPlugins[i]);
				entries.add(e);
			}
			sort(sortType);
		} //}}}
		//{{{ loadExtraJARsIfNecessary() method
		/**
		 * This should go into the core...
		 */
		private void loadPluginJAR(String jarPath)
		{
			jEdit.addPluginJAR(jarPath);
			PluginJAR jar = jEdit.getPluginJAR(jarPath);
			if(jar == null || jar.getPlugin() == null)
				return;
			String jars = jEdit.getProperty(""plugin.""
				+ jar.getPlugin().getClassName() + "".jars"");
			if(jars != null)
			{
				String dir = MiscUtilities.getParentOfPath(
					jarPath);
				StringTokenizer st = new StringTokenizer(jars);
				while(st.hasMoreTokens())
				{
					String _jarPath
						= MiscUtilities.constructPath(
						dir,st.nextToken());
					PluginJAR _jar = jEdit.getPluginJAR(
						_jarPath);
					if(_jar == null)
					{
						jEdit.addPluginJAR(_jarPath);
					}
				}
			}
			jar.checkDependencies();
			jar.activatePluginIfNecessary();
		} //}}}
		//{{{ unloadPluginJARWithDialog() method
		private void unloadPluginJARWithDialog(PluginJAR jar)
		{
			String[] dependents = jar.getDependentPlugins();
			if(dependents.length == 0)
				unloadPluginJAR(jar);
			else
			{
				Vector listModel = new Vector();
				transitiveClosure(dependents,listModel);
				int button = showListConfirm(
					""plugin-manager.dependency"",
					new String[] { jar.getFile()
					.getName() },listModel);
				if(button == JOptionPane.YES_OPTION)
					unloadPluginJAR(jar);
			}
		} //}}}
		//{{{ transitiveClosure() method
		/**
		 * If plugin A is needed by B, and B is needed by C, we want to
		 * tell the user that A is needed by B and C when they try to
		 * unload A.
		 */
		private void transitiveClosure(String[] dependents,
			Vector listModel)
		{
			for(int i = 0; i < dependents.length; i++)
			{
				String jarPath = dependents[i];
				if(!listModel.contains(jarPath))
				{
					listModel.add(jarPath);
					PluginJAR jar = jEdit.getPluginJAR(
						jarPath);
					transitiveClosure(jar.getDependentPlugins(),
						listModel);
				}
			}
		} //}}}
		//{{{ unloadPluginJAR() method
		/**
		 * This should go into a public method somewhere.
		 */
		private void unloadPluginJAR(PluginJAR jar)
		{
			String[] dependents = jar.getDependentPlugins();
			for(int i = 0; i < dependents.length; i++)
			{
				PluginJAR _jar = jEdit.getPluginJAR(
					dependents[i]);
				if(_jar != null)
				{
					unloadPluginJAR(_jar);
				}
			}
			jEdit.removePluginJAR(jar,false);
		} //}}}
	} //}}}
	//{{{ TextRenderer class
	class TextRenderer extends DefaultTableCellRenderer
	{
		private DefaultTableCellRenderer tcr;
		public TextRenderer(DefaultTableCellRenderer tcr)
		{
			this.tcr = tcr;
		}
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			Entry entry = pluginModel.getEntry(row);
			if (entry.status.equals(Entry.ERROR))
				tcr.setForeground(Color.red);
			else
				tcr.setForeground(UIManager.getColor(""Table.foreground""));
			return tcr.getTableCellRendererComponent(table,value,isSelected,false,row,column);
		}
	} //}}}
	//{{{ HideLibrariesButton class
	class HideLibrariesButton extends JCheckBox implements ActionListener
	{
		HideLibrariesButton()
		{
			super(jEdit.getProperty(""plugin-manager.hide-libraries""));
			setSelected(jEdit.getBooleanProperty(
				""plugin-manager.hide-libraries.toggle""));
			addActionListener(this);
		}
		public void actionPerformed(ActionEvent evt)
		{
			jEdit.setBooleanProperty(
				""plugin-manager.hide-libraries.toggle"",
				isSelected());
			ManagePanel.this.update();
		}
	} //}}}
	//{{{ RemoveButton class
	class RemoveButton extends JButton implements ListSelectionListener, ActionListener
	{
		public RemoveButton()
		{
			super(jEdit.getProperty(""manage-plugins.remove""));
			table.getSelectionModel().addListSelectionListener(this);
			addActionListener(this);
			setEnabled(false);
		}
		public void actionPerformed(ActionEvent evt)
		{
			int[] selected = table.getSelectedRows();
			Vector listModel = new Vector();
			Roster roster = new Roster();
			for(int i = 0; i < selected.length; i++)
			{
				Entry entry = pluginModel.getEntry(selected[i]);
				Iterator iter = entry.jars.iterator();
				while(iter.hasNext())
				{
					String jar = (String)iter.next();
					listModel.addElement(jar);
					roster.addRemove(jar);
				}
			}
			int button = showListConfirm(
				""plugin-manager.remove-confirm"",
				null,listModel);
			if(button == JOptionPane.YES_OPTION)
			{
				roster.performOperationsInAWTThread(window);
				pluginModel.update();
			}
		}
		public void valueChanged(ListSelectionEvent e)
		{
			if (table.getSelectedRowCount() == 0)
				setEnabled(false);
			else
				setEnabled(true);
		}
	} //}}}
	//{{{ HelpButton class
	class HelpButton extends JButton implements ListSelectionListener, ActionListener
	{
		private URL docURL;
		public HelpButton()
		{
			super(jEdit.getProperty(""manage-plugins.help""));
			table.getSelectionModel().addListSelectionListener(this);
			addActionListener(this);
			setEnabled(false);
		}
		public void actionPerformed(ActionEvent evt)
		{
			new HelpViewer(docURL);
		}
		public void valueChanged(ListSelectionEvent e)
		{
			if (table.getSelectedRowCount() == 1)
			{
				try
				{
					Entry entry = pluginModel.getEntry(table.getSelectedRow());
					String label = entry.clazz;
					String docs = entry.docs;
					PluginJAR jar = jEdit.getPlugin(label)
						.getPluginJAR();
					if(jar != null && label != null && docs != null)
					{
						URL url = jar.getClassLoader()
							.getResource(docs);
						if(url != null)
						{
							docURL = url;
							setEnabled(true);
							return;
						}
					}
				}
				catch (Exception ex) {}
			}
			setEnabled(false);
		}
	} //}}}
	//{{{ EntryCompare class
	static class EntryCompare implements Comparator
	{
		public static final int NAME = 1;
		public static final int STATUS = 2;
		private int type;
		public EntryCompare(int type)
		{
			this.type = type;
		}
		public int compare(Object o1, Object o2)
		{
			ManagePanel.Entry e1 = (ManagePanel.Entry)o1;
			ManagePanel.Entry e2 = (ManagePanel.Entry)o2;
			if (type == NAME)
				return compareNames(e1,e2);
			else
			{
				int result;
				if ((result = e1.status.compareToIgnoreCase(e2.status)) == 0)
					return compareNames(e1,e2);
				return result;
			}
		}
		private int compareNames(ManagePanel.Entry e1, ManagePanel.Entry e2)
		{
			String s1, s2;
			if(e1.name == null)
				s1 = MiscUtilities.getFileName(e1.jar);
			else
				s1 = e1.name;
			if(e2.name == null)
				s2 = MiscUtilities.getFileName(e2.jar);
			else
				s2 = e2.name;
			return s1.compareToIgnoreCase(s2);
		}
	} //}}}
	//{{{ HeaderMouseHandler class
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(table.getTableHeader().columnAtPoint(evt.getPoint()))
			{
				case 1:
					pluginModel.setSortType(EntryCompare.NAME);
					break;
				case 3:
					pluginModel.setSortType(EntryCompare.STATUS);
					break;
				default:
					break;
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.pluginmgr.MirrorList,"/*
 * MirrorList.java - Mirrors list
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import com.microstar.xml.*;
import java.io.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.*;
public class MirrorList
{
	public ArrayList mirrors;
	//{{{ MirrorList constructor
	public MirrorList() throws Exception
	{
		mirrors = new ArrayList();
		Mirror none = new Mirror();
		none.id = Mirror.NONE;
		none.description = none.location = none.country = none.continent = """";
		mirrors.add(none);
		String path = jEdit.getProperty(""plugin-manager.mirror-url"");
		MirrorListHandler handler = new MirrorListHandler(this,path);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		Reader in = new BufferedReader(new InputStreamReader(
			new URL(path).openStream()));
		try
		{
			parser.parse(null,null,in);
		}
		finally
		{
			in.close();
		}
	} //}}}
	//{{{ Private members
	//{{{ add() method
	void add(Mirror mirror)
	{
		mirrors.add(mirror);
	} //}}}
	//{{{ finished() method
	void finished()
	{
		Collections.sort(mirrors,new MirrorCompare());
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ Mirror class
	public static class Mirror
	{
		public static final String NONE = ""NONE"";
		public String id;
		public String description;
		public String location;
		public String country;
		public String continent;
	} //}}}
	//{{{ MirrorCompare class
	class MirrorCompare implements Comparator
	{
		public int compare(Object o1,Object o2)
		{
			Mirror m1 = (Mirror)o1;
			Mirror m2 = (Mirror)o2;
			int result;
			if ((result = m1.continent.compareToIgnoreCase(m2.continent)) == 0)
				if ((result = m1.country.compareToIgnoreCase(m2.country)) == 0)
					if ((result = m1.location.compareToIgnoreCase(m2.location)) == 0)
						return m1.description.compareToIgnoreCase(m2.description);
			return result;
		}
		public boolean equals(Object obj)
		{
			return (obj instanceof MirrorCompare);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.pluginmgr.MirrorListHandler,"/*
 * MirrorListHandler.java - XML handler for the mirrors list
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki (parts copied from Slava Pestov :) )
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import com.microstar.xml.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.util.Log;
class MirrorListHandler extends HandlerBase
{
	//{{{ Constructor
	MirrorListHandler(MirrorList mirrors, String path)
	{
		this.mirrors = mirrors;
		this.path = path;
		stateStack = new Stack();
	} //}}}
	//{{{ resolveEntity() method
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""mirrors.dtd"".equals(systemId))
		{
			// this will result in a slight speed up, since we
			// don't need to read the DTD anyway, as AElfred is
			// non-validating
			return new StringReader(""<!-- -->"");
		}
		return null;
	} //}}}
	//{{{ attribute() method
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();
		if(aname == ""ID"")
			id = value;
	} //}}}
	//{{{ doctypeDecl() method
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""MIRRORS"".equals(name))
			return;
		Log.log(Log.ERROR,this,path + "": DOCTYPE must be MIRRORS"");
	} //}}}
	//{{{ charData() method
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if(tag == ""DESCRIPTION"")
			description = text;
		else if(tag == ""LOCATION"")
			location = text;
		else if(tag == ""COUNTRY"")
			country = text;
		else if(tag == ""CONTINENT"")
			continent = text;
	} //}}}
	//{{{ startElement() method
	public void startElement(String tag)
	{
		tag = pushElement(tag);
		if(tag == ""MIRROR"")
			mirror = new MirrorList.Mirror();
	} //}}}
	//{{{ endElement() method
	public void endElement(String tag)
	{
		if(tag == null)
			return;
		else
			tag = tag.intern();
		popElement();
		if(tag == ""MIRROR"")
		{
			mirror.id = id;
			mirror.description = description;
			mirror.location = location;
			mirror.country = country;
			mirror.continent = continent;
			mirrors.add(mirror);
		}
	} //}}}
	//{{{ startDocument() method
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	} //}}}
	//{{{ endDocument() method
	public void endDocument()
	{
		mirrors.finished();
	} //}}}
	//{{{ Private members
	//{{{ Variables
	private String id;
	private String description;
	private String location;
	private String country;
	private String continent;
	private MirrorList mirrors;
	private MirrorList.Mirror mirror;
	private Stack stateStack;
	private String path;
	//}}}
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	}
	private String peekElement()
	{
		return (String) stateStack.peek();
	}
	private String popElement()
	{
		return (String) stateStack.pop();
	}
	//}}}
}
"
org.gjt.sp.jedit.pluginmgr.PluginList,"/*
 * PluginList.java - Plugin list downloaded from server
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
//{{{ Imports
import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.Hashtable;
import java.util.Vector;
import java.util.zip.GZIPInputStream;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.*;
//}}}
/**
 * Plugin list downloaded from server.
 * @since jEdit 3.2pre2
 */
class PluginList
{
	/**
	 * Magic numbers used for auto-detecting GZIP files.
	 */
	public static final int GZIP_MAGIC_1 = 0x1f;
	public static final int GZIP_MAGIC_2 = 0x8b;
	Vector plugins;
	Hashtable pluginHash;
	Vector pluginSets;
	//{{{ PluginList constructor
	PluginList() throws Exception
	{
		plugins = new Vector();
		pluginHash = new Hashtable();
		pluginSets = new Vector();
		String path = jEdit.getProperty(""plugin-manager.export-url"");
		String id = jEdit.getProperty(""plugin-manager.mirror.id"");
		if (!id.equals(MirrorList.Mirror.NONE))
			path += ""?mirror=""+id;
		PluginListHandler handler = new PluginListHandler(this,path);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		InputStream in = new BufferedInputStream(new URL(path).openStream());
		try
		{
			if(in.markSupported())
			{
				in.mark(2);
				int b1 = in.read();
				int b2 = in.read();
				in.reset();
				if(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)
					in = new GZIPInputStream(in);
			}
			parser.parse(null,null,new InputStreamReader(in,""UTF8""));
		}
		finally
		{
			in.close();
		}
	} //}}}
	//{{{ addPlugin() method
	void addPlugin(Plugin plugin)
	{
		plugin.checkIfInstalled();
		plugins.addElement(plugin);
		pluginHash.put(plugin.name,plugin);
	} //}}}
	//{{{ addPluginSet() method
	void addPluginSet(PluginSet set)
	{
		pluginSets.addElement(set);
	} //}}}
	//{{{ finished() method
	void finished()
	{
		// after the entire list is loaded, fill out plugin field
		// in dependencies
		for(int i = 0; i < plugins.size(); i++)
		{
			Plugin plugin = (Plugin)plugins.elementAt(i);
			for(int j = 0; j < plugin.branches.size(); j++)
			{
				Branch branch = (Branch)plugin.branches.elementAt(j);
				for(int k = 0; k < branch.deps.size(); k++)
				{
					Dependency dep = (Dependency)branch.deps.elementAt(k);
					if(dep.what.equals(""plugin""))
						dep.plugin = (Plugin)pluginHash.get(dep.pluginName);
				}
			}
		}
	} //}}}
	//{{{ dump() method
	void dump()
	{
		for(int i = 0; i < plugins.size(); i++)
		{
			System.err.println((Plugin)plugins.elementAt(i));
			System.err.println();
		}
	} //}}}
	//{{{ PluginSet class
	static class PluginSet
	{
		String name;
		String description;
		Vector plugins = new Vector();
		public String toString()
		{
			return plugins.toString();
		}
	} //}}}
	//{{{ Plugin class
	static public class Plugin
	{
		String jar;
		String name;
		String description;
		String author;
		Vector branches = new Vector();
		//String installed;
		//String installedVersion;
		void checkIfInstalled()
		{
			/* // check if the plugin is already installed.
			// this is a bit of hack
			PluginJAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();
				if(!new File(path).exists())
					continue;
				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;
					EditPlugin plugin = jars[i].getPlugin();
					if(plugin != null)
					{
						installedVersion = jEdit.getProperty(
							""plugin."" + plugin.getClassName()
							+ "".version"");
					}
					break;
				}
			}
			String[] notLoaded = jEdit.getNotLoadedPluginJARs();
			for(int i = 0; i < notLoaded.length; i++)
			{
				String path = notLoaded[i];
				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;
					break;
				}
			} */
		}
		String getInstalledVersion()
		{
			PluginJAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();
				if(MiscUtilities.getFileName(path).equals(jar))
				{
					EditPlugin plugin = jars[i].getPlugin();
					if(plugin != null)
					{
						return jEdit.getProperty(
							""plugin."" + plugin.getClassName()
							+ "".version"");
					}
					else
						return null;
				}
			}
			return null;
		}
		String getInstalledPath()
		{
			PluginJAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();
				if(MiscUtilities.getFileName(path).equals(jar))
					return path;
			}
			return null;
		}
		/**
		 * Find the first branch compatible with the running jEdit release.
		 */
		Branch getCompatibleBranch()
		{
			for(int i = 0; i < branches.size(); i++)
			{
				Branch branch = (Branch)branches.elementAt(i);
				if(branch.canSatisfyDependencies())
					return branch;
			}
			return null;
		}
		boolean canBeInstalled()
		{
			Branch branch = getCompatibleBranch();
			return branch != null && !branch.obsolete
				&& branch.canSatisfyDependencies();
		}
		void install(Roster roster, String installDirectory, boolean downloadSource)
		{
			String installed = getInstalledPath();
			Branch branch = getCompatibleBranch();
			if(branch.obsolete)
			{
				if(installed != null)
					roster.addRemove(installed);
				return;
			}
			//branch.satisfyDependencies(roster,installDirectory,
			//	downloadSource);
			if(installed != null)
			{
				installDirectory = MiscUtilities.getParentOfPath(
					installed);
			}
			roster.addInstall(
				installed,
				(downloadSource ? branch.downloadSource : branch.download),
				installDirectory,
				(downloadSource ? branch.downloadSourceSize : branch.downloadSize));
		}
		public String toString()
		{
			return name;
		}
	} //}}}
	//{{{ Branch class
	static class Branch
	{
		String version;
		String date;
		int downloadSize;
		String download;
		int downloadSourceSize;
		String downloadSource;
		boolean obsolete;
		Vector deps = new Vector();
		boolean canSatisfyDependencies()
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				if(!dep.canSatisfy())
					return false;
			}
			return true;
		}
		void satisfyDependencies(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				dep.satisfy(roster,installDirectory,downloadSource);
			}
		}
		public String toString()
		{
			return ""[version="" + version + "",download="" + download
				+ "",obsolete="" + obsolete + "",deps="" + deps + ""]"";
		}
	} //}}}
	//{{{ Dependency class
	static class Dependency
	{
		String what;
		String from;
		String to;
		// only used if what is ""plugin""
		String pluginName;
		Plugin plugin;
		Dependency(String what, String from, String to, String pluginName)
		{
			this.what = what;
			this.from = from;
			this.to = to;
			this.pluginName = pluginName;
		}
		boolean isSatisfied()
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					String installedVersion = plugin.getInstalledVersion();
					if(installedVersion != null
						&&
					(from == null || MiscUtilities.compareStrings(
						installedVersion,from,false) >= 0)
						&&
					   (to == null || MiscUtilities.compareStrings(
					   	installedVersion,to,false) <= 0))
					{
						return true;
					}
				}
				return false;
			}
			else if(what.equals(""jdk""))
			{
				String javaVersion = System.getProperty(""java.version"").substring(0,3);
				if((from == null || MiscUtilities.compareStrings(
					javaVersion,from,false) >= 0)
					&&
				   (to == null || MiscUtilities.compareStrings(
				   	javaVersion,to,false) <= 0))
					return true;
				else
					return false;
			}
			else if(what.equals(""jedit""))
			{
				String build = jEdit.getBuild();
				if((from == null || MiscUtilities.compareStrings(
					build,from,false) >= 0)
					&&
				   (to == null || MiscUtilities.compareStrings(
				   	build,to,false) <= 0))
					return true;
				else
					return false;
			}
			else
			{
				Log.log(Log.ERROR,this,""Invalid dependency: "" + what);
				return false;
			}
		}
		boolean canSatisfy()
		{
			if(isSatisfied())
				return true;
			else if(what.equals(""plugin""))
			{
				return plugin.canBeInstalled();
			}
			else
				return false;
		}
		void satisfy(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			if(what.equals(""plugin""))
			{
				String installedVersion = plugin.getInstalledVersion();
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = (Branch)plugin.branches
						.elementAt(i);
					if((installedVersion == null
						||
					MiscUtilities.compareStrings(
						installedVersion,branch.version,false) < 0)
						&&
					(from == null || MiscUtilities.compareStrings(
						branch.version,from,false) >= 0)
						&&
					   (to == null || MiscUtilities.compareStrings(
					   	branch.version,to,false) <= 0))
					{
						plugin.install(roster,installDirectory,
							downloadSource);
						return;
					}
				}
			}
		}
		public String toString()
		{
			return ""[what="" + what + "",from="" + from
				+ "",to="" + to + "",plugin="" + plugin + ""]"";
		}
	} //}}}
}
"
org.gjt.sp.jedit.pluginmgr.PluginListHandler,"/*
 * PluginListHandler.java - XML handler for the plugin list
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;
class PluginListHandler extends HandlerBase
{
	PluginListHandler(PluginList pluginList, String path)
	{
		this.pluginList = pluginList;
		this.path = path;
		stateStack = new Stack();
	}
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""plugins.dtd"".equals(systemId))
		{
			// this will result in a slight speed up, since we
			// don't need to read the DTD anyway, as AElfred is
			// non-validating
			return new StringReader(""<!-- -->"");
			/* try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(
					""/org/gjt/sp/jedit/pluginmgr/plugins.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" plugins.dtd:"");
				Log.log(Log.ERROR,this,e);
			} */
		}
		return null;
	}
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();
		if(aname == ""NAME"")
			name = value;
		else if(aname == ""JAR"")
			jar = value;
		else if(aname == ""VERSION"")
			version = value;
		else if(aname == ""DATE"")
			date = value;
		else if(aname == ""OBSOLETE"")
			obsolete = (""TRUE"".equals(value));
		else if(aname == ""WHAT"")
			depWhat = value;
		else if(aname == ""FROM"")
			depFrom = value;
		else if(aname == ""TO"")
			depTo = value;
		else if(aname == ""PLUGIN"")
			depPlugin = value;
		else if(aname == ""SIZE"")
		{
			size = Integer.parseInt(value);
			if(size == 0)
				Log.log(Log.WARNING,this,""SIZE = 0"");
		}
	}
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""PLUGINS"".equals(name))
			return;
		Log.log(Log.ERROR,this,path + "": DOCTYPE must be PLUGINS"");
	}
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if(tag == ""DESCRIPTION"")
		{
			description = text;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
			pluginSetEntry = text;
		else if(tag == ""AUTHOR"")
		{
			if(author != null && author.length() != 0)
				author = author + "", "" + text;
			else
				author = text;
		}
		else if(tag == ""DOWNLOAD"")
			download = text;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSource = text;
	}
	public void startElement(String tag)
	{
		tag = pushElement(tag);
		if(tag == ""PLUGIN_SET"")
		{
			description = null;
			pluginSet = new PluginList.PluginSet();
			pluginSet.name = name;
		}
		else if(tag == ""PLUGIN"")
		{
			description = null;
			author = null;
			branch = null;
			plugin = new PluginList.Plugin();
		}
		else if(tag == ""BRANCH"")
		{
			download = null;
			branch = new PluginList.Branch();
		}
		else if(tag == ""DOWNLOAD"")
			downloadSize = size;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSourceSize = size;
	}
	public void endElement(String tag)
	{
		if(tag == null)
			return;
		else
			tag = tag.intern();
		popElement();
		if(tag == ""PLUGIN_SET"")
		{
			pluginList.addPluginSet(pluginSet);
			pluginSet = null;
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
		{
			pluginSet.plugins.addElement(pluginSetEntry);
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN"")
		{
			plugin.jar = jar;
			plugin.name = name;
			plugin.author = author;
			plugin.description = description;
			pluginList.addPlugin(plugin);
			jar = null;
			name = null;
			author = null;
		}
		else if(tag == ""BRANCH"")
		{
			branch.version = version;
			branch.date = date;
			branch.download = download;
			branch.downloadSize = downloadSize;
			branch.downloadSource = downloadSource;
			branch.downloadSourceSize = downloadSourceSize;
			branch.obsolete = obsolete;
			plugin.branches.addElement(branch);
			version = null;
			download = null;
			obsolete = false;
		}
		else if(tag == ""DEPEND"")
		{
			PluginList.Dependency dep = new PluginList.Dependency(
				depWhat,depFrom,depTo,depPlugin);
			branch.deps.addElement(dep);
			depWhat = null;
			depFrom = null;
			depTo = null;
			depPlugin = null;
		}
	}
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	public void endDocument()
	{
		pluginList.finished();
	}
	// end HandlerBase implementation
	// private members
	private String path;
	private PluginList pluginList;
	private PluginList.PluginSet pluginSet;
	private String pluginSetEntry;
	private PluginList.Plugin plugin;
	private String jar;
	private String author;
	private PluginList.Branch branch;
	private boolean obsolete;
	private String version;
	private String date;
	private String download;
	private int downloadSize;
	private String downloadSource;
	private int downloadSourceSize;
	private int size;
	private String depWhat;
	private String depFrom;
	private String depTo;
	private String depPlugin;
	private String name;
	private String description;
	private Stack stateStack;
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	}
	private String peekElement()
	{
		return (String) stateStack.peek();
	}
	private String popElement()
	{
		return (String) stateStack.pop();
	}
}
"
org.gjt.sp.jedit.pluginmgr.PluginManager,"/*
 * PluginManager.java - Plugin manager window
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Kris Kopicki
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
//{{{ Imports
import com.microstar.xml.XmlException;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkRequest;
//}}}
public class PluginManager extends JFrame implements EBComponent
{
	//{{{ getInstance() method
	/**
	 * Returns the currently visible plugin manager window, or null.
	 * @since jEdit 4.2pre2
	 */
	public static PluginManager getInstance()
	{
		return instance;
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""plugin-manager"");
		instance = null;
		EditBus.removeFromBus(this);
		super.dispose();
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage message)
	{
		// Force the install tab to refresh for possible
		// change of mirror
		if (message instanceof PropertiesChanged)
		{
			pluginList = null;
			updatePluginList();
			if(tabPane.getSelectedIndex() != 0)
			{
				installer.updateModel();
				updater.updateModel();
			}
		}
		else if (message instanceof PluginUpdate)
		{
			if(!queuedUpdate)
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						queuedUpdate = false;
						manager.update();
					}
				});
				queuedUpdate = true;
			}
		}
	} //}}}
	//{{{ showPluginManager() method
	public static void showPluginManager(Frame frame)
	{
		if (instance == null)
			instance = new PluginManager();
		else
		{
			instance.toFront();
			return;
		}
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		dispose();
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		dispose();
	} //}}}
	//{{{ getPluginList() method
	public PluginList getPluginList()
	{
		return pluginList;
	} //}}}
	//{{{ Private members
	private static PluginManager instance;
	//{{{ Instance variables
	private JTabbedPane tabPane;
	private JButton done;
	private JButton mgrOptions;
	private JButton pluginOptions;
	private InstallPanel installer;
	private InstallPanel updater;
	private ManagePanel manager;
	private PluginList pluginList;
	private boolean queuedUpdate;
	private boolean downloadingPluginList;
	//}}}
	//{{{ PluginManager constructor
	private PluginManager()
	{
		super(jEdit.getProperty(""plugin-manager.title""));
		EditBus.addToBus(this);
		/* Setup panes */
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		tabPane = new JTabbedPane();
		tabPane.addTab(jEdit.getProperty(""manage-plugins.title""),
			manager = new ManagePanel(this));
		tabPane.addTab(jEdit.getProperty(""update-plugins.title""),
			updater = new InstallPanel(this,true));
		tabPane.addTab(jEdit.getProperty(""install-plugins.title""),
			installer = new InstallPanel(this,false));
		content.add(BorderLayout.CENTER,tabPane);
		tabPane.addChangeListener(new ListUpdater());
		/* Create the buttons */
		Box buttons = new Box(BoxLayout.X_AXIS);
		ActionListener al = new ActionHandler();
		mgrOptions = new JButton(jEdit.getProperty(""plugin-manager.mgr-options""));
		mgrOptions.addActionListener(al);
		pluginOptions = new JButton(jEdit.getProperty(""plugin-manager.plugin-options""));
		pluginOptions.addActionListener(al);
		done = new JButton(jEdit.getProperty(""plugin-manager.done""));
		done.addActionListener(al);
		buttons.add(Box.createGlue());
		buttons.add(mgrOptions);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(pluginOptions);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(done);
		buttons.add(Box.createGlue());
		getRootPane().setDefaultButton(done);
		content.add(BorderLayout.SOUTH,buttons);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		setIconImage(GUIUtilities.getPluginIcon());
		pack();
		GUIUtilities.loadGeometry(this,""plugin-manager"");
		setVisible(true);
	} //}}}
	//{{{ updatePluginList() method
	private void updatePluginList()
	{
		if(jEdit.getSettingsDirectory() == null
			&& jEdit.getJEditHome() == null)
		{
			GUIUtilities.error(this,""no-settings"",null);
			return;
		}
		else if(pluginList != null || downloadingPluginList)
		{
			return;
		}
		final Exception[] exception = new Exception[1];
		VFSManager.runInWorkThread(new WorkRequest()
		{
			public void run()
			{
				try
				{
					downloadingPluginList = true;
					setStatus(jEdit.getProperty(
						""plugin-manager.list-download""));
					pluginList = new PluginList();
				}
				catch(Exception e)
				{
					exception[0] = e;
				}
				finally
				{
					downloadingPluginList = false;
				}
			}
		});
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				if(exception[0] instanceof XmlException)
				{
					XmlException xe = (XmlException)
						exception[0];
					int line = xe.getLine();
					String path = jEdit.getProperty(
						""plugin-manager.export-url"");
					String message = xe.getMessage();
					Log.log(Log.ERROR,this,path + "":"" + line
						+ "": "" + message);
					String[] pp = { path,
						String.valueOf(line),
						message };
					GUIUtilities.error(PluginManager.this,
						""plugin-list.xmlerror"",pp);
				}
				else if(exception[0] != null)
				{
					Exception e = exception[0];
					Log.log(Log.ERROR,this,e);
					String[] pp = { e.toString() };
					String ok = jEdit.getProperty(
						""common.ok"");
					String proxyButton = jEdit.getProperty(
						""plugin-list.ioerror.proxy-servers"");
					int retVal =
						JOptionPane.showOptionDialog(
						PluginManager.this,
						jEdit.getProperty(""plugin-list.ioerror.message"",pp),
						jEdit.getProperty(""plugin-list.ioerror.title""),
						JOptionPane.YES_NO_OPTION,
						JOptionPane.ERROR_MESSAGE,
						null,
						new Object[] {
							proxyButton,
							ok
						},
						ok);
					if(retVal == 0)
					{
						new GlobalOptions(
							PluginManager.this,
							""firewall"");
					}
				}
			}
		});
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == done)
				ok();
			else if (source == mgrOptions)
				new GlobalOptions(PluginManager.this,""plugin-manager"");
			else if (source == pluginOptions)
				new PluginOptions(PluginManager.this);
		}
	} //}}}
	//{{{ ListUpdater class
	class ListUpdater implements ChangeListener
	{
		public void stateChanged(ChangeEvent e)
		{
			final Component selected = tabPane.getSelectedComponent();
			if(selected == installer || selected == updater)
			{
				updatePluginList();
				installer.updateModel();
				updater.updateModel();
			}
			else if(selected == manager)
				manager.update();
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.pluginmgr.PluginManagerProgress,"/*
 * PluginManagerProgress.java - Plugin download progress meter
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
//}}}
class PluginManagerProgress extends JDialog
{
	//{{{ PluginManagerProgress constructor
	public PluginManagerProgress(PluginManager dialog, Roster roster)
	{
		super(dialog,jEdit.getProperty(""plugin-manager.progress""),true);
		this.roster = roster;
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		progress = new JProgressBar();
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""plugin-manager.progress""));
		int maximum = 0;
		count = roster.getOperationCount();
		for(int i = 0; i < count; i++)
		{
			maximum += roster.getOperation(i).getMaximum();
		}
		progress.setMaximum(maximum);
		content.add(BorderLayout.NORTH,progress);
		stop = new JButton(jEdit.getProperty(""plugin-manager.progress.stop""));
		stop.addActionListener(new ActionHandler());
		JPanel panel = new JPanel(new FlowLayout(
			FlowLayout.CENTER,0,0));
		panel.add(stop);
		content.add(BorderLayout.CENTER,panel);
		addWindowListener(new WindowHandler());
		pack();
		setLocationRelativeTo(dialog);
		setVisible(true);
	} //}}}
	//{{{ setValue() method
	public void setValue(final int value)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				progress.setValue(valueSoFar + value);
			}
		});
	} //}}}
	//{{{ done() method
	public void done()
	{
		try
		{
			if(done == count)
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						dispose();
					}
				});
			}
			else
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						valueSoFar += roster.getOperation(done - 1)
							.getMaximum();
						progress.setValue(valueSoFar);
						done++;
					}
				});
			}
		}
		catch(Exception e)
		{
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private Thread thread;
	private JProgressBar progress;
	private JButton stop;
	private int count;
	private int done = 1;
	// progress value as of start of current task
	private int valueSoFar;
	private Roster roster;
	//}}}
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == stop)
			{
				thread.stop();
				dispose();
			}
		}
	} //}}}
	//{{{ WindowHandler class
	class WindowHandler extends WindowAdapter
	{
		boolean done;
		public void windowOpened(WindowEvent evt)
		{
			if(done)
				return;
			done = true;
			thread = new RosterThread();
			thread.start();
		}
		public void windowClosing(WindowEvent evt)
		{
			thread.stop();
			dispose();
		}
	} //}}}
	//{{{ RosterThread class
	class RosterThread extends Thread
	{
		RosterThread()
		{
			super(""Plugin manager thread"");
		}
		public void run()
		{
			roster.performOperationsInWorkThread(PluginManagerProgress.this);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.pluginmgr.Roster,"/*
 * Roster.java - A list of things to do, used in various places
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
//{{{ Imports
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
class Roster
{
	//{{{ Roster constructor
	Roster()
	{
		operations = new ArrayList();
		toLoad = new ArrayList();
	} //}}}
	//{{{ addRemove() method
	void addRemove(String plugin)
	{
		addOperation(new Remove(plugin));
	} //}}}
	//{{{ addInstall() method
	void addInstall(String installed, String url, String installDirectory,
		int size)
	{
		addOperation(new Install(installed,url,installDirectory,size));
	} //}}}
	//{{{ getOperation() method
	public Operation getOperation(int i)
	{
		return (Operation)operations.get(i);
	} //}}}
	//{{{ getOperationCount() method
	int getOperationCount()
	{
		return operations.size();
	} //}}}
	//{{{ isEmpty() method
	boolean isEmpty()
	{
		return operations.size() == 0;
	} //}}}
	//{{{ performOperationsInWorkThread() method
	void performOperationsInWorkThread(PluginManagerProgress progress)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = (Operation)operations.get(i);
			op.runInWorkThread(progress);
			progress.done();
			if(Thread.interrupted())
				return;
		}
	} //}}}
	//{{{ performOperationsInAWTThread() method
	void performOperationsInAWTThread(Component comp)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = (Operation)operations.get(i);
			op.runInAWTThread(comp);
		}
		// add the JARs before checking deps since dep check might
		// require all JARs to be present
		for(int i = 0; i < toLoad.size(); i++)
		{
			String pluginName = (String)toLoad.get(i);
			if(jEdit.getPluginJAR(pluginName) != null)
			{
				Log.log(Log.WARNING,this,""Already loaded: ""
					+ pluginName);
			}
			else
				jEdit.addPluginJAR(pluginName);
		}
		for(int i = 0; i < toLoad.size(); i++)
		{
			String pluginName = (String)toLoad.get(i);
			PluginJAR plugin = jEdit.getPluginJAR(pluginName);
			if(plugin != null)
				plugin.checkDependencies();
		}
		// now activate the plugins
		for(int i = 0; i < toLoad.size(); i++)
		{
			String pluginName = (String)toLoad.get(i);
			PluginJAR plugin = jEdit.getPluginJAR(pluginName);
			if(plugin != null)
				plugin.activatePluginIfNecessary();
		}
	} //}}}
	//{{{ Private members
	private static File downloadDir;
	private List operations;
	private List toLoad;
	//{{{ addOperation() method
	private void addOperation(Operation op)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			if(operations.get(i).equals(op))
				return;
		}
		operations.add(op);
	} //}}}
	//{{{ getDownloadDir() method
	private static String getDownloadDir()
	{
		if(downloadDir == null)
		{
			String settings = jEdit.getSettingsDirectory();
			if(settings == null)
				settings = System.getProperty(""user.home"");
			downloadDir = new File(MiscUtilities.constructPath(
				settings,""PluginManager.download""));
			downloadDir.mkdirs();
		}
		return downloadDir.getPath();
	} //}}}
	//}}}
	//{{{ Operation interface
	static abstract class Operation
	{
		public void runInWorkThread(PluginManagerProgress progress)
		{
		}
		public void runInAWTThread(Component comp)
		{
		}
		public int getMaximum()
		{
			return 0;
		}
	} //}}}
	//{{{ Remove class
	class Remove extends Operation
	{
		//{{{ Remove constructor
		Remove(String plugin)
		{
			this.plugin = plugin;
		} //}}}
		//{{{ runInAWTThread() method
		public void runInAWTThread(Component comp)
		{
			// close JAR file and all JARs that depend on this
			PluginJAR jar = jEdit.getPluginJAR(plugin);
			if(jar != null)
			{
				unloadPluginJAR(jar);
				String cachePath = jar.getCachePath();
				if(cachePath != null)
					new File(cachePath).delete();
			}
			toLoad.remove(plugin);
			// remove cache file
			// move JAR first
			File jarFile = new File(plugin);
			File srcFile = new File(plugin.substring(0,plugin.length() - 4));
			Log.log(Log.NOTICE,this,""Deleting "" + jarFile);
			boolean ok = jarFile.delete();
			if(srcFile.exists())
				ok &= deleteRecursively(srcFile);
			if(!ok)
			{
				String[] args = { plugin };
				GUIUtilities.error(comp,""plugin-manager.remove-failed"",args);
			}
		} //}}}
		//{{{ unloadPluginJAR() method
		/**
		 * This should go into a public method somewhere.
		 */
		private void unloadPluginJAR(PluginJAR jar)
		{
			String[] dependents = jar.getDependentPlugins();
			for(int i = 0; i < dependents.length; i++)
			{
				PluginJAR _jar = jEdit.getPluginJAR(
					dependents[i]);
				if(_jar != null)
				{
					toLoad.add(dependents[i]);
					unloadPluginJAR(_jar);
				}
			}
			jEdit.removePluginJAR(jar,false);
		} //}}}
		//{{{ equals() method
		public boolean equals(Object o)
		{
			if(o instanceof Remove
				&& ((Remove)o).plugin.equals(plugin))
				return true;
			else
				return false;
		} //}}}
		//{{{ Private members
		private String plugin;
		private boolean deleteRecursively(File file)
		{
			Log.log(Log.NOTICE,this,""Deleting "" + file + "" recursively"");
			boolean ok = true;
			if(file.isDirectory())
			{
				String path = file.getPath();
				String[] children = file.list();
				for(int i = 0; i < children.length; i++)
				{
					ok &= deleteRecursively(new File(path,children[i]));
				}
			}
			ok &= file.delete();
			return ok;
		} //}}}
	} //}}}
	//{{{ Install class
	class Install extends Operation
	{
		int size;
		//{{{ Install constructor
		Install(String installed, String url, String installDirectory,
			int size)
		{
			// catch those hooligans passing null urls
			if(url == null)
				throw new NullPointerException();
			this.installed = installed;
			this.url = url;
			this.installDirectory = installDirectory;
			this.size = size;
		} //}}}
		//{{{ getMaximum() method
		public int getMaximum()
		{
			return size;
		} //}}}
		//{{{ runInWorkThread() method
		public void runInWorkThread(PluginManagerProgress progress)
		{
			String fileName = MiscUtilities.getFileName(url);
			path = download(progress,fileName,url);
		} //}}}
		//{{{ runInAWTThread() method
		public void runInAWTThread(Component comp)
		{
			// check if download failed
			if(path == null)
				return;
			// if download OK, remove existing version
			if(installed != null)
				new Remove(installed).runInAWTThread(comp);
			ZipFile zipFile = null;
			try
			{
				zipFile = new ZipFile(path);
				Enumeration e = zipFile.entries();
				while(e.hasMoreElements())
				{
					ZipEntry entry = (ZipEntry)e.nextElement();
					String name = entry.getName().replace('/',File.separatorChar);
					File file = new File(installDirectory,name);
					if(entry.isDirectory())
						file.mkdirs();
					else
					{
						new File(file.getParent()).mkdirs();
						copy(null,
							zipFile.getInputStream(entry),
							new FileOutputStream(
							file),false);
						if(file.getName().toLowerCase().endsWith("".jar""))
							toLoad.add(file.getPath());
					}
				}
			}
			catch(InterruptedIOException iio)
			{
			}
			catch(final IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] args = { io.getMessage() };
				GUIUtilities.error(null,""ioerror"",args);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
			finally
			{
				try
				{
					if(zipFile != null)
						zipFile.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}
				if(jEdit.getBooleanProperty(
					""plugin-manager.deleteDownloads""))
				{
					new File(path).delete();
				}
			}
		} //}}}
		//{{{ equals() method
		public boolean equals(Object o)
		{
			if(o instanceof Install
				&& ((Install)o).url.equals(url))
			{
				/* even if installDirectory is different */
				return true;
			}
			else
				return false;
		} //}}}
		//{{{ Private members
		private String installed;
		private String url;
		private String installDirectory;
		private String path;
		//{{{ download() method
		private String download(PluginManagerProgress progress,
			String fileName, String url)
		{
			try
			{
				URLConnection conn = new URL(url).openConnection();
				String path = MiscUtilities.constructPath(getDownloadDir(),fileName);
				if(!copy(progress,conn.getInputStream(),
					new FileOutputStream(path),true))
					return null;
				return path;
			}
			catch(InterruptedIOException iio)
			{
				// do nothing, user clicked 'Stop'
				return null;
			}
			catch(final IOException io)
			{
				Log.log(Log.ERROR,this,io);
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						String[] args = { io.getMessage() };
						GUIUtilities.error(null,""ioerror"",args);
					}
				});
				return null;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				return null;
			}
		} //}}}
		//{{{ copy() method
		private boolean copy(PluginManagerProgress progress,
			InputStream in, OutputStream out, boolean canStop)
			throws Exception
		{
			in = new BufferedInputStream(in);
			out = new BufferedOutputStream(out);
			try
			{
				byte[] buf = new byte[4096];
				int copied = 0;
loop:				for(;;)
				{
					int count = in.read(buf,0,buf.length);
					if(count == -1)
						break loop;
					copied += count;
					if(progress != null)
						progress.setValue(copied);
					out.write(buf,0,count);
					if(canStop && Thread.interrupted())
					{
						in.close();
						out.close();
						return false;
					}
				}
			}
			finally
			{
				in.close();
				out.close();
			}
			return true;
		} //}}}
		//}}}
	} //}}}
}
"
org.gjt.sp.jedit.print.BufferPrintable,"/*
 * BufferPrintable.java - Printable implementation
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2003 Slava Pestov
 * Portions copyright (C) 2002 Thomas Dilts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.print;
//{{{ Imports
import javax.swing.text.Segment;
import javax.swing.text.TabExpander;
import javax.swing.SwingUtilities;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.print.*;
import java.awt.*;
import java.lang.reflect.Method;
import java.util.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
//}}}
class BufferPrintable implements Printable
{
	//{{{ BufferPrintable constructor
	BufferPrintable(PrinterJob job, Object format,
		View view, Buffer buffer, Font font, boolean header,
		boolean footer, boolean lineNumbers, boolean color)
	{
		this.job = job;
		this.format = format;
		this.view = view;
		this.buffer = buffer;
		this.font = font;
		this.header = header;
		this.footer = footer;
		this.lineNumbers = lineNumbers;
		styles = GUIUtilities.loadStyles(jEdit.getProperty(""print.font""),
			jEdit.getIntegerProperty(""print.fontsize"",10),color);
		styles[Token.NULL] = new SyntaxStyle(textColor,null,font);
		// Change any white text to black
		for(int i = 0; i < styles.length; i++)
		{
			SyntaxStyle s = styles[i];
			if(s.getForegroundColor().equals(Color.WHITE)
				&& s.getBackgroundColor() == null)
			{
				styles[i] = new SyntaxStyle(
					Color.BLACK,
					styles[i].getBackgroundColor(),
					styles[i].getFont());
			}
		}
		lineList = new ArrayList();
		tokenHandler = new DisplayTokenHandler();
	} //}}}
	//{{{ print() method
	public void print()
	{
		try
		{
			//buffer.readLock();
			if(format == null)
				job.print();
			else
			{
				Method method = PrinterJob.class.getMethod(
					""print"",new Class[] { Class.forName(
					""javax.print.attribute.PrintRequestAttributeSet"") });
				method.invoke(job,new Object[] { format });
			}
		}
		catch(PrinterAbortException ae)
		{
			Log.log(Log.DEBUG,this,ae);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			final String[] args = { e.toString() };
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""print-error"",args);
				}
			});
		}
		finally
		{
			//buffer.readUnlock();
		}
	} //}}}
	//{{{ print() method
	public int print(Graphics _gfx, PageFormat pageFormat, int pageIndex)
		throws PrinterException
	{
		// we keep the first non-null frc we get, since sometimes
		// we get invalid ones on subsequent pages on Windows
		if(frc == null)
		{
			frc = ((Graphics2D)_gfx).getFontRenderContext();
			Log.log(Log.DEBUG,this,""Font render context is "" + frc);
		}
		Log.log(Log.DEBUG,this,""Asked to print page "" + pageIndex);
		Log.log(Log.DEBUG,this,""Current page is "" + currentPage);
		if(pageIndex > currentPage)
		{
			for(int i = currentPage; i < pageIndex; i++)
			{
				Log.log(Log.DEBUG,this,""Current physical line is now "" + currentPageStart);
				currentPhysicalLine = currentPageStart;
				printPage(_gfx,pageFormat,i,true);
			}
			currentPage = pageIndex - 1;
			Log.log(Log.DEBUG,this,""Current page is now "" + currentPage);
		}
		if(pageIndex == currentPage + 1)
		{
			if(end)
			{
				Log.log(Log.DEBUG,this,""The end"");
				return NO_SUCH_PAGE;
			}
			currentPageStart = currentPhysicalLine;
			Log.log(Log.DEBUG,this,""#2 - Current physical line is now "" + currentPageStart);
			currentPage = pageIndex;
			Log.log(Log.DEBUG,this,""#2 - Current page is now "" + currentPage);
		}
		else if(pageIndex == currentPage)
		{
			currentPhysicalLine = currentPageStart;
			Log.log(Log.DEBUG,this,""#3 - Current physical line is now "" + currentPageStart);
		}
		printPage(_gfx,pageFormat,pageIndex,true);
		return PAGE_EXISTS;
	} //}}}
	//{{{ Private members
	//{{{ Static variables
	private static Color headerColor = Color.lightGray;
	private static Color headerTextColor = Color.black;
	private static Color footerColor = Color.lightGray;
	private static Color footerTextColor = Color.black;
	private static Color lineNumberColor = Color.gray;
	private static Color textColor = Color.black;
	//}}}
	//{{{ Instance variables
	private PrinterJob job;
	private Object format;
	private View view;
	private Buffer buffer;
	private Font font;
	private SyntaxStyle[] styles;
	private boolean header;
	private boolean footer;
	private boolean lineNumbers;
	private int currentPage;
	private int currentPageStart;
	private int currentPhysicalLine;
	private boolean end;
	private LineMetrics lm;
	private ArrayList lineList;
	private FontRenderContext frc;
	private DisplayTokenHandler tokenHandler;
	//}}}
	//{{{ printPage() method
	private void printPage(Graphics _gfx, PageFormat pageFormat, int pageIndex,
		boolean actuallyPaint)
	{
		Log.log(Log.DEBUG,this,""printPage("" + pageIndex + "","" + actuallyPaint + "")"");
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setFont(font);
		double pageX = pageFormat.getImageableX();
		double pageY = pageFormat.getImageableY();
		double pageWidth = pageFormat.getImageableWidth();
		double pageHeight = pageFormat.getImageableHeight();
		Log.log(Log.DEBUG,this,""#1 - Page dimensions: "" + pageWidth
			+ ""x"" + pageHeight);
		if(header)
		{
			double headerHeight = paintHeader(gfx,pageX,pageY,pageWidth,
				actuallyPaint);
			pageY += headerHeight;
			pageHeight -= headerHeight;
		}
		if(footer)
		{
			double footerHeight = paintFooter(gfx,pageX,pageY,pageWidth,
				pageHeight,pageIndex,actuallyPaint);
			pageHeight -= footerHeight;
		}
		boolean glyphVector = jEdit.getBooleanProperty(""print.glyphVector"");
		double lineNumberWidth;
		//{{{ determine line number width
		if(lineNumbers)
		{
			// the +1's ensure that 99 gets 3 digits, 103 gets 4 digits,
			// and so on.
			int lineNumberDigits = (int)Math.ceil(Math.log(buffer.getLineCount() + 1)
				/ Math.log(10)) + 1;
			// now that we know how many chars there are, get the width.
			char[] chars = new char[lineNumberDigits];
			for(int i = 0; i < chars.length; i++)
				chars[i] = ' ';
			lineNumberWidth = font.getStringBounds(chars,
				0,lineNumberDigits,frc).getWidth();
		}
		else
			lineNumberWidth = 0.0;
		//}}}
		Log.log(Log.DEBUG,this,""#2 - Page dimensions: ""
			+ (pageWidth - lineNumberWidth)
			+ ""x"" + pageHeight);
		//{{{ calculate tab size
		int tabSize = jEdit.getIntegerProperty(""print.tabSize"",8);
		char[] chars = new char[tabSize];
		for(int i = 0; i < chars.length; i++)
			chars[i] = ' ';
		double tabWidth = font.getStringBounds(chars,
			0,tabSize,frc).getWidth();
		PrintTabExpander e = new PrintTabExpander(tabWidth);
		//}}}
		double y = 0.0;
		lm = font.getLineMetrics(""gGyYX"",frc);
		Log.log(Log.DEBUG,this,""Line height is "" + lm.getHeight());
print_loop:	for(;;)
		{
			if(currentPhysicalLine == buffer.getLineCount())
			{
				Log.log(Log.DEBUG,this,""Finished buffer"");
				end = true;
				break print_loop;
			}
			lineList.clear();
			tokenHandler.init(styles,frc,e,lineList,
				(float)(pageWidth - lineNumberWidth));
			buffer.markTokens(currentPhysicalLine,tokenHandler);
			if(lineList.size() == 0)
				lineList.add(null);
			if(y + (lm.getHeight() * lineList.size()) >= pageHeight)
			{
				Log.log(Log.DEBUG,this,""Finished page before line "" + currentPhysicalLine);
				break print_loop;
			}
			if(lineNumbers && actuallyPaint)
			{
				gfx.setFont(font);
				gfx.setColor(lineNumberColor);
				gfx.drawString(String.valueOf(currentPhysicalLine + 1),
					(float)pageX,(float)(pageY + y + lm.getHeight()));
			}
			for(int i = 0; i < lineList.size(); i++)
			{
				y += lm.getHeight();
				Chunk chunks = (Chunk)lineList.get(i);
				if(chunks != null && actuallyPaint)
				{
					Chunk.paintChunkBackgrounds(chunks,gfx,
						(float)(pageX + lineNumberWidth),
						(float)(pageY + y));
					Chunk.paintChunkList(chunks,gfx,
						(float)(pageX + lineNumberWidth),
						(float)(pageY + y),glyphVector);
				}
			}
			currentPhysicalLine++;
		}
	} //}}}
	//{{{ paintHeader() method
	private double paintHeader(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, boolean actuallyPaint)
	{
		String headerText = jEdit.getProperty(""print.headerText"",
			new String[] { buffer.getName() });
		FontRenderContext frc = gfx.getFontRenderContext();
		lm = font.getLineMetrics(headerText,frc);
		Rectangle2D bounds = font.getStringBounds(headerText,frc);
		Rectangle2D headerBounds = new Rectangle2D.Double(
			pageX,pageY,pageWidth,bounds.getHeight());
		if(actuallyPaint)
		{
			gfx.setColor(headerColor);
			gfx.fill(headerBounds);
			gfx.setColor(headerTextColor);
			gfx.drawString(headerText,
				(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
				(float)(pageY + lm.getAscent()));
		}
		return headerBounds.getHeight();
	}
	//}}}
	//{{{ paintFooter() method
	private double paintFooter(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, double pageHeight, int pageIndex,
		boolean actuallyPaint)
	{
		String footerText = jEdit.getProperty(""print.footerText"",
			new Object[] { new Date(), new Integer(pageIndex + 1) });
		FontRenderContext frc = gfx.getFontRenderContext();
		lm = font.getLineMetrics(footerText,frc);
		Rectangle2D bounds = font.getStringBounds(footerText,frc);
		Rectangle2D footerBounds = new Rectangle2D.Double(
			pageX,pageY + pageHeight - bounds.getHeight(),
			pageWidth,bounds.getHeight());
		if(actuallyPaint)
		{
			gfx.setColor(footerColor);
			gfx.fill(footerBounds);
			gfx.setColor(footerTextColor);
			gfx.drawString(footerText,
				(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
				(float)(pageY + pageHeight - bounds.getHeight()
				+ lm.getAscent()));
		}
		return footerBounds.getHeight();
	} //}}}
	//}}}
	//{{{ PrintTabExpander class
	static class PrintTabExpander implements TabExpander
	{
		private double tabWidth;
		//{{{ PrintTabExpander constructor
		public PrintTabExpander(double tabWidth)
		{
			this.tabWidth = tabWidth;
		} //}}}
		//{{{ nextTabStop() method
		public float nextTabStop(float x, int tabOffset)
		{
			int ntabs = (int)((x + 1) / tabWidth);
			return (float)((ntabs + 1) * tabWidth);
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.print.BufferPrinter1_3,"/*
 * BufferPrinter1_3.java - Main class that controls printing
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 * Portions copyright (C) 2002 Thomas Dilts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.print;
//{{{ Imports
import java.awt.print.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
//}}}
public class BufferPrinter1_3
{
	//{{{ getPrintJob() method
	private static PrinterJob getPrintJob()
	{
		job = PrinterJob.getPrinterJob();
		int orientation = jEdit.getIntegerProperty(""print.orientation"",PageFormat.PORTRAIT);
		double width = jEdit.getDoubleProperty(""print.width"",0);
		double height = jEdit.getDoubleProperty(""print.height"",0);
		double x = jEdit.getDoubleProperty(""print.x"",0);
		double y = jEdit.getDoubleProperty(""print.y"",0);
		double pagewidth = jEdit.getDoubleProperty(""print.pagewidth"",0);
		double pageheight = jEdit.getDoubleProperty(""print.pageheight"",0);
		format = job.defaultPage();
		//format.setOrientation(PageFormat.PORTRAIT);
		if(width!=0 && height!=0 )
		{
			Paper pap = format.getPaper();
			pap.setImageableArea(x,y,width,height);
			pap.setSize(pagewidth,pageheight);
			format.setPaper(pap);
		}
		format.setOrientation(orientation);
		return job;
	}//}}}
	//{{{ pageSetup() method
	public static void pageSetup(View view)
	{
		job = getPrintJob();
		PageFormat newFormat = job.pageDialog(format);
		if(newFormat != null)
		{
			format = newFormat;
			jEdit.setIntegerProperty(""print.orientation"",format.getOrientation());
			Paper paper=format.getPaper();
			jEdit.setDoubleProperty(""print.width"",paper.getImageableWidth());
			jEdit.setDoubleProperty(""print.height"",paper.getImageableHeight());
			jEdit.setDoubleProperty(""print.x"",paper.getImageableX());
			jEdit.setDoubleProperty(""print.y"",paper.getImageableY());
			jEdit.setDoubleProperty(""print.pagewidth"",paper.getWidth());
			jEdit.setDoubleProperty(""print.pageheight"",paper.getHeight());
		}
	} //}}}
	//{{{ print() method
	public static void print(final View view, final Buffer buffer, boolean selection)
	{
		job = getPrintJob();
		job.setJobName(buffer.getPath());
		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = jEdit.getFontProperty(""print.font"");
		BufferPrintable printable = new BufferPrintable(job,null,view,
			buffer,font,header,footer,lineNumbers,color);
		job.setPrintable(printable,format);
		if(!job.printDialog())
			return;
		printable.print();
	} //}}}
	//{{{ getPageFormat() method
	public static PageFormat getPageFormat()
	{
		return format;
	} //}}}
	//{{{ Private members
	private static PageFormat format;
	private static PrinterJob job;
	//}}}
}
"
org.gjt.sp.jedit.print.BufferPrinter1_4,"/*
 * BufferPrinter1_4.java - Main class that controls printing
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 * Portions copyright (C) 2002 Thomas Dilts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.print;
//{{{ Imports
import javax.print.attribute.*;
import javax.print.attribute.standard.*;
import java.awt.print.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
public class BufferPrinter1_4
{
	//{{{ getPrintJob() method
	private static PrinterJob getPrintJob(String jobName)
	{
		job = PrinterJob.getPrinterJob();
		format = new HashPrintRequestAttributeSet();
		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			String printSpecPath = MiscUtilities.constructPath(
				settings, ""printspec"");
			File filePrintSpec = new File(printSpecPath);
			if (filePrintSpec.exists())
			{
				try
				{
					FileInputStream fileIn = new FileInputStream(filePrintSpec);
					ObjectInputStream obIn = new ObjectInputStream(fileIn);
					format = (HashPrintRequestAttributeSet)obIn.readObject();
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,BufferPrinter1_4.class,e);
				}
				//for backwards compatibility, the color variable is stored also as a property
				if(jEdit.getBooleanProperty(""print.color""))
					format.add(Chromaticity.COLOR);
				else
					format.add(Chromaticity.MONOCHROME);
				//no need to always keep the same job name for every printout.
				format.add(new JobName(jobName, null));
			}
		}
		return job;
	} //}}}
	//{{{ pageSetup() method
	public static void pageSetup(View view)
	{
		PrinterJob prnJob = getPrintJob(""PageSetupOnly"");
		if(prnJob.pageDialog(format)!=null)
			savePrintSpec();
	} //}}}
	//{{{ print() method
	public static void print(final View view, final Buffer buffer, boolean selection)
	{
		job = getPrintJob(buffer.getPath());
		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = jEdit.getFontProperty(""print.font"");
		BufferPrintable printable = new BufferPrintable(job,format,view,
			buffer,font,header,footer,lineNumbers,color);
		job.setPrintable(printable);
		if(!job.printDialog(format))
			return;
		savePrintSpec();
		printable.print();
	} //}}}
	//{{{ getPageFormat() method
	public static PageFormat getPageFormat()
	{
		//convert from PrintRequestAttributeSet to the pageFormat
		PrinterJob prnJob=getPrintJob("" "");
		PageFormat pf=prnJob.defaultPage();
		Paper pap=pf.getPaper();
		MediaSizeName media=(MediaSizeName)format.get(
		                            Media.class);
		MediaSize ms=MediaSize.getMediaSizeForName(media);
		MediaPrintableArea mediaarea=(MediaPrintableArea)format.get(
		                                     MediaPrintableArea.class);
		if(mediaarea!=null)
			pap.setImageableArea((double)(mediaarea.getX(MediaPrintableArea.INCH)*72),
			                     (double)(mediaarea.getY(MediaPrintableArea.INCH)*72),
			                     (double)(mediaarea.getWidth(MediaPrintableArea.INCH)*72),
			                     (double)(mediaarea.getHeight(MediaPrintableArea.INCH)*72));
		if(ms!=null)
			pap.setSize((double)(ms.getX(MediaSize.INCH)*72),
			            (double)(ms.getY(MediaSize.INCH)*72));
		pf.setPaper(pap);
		OrientationRequested orientation=(OrientationRequested)format.get(
		                                         OrientationRequested.class);
		if(orientation!=null)
		{
			if(orientation.getValue()==OrientationRequested.LANDSCAPE.getValue())
			{
				pf.setOrientation(PageFormat.LANDSCAPE);
			}
			else if(orientation.getValue()==OrientationRequested.REVERSE_LANDSCAPE.getValue())
			{
				pf.setOrientation(PageFormat.REVERSE_LANDSCAPE);
			}
			else if(orientation.getValue()==OrientationRequested.PORTRAIT.getValue())
			{
				pf.setOrientation(PageFormat.PORTRAIT);
			}
			else if(orientation.getValue()==OrientationRequested.REVERSE_PORTRAIT.getValue())
			{
				//doesnt exist??
				//pf.setOrientation(PageFormat.REVERSE_PORTRAIT);
				//then just do the next best thing
				pf.setOrientation(PageFormat.PORTRAIT);
			}
		}
		return pf;
	} //}}}
	//{{{ savePrintSpec() method
	private static void savePrintSpec()
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
			return;
		String printSpecPath = MiscUtilities.constructPath(
			settings, ""printspec"");
		File filePrintSpec = new File(printSpecPath);
		try
		{
			FileOutputStream fileOut=new FileOutputStream(filePrintSpec);
			ObjectOutputStream obOut=new ObjectOutputStream(fileOut);
			obOut.writeObject(format);
			//for backwards compatibility, the color variable is stored also as a property
			Chromaticity cc=(Chromaticity)format.get(Chromaticity.class);
			if (cc!=null)
				jEdit.setBooleanProperty(""print.color"",
					cc.getValue()==Chromaticity.COLOR.getValue());
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	//}}}
	//{{{ Private members
	private static PrintRequestAttributeSet format;
	private static PrinterJob job;
	//}}}
}
"
org.gjt.sp.jedit.proto.jeditresource.Handler,"/*
 * Handler.java - jEdit plugin list URL protocol handler
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.proto.jeditresource;
import java.io.IOException;
import java.net.*;
public class Handler extends URLStreamHandler
{
	public URLConnection openConnection(URL url)
		throws IOException
	{
		PluginResURLConnection c = new PluginResURLConnection(url);
		c.connect();
		return c;
	}
}
"
org.gjt.sp.jedit.proto.jeditresource.PluginResURLConnection,"/*
 * PluginResURLConnection.java - jEdit plugin resource URL connection
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.proto.jeditresource;
//{{{ Imports
import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;
//}}}
public class PluginResURLConnection extends URLConnection
{
	public PluginResURLConnection(URL url)
		throws IOException
	{
		super(url);
		String file = url.getFile();
		int index = file.indexOf('!',0);
		if(index == -1)
		{
			plugin = null;
			resource = file;
		}
		else
		{
			int start;
			if(file.charAt(0) == '/')
				start = 1;
			else
				start = 0;
			plugin = file.substring(start,index);
			resource = file.substring(index + 1);
		}
		if(plugin != null && resource.startsWith(""/""))
			resource = resource.substring(1);
	}
	public void connect() throws IOException
	{
		if(!connected)
		{
			if(plugin == null)
			{
				in = jEdit.class.getResourceAsStream(resource);
			}
			else
			{
				PluginJAR[] plugins = jEdit.getPluginJARs();
				for(int i = 0; i < plugins.length; i++)
				{
					PluginJAR jar = plugins[i];
					if(MiscUtilities.getFileName(jar.getPath())
						.equalsIgnoreCase(plugin))
					{
						in = jar.getClassLoader()
							.getResourceAsStream(
							resource);
						break;
					}
				}
			}
			if(in == null)
			{
				throw new IOException(""Resource not found: ""
					+ resource);
			}
			connected = true;
		}
	}
	public InputStream getInputStream()
		throws IOException
	{
		connect();
		return in;
	}
	public String getHeaderField(String name)
	{
		if(name.equals(""content-type""))
		{
			String lcResource = resource.toLowerCase();
			if(lcResource.endsWith("".html""))
				return ""text/html"";
			else if(lcResource.endsWith("".txt""))
				return ""text/plain"";
			else if(lcResource.endsWith("".rtf""))
				return ""text/rtf"";
			else if(lcResource.endsWith("".gif""))
				return ""image/gif"";
			else if(lcResource.endsWith("".jpg"")
				|| lcResource.endsWith("".jpeg""))
				return ""image/jpeg"";
			else
				return null;
		}
		else
			return null;
	}
	// private members
	private InputStream in;
	private String plugin;
	private String resource;
}
"
org.gjt.sp.jedit.search.AllBufferSet,"/*
 * AllBufferSet.java - All buffer matcher
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import gnu.regexp.*;
import java.awt.Component;
import java.util.ArrayList;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * A file set for searching all open buffers.
 * @author Slava Pestov
 * @version $Id: AllBufferSet.java,v 1.4 2002/06/18 02:44:52 spestov Exp $
 */
public class AllBufferSet extends BufferListSet
{
	//{{{ AllBufferSet constructor
	/**
	 * Creates a new all buffer set.
	 * @param glob The filename glob
	 * @since jEdit 2.7pre3
	 */
	public AllBufferSet(String glob)
	{
		this.glob = glob;
	} //}}}
	//{{{ getFileFilter() method
	/**
	 * Returns the filename filter.
	 * @since jEdit 2.7pre3
	 */
	public String getFileFilter()
	{
		return glob;
	} //}}}
	//{{{ getCode() method
	/**
	 * Returns the BeanShell code that will recreate this file set.
	 * @since jEdit 2.7pre3
	 */
	public String getCode()
	{
		return ""new AllBufferSet(\"""" + MiscUtilities.charsToEscapes(glob)
			+ ""\"")"";
	} //}}}
	//{{{ Instance variables
	private String glob;
	//}}}
	//{{{ _getFiles() method
	protected String[] _getFiles(Component comp)
	{
		Buffer[] buffers = jEdit.getBuffers();
		ArrayList returnValue = new ArrayList(buffers.length);
		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			return null;
		}
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(filter.isMatch(buffer.getName()))
				returnValue.add(buffer.getPath());
		}
		return (String[])returnValue.toArray(new String[returnValue.size()]);
	} //}}}
}
"
org.gjt.sp.jedit.search.BoyerMooreSearchMatcher,"/*
 * BoyerMooreSearchMatcher.java - Literal pattern String matcher utilizing the
 *         Boyer-Moore algorithm
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000 mike dillon
 * Portions copyright (C) 2001 Tom Locke
 * Portions copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import bsh.BshMethod;
import bsh.NameSpace;
import gnu.regexp.CharIndexed;
import org.gjt.sp.jedit.BeanShell;
//}}}
/**
 * Implements literal search using the Boyer-Moore algorithm.
 */
public class BoyerMooreSearchMatcher extends SearchMatcher
{
	//{{{ BoyerMooreSearchMatcher constructor
	/**
	 * Creates a new string literal matcher.
	 */
	public BoyerMooreSearchMatcher(String pattern, boolean ignoreCase)
	{
		this.pattern = pattern.toCharArray();
		if(ignoreCase)
		{
			for(int i = 0; i < this.pattern.length; i++)
			{
				this.pattern[i] = Character.toUpperCase(
					this.pattern[i]);
			}
		}
		this.ignoreCase = ignoreCase;
		pattern_end = this.pattern.length - 1;
	} //}}}
	//{{{ nextMatch() method
	/**
	 * Returns the offset of the first match of the specified text
	 * within this matcher.
	 * @param text The text to search in
	 * @param start True if the start of the segment is the beginning of the
	 * buffer
	 * @param end True if the end of the segment is the end of the buffer
	 * @param firstTime If false and the search string matched at the start
	 * offset with length zero, automatically find next match
	 * @param reverse If true, searching will be performed in a backward
	 * direction.
	 * @return an array where the first element is the start offset
	 * of the match, and the second element is the end offset of
	 * the match
	 * @since jEdit 4.2pre4
	 */
	public SearchMatcher.Match nextMatch(CharIndexed text,
		boolean start, boolean end, boolean firstTime,
		boolean reverse)
	{
		int pos = match(text,reverse);
		if (pos == -1)
		{
			return null;
		}
		else
		{
			returnValue.start = pos;
			returnValue.end = pos + pattern.length;
			return returnValue;
		}
	} //}}}
	//{{{ match() method
	/*
	 *  a good introduction to the Boyer-Moore fast string matching
	 *  algorithm may be found on Moore's website at:
	 *
	 *   http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/
	 *
	 */
	public int match(CharIndexed text, boolean reverse)
	{
		//{{{
		// lazily create skip and suffix arrays for either the
		// search pattern, or the reversed search pattern
		int[] skip, suffix;
		if(reverse)
		{
			if(back_skip == null)
			{
				back_skip = generateSkipArray(true);
				back_suffix = generateSuffixArray(true);
			}
			skip = back_skip;
			suffix = back_suffix;
		}
		else
		{
			if(fwd_skip == null)
			{
				fwd_skip = generateSkipArray(false);
				fwd_suffix = generateSuffixArray(false);
			}
			skip = fwd_skip;
			suffix = fwd_suffix;
		} //}}}
		// position variable for pattern test position
		int pos;
		// position variable for pattern start
		int anchor = 0;
		// last possible start position of a match with this pattern;
		// this is negative if the pattern is longer than the text
		// causing the search loop below to immediately fail
		//int last_anchor = reverseSearch
		//	? offset + pattern.length - 1
		//	: length - pattern.length;
		char ch = 0;
		int bad_char;
		int good_suffix;
		// the search works by starting the anchor (first character
		// of the pattern) at the initial offset. as long as the
		// anchor is far enough from the enough of the text for the
		// pattern to match, and until the pattern matches, we
		// compare the pattern to the text from the last character
		// to the first character in reverse order. where a character
		// in the pattern mismatches, we use the two heuristics
		// based on the mismatch character and its position in the
		// pattern to determine the furthest we can move the anchor
		// without missing any potential pattern matches.
SEARCH:
		while (text.isValid())
		{
			for (pos = pattern_end; pos >= 0; --pos)
			{
				ch = text.charAt(pos);
				if(ignoreCase)
					ch = Character.toUpperCase(ch);
				// pattern test
				if ((reverse ? ch != pattern[pattern_end - pos]
					: ch != pattern[pos]))
				{
					// character mismatch, determine how many characters to skip
					// heuristic #1
					bad_char = pos - skip[getSkipIndex(ch)];
					// heuristic #2
					good_suffix = suffix[pos];
					// skip the greater of the two distances provided by the
					// heuristics
					int skip_index = (bad_char > good_suffix) ? bad_char : good_suffix;
					anchor += skip_index;
					text.move(skip_index);
					// go back to the while loop
					continue SEARCH;
				}
			}
			// MATCH: return the position of its first character
			return anchor;
		}
		// MISMATCH: return -1 as defined by API
		return -1;
	} //}}}
	//{{{ Private members
	private char[] pattern;
	private int pattern_end;
	private boolean ignoreCase;
	// Boyer-Moore member fields
	private int[] fwd_skip;
	private int[] fwd_suffix;
	private int[] back_skip;
	private int[] back_suffix;
	//}}}
	// Boyer-Moore helper methods
	//{{{ generateSkipArray() method
	/*
	 *  the 'skip' array is used to determine for each index in the
	 *  hashed alphabet how many characters can be skipped if
	 *  a mismatch occurs on a characater hashing to that index.
	 */
	private int[] generateSkipArray(boolean reverse)
	{
		// initialize the skip array to all zeros
		int[] skip = new int[256];
		// leave the table cleanly-initialized for an empty pattern
		if (pattern.length == 0)
			return skip;
		int pos = 0;
		do
		{
			skip[getSkipIndex(pattern[reverse ? pattern_end - pos : pos])] = pos;
		}
		while (++pos < pattern.length);
		return skip;
	} //}}}
	//{{{ getSkipIndex() method
	/*
	 *  to avoid our skip table having a length of 2 ^ 16, we hash each
	 *  character of the input into a character in the alphabet [\x00-\xFF]
	 *  using the lower 8 bits of the character's value (resulting in
	 *  a more reasonable skip table of length 2 ^ 8).
	 *
	 *  the result of this is that more than one character can hash to the
	 *  same index, but since the skip table encodes the position of
	 *  occurence of the character furthest into the string with a particular
	 *  index (whether or not it is the only character with that index), an
	 *  index collision only means that that this heuristic will give a
	 *  sub-optimal skip (i.e. a complete skip table could use the differences
	 *  between colliding characters to maximal effect, at the expense of
	 *  building a table that is over 2 orders of magnitude larger and very
	 *  sparse).
	 */
	private static final int getSkipIndex(char ch)
	{
		return ((int) ch) & 0x000000FF;
	} //}}}
	//{{{ generateSuffixArray() method
	/*
	 *  XXX: hairy code that is basically just a functional(?) port of some
	 *  other code i barely understood
	 */
	private int[] generateSuffixArray(boolean reverse)
	{
		int m = pattern.length;
		int j = m + 1;
		int[] suffix = new int[j];
		int[] tmp = new int[j];
		tmp[m] = j;
		for (int i = m; i > 0; --i)
		{
			while (j <= m && pattern[reverse ? pattern_end - i + 1 : i - 1]
				!= pattern[reverse ? pattern_end - j + 1 : j - 1])
			{
				if (suffix[j] == 0)
				{
					suffix[j] = j - i;
				}
				j = tmp[j];
			}
			tmp[i - 1] = --j;
		}
		int k = tmp[0];
		for (j = 0; j <= m; j++)
		{
			// the code above builds a 1-indexed suffix array,
			// but we shift it to be 0-indexed, ignoring the
			// original 0-th element
			if (j > 0)
			{
				suffix[j - 1] = (suffix[j] == 0) ? k : suffix[j];
			}
			if (j == k)
			{
				k = tmp[k];
			}
		}
		return suffix;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.search.BufferListSet,"/*
 * BufferListSet.java - Buffer list matcher
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import java.awt.Component;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.*;
//}}}
/**
 * A file set for searching a user-specified list of buffers.
 * @author Slava Pestov
 * @version $Id: BufferListSet.java,v 1.6 2004/02/22 20:00:54 spestov Exp $
 */
public abstract class BufferListSet implements SearchFileSet
{
	//{{{ getFirstFile() method
	public synchronized String getFirstFile(View view)
	{
		if(files == null)
			files = _getFiles(view);
		if(files == null || files.length == 0)
			return null;
		else
			return files[0];
	} //}}}
	//{{{ getNextFile() method
	public synchronized String getNextFile(View view, String file)
	{
		if(files == null)
			files = _getFiles(view);
		if(files == null || files.length == 0)
			return null;
		if(file == null)
		{
			file = view.getBuffer().getSymlinkPath();
			VFS vfs = VFSManager.getVFSForPath(file);
			boolean ignoreCase = ((vfs.getCapabilities()
				& VFS.CASE_INSENSITIVE_CAP) != 0);
			for(int i = 0; i < files.length; i++)
			{
				if(MiscUtilities.compareStrings(
					files[i],file,ignoreCase) == 0)
				{
					return file;
				}
			}
			return getFirstFile(view);
		}
		else
		{
			// -1 so that the last isn't checked
			VFS vfs = VFSManager.getVFSForPath(file);
			boolean ignoreCase = ((vfs.getCapabilities()
				& VFS.CASE_INSENSITIVE_CAP) != 0);
			for(int i = 0; i < files.length - 1; i++)
			{
				if(MiscUtilities.compareStrings(
					files[i],file,ignoreCase) == 0)
				{
					return files[i+1];
				}
			}
			return null;
		}
	} //}}}
	//{{{ getFiles() method
	public synchronized String[] getFiles(View view)
	{
		if(files == null)
			files = _getFiles(view);
		if(files == null || files.length == 0)
			return null;
		else
			return files;
	} //}}}
	//{{{ getFileCount() method
	public synchronized int getFileCount(View view)
	{
		if(files == null)
			files = _getFiles(view);
		if(files == null)
			return 0;
		else
			return files.length;
	} //}}}
	//{{{ getCode() method
	public String getCode()
	{
		// not supported for arbitriary filesets
		return null;
	} //}}}
	//{{{ invalidateCachedList() method
	public synchronized void invalidateCachedList()
	{
		files = null;
	} //}}}
	/**
	 * Note that the paths in the returned list must be
	 * fully canonicalized.
	 */
	protected abstract String[] _getFiles(Component comp);
	private String[] files;
}
"
org.gjt.sp.jedit.search.CurrentBufferSet,"/*
 * CurrentBufferSet.java - Current buffer matcher
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import org.gjt.sp.jedit.*;
/**
 * A file set for searching the current buffer.
 * @author Slava Pestov
 * @version $Id: CurrentBufferSet.java,v 1.4 2002/05/28 01:50:19 spestov Exp $
 */
public class CurrentBufferSet implements SearchFileSet
{
	//{{{ getFirstFile() method
	public String getFirstFile(View view)
	{
		return view.getBuffer().getPath();
	} //}}}
	//{{{ getNextFile() method
	public String getNextFile(View view, String file)
	{
		if(file == null)
			return view.getBuffer().getPath();
		else
			return null;
	} //}}}
	//{{{ getFiles() method
	public String[] getFiles(View view)
	{
		return new String[] { view.getBuffer().getPath() };
	} //}}}
	//{{{ getFileCount() method
	public int getFileCount(View view)
	{
		return 1;
	} //}}}
	//{{{ getCode() method
	public String getCode()
	{
		return ""new CurrentBufferSet()"";
	} //}}}
}
"
org.gjt.sp.jedit.search.DirectoryListSet,"/*
 * DirectoryListSet.java - Directory list matcher
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Recursive directory search.
 * @author Slava Pestov
 * @version $Id: DirectoryListSet.java,v 1.6 2003/03/22 22:52:09 spestov Exp $
 */
public class DirectoryListSet extends BufferListSet
{
	//{{{ DirectoryListSet constructor
	public DirectoryListSet(String directory, String glob, boolean recurse)
	{
		this.directory = directory;
		this.glob = glob;
		this.recurse = recurse;
	} //}}}
	//{{{ getDirectory() method
	public String getDirectory()
	{
		return directory;
	} //}}}
	//{{{ setDirectory() method
	/**
	 * @since jEdit 4.2pre1
	 */
	public void setDirectory(String directory)
	{
		this.directory = directory;
		invalidateCachedList();
	} //}}}
	//{{{ getFileFilter() method
	public String getFileFilter()
	{
		return glob;
	} //}}}
	//{{{ setFileFilter() method
	/**
	 * @since jEdit 4.2pre1
	 */
	public void setFileFilter(String glob)
	{
		this.glob = glob;
		invalidateCachedList();
	} //}}}
	//{{{ isRecursive() method
	public boolean isRecursive()
	{
		return recurse;
	} //}}}
	//{{{ setRecursive() method
	/**
	 * @since jEdit 4.2pre1
	 */
	public void setRecursive(boolean recurse)
	{
		this.recurse = recurse;
		invalidateCachedList();
	} //}}}
	//{{{ getCode() method
	public String getCode()
	{
		return ""new DirectoryListSet(\"""" + MiscUtilities.charsToEscapes(directory)
			+ ""\"",\"""" + MiscUtilities.charsToEscapes(glob) + ""\"",""
			+ recurse + "")"";
	} //}}}
	//{{{ _getFiles() method
	protected String[] _getFiles(final Component comp)
	{
		final VFS vfs = VFSManager.getVFSForPath(directory);
		Object session;
		if(SwingUtilities.isEventDispatchThread())
		{
			session = vfs.createVFSSession(directory,comp);
		}
		else
		{
			final Object[] returnValue = new Object[1];
			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						returnValue[0] = vfs.createVFSSession(directory,comp);
					}
				});
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
			session = returnValue[0];
		}
		if(session == null)
			return null;
		try
		{
			return vfs._listDirectory(session,directory,glob,recurse,comp);
		}
		catch(IOException io)
		{
			VFSManager.error(comp,directory,""ioerror"",new String[]
				{ io.toString() });
			return null;
		}
	} //}}}
	//{{{ Private members
	private String directory;
	private String glob;
	private boolean recurse;
	//}}}
}
"
org.gjt.sp.jedit.search.HyperSearchRequest,"/*
 * HyperSearchRequest.java - HyperSearch request, run in I/O thread
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import javax.swing.text.Segment;
import javax.swing.tree.*;
import javax.swing.SwingUtilities;
import org.gjt.sp.jedit.textarea.Selection;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.*;
//}}}
class HyperSearchRequest extends WorkRequest
{
	//{{{ HyperSearchRequest constructor
	public HyperSearchRequest(View view, SearchMatcher matcher,
		HyperSearchResults results, Selection[] selection)
	{
		this.view = view;
		this.matcher = matcher;
		this.results = results;
		this.searchString = SearchAndReplace.getSearchString();
		this.rootSearchNode = new DefaultMutableTreeNode(searchString);
		this.selection = selection;
	} //}}}
	//{{{ run() method
	public void run()
	{
		setStatus(jEdit.getProperty(""hypersearch-status""));
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		String[] files = fileset.getFiles(view);
		if(files == null || files.length == 0)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""empty-fileset"",null);
					results.searchDone(rootSearchNode);
				}
			});
			return;
		}
		setProgressMaximum(fileset.getFileCount(view));
		// to minimise synchronization and stuff like that, we only
		// show a status message at most twice a second
		// initially zero, so that we always show the first message
		long lastStatusTime = 0;
		try
		{
			if(selection != null)
			{
				Buffer buffer = view.getBuffer();
				searchInSelection(buffer);
			}
			else
			{
				int current = 0;
loop:				for(int i = 0; i < files.length; i++)
				{
					String file = files[i];
					current++;
					long currentTime = System.currentTimeMillis();
					if(currentTime - lastStatusTime > 250)
					{
						setProgressValue(current);
						lastStatusTime = currentTime;
					}
					Buffer buffer = jEdit.openTemporary(null,null,file,false);
					if(buffer == null)
						continue loop;
					doHyperSearch(buffer);
				};
			}
		}
		catch(final Exception e)
		{
			Log.log(Log.ERROR,this,e);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					SearchAndReplace.handleError(view,e);
				}
			});
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					results.searchDone(rootSearchNode);
				}
			});
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private View view;
	private SearchMatcher matcher;
	private HyperSearchResults results;
	private DefaultMutableTreeNode rootSearchNode;
	private Selection[] selection;
	private String searchString;
	//}}}
	//{{{ searchInSelection() method
	private int searchInSelection(Buffer buffer) throws Exception
	{
		setAbortable(false);
		int resultCount = 0;
		try
		{
			buffer.readLock();
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Rect)
				{
					for(int j = s.getStartLine();
						j <= s.getEndLine(); j++)
					{
						resultCount += doHyperSearch(buffer,
							s.getStart(buffer,j),
							s.getEnd(buffer,j));
					}
				}
				else
				{
					resultCount += doHyperSearch(buffer,
						s.getStart(),s.getEnd());
				}
			}
		}
		finally
		{
			buffer.readUnlock();
		}
		setAbortable(true);
		return resultCount;
	} //}}}
	//{{{ doHyperSearch() method
	private int doHyperSearch(Buffer buffer)
		throws Exception
	{
		return doHyperSearch(buffer, 0, buffer.getLength());
	} //}}}
	//{{{ doHyperSearch() method
	private int doHyperSearch(Buffer buffer, int start, int end)
		throws Exception
	{
		setAbortable(false);
		final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(
			buffer.getPath());
		int resultCount = doHyperSearch(buffer,start,end,bufferNode);
		if(resultCount != 0)
		{
			rootSearchNode.insert(bufferNode,rootSearchNode.getChildCount());
		}
		setAbortable(true);
		return resultCount;
	} //}}}
	//{{{ doHyperSearch() method
	private int doHyperSearch(Buffer buffer, int start, int end,
		DefaultMutableTreeNode bufferNode)
	{
		int resultCount = 0;
		try
		{
			buffer.readLock();
			boolean endOfLine = (buffer.getLineEndOffset(
				buffer.getLineOfOffset(end)) - 1 == end);
			Segment text = new Segment();
			int offset = start;
			HyperSearchResult lastResult = null;
loop:			for(int counter = 0; ; counter++)
			{
				boolean startOfLine = (buffer.getLineStartOffset(
					buffer.getLineOfOffset(offset)) == offset);
				buffer.getText(offset,end - offset,text);
				SearchMatcher.Match match = matcher.nextMatch(
					new CharIndexedSegment(text,false),
					startOfLine,endOfLine,counter == 0,
					false);
				if(match == null)
					break loop;
				int newLine = buffer.getLineOfOffset(
					offset + match.start);
				if(lastResult == null || lastResult.line != newLine)
				{
					lastResult = new HyperSearchResult(
						buffer,newLine);
					bufferNode.add(
						new DefaultMutableTreeNode(
						lastResult,false));
				}
				lastResult.addOccur(offset + match.start,
					offset + match.end);
				offset += match.end;
				resultCount++;
			}
		}
		finally
		{
			buffer.readUnlock();
		}
		return resultCount;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.search.HyperSearchResult,"/*
 * HyperSearchResult.java - HyperSearch result
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import javax.swing.text.Position;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * A set of occurrences of the search string on a given line in a buffer.
 */
public class HyperSearchResult
{
	public String path;
	public Buffer buffer;
	public int line;
	public String str; // cached for speed
	public Occur occur;
	public int occurCount;
	//{{{ getBuffer() method
	public Buffer getBuffer()
	{
		if(buffer == null)
			buffer = jEdit.openFile(null,path);
		return buffer;
	} //}}}
	//{{{ getSelection() method
	/**
	 * Returns an array of selection objects pointing to the occurrences
	 * of the search term on the current line. The buffer must be opened
	 * first.
	 * @since jEdit 4.2pre5
	 */
	public Selection[] getSelection()
	{
		if(buffer == null)
			return null;
		Selection[] returnValue = new Selection[occurCount];
		Occur o = occur;
		int i = 0;
		while(o != null)
		{
			Selection.Range s = new Selection.Range(
				o.startPos.getOffset(),
				o.endPos.getOffset()
			);
			returnValue[i++] = s;
			o = o.next;
		}
		return returnValue;
	} //}}}
	//{{{ goTo() method
	public void goTo(final View view)
	{
		if(buffer == null)
			buffer = jEdit.openFile(null,path);
		if(buffer == null)
			return;
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				Selection[] s = getSelection();
				if(s == null)
					return;
				EditPane pane = view.goToBuffer(buffer);
				JEditTextArea textArea = pane.getTextArea();
				if(textArea.isMultipleSelectionEnabled())
					textArea.addToSelection(s);
				else
					textArea.setSelection(s);
				textArea.moveCaretPosition(occur.endPos.getOffset());
			}
		});
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		return str;
	} //}}}
	//{{{ Package-private members
	//{{{ HyperSearchResult constructor
	HyperSearchResult(Buffer buffer, int line)
	{
		path = buffer.getPath();
		if(!buffer.isTemporary())
			bufferOpened(buffer);
		this.line = line;
		str = (line + 1) + "": "" + buffer.getLineText(line)
			.replace('\t',' ').trim();
	} //}}}
	//{{{ bufferOpened() method
	void bufferOpened(Buffer buffer)
	{
		this.buffer = buffer;
		Occur o = occur;
		while(o != null)
		{
			o.bufferOpened();
			o = o.next;
		}
	} //}}}
	//{{{ bufferClosed() method
	void bufferClosed()
	{
		buffer = null;
		Occur o = occur;
		while(o != null)
		{
			o.bufferClosed();
			o = o.next;
		}
	} //}}}
	//{{{ addOccur() method
	void addOccur(int start, int end)
	{
		Occur o = new Occur(start,end);
		o.next = occur;
		occur = o;
		occurCount++;
	} //}}}
	//{{{ pathEquals() method
	/**
	 * @param path A canonical path
	 */
	boolean pathEquals(String path)
	{
		return path.equals(MiscUtilities.resolveSymlinks(this.path));
	} //}}}
	//}}}
	//{{{ Occur class
	public class Occur
	{
		public int start, end;
		public Position startPos, endPos;
		public Occur next;
		//{{{ Occur constructor
		Occur(int start, int end)
		{
			this.start = start;
			this.end = end;
			if(buffer != null && !buffer.isTemporary())
				bufferOpened();
		} //}}}
		//{{{ bufferOpened() method
		void bufferOpened()
		{
			startPos = buffer.createPosition(Math.min(
				buffer.getLength(),start));
			endPos = buffer.createPosition(Math.min(
				buffer.getLength(),end));
		} //}}}
		//{{{ bufferClosed() method
		void bufferClosed()
		{
			start = startPos.getOffset();
			end = endPos.getOffset();
			startPos = endPos = null;
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.search.HyperSearchResults,"/*
 * HyperSearchResults.java - HyperSearch results
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 2002 Peter Cox
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.gui.DefaultFocusComponent;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
//}}}
/**
 * HyperSearch results window.
 * @author Slava Pestov
 * @version $Id: HyperSearchResults.java,v 1.34 2004/08/21 01:49:06 spestov Exp $
 */
public class HyperSearchResults extends JPanel implements EBComponent,
	DefaultFocusComponent
{
	public static final String NAME = ""hypersearch-results"";
	//{{{ HyperSearchResults constructor
	public HyperSearchResults(View view)
	{
		super(new BorderLayout());
		this.view = view;
		caption = new JLabel();
		Box toolBar = new Box(BoxLayout.X_AXIS);
		toolBar.add(caption);
		toolBar.add(Box.createGlue());
		ActionHandler ah = new ActionHandler();
		clear = new RolloverButton(GUIUtilities.loadIcon(""Clear.png""));
		clear.setToolTipText(jEdit.getProperty(
			""hypersearch-results.clear.label""));
		clear.addActionListener(ah);
		toolBar.add(clear);
		multi = new RolloverButton();
		multi.setToolTipText(jEdit.getProperty(
			""hypersearch-results.multi.label""));
		multi.addActionListener(ah);
		toolBar.add(multi);
		add(BorderLayout.NORTH, toolBar);
		resultTreeRoot = new DefaultMutableTreeNode();
		resultTreeModel = new DefaultTreeModel(resultTreeRoot);
		resultTree = new JTree(resultTreeModel);
		resultTree.setCellRenderer(new ResultCellRenderer());
		resultTree.setVisibleRowCount(16);
		resultTree.setRootVisible(false);
		resultTree.setShowsRootHandles(true);
		// looks bad with the OS X L&F, apparently...
		if(!OperatingSystem.isMacOSLF())
			resultTree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		resultTree.setEditable(false);
		resultTree.addKeyListener(new KeyHandler());
		resultTree.addMouseListener(new MouseHandler());
		JScrollPane scrollPane = new JScrollPane(resultTree);
		Dimension dim = scrollPane.getPreferredSize();
		dim.width = 400;
		scrollPane.setPreferredSize(dim);
		add(BorderLayout.CENTER, scrollPane);
	} //}}}
	//{{{ focusOnDefaultComponent() method
	public void focusOnDefaultComponent()
	{
		resultTree.requestFocus();
	} //}}}
	//{{{ addNotify() method
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
		multiStatus = jEdit.getBooleanProperty(
			""hypersearch-results.multi"");
		updateMultiStatus();
	} //}}}
	//{{{ removeNotify() method
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
		jEdit.setBooleanProperty(""hypersearch-results.multi"",multiStatus);
	} //}}}
	//{{{ visitBuffers() method
	private void visitBuffers(ResultVisitor visitor, Buffer buffer)
	{
		// impl note: since multiple searches now allowed,
		// extra level in hierarchy
		for(int i = resultTreeRoot.getChildCount() - 1; i >= 0; i--)
		{
			DefaultMutableTreeNode searchNode
				= (DefaultMutableTreeNode)
				resultTreeRoot.getChildAt(i);
			for(int j = searchNode.getChildCount() - 1;
				j >= 0; j--)
			{
				DefaultMutableTreeNode bufferNode
					= (DefaultMutableTreeNode)
					searchNode.getChildAt(j);
				for(int k = bufferNode.getChildCount() - 1;
					k >= 0; k--)
				{
					Object userObject =
						((DefaultMutableTreeNode)bufferNode
						.getChildAt(k)).getUserObject();
					HyperSearchResult result
						= (HyperSearchResult)
						userObject;
					if(result.pathEquals(buffer.getSymlinkPath()))
						visitor.visit(buffer,result);
				}
			}
		}
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			Buffer buffer = bmsg.getBuffer();
			Object what = bmsg.getWhat();
			if(what == BufferUpdate.LOADED ||
				what == BufferUpdate.CLOSED)
			{
				ResultVisitor visitor = null;
				if (what == BufferUpdate.LOADED)
				{
					visitor = new BufferLoadedVisitor();
				}
				else // BufferUpdate.CLOSED
				{
					visitor = new BufferClosedVisitor();
				}
				visitBuffers(visitor,buffer);
			}
		}
	} //}}}
	//{{{ getTreeModel() method
	public DefaultTreeModel getTreeModel()
	{
		return resultTreeModel;
	} //}}}
	//{{{ getTree() method
	/**
	 * Returns the result tree.
	 * @since jEdit 4.1pre9
	 */
	public JTree getTree()
	{
		return resultTree;
	} //}}}
	//{{{ searchStarted() method
	public void searchStarted()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.searching""));
	} //}}}
	//{{{ searchFailed() method
	public void searchFailed()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.no-results""));
		// collapse all nodes, as suggested on user mailing list...
		for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				resultTreeRoot.getChildAt(i);
			resultTree.collapsePath(new TreePath(new Object[] {
				resultTreeRoot, node }));
		}
	} //}}}
	//{{{ searchDone() method
	public void searchDone(final DefaultMutableTreeNode searchNode)
	{
		final int nodeCount = searchNode.getChildCount();
		if (nodeCount < 1)
		{
			searchFailed();
			return;
		}
		caption.setText(jEdit.getProperty(""hypersearch-results.done""));
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(!multiStatus)
				{
					for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
					{
						resultTreeRoot.remove(0);
					}
				}
				resultTreeRoot.add(searchNode);
				resultTreeModel.reload(resultTreeRoot);
				TreePath lastNode = null;
				for(int i = 0; i < nodeCount; i++)
				{
					lastNode = new TreePath(
						((DefaultMutableTreeNode)
						searchNode.getChildAt(i))
						.getPath());
					resultTree.expandPath(lastNode);
				}
				resultTree.scrollPathToVisible(
					new TreePath(new Object[] {
					resultTreeRoot,searchNode }));
			}
		});
	} //}}}
	//{{{ Private members
	private View view;
	private JLabel caption;
	private JTree resultTree;
	private DefaultMutableTreeNode resultTreeRoot;
	private DefaultTreeModel resultTreeModel;
	private RolloverButton clear;
	private RolloverButton multi;
	private boolean multiStatus;
	//{{{ updateMultiStatus() method
	private void updateMultiStatus()
	{
		if(multiStatus)
			multi.setIcon(GUIUtilities.loadIcon(""MultipleResults.png""));
		else
			multi.setIcon(GUIUtilities.loadIcon(""SingleResult.png""));
	} //}}}
	//{{{ goToSelectedNode() method
	private void goToSelectedNode()
	{
		TreePath path = resultTree.getSelectionPath();
		if(path == null)
			return;
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)path
			.getLastPathComponent();
		Object value = node.getUserObject();
		if(node.getParent() == resultTreeRoot)
		{
			// do nothing if clicked ""foo (showing n occurrences in m files)""
		}
		else if(value instanceof String)
		{
			Buffer buffer = jEdit.openFile(view,(String)value);
			if(buffer == null)
				return;
			view.goToBuffer(buffer);
			// fuck me dead
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					resultTree.requestFocus();
				}
			});
		}
		else if (value instanceof HyperSearchResult)
		{
			((HyperSearchResult)value).goTo(view);
		}
	} //}}}
	//}}}
	//{{{ ActionHandler class
	public class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == clear)
			{
				resultTreeRoot.removeAllChildren();
				resultTreeModel.reload(resultTreeRoot);
			}
			else if(source == multi)
			{
				multiStatus = !multiStatus;
				updateMultiStatus();
				if(!multiStatus)
				{
					for(int i = resultTreeRoot.getChildCount() - 2; i >= 0; i--)
					{
						resultTreeModel.removeNodeFromParent(
							(MutableTreeNode)resultTreeRoot
							.getChildAt(i));
					}
				}
			}
		}
	} //}}}
	//{{{ KeyHandler class
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				goToSelectedNode();
				// fuck me dead
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						resultTree.requestFocus();
					}
				});
				evt.consume();
			}
		}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseAdapter
	{
		//{{{ mousePressed() method
		public void mousePressed(MouseEvent evt)
		{
			if(evt.isConsumed())
				return;
			TreePath path1 = resultTree.getPathForLocation(
				evt.getX(),evt.getY());
			if(path1 == null)
				return;
			resultTree.setSelectionPath(path1);
			if (GUIUtilities.isPopupTrigger(evt))
				showPopupMenu(evt);
			else
			{
				goToSelectedNode();
				view.toFront();
				view.requestFocus();
				view.getTextArea().requestFocus();
			}
		} //}}}
		//{{{ Private members
		private JPopupMenu popupMenu;
		//{{{ showPopupMenu method
		private void showPopupMenu(MouseEvent evt)
		{
			if (popupMenu == null)
			{
				popupMenu = new JPopupMenu();
				popupMenu.add(new RemoveTreeNodeAction());
			}
			GUIUtilities.showPopupMenu(popupMenu,evt.getComponent(),
				evt.getX(),evt.getY());
			evt.consume();
		} //}}}
		//}}}
	} //}}}
	//{{{ RemoveTreeNodeAction class
	class RemoveTreeNodeAction extends AbstractAction
	{
		public RemoveTreeNodeAction()
		{
			super(jEdit.getProperty(""hypersearch-results.remove-node""));
		}
		public void actionPerformed(ActionEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			if(path == null)
				return;
			MutableTreeNode value = (MutableTreeNode)path
				.getLastPathComponent();
			resultTreeModel.removeNodeFromParent(value);
		}
	}//}}}
	//{{{ RemoveAllTreeNodesAction class
	class RemoveAllTreeNodesAction extends AbstractAction
	{
		public RemoveAllTreeNodesAction()
		{
			super(jEdit.getProperty(""hypersearch-results.remove-all-nodes""));
		}
		public void actionPerformed(ActionEvent evt)
		{
			resultTreeRoot = new DefaultMutableTreeNode();
			resultTreeModel = new DefaultTreeModel(resultTreeRoot);
			resultTree.setModel(resultTreeModel);
		}
	}//}}}
	//{{{ ResultCellRenderer class
	class ResultCellRenderer extends DefaultTreeCellRenderer
	{
		Font plainFont, boldFont;
		//{{{ ResultCellRenderer constructor
		ResultCellRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			if(plainFont == null)
				plainFont = jEdit.getFontProperty(""metal.secondary.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,
				plainFont.getSize());
		} //}}}
		//{{{ getTreeCellRendererComponent() method
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,hasFocus);
			setIcon(null);
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
			if (node.getParent() == resultTreeRoot)
			{
				ResultCellRenderer.this.setFont(boldFont);
				int bufferCount = node.getChildCount();
				int resultCount = 0;
				for (int i = 0; i < bufferCount; i++)
				{
					resultCount += node.getChildAt(i).getChildCount();
				}
				String property = ""hypersearch-results.result-caption"";
				if (bufferCount == 1)
				{
					property += resultCount == 1 ? ""1"" : ""2"";
				}
				Object[] pp = { node.toString(), new Integer(resultCount), new Integer(bufferCount) };
				setText(jEdit.getProperty(property,pp));
			}
			else if(node.getUserObject() instanceof String)
			{
				// file name
				ResultCellRenderer.this.setFont(boldFont);
				int count = node.getChildCount();
				if(count == 1)
				{
					setText(jEdit.getProperty(""hypersearch-results""
						+ "".file-caption1"",new Object[] {
						node.getUserObject()
						}));
				}
				else
				{
					setText(jEdit.getProperty(""hypersearch-results""
						+ "".file-caption"",new Object[] {
						node.getUserObject(),
						new Integer(count)
						}));
				}
			}
			else
			{
				ResultCellRenderer.this.setFont(plainFont);
			}
			return this;
		} //}}}
	} //}}}
	// these are used to eliminate code duplication. i don't normally use
	// the visitor or ""template method"" pattern, but this code was contributed
	// by Peter Cox and i don't feel like changing it around too much.
	//{{{ ResultVisitor interface
	interface ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result);
	} //}}}
	//{{{ BufferLoadedVisitor class
	class BufferLoadedVisitor implements ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result)
		{
			result.bufferOpened(buffer);
		}
	} //}}}
	//{{{ BufferClosedVisitor class
	class BufferClosedVisitor implements ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result)
		{
			result.bufferClosed();
		}
	} //}}}
}
"
org.gjt.sp.jedit.search.RESearchMatcher,"/*
 * RESearchMatcher.java - Regular expression matcher
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import bsh.BshMethod;
import bsh.NameSpace;
import gnu.regexp.*;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.jedit.MiscUtilities;
//}}}
/**
 * A regular expression string matcher using {@link gnu.regexp}.
 * @author Slava Pestov
 * @version $Id: RESearchMatcher.java,v 1.22 2003/07/14 23:00:54 spestov Exp $
 */
public class RESearchMatcher extends SearchMatcher
{
	/**
	 * Perl5 syntax with character classes enabled.
	 * @since jEdit 3.0pre5
	 */
	public static final RESyntax RE_SYNTAX_JEDIT
		= new RESyntax(RESyntax.RE_SYNTAX_PERL5)
		.set(RESyntax.RE_CHAR_CLASSES)
		.setLineSeparator(""\n"");
	//{{{ RESearchMatcher constructor
	/**
	 * Creates a new regular expression string matcher.
	 * @since jEdit 4.2pre4
	 */
	public RESearchMatcher(String search, boolean ignoreCase)
		throws REException
	{
		re = new RE(search,(ignoreCase ? RE.REG_ICASE : 0)
			| RE.REG_MULTILINE,RE_SYNTAX_JEDIT);
		returnValue = new Match();
	} //}}}
	//{{{ nextMatch() method
	/**
	 * Returns the offset of the first match of the specified text
	 * within this matcher.
	 * @param text The text to search in
	 * @param start True if the start of the segment is the beginning of the
	 * buffer
	 * @param end True if the end of the segment is the end of the buffer
	 * @param firstTime If false and the search string matched at the start
	 * offset with length zero, automatically find next match
	 * @param reverse If true, searching will be performed in a backward
	 * direction.
	 * @return an array where the first element is the start offset
	 * of the match, and the second element is the end offset of
	 * the match
	 * @since jEdit 4.2pre4
	 */
	public SearchMatcher.Match nextMatch(CharIndexed text, boolean start,
		boolean end, boolean firstTime, boolean reverse)
	{
		int flags = 0;
		// unless we are matching from the start of the buffer,
		// ^ should not match on the beginning of the substring
		if(!start)
			flags |= RE.REG_NOTBOL;
		// unless we are matching to the end of the buffer,
		// $ should not match on the end of the substring
		if(!end)
			flags |= RE.REG_NOTEOL;
		REMatch match = re.getMatch(text,0,flags);
		if(match == null)
			return null;
		returnValue.substitutions = new String[
			re.getNumSubs() + 1];
		for(int i = 0; i < returnValue.substitutions.length; i++)
		{
			returnValue.substitutions[i] = match.toString(i);
		}
		int _start = match.getStartIndex();
		int _end = match.getEndIndex();
		// some regexps (eg ^ by itself) have a length == 0, so we
		// implement this hack. if you don't understand what's going on
		// here, then go back to watching MTV
		if(!firstTime && _start == 0 && _end == 0)
		{
			text.move(1);
			if(text.charAt(0) == CharIndexed.OUT_OF_BOUNDS)
			{
				// never mind
				return null;
			}
			match = re.getMatch(text,0,flags | RE.REG_NOTBOL);
			if(match == null)
				return null;
			else
			{
				_start = match.getStartIndex() + 1;
				_end = match.getEndIndex() + 1;
			}
		}
		returnValue.start = _start;
		returnValue.end = _end;
		return returnValue;
	} //}}}
	//{{{ Private members
	private RE re;
	//}}}
}
"
org.gjt.sp.jedit.search.SearchAndReplace,"/*
 * SearchAndReplace.java - Search and replace
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 * Portions copyright (C) 2001 Tom Locke
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import bsh.*;
import java.awt.*;
import javax.swing.JOptionPane;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.TextAreaDialog;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.CharIndexedSegment;
import org.gjt.sp.util.Log;
//}}}
/**
 * Class that implements regular expression and literal search within
 * jEdit buffers.<p>
 *
 * There are two main groups of methods in this class:
 * <ul>
 * <li>Property accessors - for changing search and replace settings.</li>
 * <li>Actions - for performing search and replace.</li>
 * </ul>
 *
 * The ""HyperSearch"" and ""Keep dialog"" features, as reflected in
 * checkbox options in the search dialog, are not handled from within
 * this class. If you wish to have these options set before the search dialog
 * appears, make a prior call to either or both of the following:
 *
 * <pre> jEdit.setBooleanProperty(""search.hypersearch.toggle"",true);
 * jEdit.setBooleanProperty(""search.keepDialog.toggle"",true);</pre>
 *
 * If you are not using the dialog to undertake a search or replace, you may
 * call any of the search and replace methods (including
 * {@link #hyperSearch(View)}) without concern for the value of these
 * properties.
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: SearchAndReplace.java,v 1.64 2004/08/08 03:41:34 spestov Exp $
 */
public class SearchAndReplace
{
	//{{{ Getters and setters
	//{{{ setSearchString() method
	/**
	 * Sets the current search string.
	 * @param search The new search string
	 */
	public static void setSearchString(String search)
	{
		if(search.equals(SearchAndReplace.search))
			return;
		SearchAndReplace.search = search;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getSearchString() method
	/**
	 * Returns the current search string.
	 */
	public static String getSearchString()
	{
		return search;
	} //}}}
	//{{{ setReplaceString() method
	/**
	 * Sets the current replacement string.
	 * @param replace The new replacement string
	 */
	public static void setReplaceString(String replace)
	{
		if(replace.equals(SearchAndReplace.replace))
			return;
		SearchAndReplace.replace = replace;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getReplaceString() method
	/**
	 * Returns the current replacement string.
	 */
	public static String getReplaceString()
	{
		return replace;
	} //}}}
	//{{{ setIgnoreCase() method
	/**
	 * Sets the ignore case flag.
	 * @param ignoreCase True if searches should be case insensitive,
	 * false otherwise
	 */
	public static void setIgnoreCase(boolean ignoreCase)
	{
		if(ignoreCase == SearchAndReplace.ignoreCase)
			return;
		SearchAndReplace.ignoreCase = ignoreCase;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getIgnoreCase() method
	/**
	 * Returns the state of the ignore case flag.
	 * @return True if searches should be case insensitive,
	 * false otherwise
	 */
	public static boolean getIgnoreCase()
	{
		return ignoreCase;
	} //}}}
	//{{{ setRegexp() method
	/**
	 * Sets the state of the regular expression flag.
	 * @param regexp True if regular expression searches should be
	 * performed
	 */
	public static void setRegexp(boolean regexp)
	{
		if(regexp == SearchAndReplace.regexp)
			return;
		SearchAndReplace.regexp = regexp;
		if(regexp && reverse)
			reverse = false;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getRegexp() method
	/**
	 * Returns the state of the regular expression flag.
	 * @return True if regular expression searches should be performed
	 */
	public static boolean getRegexp()
	{
		return regexp;
	} //}}}
	//{{{ setReverseSearch() method
	/**
	 * Determines whether a reverse search will conducted from the current
	 * position to the beginning of a buffer. Note that reverse search and
	 * regular expression search is mutually exclusive; enabling one will
	 * disable the other.
	 * @param reverse True if searches should go backwards,
	 * false otherwise
	 */
	public static void setReverseSearch(boolean reverse)
	{
		if(reverse == SearchAndReplace.reverse)
			return;
		SearchAndReplace.reverse = reverse;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getReverseSearch() method
	/**
	 * Returns the state of the reverse search flag.
	 * @return True if searches should go backwards,
	 * false otherwise
	 */
	public static boolean getReverseSearch()
	{
		return reverse;
	} //}}}
	//{{{ setBeanShellReplace() method
	/**
	 * Sets the state of the BeanShell replace flag.
	 * @param beanshell True if the replace string is a BeanShell expression
	 * @since jEdit 3.2pre2
	 */
	public static void setBeanShellReplace(boolean beanshell)
	{
		if(beanshell == SearchAndReplace.beanshell)
			return;
		SearchAndReplace.beanshell = beanshell;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getBeanShellReplace() method
	/**
	 * Returns the state of the BeanShell replace flag.
	 * @return True if the replace string is a BeanShell expression
	 * @since jEdit 3.2pre2
	 */
	public static boolean getBeanShellReplace()
	{
		return beanshell;
	} //}}}
	//{{{ setAutoWrap() method
	/**
	 * Sets the state of the auto wrap around flag.
	 * @param wrap If true, the 'continue search from start' dialog
	 * will not be displayed
	 * @since jEdit 3.2pre2
	 */
	public static void setAutoWrapAround(boolean wrap)
	{
		if(wrap == SearchAndReplace.wrap)
			return;
		SearchAndReplace.wrap = wrap;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getAutoWrap() method
	/**
	 * Returns the state of the auto wrap around flag.
	 * @since jEdit 3.2pre2
	 */
	public static boolean getAutoWrapAround()
	{
		return wrap;
	} //}}}
	//{{{ setSearchMatcher() method
	/**
	 * Sets a custom search string matcher. Note that calling
	 * {@link #setSearchString(String)},
	 * {@link #setIgnoreCase(boolean)}, or {@link #setRegexp(boolean)}
	 * will reset the matcher to the default.
	 */
	public static void setSearchMatcher(SearchMatcher matcher)
	{
		SearchAndReplace.matcher = matcher;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getSearchMatcher() method
	/**
	 * Returns the current search string matcher.
	 * @exception IllegalArgumentException if regular expression search
	 * is enabled, the search string or replacement string is invalid
	 * @since jEdit 4.1pre7
	 */
	public static SearchMatcher getSearchMatcher()
		throws Exception
	{
		if(matcher != null)
			return matcher;
		if(search == null || """".equals(search))
			return null;
		if(regexp)
			matcher = new RESearchMatcher(search,ignoreCase);
		else
		{
			matcher = new BoyerMooreSearchMatcher(search,ignoreCase);
		}
		return matcher;
	} //}}}
	//{{{ setSearchFileSet() method
	/**
	 * Sets the current search file set.
	 * @param fileset The file set to perform searches in
	 * @see AllBufferSet
	 * @see CurrentBufferSet
	 * @see DirectoryListSet
	 */
	public static void setSearchFileSet(SearchFileSet fileset)
	{
		SearchAndReplace.fileset = fileset;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ getSearchFileSet() method
	/**
	 * Returns the current search file set.
	 */
	public static SearchFileSet getSearchFileSet()
	{
		return fileset;
	} //}}}
	//{{{ getSmartCaseReplace() method
	/**
	 * Returns if the replacement string will assume the same case as
	 * each specific occurrence of the search string.
	 * @since jEdit 4.2pre10
	 */
	public static boolean getSmartCaseReplace()
	{
		return (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);
	} //}}}
	//}}}
	//{{{ Actions
	//{{{ hyperSearch() method
	/**
	 * Performs a HyperSearch.
	 * @param view The view
	 * @since jEdit 2.7pre3
	 */
	public static boolean hyperSearch(View view)
	{
		return hyperSearch(view,false);
	} //}}}
	//{{{ hyperSearch() method
	/**
	 * Performs a HyperSearch.
	 * @param view The view
	 * @param selection If true, will only search in the current selection.
	 * Note that the file set must be the current buffer file set for this
	 * to work.
	 * @since jEdit 4.0pre1
	 */
	public static boolean hyperSearch(View view, boolean selection)
	{
		// component that will parent any dialog boxes
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;
		record(view,""hyperSearch(view,"" + selection + "")"",false,
			!selection);
		view.getDockableWindowManager().addDockableWindow(
			HyperSearchResults.NAME);
		final HyperSearchResults results = (HyperSearchResults)
			view.getDockableWindowManager()
			.getDockable(HyperSearchResults.NAME);
		results.searchStarted();
		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
			{
				view.getToolkit().beep();
				results.searchFailed();
				return false;
			}
			Selection[] s;
			if(selection)
			{
				s = view.getTextArea().getSelection();
				if(s == null)
				{
					results.searchFailed();
					return false;
				}
			}
			else
				s = null;
			VFSManager.runInWorkThread(new HyperSearchRequest(view,
				matcher,results,s));
			return true;
		}
		catch(Exception e)
		{
			results.searchFailed();
			handleError(comp,e);
			return false;
		}
	} //}}}
	//{{{ find() method
	/**
	 * Finds the next occurance of the search string.
	 * @param view The view
	 * @return True if the operation was successful, false otherwise
	 */
	public static boolean find(View view)
	{
		// component that will parent any dialog boxes
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null || !comp.isShowing())
			comp = view;
		boolean repeat = false;
		String path = fileset.getNextFile(view,null);
		if(path == null)
		{
			GUIUtilities.error(comp,""empty-fileset"",null);
			return false;
		}
		boolean _reverse = reverse && fileset instanceof CurrentBufferSet;
		if(_reverse && regexp)
		{
			GUIUtilities.error(comp,""regexp-reverse"",null);
			return false;
		}
		try
		{
			view.showWaitCursor();
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
			{
				view.getToolkit().beep();
				return false;
			}
			record(view,""find(view)"",false,true);
loop:			for(;;)
			{
				while(path != null)
				{
					Buffer buffer = jEdit.openTemporary(
						view,null,path,false);
					/* this is stupid and misleading.
					 * but 'path' is not used anywhere except
					 * the above line, and if this is done
					 * after the 'continue', then we will
					 * either hang, or be forced to duplicate
					 * it inside the buffer == null, or add
					 * a 'finally' clause. you decide which one's
					 * worse. */
					path = fileset.getNextFile(view,path);
					if(buffer == null)
						continue loop;
					// Wait for the buffer to load
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();
					int start;
					if(view.getBuffer() == buffer && !repeat)
					{
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else if(_reverse)
							start = s.getStart();
						else
							start = s.getEnd();
					}
					else if(_reverse)
						start = buffer.getLength();
					else
						start = 0;
					if(find(view,buffer,start,repeat,_reverse))
						return true;
				}
				if(repeat)
				{
					if(!BeanShell.isScriptRunning())
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(""view.status.search-not-found""));
						view.getToolkit().beep();
					}
					return false;
				}
				boolean restart;
				// if auto wrap is on, always restart search.
				// if auto wrap is off, and we're called from
				// a macro, stop search. If we're called
				// interactively, ask the user what to do.
				if(wrap)
				{
					if(!BeanShell.isScriptRunning())
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(""view.status.auto-wrap""));
						// beep if beep property set
						if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
						{
							view.getToolkit().beep();
						}
					}
					restart = true;
				}
				else if(BeanShell.isScriptRunning())
				{
					restart = false;
				}
				else
				{
					Integer[] args = { new Integer(_reverse ? 1 : 0) };
					int result = GUIUtilities.confirm(comp,
						""keepsearching"",args,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					restart = (result == JOptionPane.YES_OPTION);
				}
				if(restart)
				{
					// start search from beginning
					path = fileset.getFirstFile(view);
					repeat = true;
				}
				else
					break loop;
			}
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			view.hideWaitCursor();
		}
		return false;
	} //}}}
	//{{{ find() method
	/**
	 * Finds the next instance of the search string in the specified
	 * buffer.
	 * @param view The view
	 * @param buffer The buffer
	 * @param start Location where to start the search
	 */
	public static boolean find(View view, Buffer buffer, int start)
		throws Exception
	{
		return find(view,buffer,start,false,false);
	} //}}}
	//{{{ find() method
	/**
	 * Finds the next instance of the search string in the specified
	 * buffer.
	 * @param view The view
	 * @param buffer The buffer
	 * @param start Location where to start the search
	 * @param firstTime See {@link SearchMatcher#nextMatch(CharIndexed,
	 * boolean,boolean,boolean,boolean)}.
	 * @since jEdit 4.1pre7
	 */
	public static boolean find(View view, Buffer buffer, int start,
		boolean firstTime, boolean reverse) throws Exception
	{
		SearchMatcher matcher = getSearchMatcher();
		if(matcher == null)
		{
			view.getToolkit().beep();
			return false;
		}
		Segment text = new Segment();
		if(reverse)
			buffer.getText(0,start,text);
		else
			buffer.getText(start,buffer.getLength() - start,text);
		// the start and end flags will be wrong with reverse search enabled,
		// but they are only used by the regexp matcher, which doesn't
		// support reverse search yet.
		//
		// REMIND: fix flags when adding reverse regexp search.
		SearchMatcher.Match match = matcher.nextMatch(new CharIndexedSegment(text,reverse),
			start == 0,true,firstTime,reverse);
		if(match != null)
		{
			jEdit.commitTemporary(buffer);
			view.setBuffer(buffer);
			JEditTextArea textArea = view.getTextArea();
			if(reverse)
			{
				textArea.setSelection(new Selection.Range(
					start - match.end,
					start - match.start));
				// make sure end of match is visible
				textArea.scrollTo(start - match.start,false);
				textArea.moveCaretPosition(start - match.end);
			}
			else
			{
				textArea.setSelection(new Selection.Range(
					start + match.start,
					start + match.end));
				textArea.moveCaretPosition(start + match.end);
				// make sure start of match is visible
				textArea.scrollTo(start + match.start,false);
			}
			return true;
		}
		else
			return false;
	} //}}}
	//{{{ replace() method
	/**
	 * Replaces the current selection with the replacement string.
	 * @param view The view
	 * @return True if the operation was successful, false otherwise
	 */
	public static boolean replace(View view)
	{
		// component that will parent any dialog boxes
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;
		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();
		if(!buffer.isEditable())
			return false;
		boolean smartCaseReplace = getSmartCaseReplace();
		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return false;
		}
		record(view,""replace(view)"",true,false);
		// a little hack for reverse replace and find
		int caret = textArea.getCaretPosition();
		Selection s = textArea.getSelectionAtOffset(caret);
		if(s != null)
			caret = s.getStart();
		try
		{
			buffer.beginCompoundEdit();
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;
			initReplace();
			int retVal = 0;
			for(int i = 0; i < selection.length; i++)
			{
				s = selection[i];
				retVal += replaceInSelection(textArea,
					buffer,matcher,smartCaseReplace,s);
			}
			boolean _reverse = !regexp && reverse && fileset instanceof CurrentBufferSet;
			if(_reverse)
			{
				// so that Replace and Find continues from
				// the right location
				textArea.moveCaretPosition(caret);
			}
			else
			{
				s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s != null)
					textArea.moveCaretPosition(s.getEnd());
			}
			if(retVal == 0)
			{
				view.getToolkit().beep();
				return false;
			}
			return true;
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		return false;
	} //}}}
	//{{{ replace() method
	/**
	 * Replaces text in the specified range with the replacement string.
	 * @param view The view
	 * @param buffer The buffer
	 * @param start The start offset
	 * @param end The end offset
	 * @return True if the operation was successful, false otherwise
	 */
	public static boolean replace(View view, Buffer buffer, int start, int end)
	{
		if(!buffer.isEditable())
			return false;
		// component that will parent any dialog boxes
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;
		boolean smartCaseReplace = getSmartCaseReplace();
		try
		{
			buffer.beginCompoundEdit();
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;
			initReplace();
			int retVal = 0;
			retVal += _replace(buffer,matcher,start,end,
				smartCaseReplace);
			if(retVal != 0)
				return true;
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		return false;
	} //}}}
	//{{{ replaceAll() method
	/**
	 * Replaces all occurances of the search string with the replacement
	 * string.
	 * @param view The view
	 */
	public static boolean replaceAll(View view)
	{
		// component that will parent any dialog boxes
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;
		int fileCount = 0;
		int occurCount = 0;
		if(fileset.getFileCount(view) == 0)
		{
			GUIUtilities.error(comp,""empty-fileset"",null);
			return false;
		}
		record(view,""replaceAll(view)"",true,true);
		view.showWaitCursor();
		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);
		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;
			initReplace();
			String path = fileset.getFirstFile(view);
loop:			while(path != null)
			{
				Buffer buffer = jEdit.openTemporary(
					view,null,path,false);
				/* this is stupid and misleading.
				 * but 'path' is not used anywhere except
				 * the above line, and if this is done
				 * after the 'continue', then we will
				 * either hang, or be forced to duplicate
				 * it inside the buffer == null, or add
				 * a 'finally' clause. you decide which one's
				 * worse. */
				path = fileset.getNextFile(view,path);
				if(buffer == null)
					continue loop;
				// Wait for buffer to finish loading
				if(buffer.isPerformingIO())
					VFSManager.waitForRequests();
				if(!buffer.isEditable())
					continue loop;
				// Leave buffer in a consistent state if
				// an error occurs
				int retVal = 0;
				try
				{
					buffer.beginCompoundEdit();
					retVal = _replace(buffer,matcher,
						0,buffer.getLength(),
						smartCaseReplace);
				}
				finally
				{
					buffer.endCompoundEdit();
				}
				if(retVal != 0)
				{
					fileCount++;
					occurCount += retVal;
					jEdit.commitTemporary(buffer);
				}
			}
		}
		catch(Exception e)
		{
			handleError(comp,e);
		}
		finally
		{
			view.hideWaitCursor();
		}
		/* Don't do this when playing a macro, cos it's annoying */
		if(!BeanShell.isScriptRunning())
		{
			Object[] args = { new Integer(occurCount),
				new Integer(fileCount) };
			view.getStatus().setMessageAndClear(jEdit.getProperty(
				""view.status.replace-all"",args));
			if(occurCount == 0)
				view.getToolkit().beep();
		}
		return (fileCount != 0);
	} //}}}
	//}}}
	//{{{ load() method
	/**
	 * Loads search and replace state from the properties.
	 */
	public static void load()
	{
		search = jEdit.getProperty(""search.find.value"");
		replace = jEdit.getProperty(""search.replace.value"");
		ignoreCase = jEdit.getBooleanProperty(""search.ignoreCase.toggle"");
		regexp = jEdit.getBooleanProperty(""search.regexp.toggle"");
		beanshell = jEdit.getBooleanProperty(""search.beanshell.toggle"");
		wrap = jEdit.getBooleanProperty(""search.wrap.toggle"");
		fileset = new CurrentBufferSet();
		// Tags plugin likes to call this method at times other than
		// startup; so we need to fire a SearchSettingsChanged to
		// notify the search bar and so on.
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} //}}}
	//{{{ save() method
	/**
	 * Saves search and replace state to the properties.
	 */
	public static void save()
	{
		jEdit.setProperty(""search.find.value"",search);
		jEdit.setProperty(""search.replace.value"",replace);
		jEdit.setBooleanProperty(""search.ignoreCase.toggle"",ignoreCase);
		jEdit.setBooleanProperty(""search.regexp.toggle"",regexp);
		jEdit.setBooleanProperty(""search.beanshell.toggle"",beanshell);
		jEdit.setBooleanProperty(""search.wrap.toggle"",wrap);
	} //}}}
	//{{{ handleError() method
	static void handleError(Component comp, Exception e)
	{
		Log.log(Log.ERROR,SearchAndReplace.class,e);
		if(comp instanceof Dialog)
		{
			new TextAreaDialog((Dialog)comp,
				beanshell ? ""searcherror-bsh""
				: ""searcherror"",e);
		}
		else
		{
			new TextAreaDialog((Frame)comp,
				beanshell ? ""searcherror-bsh""
				: ""searcherror"",e);
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private static String search;
	private static String replace;
	private static BshMethod replaceMethod;
	private static NameSpace replaceNS = new NameSpace(
		BeanShell.getNameSpace(),
		BeanShell.getNameSpace().getClassManager(),
		""search and replace"");
	private static boolean regexp;
	private static boolean ignoreCase;
	private static boolean reverse;
	private static boolean beanshell;
	private static boolean wrap;
	private static SearchMatcher matcher;
	private static SearchFileSet fileset;
	//}}}
	//{{{ initReplace() method
	/**
	 * Set up BeanShell replace if necessary.
	 */
	private static void initReplace() throws Exception
	{
		if(beanshell && replace.length() != 0)
		{
			replaceMethod = BeanShell.cacheBlock(""replace"",
				""return ("" + replace + "");"",true);
		}
		else
			replaceMethod = null;
	} //}}}
	//{{{ record() method
	private static void record(View view, String action,
		boolean replaceAction, boolean recordFileSet)
	{
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
		{
			recorder.record(""SearchAndReplace.setSearchString(\""""
				+ MiscUtilities.charsToEscapes(search) + ""\"");"");
			if(replaceAction)
			{
				recorder.record(""SearchAndReplace.setReplaceString(\""""
					+ MiscUtilities.charsToEscapes(replace) + ""\"");"");
				recorder.record(""SearchAndReplace.setBeanShellReplace(""
					+ beanshell + "");"");
			}
			else
			{
				// only record this if doing a find next
				recorder.record(""SearchAndReplace.setAutoWrapAround(""
					+ wrap + "");"");
				recorder.record(""SearchAndReplace.setReverseSearch(""
					+ reverse + "");"");
			}
			recorder.record(""SearchAndReplace.setIgnoreCase(""
				+ ignoreCase + "");"");
			recorder.record(""SearchAndReplace.setRegexp(""
				+ regexp + "");"");
			if(recordFileSet)
			{
				recorder.record(""SearchAndReplace.setSearchFileSet(""
					+ fileset.getCode() + "");"");
			}
			recorder.record(""SearchAndReplace."" + action + "";"");
		}
	} //}}}
	//{{{ replaceInSelection() method
	private static int replaceInSelection(JEditTextArea textArea,
		Buffer buffer, SearchMatcher matcher, boolean smartCaseReplace,
		Selection s) throws Exception
	{
		/* if an occurence occurs at the
		beginning of the selection, the
		selection start will get moved.
		this sucks, so we hack to avoid it. */
		int start = s.getStart();
		int returnValue;
		if(s instanceof Selection.Range)
		{
			returnValue = _replace(buffer,matcher,
				s.getStart(),s.getEnd(),
				smartCaseReplace);
			textArea.removeFromSelection(s);
			textArea.addToSelection(new Selection.Range(
				start,s.getEnd()));
		}
		else if(s instanceof Selection.Rect)
		{
			Selection.Rect rect = (Selection.Rect)s;
			int startCol = rect.getStartColumn(
				buffer);
			int endCol = rect.getEndColumn(
				buffer);
			returnValue = 0;
			for(int j = s.getStartLine(); j <= s.getEndLine(); j++)
			{
				returnValue += _replace(buffer,matcher,
					getColumnOnOtherLine(buffer,j,startCol),
					getColumnOnOtherLine(buffer,j,endCol),
					smartCaseReplace);
			}
			textArea.addToSelection(new Selection.Rect(
				start,s.getEnd()));
		}
		else
			throw new RuntimeException(""Unsupported: "" + s);
		return returnValue;
	} //}}}
	//{{{ _replace() method
	/**
	 * Replaces all occurances of the search string with the replacement
	 * string.
	 * @param buffer The buffer
	 * @param start The start offset
	 * @param end The end offset
	 * @param matcher The search matcher to use
	 * @param smartCaseReplace See user's guide
	 * @return The number of occurrences replaced
	 */
	private static int _replace(Buffer buffer,
		SearchMatcher matcher, int start, int end,
		boolean smartCaseReplace)
		throws Exception
	{
		int occurCount = 0;
		boolean endOfLine = (buffer.getLineEndOffset(
			buffer.getLineOfOffset(end)) - 1 == end);
		Segment text = new Segment();
		int offset = start;
loop:		for(int counter = 0; ; counter++)
		{
			buffer.getText(offset,end - offset,text);
			boolean startOfLine = (buffer.getLineStartOffset(
				buffer.getLineOfOffset(offset)) == offset);
			SearchMatcher.Match occur = matcher.nextMatch(
				new CharIndexedSegment(text,false),
				startOfLine,endOfLine,counter == 0,
				false);
			if(occur == null)
				break loop;
			String found = new String(text.array,
				text.offset + occur.start,
				occur.end - occur.start);
			int length = replaceOne(buffer,occur,offset,found,
				smartCaseReplace);
			if(length == -1)
				offset += occur.end;
			else
			{
				offset += occur.start + length;
				end += (length - found.length());
				occurCount++;
			}
		}
		return occurCount;
	} //}}}
	//{{{ replaceOne() method
	/**
	 * Replace one occurrence of the search string with the
	 * replacement string.
	 */
	private static int replaceOne(Buffer buffer, SearchMatcher.Match occur,
		int offset, String found, boolean smartCaseReplace)
		throws Exception
	{
		String subst = replaceOne(occur,found);
		if(smartCaseReplace && ignoreCase)
		{
			int strCase = TextUtilities.getStringCase(found);
			if(strCase == TextUtilities.LOWER_CASE)
				subst = subst.toLowerCase();
			else if(strCase == TextUtilities.UPPER_CASE)
				subst = subst.toUpperCase();
			else if(strCase == TextUtilities.TITLE_CASE)
				subst = TextUtilities.toTitleCase(subst);
		}
		if(subst != null)
		{
			int start = offset + occur.start;
			int end = offset + occur.end;
			buffer.remove(start,end - start);
			buffer.insert(start,subst);
			return subst.length();
		}
		else
			return -1;
	} //}}}
	//{{{ replaceOne() method
	private static String replaceOne(SearchMatcher.Match occur,
		String found) throws Exception
	{
		if(regexp)
		{
			if(replaceMethod != null)
				return regexpBeanShellReplace(occur);
			else
				return regexpReplace(occur,found);
		}
		else
		{
			if(replaceMethod != null)
				return literalBeanShellReplace(found);
			else
				return replace;
		}
	} //}}}
	//{{{ regexpBeanShellReplace() method
	private static String regexpBeanShellReplace(SearchMatcher.Match occur)
		throws Exception
	{
		for(int i = 0; i < occur.substitutions.length; i++)
		{
			replaceNS.setVariable(""_"" + i,
				occur.substitutions[i]);
		}
		Object obj = BeanShell.runCachedBlock(
			replaceMethod,null,replaceNS);
		if(obj == null)
			return """";
		else
			return obj.toString();
	} //}}}
	//{{{ regexpReplace() method
	private static String regexpReplace(SearchMatcher.Match occur,
		String found) throws Exception
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < replace.length(); i++)
		{
			char ch = replace.charAt(i);
			switch(ch)
			{
			case '$':
				if(i == replace.length() - 1)
				{
					buf.append(ch);
					break;
				}
				ch = replace.charAt(++i);
				if(ch == '$')
					buf.append('$');
				else if(ch == '0')
					buf.append(found);
				else if(Character.isDigit(ch))
				{
					int n = ch - '0';
					if(n < occur
						.substitutions
						.length)
					{
						buf.append(
							occur
							.substitutions
							[n]
						);
					}
				}
				break;
			case '\\':
				if(i == replace.length() - 1)
				{
					buf.append('\\');
					break;
				}
				ch = replace.charAt(++i);
				switch(ch)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(ch);
					break;
				}
				break;
			default:
				buf.append(ch);
				break;
			}
		}
		return buf.toString();
	} //}}}
	//{{{ literalBeanShellReplace() method
	private static String literalBeanShellReplace(String found)
		throws Exception
	{
		replaceNS.setVariable(""_0"",found);
		Object obj = BeanShell.runCachedBlock(
			replaceMethod,
			null,replaceNS);
		if(obj == null)
			return """";
		else
			return obj.toString();
	} //}}}
	//{{{ getColumnOnOtherLine() method
	/**
	 * Should be somewhere else...
	 */
	private static int getColumnOnOtherLine(Buffer buffer, int line,
		int col)
	{
		int returnValue = buffer.getOffsetOfVirtualColumn(
			line,col,null);
		if(returnValue == -1)
			return buffer.getLineEndOffset(line) - 1;
		else
			return buffer.getLineStartOffset(line) + returnValue;
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.search.SearchBar,"/*
 * SearchBar.java - Search & replace toolbar
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import java.awt.event.*;
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Incremental search tool bar.
 */
public class SearchBar extends JPanel
{
	//{{{ SearchBar constructor
	public SearchBar(final View view, boolean temp)
	{
		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
		this.view = view;
		add(Box.createHorizontalStrut(2));
		JLabel label = new JLabel(jEdit.getProperty(""view.search.find""));
		add(label);
		add(Box.createHorizontalStrut(12));
		add(find = new HistoryTextField(""find""));
		find.setSelectAllOnFocus(true);
		Dimension max = find.getPreferredSize();
		max.width = Integer.MAX_VALUE;
		find.setMaximumSize(max);
		ActionHandler actionHandler = new ActionHandler();
		find.addKeyListener(new KeyHandler());
		find.addActionListener(actionHandler);
		find.getDocument().addDocumentListener(new DocumentHandler());
		Insets margin = new Insets(1,1,1,1);
		add(Box.createHorizontalStrut(12));
		add(ignoreCase = new JCheckBox(jEdit.getProperty(
			""search.case"")));
		ignoreCase.addActionListener(actionHandler);
		ignoreCase.setMargin(margin);
		ignoreCase.setRequestFocusEnabled(false);
		add(Box.createHorizontalStrut(2));
		add(regexp = new JCheckBox(jEdit.getProperty(
			""search.regexp"")));
		regexp.addActionListener(actionHandler);
		regexp.setMargin(margin);
		regexp.setRequestFocusEnabled(false);
		add(Box.createHorizontalStrut(2));
		add(hyperSearch = new JCheckBox(jEdit.getProperty(
			""search.hypersearch"")));
		hyperSearch.addActionListener(actionHandler);
		hyperSearch.setMargin(margin);
		hyperSearch.setRequestFocusEnabled(false);
		update();
		//{{{ Create the timer used by incremental search
		timer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(!incrementalSearch(searchStart,searchReverse))
				{
					if(!incrementalSearch(
						(searchReverse
						? view.getBuffer().getLength()
						: 0),searchReverse))
					{
						// not found at all.
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(
							""view.status.search-not-found""));
					}
				}
			}
		}); //}}}
		// if 'temp' is true, hide search bar after user is done with it
		this.temp = temp;
		propertiesChanged();
	} //}}}
	//{{{ getField() method
	public HistoryTextField getField()
	{
		return find;
	} //}}}
	//{{{ setHyperSearch() method
	public void setHyperSearch(boolean hyperSearch)
	{
		jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",hyperSearch);
		this.hyperSearch.setSelected(hyperSearch);
	} //}}}
	//{{{ update() method
	public void update()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		hyperSearch.setSelected(jEdit.getBooleanProperty(
			""view.search.hypersearch.toggle""));
	} //}}}
	//{{{ propertiesChanged() method
	public void propertiesChanged()
	{
		if(temp)
		{
			if(close == null)
			{
				close = new RolloverButton(GUIUtilities.loadIcon(""closebox.gif""));
				close.addActionListener(new ActionHandler());
				close.setToolTipText(jEdit.getProperty(
					""view.search.close-tooltip""));
			}
			add(close);
		}
		else if(close != null)
			remove(close);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private View view;
	private HistoryTextField find;
	private JCheckBox ignoreCase, regexp, hyperSearch;
	private Timer timer;
	// close button only there if 'temp' is true
	private RolloverButton close;
	private int searchStart;
	private boolean searchReverse;
	private boolean temp;
	//}}}
	//{{{ find() method
	private void find(boolean reverse)
	{
		timer.stop();
		String text = find.getText();
		//{{{ If nothing entered, show search and replace dialog box
		if(text.length() == 0)
		{
			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
			SearchDialog.showSearchDialog(view,null,SearchDialog.CURRENT_BUFFER);
		} //}}}
		//{{{ HyperSearch
		else if(hyperSearch.isSelected())
		{
			if(temp)
			{
				view.removeToolBar(SearchBar.this);
			}
                        else
				find.setText(null);
			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(view);
		} //}}}
		//{{{ Incremental search
		else
		{
			if(reverse && SearchAndReplace.getRegexp())
			{
				GUIUtilities.error(view,""regexp-reverse"",null);
				return;
			}
			// on enter, start search from end
			// of current match to find next one
			int start;
			JEditTextArea textArea = view.getTextArea();
			Selection s = textArea.getSelectionAtOffset(
				textArea.getCaretPosition());
			if(s == null)
				start = textArea.getCaretPosition();
			else if(reverse)
				start = s.getStart();
			else
				start = s.getEnd();
			if(!incrementalSearch(start,reverse))
			{
				// not found. start from
				// beginning
				if(!incrementalSearch(reverse
					? view.getBuffer().getLength()
					: 0,reverse))
				{
					// not found at all.
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(
						""view.status.search-not-found""));
				}
				else
				{
					// inform user search restarted
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					// beep if beep property set
					if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
					{
						getToolkit().beep();
					}
				}
			}
		} //}}}
	} //}}}
	//{{{ incrementalSearch() method
	private boolean incrementalSearch(int start, boolean reverse)
	{
		/* For example, if the current fileset is a directory,
		 * C+g will find the next match within that fileset.
		 * This can be annoying if you have just done an
		 * incremental search and want the next occurrence
		 * in the current buffer. */
		SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
		SearchAndReplace.setSearchString(find.getText());
		SearchAndReplace.setReverseSearch(reverse);
		try
		{
			if(SearchAndReplace.find(view,view.getBuffer(),start,false,reverse))
				return true;
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,this,e);
			// invalid regexp, ignore
			// return true to avoid annoying beeping while
			// typing a re
			return true;
		}
		return false;
	} //}}}
	//{{{ timerIncrementalSearch() method
	private void timerIncrementalSearch(int start, boolean reverse)
	{
		this.searchStart = start;
		this.searchReverse = reverse;
		timer.stop();
		timer.setRepeats(false);
		timer.setInitialDelay(150);
		timer.start();
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ ActionHandler class
	class ActionHandler implements ActionListener
	{
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == find)
				find(false);
			else if(source == hyperSearch)
			{
				jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",
					hyperSearch.isSelected());
				update();
			}
			else if(source == ignoreCase)
			{
				SearchAndReplace.setIgnoreCase(ignoreCase
					.isSelected());
			}
			else if(source == regexp)
			{
				SearchAndReplace.setRegexp(regexp
					.isSelected());
			}
			else if(source == close)
			{
				view.removeToolBar(SearchBar.this);
				view.getEditPane().focusOnTextArea();
			}
		} //}}}
	} //}}}
	//{{{ DocumentHandler class
	class DocumentHandler implements DocumentListener
	{
		//{{{ insertUpdate() method
		public void insertUpdate(DocumentEvent evt)
		{
			// on insert, start search from beginning of
			// current match. This will continue to highlight
			// the current match until another match is found
			if(!hyperSearch.isSelected())
			{
				int start;
				JEditTextArea textArea = view.getTextArea();
				Selection s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s == null)
					start = textArea.getCaretPosition();
				else
					start = s.getStart();
				timerIncrementalSearch(start,false);
			}
		} //}}}
		//{{{ removeUpdate() method
		public void removeUpdate(DocumentEvent evt)
		{
			// on backspace, restart from beginning
			if(!hyperSearch.isSelected())
			{
				String text = find.getText();
				if(text.length() != 0)
				{
					// don't beep if not found.
					// subsequent beeps are very
					// annoying when backspacing an
					// invalid search string.
					if(regexp.isSelected())
					{
						// reverse regexp search
						// not supported yet, so
						// 'simulate' with restart
						timerIncrementalSearch(0,false);
					}
					else
					{
						int start;
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else
							start = s.getStart();
						timerIncrementalSearch(start,true);
					}
				}
			}
		} //}}}
		//{{{ changedUpdate() method
		public void changedUpdate(DocumentEvent evt) {}
		//}}}
	} //}}}
	//{{{ KeyHandler class
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_ESCAPE:
				if(temp)
				{
					view.removeToolBar(SearchBar.this);
				}
				evt.consume();
				view.getEditPane().focusOnTextArea();
				break;
			case KeyEvent.VK_ENTER:
				if(evt.isShiftDown())
				{
					evt.consume();
					find(true);
				}
				break;
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.search.SearchDialog,"/*
 * SearchDialog.java - Search and replace dialog
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
//{{{ Imports
import javax.swing.border.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.util.HashMap;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.*;
//}}}
/**
 * Search and replace dialog.
 * @author Slava Pestov
 * @version $Id: SearchDialog.java,v 1.52 2004/02/24 03:46:51 spestov Exp $
 */
public class SearchDialog extends EnhancedDialog implements EBComponent
{
	//{{{ Constants
	/**
	 * Default file set.
	 * @since jEdit 3.2pre2
	 */
	public static final int CURRENT_BUFFER = 0;
	public static final int ALL_BUFFERS = 1;
	public static final int DIRECTORY = 2;
	//}}}
	//{{{ getSearchDialog() method
	public static SearchDialog getSearchDialog(View view)
	{
		if(Debug.DISABLE_SEARCH_DIALOG_POOL)
			return new SearchDialog(view);
		else
			return (SearchDialog)viewHash.get(view);
	} //}}}
	//{{{ preloadSearchDialog() method
	/**
	 * Preloads the search dialog for the given for so that it can be
	 * quickly displayed later.
	 * @since jEdit 4.2pre3
	 */
	public static void preloadSearchDialog(View view)
	{
		if(Debug.DISABLE_SEARCH_DIALOG_POOL)
			return;
		SearchDialog dialog = new SearchDialog(view);
		viewHash.put(view,dialog);
	} //}}}
	//{{{ showSearchDialog() method
	/**
	 * Displays a search and replace dialog box, reusing an existing one
	 * if necessary.
	 * @param view The view
	 * @param searchString The search string
	 * @param searchIn One of CURRENT_BUFFER, ALL_BUFFERS, or DIRECTORY
	 * @since jEdit 4.0pre6
	 */
	public static void showSearchDialog(View view, String searchString,
		int searchIn)
	{
		SearchDialog dialog = getSearchDialog(view);
		dialog.setSearchString(searchString,searchIn);
		GUIUtilities.requestFocus(dialog,dialog.find);
		// ugly workaround
		if(OperatingSystem.isUnix() && !OperatingSystem.isMacOS())
			dialog.setVisible(false);
		dialog.setVisible(true);
		dialog.toFront();
		dialog.requestFocus();
	} //}}}
	//{{{ setSearchString() method
	/**
	 * Sets the search string.
	 * @since jEdit 4.0pre5
	 */
	public void setSearchString(String searchString, int searchIn)
	{
		find.setText(null);
		replace.setText(null);
		if(searchString == null)
			searchCurrentBuffer.setSelected(true);
		else
		{
			if(searchString.indexOf('\n') == -1)
			{
				find.setText(searchString);
				find.selectAll();
				searchCurrentBuffer.setSelected(true);
			}
			else if(searchIn == CURRENT_BUFFER)
			{
				searchSelection.setSelected(true);
				hyperSearch.setSelected(true);
			}
		}
		if(searchIn == CURRENT_BUFFER)
		{
			if(!searchSelection.isSelected())
			{
				// might be already selected, see above.
				searchCurrentBuffer.setSelected(true);
				/* this property is only loaded and saved if
				 * the 'current buffer' file set is selected.
				 * otherwise, it defaults to on. */
				hyperSearch.setSelected(jEdit.getBooleanProperty(
					""search.hypersearch.toggle""));
			}
		}
		else if(searchIn == ALL_BUFFERS)
		{
			searchAllBuffers.setSelected(true);
			hyperSearch.setSelected(true);
		}
		else if(searchIn == DIRECTORY)
		{
			SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
			if(fileset instanceof DirectoryListSet)
			{
				filter.setText(((DirectoryListSet)fileset)
					.getFileFilter());
				directory.setText(((DirectoryListSet)fileset)
					.getDirectory());
				searchSubDirectories.setSelected(((DirectoryListSet)fileset)
					.isRecursive());
			}
			hyperSearch.setSelected(true);
			searchDirectory.setSelected(true);
		}
		updateEnabled();
	} //}}}
	//{{{ ok() method
	public void ok()
	{
		try
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
			if(!save(false))
				return;
			if(searchSelection.isSelected()
				&& view.getTextArea().getSelectionCount() == 0)
			{
				GUIUtilities.error(view,""search-no-selection"",null);
				return;
			}
			if(hyperSearch.isSelected() || searchSelection.isSelected())
			{
				if(SearchAndReplace.hyperSearch(view,
					searchSelection.isSelected()))
					closeOrKeepDialog();
			}
			else
			{
				if(SearchAndReplace.find(view))
					closeOrKeepDialog();
				else
				{
					toFront();
					requestFocus();
					find.requestFocus();
				}
			}
		}
		finally
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		}
	} //}}}
	//{{{ cancel() method
	public void cancel()
	{
		save(true);
		GUIUtilities.saveGeometry(this,""search"");
		setVisible(false);
	} //}}}
	//{{{ handleMessage() method
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof SearchSettingsChanged)
		{
			if(!saving)
				load();
		}
	} //}}}
	//{{{ dispose() method
	public void dispose()
	{
		EditBus.removeFromBus(this);
		viewHash.remove(view);
		super.dispose();
	} //}}}
	//{{{ Private members
	private static HashMap viewHash = new HashMap();
	//{{{ Instance variables
	private View view;
	// fields
	private HistoryTextField find, replace;
	private JRadioButton stringReplace, beanShellReplace;
	// search settings
	private JCheckBox keepDialog, ignoreCase, regexp, hyperSearch,
		wrap;
	private JRadioButton searchBack, searchForward;
	private JRadioButton searchSelection, searchCurrentBuffer,
		searchAllBuffers, searchDirectory;
	// multifile settings
	private HistoryTextField filter, directory;
	private JCheckBox searchSubDirectories;
	private JButton choose;
	private JButton synchronize;
	// buttons
	private JButton findBtn, /* replaceBtn, */ replaceAndFindBtn, replaceAllBtn,
		closeBtn;
	private boolean saving;
	//}}}
	//{{{ SearchDialog constructor
	/**
	 * Creates a new search and replace dialog box.
	 * @param view The view
	 * @param searchString The search string
	 */
	private SearchDialog(View view)
	{
		super(view,jEdit.getProperty(""search.title""),false);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(0,12,12,12));
		setContentPane(content);
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.add(BorderLayout.NORTH,createFieldPanel());
		centerPanel.add(BorderLayout.CENTER,createSearchSettingsPanel());
		content.add(BorderLayout.CENTER,centerPanel);
		content.add(BorderLayout.SOUTH,createMultiFilePanel());
		content.add(BorderLayout.EAST,createButtonsPanel());
		pack();
		jEdit.unsetProperty(""search.width"");
		jEdit.unsetProperty(""search.d-width"");
		jEdit.unsetProperty(""search.height"");
		jEdit.unsetProperty(""search.d-height"");
		GUIUtilities.loadGeometry(this,""search"");
		load();
		EditBus.addToBus(this);
	} //}}}
	//{{{ createFieldPanel() method
	private JPanel createFieldPanel()
	{
		ButtonActionHandler actionHandler = new ButtonActionHandler();
		JPanel fieldPanel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1));
		fieldPanel.setBorder(new EmptyBorder(0,0,12,12));
		JLabel label = new JLabel(jEdit.getProperty(""search.find""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.find.mnemonic"")
			.charAt(0));
		find = new HistoryTextField(""find"");
		find.setColumns(25);
		find.addActionListener(actionHandler);
		label.setLabelFor(find);
		label.setBorder(new EmptyBorder(12,0,2,0));
		fieldPanel.add(label);
		fieldPanel.add(find);
		label = new JLabel(jEdit.getProperty(""search.replace""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.replace.mnemonic"")
			.charAt(0));
		label.setBorder(new EmptyBorder(12,0,0,0));
		fieldPanel.add(label);
		ButtonGroup grp = new ButtonGroup();
		ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler();
		// we use a custom JRadioButton subclass that returns
		// false for isFocusTraversable() so that the user can
		// tab from the search field to the replace field with
		// one keystroke
		Box replaceModeBox = new Box(BoxLayout.X_AXIS);
		stringReplace = new MyJRadioButton(jEdit.getProperty(
			""search.string-replace-btn""));
		stringReplace.addActionListener(replaceActionHandler);
		grp.add(stringReplace);
		replaceModeBox.add(stringReplace);
		replaceModeBox.add(Box.createHorizontalStrut(12));
		beanShellReplace = new MyJRadioButton(jEdit.getProperty(
			""search.beanshell-replace-btn""));
		beanShellReplace.addActionListener(replaceActionHandler);
		grp.add(beanShellReplace);
		replaceModeBox.add(beanShellReplace);
		fieldPanel.add(replaceModeBox);
		fieldPanel.add(Box.createVerticalStrut(3));
		replace = new HistoryTextField(""replace"");
		replace.addActionListener(actionHandler);
		label.setLabelFor(replace);
		fieldPanel.add(replace);
		return fieldPanel;
	} //}}}
	//{{{ createSearchSettingsPanel() method
	private JPanel createSearchSettingsPanel()
	{
		JPanel searchSettings = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,3));
		searchSettings.setBorder(new EmptyBorder(0,0,12,12));
		SettingsActionHandler actionHandler = new SettingsActionHandler();
		ButtonGroup fileset = new ButtonGroup();
		ButtonGroup direction = new ButtonGroup();
		searchSettings.add(new JLabel(jEdit.getProperty(""search.fileset"")));
		searchSettings.add(new JLabel(jEdit.getProperty(""search.settings"")));
		searchSettings.add(new JLabel(jEdit.getProperty(""search.direction"")));
		searchSelection = new JRadioButton(jEdit.getProperty(""search.selection""));
		searchSelection.setMnemonic(jEdit.getProperty(""search.selection.mnemonic"")
			.charAt(0));
		fileset.add(searchSelection);
		searchSettings.add(searchSelection);
		searchSelection.addActionListener(actionHandler);
		keepDialog = new JCheckBox(jEdit.getProperty(""search.keep""));
		keepDialog.setMnemonic(jEdit.getProperty(""search.keep.mnemonic"")
			.charAt(0));
		searchSettings.add(keepDialog);
		searchBack = new JRadioButton(jEdit.getProperty(""search.back""));
		searchBack.setMnemonic(jEdit.getProperty(""search.back.mnemonic"")
			.charAt(0));
		direction.add(searchBack);
		searchSettings.add(searchBack);
		searchBack.addActionListener(actionHandler);
		searchCurrentBuffer = new JRadioButton(jEdit.getProperty(""search.current""));
		searchCurrentBuffer.setMnemonic(jEdit.getProperty(""search.current.mnemonic"")
			.charAt(0));
		fileset.add(searchCurrentBuffer);
		searchSettings.add(searchCurrentBuffer);
		searchCurrentBuffer.addActionListener(actionHandler);
		ignoreCase = new JCheckBox(jEdit.getProperty(""search.case""));
		ignoreCase.setMnemonic(jEdit.getProperty(""search.case.mnemonic"")
			.charAt(0));
		searchSettings.add(ignoreCase);
		ignoreCase.addActionListener(actionHandler);
		searchForward = new JRadioButton(jEdit.getProperty(""search.forward""));
		searchForward.setMnemonic(jEdit.getProperty(""search.forward.mnemonic"")
			.charAt(0));
		direction.add(searchForward);
		searchSettings.add(searchForward);
		searchForward.addActionListener(actionHandler);
		searchAllBuffers = new JRadioButton(jEdit.getProperty(""search.all""));
		searchAllBuffers.setMnemonic(jEdit.getProperty(""search.all.mnemonic"")
			.charAt(0));
		fileset.add(searchAllBuffers);
		searchSettings.add(searchAllBuffers);
		searchAllBuffers.addActionListener(actionHandler);
		regexp = new JCheckBox(jEdit.getProperty(""search.regexp""));
		regexp.setMnemonic(jEdit.getProperty(""search.regexp.mnemonic"")
			.charAt(0));
		searchSettings.add(regexp);
		regexp.addActionListener(actionHandler);
		wrap = new JCheckBox(jEdit.getProperty(""search.wrap""));
		wrap.setMnemonic(jEdit.getProperty(""search.wrap.mnemonic"")
			.charAt(0));
		searchSettings.add(wrap);
		wrap.addActionListener(actionHandler);
		searchDirectory = new JRadioButton(jEdit.getProperty(""search.directory""));
		searchDirectory.setMnemonic(jEdit.getProperty(""search.directory.mnemonic"")
			.charAt(0));
		fileset.add(searchDirectory);
		searchSettings.add(searchDirectory);
		searchDirectory.addActionListener(actionHandler);
		hyperSearch = new JCheckBox(jEdit.getProperty(""search.hypersearch""));
		hyperSearch.setMnemonic(jEdit.getProperty(""search.hypersearch.mnemonic"")
			.charAt(0));
		searchSettings.add(hyperSearch);
		hyperSearch.addActionListener(actionHandler);
		return searchSettings;
	} //}}}
	//{{{ createMultiFilePanel() method
	private JPanel createMultiFilePanel()
	{
		JPanel multifile = new JPanel();
		GridBagLayout layout = new GridBagLayout();
		multifile.setLayout(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = cons.gridwidth = cons.gridheight = 1;
		cons.anchor = GridBagConstraints.WEST;
		cons.fill = GridBagConstraints.HORIZONTAL;
		MultiFileActionHandler actionListener = new MultiFileActionHandler();
		filter = new HistoryTextField(""search.filter"");
		filter.addActionListener(actionListener);
		cons.insets = new Insets(0,0,3,0);
		JLabel label = new JLabel(jEdit.getProperty(""search.filterField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.filterField.mnemonic"")
			.charAt(0));
		label.setLabelFor(filter);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);
		cons.gridwidth = 2;
		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		layout.setConstraints(filter,cons);
		multifile.add(filter);
		cons.gridwidth = 1;
		cons.weightx = 0.0f;
		cons.insets = new Insets(0,0,3,0);
		synchronize = new JButton(jEdit.getProperty(
			""search.synchronize""));
		synchronize.setMnemonic(jEdit.getProperty(
			""search.synchronize.mnemonic"")
			.charAt(0));
		synchronize.addActionListener(actionListener);
		layout.setConstraints(synchronize,cons);
		multifile.add(synchronize);
		cons.gridy++;
		directory = new HistoryTextField(""search.directory"");
		directory.setColumns(25);
		directory.addActionListener(actionListener);
		label = new JLabel(jEdit.getProperty(""search.directoryField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.directoryField.mnemonic"")
			.charAt(0));
		label.setLabelFor(directory);
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);
		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		cons.gridwidth = 2;
		layout.setConstraints(directory,cons);
		multifile.add(directory);
		choose = new JButton(jEdit.getProperty(""search.choose""));
		choose.setMnemonic(jEdit.getProperty(""search.choose.mnemonic"")
			.charAt(0));
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		cons.gridwidth = 1;
		layout.setConstraints(choose,cons);
		multifile.add(choose);
		choose.addActionListener(actionListener);
		cons.insets = new Insets(0,0,0,0);
		cons.gridy++;
		cons.gridwidth = 3;
 		searchSubDirectories = new JCheckBox(jEdit.getProperty(
 			""search.subdirs""));
 		layout.setConstraints(searchSubDirectories,cons);
 		multifile.add(searchSubDirectories);
		return multifile;
	} //}}}
	//{{{ createButtonsPanel() method
	private Box createButtonsPanel()
	{
		Box box = new Box(BoxLayout.Y_AXIS);
		ButtonActionHandler actionHandler = new ButtonActionHandler();
		box.add(Box.createVerticalStrut(12));
		JPanel grid = new JPanel(new GridLayout(5,1,0,12));
		findBtn = new JButton(jEdit.getProperty(""search.findBtn""));
		getRootPane().setDefaultButton(findBtn);
		grid.add(findBtn);
		findBtn.addActionListener(actionHandler);
		/* replaceBtn = new JButton(jEdit.getProperty(""search.replaceBtn""));
		replaceBtn.setMnemonic(jEdit.getProperty(""search.replaceBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceBtn);
		replaceBtn.addActionListener(actionHandler); */
		replaceAndFindBtn = new JButton(jEdit.getProperty(""search.replaceAndFindBtn""));
		replaceAndFindBtn.setMnemonic(jEdit.getProperty(""search.replaceAndFindBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAndFindBtn);
		replaceAndFindBtn.addActionListener(actionHandler);
		replaceAllBtn = new JButton(jEdit.getProperty(""search.replaceAllBtn""));
		replaceAllBtn.setMnemonic(jEdit.getProperty(""search.replaceAllBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAllBtn);
		replaceAllBtn.addActionListener(actionHandler);
		closeBtn = new JButton(jEdit.getProperty(""common.close""));
		grid.add(closeBtn);
		closeBtn.addActionListener(actionHandler);
		grid.setMaximumSize(grid.getPreferredSize());
		box.add(grid);
		box.add(Box.createGlue());
		return box;
	} //}}}
	//{{{ updateEnabled() method
	private void updateEnabled()
	{
		wrap.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());
		boolean reverseEnabled = !hyperSearch.isSelected()
			&& searchCurrentBuffer.isSelected()
			&& !regexp.isSelected();
		searchBack.setEnabled(reverseEnabled);
		searchForward.setEnabled(reverseEnabled);
		if(!reverseEnabled)
			searchForward.setSelected(true);
		filter.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());
		directory.setEnabled(searchDirectory.isSelected());
		choose.setEnabled(searchDirectory.isSelected());
		searchSubDirectories.setEnabled(searchDirectory.isSelected());
		synchronize.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());
		findBtn.setEnabled(!searchSelection.isSelected()
			|| hyperSearch.isSelected());
		replaceAndFindBtn.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());
	} //}}}
	//{{{ save() method
	/**
	 * @param cancel If true, we don't bother the user with warning messages
	 */
	private boolean save(boolean cancel)
	{
		try
		{
			// prevents us from handling SearchSettingsChanged
			// as a result of below
			saving = true;
			SearchAndReplace.setIgnoreCase(ignoreCase.isSelected());
			SearchAndReplace.setRegexp(regexp.isSelected());
			SearchAndReplace.setReverseSearch(searchBack.isSelected());
			SearchAndReplace.setAutoWrapAround(wrap.isSelected());
			String filter = this.filter.getText();
			this.filter.addCurrentToHistory();
			if(filter.length() == 0)
				filter = ""*"";
			SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
			boolean recurse = searchSubDirectories.isSelected();
			if(searchSelection.isSelected())
				fileset = new CurrentBufferSet();
			else if(searchCurrentBuffer.isSelected())
			{
				fileset = new CurrentBufferSet();
				jEdit.setBooleanProperty(""search.hypersearch.toggle"",
					hyperSearch.isSelected());
			}
			else if(searchAllBuffers.isSelected())
				fileset = new AllBufferSet(filter);
			else if(searchDirectory.isSelected())
			{
				String directory = this.directory.getText();
				this.directory.addCurrentToHistory();
				directory = MiscUtilities.constructPath(
					view.getBuffer().getDirectory(),directory);
				if((VFSManager.getVFSForPath(directory).getCapabilities()
					& VFS.LOW_LATENCY_CAP) == 0)
				{
					if(cancel)
						return false;
					int retVal = GUIUtilities.confirm(
						SearchDialog.this,""remote-dir-search"",
						null,JOptionPane.YES_NO_OPTION,
						JOptionPane.WARNING_MESSAGE);
					if(retVal != JOptionPane.YES_OPTION)
						return false;
				}
				if(fileset instanceof DirectoryListSet)
				{
					DirectoryListSet dset = (DirectoryListSet)fileset;
					dset.setDirectory(directory);
					dset.setFileFilter(filter);
					dset.setRecursive(recurse);
					EditBus.send(new SearchSettingsChanged(null));
				}
				else
					fileset = new DirectoryListSet(directory,filter,recurse);
			}
			else
			{
				// can't happen
				fileset = null;
			}
			jEdit.setBooleanProperty(""search.subdirs.toggle"",
				recurse);
			jEdit.setBooleanProperty(""search.keepDialog.toggle"",
				keepDialog.isSelected());
			SearchAndReplace.setSearchFileSet(fileset);
			replace.addCurrentToHistory();
			SearchAndReplace.setReplaceString(replace.getText());
			if(find.getText().length() == 0)
			{
				if(!cancel)
					getToolkit().beep();
				return false;
			}
			find.addCurrentToHistory();
			SearchAndReplace.setSearchString(find.getText());
			return true;
		}
		finally
		{
			saving = false;
		}
	} //}}}
	//{{{ synchronizeMultiFileSettings() method
	private void synchronizeMultiFileSettings()
	{
		directory.setText(view.getBuffer().getDirectory());
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		if(fileset instanceof AllBufferSet)
		{
			filter.setText(((AllBufferSet)fileset)
				.getFileFilter());
		}
		else
		{
			filter.setText(""*"" + MiscUtilities
				.getFileExtension(view.getBuffer()
				.getName()));
		}
	} //}}}
	//{{{ closeOrKeepDialog() method
	private void closeOrKeepDialog()
	{
		if(keepDialog.isSelected())
		{
			// Windows bug workaround in case a YES/NO confirm
			// was shown
			// ... but if HyperSearch results window is floating,
			// the workaround causes problems!
			if(!hyperSearch.isSelected())
			{
				toFront();
				requestFocus();
				find.requestFocus();
			}
			return;
		}
		else
		{
			GUIUtilities.saveGeometry(this,""search"");
			setVisible(false);
		}
	} //}}}
	//{{{ load() method
	private void load()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		wrap.setSelected(SearchAndReplace.getAutoWrapAround());
		if(SearchAndReplace.getReverseSearch())
			searchBack.setSelected(true);
		else
			searchForward.setSelected(true);
		if(SearchAndReplace.getBeanShellReplace())
		{
			replace.setModel(""replace.script"");
			beanShellReplace.setSelected(true);
		}
		else
		{
			replace.setModel(""replace"");
			stringReplace.setSelected(true);
		}
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		HistoryModel model = filter.getModel();
		if(model.getSize() != 0)
			filter.setText(model.getItem(0));
		else
		{
			filter.setText(""*"" + MiscUtilities
				.getFileExtension(view.getBuffer()
				.getName()));
		}
		model = directory.getModel();
		if(model.getSize() != 0)
			directory.setText(model.getItem(0));
		else
			directory.setText(view.getBuffer().getDirectory());
		searchSubDirectories.setSelected(jEdit.getBooleanProperty(
			""search.subdirs.toggle""));
		if(fileset instanceof DirectoryListSet)
		{
			filter.setText(((DirectoryListSet)fileset)
				.getFileFilter());
			directory.setText(((DirectoryListSet)fileset)
				.getDirectory());
			searchSubDirectories.setSelected(((DirectoryListSet)fileset)
				.isRecursive());
		}
		else if(fileset instanceof AllBufferSet)
		{
			filter.setText(((AllBufferSet)fileset)
				.getFileFilter());
		}
		directory.addCurrentToHistory();
		keepDialog.setSelected(jEdit.getBooleanProperty(
			""search.keepDialog.toggle""));
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ MyJRadioButton class
	// used for the stringReplace and beanShell replace radio buttons,
	// so that the user can press tab to go from the find field to the
	// replace field in one go
	class MyJRadioButton extends JRadioButton
	{
		MyJRadioButton(String label)
		{
			super(label);
		}
		public boolean isFocusTraversable()
		{
			return false;
		}
	} //}}}
	//{{{ ReplaceActionHandler class
	class ReplaceActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			replace.setModel(beanShellReplace.isSelected()
				? ""replace.script""
				: ""replace"");
			SearchAndReplace.setBeanShellReplace(
				beanShellReplace.isSelected());
		}
	} //}}}
	//{{{ SettingsActionHandler class
	class SettingsActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == searchCurrentBuffer)
				hyperSearch.setSelected(false);
			else if(source == searchSelection
				|| source == searchAllBuffers
				|| source == searchDirectory)
				hyperSearch.setSelected(true);
			save(true);
			updateEnabled();
		}
	} //}}}
	//{{{ MultiFileActionHandler class
	class MultiFileActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == choose)
			{
				String[] dirs = GUIUtilities.showVFSFileDialog(
					view,directory.getText(),
					VFSBrowser.CHOOSE_DIRECTORY_DIALOG,
					false);
				if(dirs != null)
					directory.setText(dirs[0]);
			}
			else if(evt.getSource() == synchronize)
			{
				synchronizeMultiFileSettings();
			}
			else // source is directory or filter field
			{
				// just as if Enter was pressed in another
				// text field
				ok();
			}
		}
	} //}}}
	//{{{ ButtonActionHandler class
	class ButtonActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == closeBtn)
				cancel();
			else if(source == findBtn || source == find
				|| source == replace)
			{
				ok();
			}
			else if(source == replaceAndFindBtn)
			{
				save(false);
				if(SearchAndReplace.replace(view))
					ok();
				else
					getToolkit().beep();
			}
			else if(source == replaceAllBtn)
			{
				if(searchSelection.isSelected() &&
					view.getTextArea().getSelectionCount()
					== 0)
				{
					GUIUtilities.error(view,""search-no-selection"",null);
					return;
				}
				setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
				if(!save(false))
				{
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					getToolkit().beep();
					return;
				}
				if(searchSelection.isSelected())
				{
					if(SearchAndReplace.replace(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}
				else
				{
					if(SearchAndReplace.replaceAll(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}
				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			}
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.search.SearchFileSet,"/*
 * SearchFileSet.java - Abstract file matcher interface
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import org.gjt.sp.jedit.*;
/**
 * An abstract interface representing a set of files.
 * @author Slava Pestov
 * @version $Id: SearchFileSet.java,v 1.5 2004/03/28 00:07:27 spestov Exp $
 */
public interface SearchFileSet
{
	/**
	 * Returns the first file to search.
	 * @param view The view performing the search
	 */
	String getFirstFile(View view);
	/**
	 * Returns the next file to search.
	 * @param view The view performing the search
	 * @param path The last file searched
	 */
	String getNextFile(View view, String path);
	/**
	 * Returns all path names in this file set.
	 * @param view The view performing the search
	 */
	String[] getFiles(View view);
	/**
	 * Returns the number of files in this file set.
	 */
	int getFileCount(View view);
	/**
	 * Returns the BeanShell code that will recreate this file set.
	 */
	String getCode();
}
"
org.gjt.sp.jedit.search.SearchMatcher,"/*
 * SearchMatcher.java - Abstract string matcher interface
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import gnu.regexp.CharIndexed;
/**
 * An abstract class for matching strings.
 * @author Slava Pestov
 * @version $Id: SearchMatcher.java,v 1.11 2003/07/14 23:00:54 spestov Exp $
 */
public abstract class SearchMatcher
{
	public SearchMatcher()
	{
		returnValue = new Match();
	}
	/**
	 * Returns the offset of the first match of the specified text
	 * within this matcher.
	 * @param text The text to search in
	 * @param start True if the start of the segment is the beginning of the
	 * buffer
	 * @param end True if the end of the segment is the end of the buffer
	 * @param firstTime If false and the search string matched at the start
	 * offset with length zero, automatically find next match
	 * @param reverse If true, searching will be performed in a backward
	 * direction.
	 * @return an array where the first element is the start offset
	 * of the match, and the second element is the end offset of
	 * the match
	 * @since jEdit 4.2pre4
	 */
	public abstract Match nextMatch(CharIndexed text, boolean start,
		boolean end, boolean firstTime, boolean reverse);
	protected Match returnValue;
	//{{{ Match class
	public static class Match
	{
		public int start;
		public int end;
		public String[] substitutions;
	} //}}}
}
"
org.gjt.sp.jedit.syntax.Chunk,"/*
 * Chunk.java - A syntax token with extra information required for painting it
 * on screen
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
//{{{ Imports
import javax.swing.text.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Debug;
//}}}
/**
 * A syntax token with extra information required for painting it
 * on screen.
 * @since jEdit 4.1pre1
 */
public class Chunk extends Token
{
	//{{{ paintChunkList() method
	/**
	 * Paints a chunk list.
	 * @param chunks The chunk list
	 * @param gfx The graphics context
	 * @param x The x co-ordinate
	 * @param y The y co-ordinate
	 * @return The width of the painted text
	 * @since jEdit 4.2pre1
	 */
	public static float paintChunkList(Chunk chunks,
		Graphics2D gfx, float x, float y, boolean glyphVector)
	{
		Rectangle clipRect = gfx.getClipBounds();
		float _x = 0.0f;
		while(chunks != null)
		{
			// only paint visible chunks
			if(x + _x + chunks.width > clipRect.x
				&& x + _x < clipRect.x + clipRect.width)
			{
				// Useful for debugging purposes
				if(Debug.CHUNK_PAINT_DEBUG)
				{
					gfx.draw(new Rectangle2D.Float(x + _x,y - 10,
						chunks.width,10));
				}
				if(chunks.accessable && chunks.visible)
				{
					gfx.setFont(chunks.style.getFont());
					gfx.setColor(chunks.style.getForegroundColor());
					if(glyphVector && chunks.gv != null)
						gfx.drawGlyphVector(chunks.gv,x + _x,y);
					else if(chunks.str != null)
					{
						gfx.drawString(chunks.str,
							(int)(x + _x),(int)y);
					}
				}
			}
			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}
		return _x;
	} //}}}
	//{{{ paintChunkBackgrounds() method
	/**
	 * Paints the background highlights of a chunk list.
	 * @param chunks The chunk list
	 * @param gfx The graphics context
	 * @param x The x co-ordinate
	 * @param y The y co-ordinate
	 * @return The width of the painted backgrounds
	 * @since jEdit 4.2pre1
	 */
	public static float paintChunkBackgrounds(Chunk chunks,
		Graphics2D gfx, float x, float y)
	{
		Rectangle clipRect = gfx.getClipBounds();
		float _x = 0.0f;
		FontMetrics forBackground = gfx.getFontMetrics();
		int ascent = forBackground.getAscent();
		int height = forBackground.getHeight();
		while(chunks != null)
		{
			// only paint visible chunks
			if(x + _x + chunks.width > clipRect.x
				&& x + _x < clipRect.x + clipRect.width)
			{
				if(chunks.accessable)
				{
					//{{{ Paint token background color if necessary
					Color bgColor = chunks.background;
					if(bgColor != null)
					{
						gfx.setColor(bgColor);
						gfx.fill(new Rectangle2D.Float(
							x + _x,y - ascent,
							_x + chunks.width - _x,
							height));
					} //}}}
				}
			}
			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}
		return _x;
	} //}}}
	//{{{ offsetToX() method
	/**
	 * Converts an offset in a chunk list into an x co-ordinate.
	 * @param chunks The chunk list
	 * @param offset The offset
	 * @since jEdit 4.1pre1
	 */
	public static float offsetToX(Chunk chunks, int offset)
	{
		if(chunks != null && offset < chunks.offset)
		{
			throw new ArrayIndexOutOfBoundsException(offset + "" < ""
				+ chunks.offset);
		}
		float x = 0.0f;
		while(chunks != null)
		{
			if(chunks.accessable && offset < chunks.offset + chunks.length)
				return x + chunks.offsetToX(offset - chunks.offset);
			x += chunks.width;
			chunks = (Chunk)chunks.next;
		}
		return x;
	} //}}}
	//{{{ xToOffset() method
	/**
	 * Converts an x co-ordinate in a chunk list into an offset.
	 * @param chunks The chunk list
	 * @param x The x co-ordinate
	 * @param round Round up to next letter if past the middle of a letter?
	 * @return The offset within the line, or -1 if the x co-ordinate is too
	 * far to the right
	 * @since jEdit 4.1pre1
	 */
	public static int xToOffset(Chunk chunks, float x, boolean round)
	{
		float _x = 0.0f;
		while(chunks != null)
		{
			if(chunks.accessable && x < _x + chunks.width)
				return chunks.xToOffset(x - _x,round);
			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}
		return -1;
	} //}}}
	//{{{ Instance variables
	public boolean accessable;
	public boolean visible;
	public boolean initialized;
	public boolean monospaced;
	public int charWidth;
	// set up after init()
	public SyntaxStyle style;
	// this is either style.getBackgroundColor() or
	// styles[defaultID].getBackgroundColor()
	public Color background;
	public float width;
	public GlyphVector gv;
	public String str;
	//}}}
	//{{{ Chunk constructor
	public Chunk(float width, int offset, ParserRuleSet rules)
	{
		super(Token.NULL,offset,0,rules);
		this.width = width;
	} //}}}
	//{{{ Chunk constructor
	public Chunk(byte id, int offset, int length, ParserRuleSet rules,
		SyntaxStyle[] styles, byte defaultID)
	{
		super(id,offset,length,rules);
		accessable = true;
		style = styles[id];
		background = style.getBackgroundColor();
		if(background == null)
			background = styles[defaultID].getBackgroundColor();
	} //}}}
	//{{{ getPositions() method
	public final float[] getPositions()
	{
		if(gv == null)
			return null;
		if(positions == null)
			positions = gv.getGlyphPositions(0,length,null);
		return positions;
	} //}}}
	//{{{ offsetToX() method
	public final float offsetToX(int offset)
	{
		if(!visible)
			return 0.0f;
		else if(monospaced)
			return offset * charWidth;
		else
			return getPositions()[offset * 2];
	} //}}}
	//{{{ xToOffset() method
	public final int xToOffset(float x, boolean round)
	{
		if(!visible)
		{
			if(round && width - x < x)
				return offset + length;
			else
				return offset;
		}
		else if(monospaced)
		{
			x = Math.max(0,x);
			float remainder = x % charWidth;
			int i = (int)(x / charWidth);
			if(round && remainder > charWidth / 2)
				return offset + i + 1;
			else
				return offset + i;
		}
		else
		{
			float[] pos = getPositions();
			for(int i = 0; i < length; i++)
			{
				float glyphX = pos[i*2];
				float nextX = (i == length - 1
					? width : pos[i*2+2]);
				if(nextX > x)
				{
					if(!round || nextX - x > x - glyphX)
						return offset + i;
					else
						return offset + i + 1;
				}
			}
		}
		// wtf?
		return -1;
	} //}}}
	//{{{ init() method
	public void init(Segment seg, TabExpander expander, float x,
		FontRenderContext fontRenderContext)
	{
		initialized = true;
		if(style != null)
			charWidth = style.getCharWidth();
		if(!accessable)
		{
			// do nothing
		}
		else if(length == 1 && seg.array[seg.offset + offset] == '\t')
		{
			visible = false;
			float newX = expander.nextTabStop(x,offset + length);
			width = newX - x;
		}
		else if(charWidth != 0 && !Debug.DISABLE_MONOSPACE_HACK)
		{
			visible = monospaced = true;
			str = new String(seg.array,seg.offset + offset,length);
			width = charWidth * length;
		}
		else
		{
			visible = true;
			str = new String(seg.array,seg.offset + offset,length);
			gv = style.getFont().createGlyphVector(
				fontRenderContext,str);
			width = (float)gv.getLogicalBounds().getWidth();
		}
	} //}}}
	//{{{ Private members
	private float[] positions;
	//}}}
}
"
org.gjt.sp.jedit.syntax.DefaultTokenHandler,"/*
 * DefaultTokenHandler.java - Builds a linked list of Token objects
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.Segment;
/**
 * Builds a linked list of tokens without any additional processing.
 *
 * @author Slava Pestov
 * @version $Id: DefaultTokenHandler.java,v 1.17 2003/10/26 19:43:57 spestov Exp $
 * @since jEdit 4.1pre1
 */
public class DefaultTokenHandler implements TokenHandler
{
	//{{{ reset() method
	/**
	 * Clears the list of tokens.
	 */
	public void init()
	{
		lastToken = firstToken = null;
	} //}}}
	//{{{ getTokens() method
	/**
	 * Returns the first syntax token.
	 * @since jEdit 4.1pre1
	 */
	public Token getTokens()
	{
		return firstToken;
	} //}}}
	//{{{ handleToken() method
	/**
	 * Called by the token marker when a syntax token has been parsed.
	 * @param seg The segment containing the text
	 * @param id The token type (one of the constants in the
	 * {@link Token} class).
	 * @param offset The start offset of the token
	 * @param length The number of characters in the token
	 * @param context The line context
	 * @since jEdit 4.2pre3
	 */
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		Token token = createToken(id,offset,length,context);
		if(token != null)
			addToken(token,context);
	} //}}}
	//{{{ getLineContext() method
	/**
	 * The token handler can compare this object with the object
	 * previously given for this line to see if the token type at the end
	 * of the line has changed (meaning subsequent lines might need to be
	 * retokenized).
	 * @since jEdit 4.2pre6
	 */
	public TokenMarker.LineContext getLineContext()
	{
		return lineContext;
	} //}}}
	//{{{ setLineContext() method
	/**
	 * The token handler can compare this object with the object
	 * previously given for this line to see if the token type at the end
	 * of the line has changed (meaning subsequent lines might need to be
	 * retokenized).
	 * @since jEdit 4.2pre6
	 */
	public void setLineContext(TokenMarker.LineContext lineContext)
	{
		this.lineContext = lineContext;
	} //}}}
	//{{{ Protected members
	protected Token firstToken, lastToken;
	protected TokenMarker.LineContext lineContext;
	//{{{ getParserRuleSet() method
	protected ParserRuleSet getParserRuleSet(TokenMarker.LineContext context)
	{
		while(context != null)
		{
			if(!context.rules.isBuiltIn())
				return context.rules;
			context = context.parent;
		}
		return null;
	} //}}}
	//{{{ createToken() method
	protected Token createToken(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		return new Token(id,offset,length,getParserRuleSet(context));
	} //}}}
	//{{{ addToken() method
	protected void addToken(Token token, TokenMarker.LineContext context)
	{
		if(firstToken == null)
		{
			firstToken = lastToken = token;
		}
		else
		{
			lastToken.next = token;
			lastToken = lastToken.next;
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.syntax.DisplayTokenHandler,"/*
 * DisplayTokenHandler.java - converts tokens to chunks
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
//{{{ Imports
import javax.swing.text.*;
import java.awt.font.*;
import java.util.List;
import org.gjt.sp.jedit.syntax.*;
//}}}
/**
 * Creates {@link Chunk} objects that can be painted on screen.
 */
public class DisplayTokenHandler extends DefaultTokenHandler
{
	// don't have chunks longer than 100 characters to avoid slowing things down
	public static final int MAX_CHUNK_LEN = 100;
	//{{{ init() method
	public void init(SyntaxStyle[] styles,
		FontRenderContext fontRenderContext,
		TabExpander expander, List out,
		float wrapMargin)
	{
		super.init();
		x = 0.0f;
		this.styles = styles;
		this.fontRenderContext = fontRenderContext;
		this.expander = expander;
		// SILLY: allow for anti-aliased characters' ""fuzz""
		if(wrapMargin != 0.0f)
			this.wrapMargin = wrapMargin += 2.0f;
		else
			this.wrapMargin = 0.0f;
		this.out = out;
		seenNonWhitespace = false;
		endX = endOfWhitespace = 0.0f;
		end = null;
	} //}}}
	//{{{ getChunkList() method
	/**
	 * Returns the list of chunks.
	 * @since jEdit 4.1pre7
	 */
	public List getChunkList()
	{
		return out;
	} //}}}
	//{{{ handleToken() method
	/**
	 * Called by the token marker when a syntax token has been parsed.
	 * @param seg The segment containing the text
	 * @param id The token type (one of the constants in the
	 * {@link Token} class).
	 * @param offset The start offset of the token
	 * @param length The number of characters in the token
	 * @param context The line context
	 * @since jEdit 4.2pre3
	 */
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		if(id == Token.END)
		{
			if(firstToken != null)
				out.add(merge((Chunk)firstToken,seg));
			return;
		}
		for(int splitOffset = 0; splitOffset < length; splitOffset += MAX_CHUNK_LEN)
		{
			int splitLength = Math.min(length - splitOffset,MAX_CHUNK_LEN);
			Chunk chunk = createChunk(id,offset + splitOffset,splitLength,context);
			addToken(chunk,context);
			if(wrapMargin != 0.0f)
			{
				initChunk(chunk,seg);
				x += chunk.width;
				if(Character.isWhitespace(seg.array[
					seg.offset + chunk.offset]))
				{
					if(seenNonWhitespace)
					{
						end = lastToken;
						endX = x;
					}
					else
						endOfWhitespace = x;
				}
				else
				{
					if(x > wrapMargin
						&& end != null
						&& seenNonWhitespace)
					{
						Chunk nextLine = new Chunk(endOfWhitespace,
							end.offset + end.length,
							getParserRuleSet(context));
						initChunk(nextLine,seg);
						nextLine.next = end.next;
						end.next = null;
						if(firstToken != null)
							out.add(merge((Chunk)firstToken,seg));
						firstToken = nextLine;
						x = x - endX + endOfWhitespace;
						end = null;
						endX = x;
					}
					seenNonWhitespace = true;
				}
			}
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private SyntaxStyle[] styles;
	private FontRenderContext fontRenderContext;
	private TabExpander expander;
	private float x;
	private List out;
	private float wrapMargin;
	private float endX;
	private Token end;
	private boolean seenNonWhitespace;
	private float endOfWhitespace;
	//}}}
	//{{{ createChunk() method
	private Chunk createChunk(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		return new Chunk(id,offset,length,
			getParserRuleSet(context),styles,
			context.rules.getDefault());
	} //}}}
	//{{{ initChunk() method
	protected void initChunk(Chunk chunk, Segment seg)
	{
		chunk.init(seg,expander,x,fontRenderContext);
	} //}}}
	//{{{ merge() method
	private Chunk merge(Chunk first, Segment seg)
	{
		if(first == null)
			return null;
		Chunk chunk = first;
		while(chunk.next != null)
		{
			Chunk next = (Chunk)chunk.next;
			if(canMerge(chunk,next,seg))
			{
				// in case already initialized; un-initialize it
				chunk.initialized = false;
				chunk.length += next.length;
				chunk.width += next.width;
				chunk.next = next.next;
			}
			else
			{
				if(!chunk.initialized)
				{
					initChunk(chunk,seg);
					if(wrapMargin == 0.0f)
						x += chunk.width;
				}
				chunk = next;
			}
		}
		if(!chunk.initialized)
			initChunk(chunk,seg);
		return first;
	} //}}}
	//{{{ canMerge() method
	private boolean canMerge(Chunk c1, Chunk c2, Segment seg)
	{
		if(!c1.accessable || !c2.accessable)
			return false;
		char ch1 = seg.array[seg.offset + c1.offset];
		char ch2 = seg.array[seg.offset + c2.offset];
		return ((c1.style == c2.style)
			&& ch1 != '\t' && ch2 != '\t'
			&& (c1.length + c2.length <= MAX_CHUNK_LEN));
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.syntax.DummyTokenHandler,"/*
 * DummyTokenHandler.java - Ignores tokens
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.Segment;
/**
 * A dummy token handler that discards tokens.
 *
 * @author Slava Pestov
 * @version $Id: DummyTokenHandler.java,v 1.6 2003/10/26 19:43:58 spestov Exp $
 * @since jEdit 4.1pre1
 */
public class DummyTokenHandler implements TokenHandler
{
	/**
	 * To avoid having to create new instances of this class, use
	 * this variable. This is allowed because instances of this
	 * class do not store any state.
	 */
	public static final DummyTokenHandler INSTANCE = new DummyTokenHandler();
	//{{{ handleToken() method
	/**
	 * Called by the token marker when a syntax token has been parsed.
	 * @param seg The segment containing the text
	 * @param id The token type (one of the constants in the
	 * {@link Token} class).
	 * @param offset The start offset of the token
	 * @param length The number of characters in the token
	 * @param context The line context
	 * @since jEdit 4.2pre3
	 */
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context) {} //}}}
	//{{{ setLineContext() method
	/**
	 * The token handler can compare this object with the object
	 * previously given for this line to see if the token type at the end
	 * of the line has changed (meaning subsequent lines might need to be
	 * retokenized).
	 * @since jEdit 4.2pre6
	 */
	public void setLineContext(TokenMarker.LineContext lineContext)
	{
	} //}}}
}
"
org.gjt.sp.jedit.syntax.KeywordMap,"/*
 * KeywordMap.java - Fast keyword->id map
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2002 Slava Pestov
 * Copyright (C) 1999 Mike Dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.Segment;
import java.util.Vector;
/**
 * A <code>KeywordMap</code> is similar to a hashtable in that it maps keys
 * to values. However, the `keys' are Swing segments. This allows lookups of
 * text substrings without the overhead of creating a new string object.
 *
 * @author Slava Pestov, Mike Dillon
 * @version $Id: KeywordMap.java,v 1.8 2004/05/29 01:55:26 spestov Exp $
 */
public class KeywordMap
{
	//{{{ KeywordMap constructor
	/**
	 * Creates a new <code>KeywordMap</code>.
	 * @param ignoreCase True if keys are case insensitive
	 */
	public KeywordMap(boolean ignoreCase)
	{
		this(ignoreCase, 52);
		this.ignoreCase = ignoreCase;
		noWordSep = new StringBuffer();
	} //}}}
	//{{{ KeywordMap constructor
	/**
	 * Creates a new <code>KeywordMap</code>.
	 * @param ignoreCase True if the keys are case insensitive
	 * @param mapLength The number of `buckets' to create.
	 * A value of 52 will give good performance for most maps.
	 */
	public KeywordMap(boolean ignoreCase, int mapLength)
	{
		this.mapLength = mapLength;
		this.ignoreCase = ignoreCase;
		map = new Keyword[mapLength];
	} //}}}
	//{{{ lookup() method
	/**
	 * Looks up a key.
	 * @param text The text segment
	 * @param offset The offset of the substring within the text segment
	 * @param length The length of the substring
	 */
	public byte lookup(Segment text, int offset, int length)
	{
		if(length == 0)
			return Token.NULL;
		Keyword k = map[getSegmentMapKey(text, offset, length)];
		while(k != null)
		{
			if(length != k.keyword.length)
			{
				k = k.next;
				continue;
			}
			if(SyntaxUtilities.regionMatches(ignoreCase,text,offset,
				k.keyword))
				return k.id;
			k = k.next;
		}
		return Token.NULL;
	} //}}}
	//{{{ add() method
	/**
	 * Adds a key-value mapping.
	 * @param keyword The key
	 * @param id The value
	 */
	public void add(String keyword, byte id)
	{
		add(keyword.toCharArray(),id);
	} //}}}
	//{{{ add() method
	/**
	 * Adds a key-value mapping.
	 * @param keyword The key
	 * @param id The value
	 * @since jEdit 4.2pre3
	 */
	public void add(char[] keyword, byte id)
	{
		int key = getStringMapKey(keyword);
		// complete-word command needs a list of all non-alphanumeric
		// characters used in a keyword map.
loop:		for(int i = 0; i < keyword.length; i++)
		{
			char ch = keyword[i];
			if(!Character.isLetterOrDigit(ch))
			{
				for(int j = 0; j < noWordSep.length(); j++)
				{
					if(noWordSep.charAt(j) == ch)
						continue loop;
				}
				noWordSep.append(ch);
			}
		}
		map[key] = new Keyword(keyword,id,map[key]);
	} //}}}
	//{{{ getNonAlphaNumericChars() method
	/**
	 * Returns all non-alphanumeric characters that appear in the
	 * keywords of this keyword map.
	 * @since jEdit 4.0pre3
	 */
	public String getNonAlphaNumericChars()
	{
		return noWordSep.toString();
	} //}}}
	//{{{ getKeywords() method
	/**
	 * Returns an array containing all keywords in this keyword map.
	 * @since jEdit 4.0pre3
	 */
	public String[] getKeywords()
	{
		Vector vector = new Vector(100);
		for(int i = 0; i < map.length; i++)
		{
			Keyword keyword = map[i];
			while(keyword != null)
			{
				vector.addElement(new String(keyword.keyword));
				keyword = keyword.next;
			}
		}
		String[] retVal = new String[vector.size()];
		vector.copyInto(retVal);
		return retVal;
	} //}}}
	//{{{ getIgnoreCase() method
	/**
	 * Returns true if the keyword map is set to be case insensitive,
	 * false otherwise.
	 */
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} //}}}
	//{{{ setIgnoreCase() method
	/**
	 * Sets if the keyword map should be case insensitive.
	 * @param ignoreCase True if the keyword map should be case
	 * insensitive, false otherwise
	 */
	public void setIgnoreCase(boolean ignoreCase)
	{
		this.ignoreCase = ignoreCase;
	} //}}}
	//{{{ add() method
	/**
	 * Adds the content of another keyword map to this one.
	 * @since jEdit 4.2pre3
	 */
	public void add(KeywordMap map)
	{
		for(int i = 0; i < map.map.length; i++)
		{
			Keyword k = map.map[i];
			while(k != null)
			{
				add(k.keyword,k.id);
				k = k.next;
			}
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private int mapLength;
	private Keyword[] map;
	private boolean ignoreCase;
	private StringBuffer noWordSep;
	//}}}
	//{{{ getStringMapKey() method
	private int getStringMapKey(char[] s)
	{
		return (Character.toUpperCase(s[0]) +
				Character.toUpperCase(s[s.length-1]))
				% mapLength;
	} //}}}
	//{{{ getSegmentMapKey() method
	protected int getSegmentMapKey(Segment s, int off, int len)
	{
		return (Character.toUpperCase(s.array[off]) +
				Character.toUpperCase(s.array[off + len - 1]))
				% mapLength;
	} //}}}
	//}}}
	//{{{ Keyword class
	class Keyword
	{
		public Keyword(char[] keyword, byte id, Keyword next)
		{
			this.keyword = keyword;
			this.id = id;
			this.next = next;
		}
		public char[] keyword;
		public byte id;
		public Keyword next;
	} //}}}
}
"
org.gjt.sp.jedit.syntax.ParserRule,"/*
 * ParserRule.java - Parser rule for the token marker
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999 mike dillon
 * Portions copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import gnu.regexp.*;
/**
 * A parser rule.
 * @author mike dillon, Slava Pestov
 * @version $Id: ParserRule.java,v 1.14 2004/07/12 19:25:08 spestov Exp $
 */
public class ParserRule
{
	/**
	 * Perl5 syntax with character classes enabled.
	 * @since jEdit 4.2pre1
	 */
	// copy and paste from RESyntaxMatcher to make syntax package
	// independent of jEdit itself
	public static final RESyntax RE_SYNTAX_JEDIT
		= new RESyntax(RESyntax.RE_SYNTAX_PERL5)
		.set(RESyntax.RE_CHAR_CLASSES)
		.setLineSeparator(""\n"");
	//{{{ Major actions
	public static final int MAJOR_ACTIONS = 0x000000FF;
	public static final int SEQ = 0;
	public static final int SPAN = 1 << 1;
	public static final int MARK_PREVIOUS = 1 << 2;
	public static final int MARK_FOLLOWING = 1 << 3;
	public static final int EOL_SPAN = 1 << 4;
	//}}}
	//{{{ Action hints
	public static final int ACTION_HINTS = 0x0000FF00;
	public static final int EXCLUDE_MATCH = 1 << 8;
	public static final int NO_LINE_BREAK = 1 << 9;
	public static final int NO_WORD_BREAK = 1 << 10;
	public static final int IS_ESCAPE = 1 << 11;
	public static final int NO_ESCAPE = 1 << 12;
	public static final int REGEXP = 1 << 13;
	//}}}
	//{{{ Position match hints
	public static final int AT_LINE_START = 1 << 1;
	public static final int AT_WHITESPACE_END = 1 << 2;
	public static final int AT_WORD_START = 1 << 3;
	//}}}
	//{{{ Instance variables
	public final char hashChar;
	public final int startPosMatch;
	public final char[] start;
	public final RE startRegexp;
	public final int endPosMatch;
	public final char[] end;
	public final int action;
	public final byte token;
	public ParserRuleSet delegate;
	public ParserRule next;
	//}}}
	//{{{ createSequenceRule() method
	public static final ParserRule createSequenceRule(
		int posMatch, String seq, ParserRuleSet delegate, byte id)
	{
		return new ParserRule(SEQ, seq.charAt(0),
			posMatch, seq.toCharArray(), null,
			0, null, delegate, id);
	} //}}}
	//{{{ createRegexpSequenceRule() method
	public static final ParserRule createRegexpSequenceRule(
		char hashChar, int posMatch, String seq,
		ParserRuleSet delegate, byte id, boolean ignoreCase)
		throws REException
	{
		return new ParserRule(SEQ | REGEXP, hashChar, posMatch,
			null, new RE(""\\A"" + seq,(ignoreCase ? RE.REG_ICASE : 0),
			RE_SYNTAX_JEDIT), 0,
			null, delegate, id);
	} //}}}
	//{{{ createSpanRule() method
	public static final ParserRule createSpanRule(
		int startPosMatch, String start, int endPosMatch, String end,
		ParserRuleSet delegate, byte id, boolean excludeMatch,
		boolean noLineBreak, boolean noWordBreak, boolean noEscape)
	{
		int ruleAction = SPAN |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0) |
			((noEscape) ? NO_ESCAPE : 0);
		return new ParserRule(ruleAction, start.charAt(0), startPosMatch,
			start.toCharArray(), null,
			endPosMatch, end.toCharArray(),
			delegate, id);
	} //}}}
	//{{{ createRegexpSpanRule() method
	public static final ParserRule createRegexpSpanRule(
		char hashChar, int startPosMatch, String start,
		int endPosMatch, String end, ParserRuleSet delegate, byte id,
		boolean excludeMatch, boolean noLineBreak, boolean noWordBreak,
		boolean ignoreCase, boolean noEscape)
		throws REException
	{
		int ruleAction = SPAN | REGEXP |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0) |
			((noEscape) ? NO_ESCAPE : 0);
		return new ParserRule(ruleAction, hashChar, startPosMatch, null,
			new RE(""\\A"" + start,(ignoreCase ? RE.REG_ICASE : 0),
			RE_SYNTAX_JEDIT), endPosMatch,
			end.toCharArray(), delegate, id);
	} //}}}
	//{{{ createEOLSpanRule() method
	public static final ParserRule createEOLSpanRule(
		int posMatch, String seq, ParserRuleSet delegate, byte id,
		boolean excludeMatch)
	{
		int ruleAction = EOL_SPAN |
			((excludeMatch) ? EXCLUDE_MATCH : 0)
			| NO_LINE_BREAK;
		return new ParserRule(ruleAction, seq.charAt(0), posMatch,
			seq.toCharArray(), null, 0, null,
			delegate, id);
	} //}}}
	//{{{ createRegexpEOLSpanRule() method
	public static final ParserRule createRegexpEOLSpanRule(
		char hashChar, int posMatch, String seq, ParserRuleSet delegate,
		byte id, boolean excludeMatch, boolean ignoreCase)
		throws REException
	{
		int ruleAction = EOL_SPAN | REGEXP |
			((excludeMatch) ? EXCLUDE_MATCH : 0)
			| NO_LINE_BREAK;
		return new ParserRule(ruleAction, hashChar, posMatch,
			null, new RE(""\\A"" + seq,(ignoreCase ? RE.REG_ICASE : 0),
			RE_SYNTAX_JEDIT), 0, null,
			delegate, id);
	} //}}}
	//{{{ createMarkFollowingRule() method
	public static final ParserRule createMarkFollowingRule(
		int posMatch, String seq, byte id, boolean excludeMatch)
	{
		int ruleAction = MARK_FOLLOWING |
			((excludeMatch) ? EXCLUDE_MATCH : 0);
		return new ParserRule(ruleAction, seq.charAt(0), posMatch,
			seq.toCharArray(), null, 0, null, null, id);
	} //}}}
	//{{{ createMarkPreviousRule() method
	public static final ParserRule createMarkPreviousRule(
		int posMatch, String seq, byte id, boolean excludeMatch)
	{
		int ruleAction = MARK_PREVIOUS |
			((excludeMatch) ? EXCLUDE_MATCH : 0);
		return new ParserRule(ruleAction, seq.charAt(0), posMatch,
			seq.toCharArray(), null, 0, null, null, id);
	} //}}}
	//{{{ createEscapeRule() method
	public static final ParserRule createEscapeRule(String seq)
	{
		int ruleAction = IS_ESCAPE;
		return new ParserRule(ruleAction, seq.charAt(0),
			0, seq.toCharArray(), null, 0, null,
			null, Token.NULL);
	} //}}}
	//{{{ Private members
	private ParserRule(int action, char hashChar,
		int startPosMatch, char[] start, RE startRegexp,
		int endPosMatch, char[] end,
		ParserRuleSet delegate, byte token)
	{
		this.action = action;
		this.hashChar = hashChar;
		this.startPosMatch = startPosMatch;
		this.start = start;
		this.startRegexp = startRegexp;
		this.endPosMatch = endPosMatch;
		this.end = end;
		this.delegate = delegate;
		this.token = token;
		if(this.delegate == null)
		{
			if((action & MAJOR_ACTIONS) != SEQ)
			{
				this.delegate = ParserRuleSet.getStandardRuleSet(token);
			}
		}
	} //}}}
}
"
org.gjt.sp.jedit.syntax.ParserRuleSet,"/*
 * ParserRuleSet.java - A set of parser rules
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999 mike dillon
 * Portions copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
//{{{ Imports
import gnu.regexp.RE;
import java.util.*;
//}}}
/**
 * A set of parser rules.
 * @author mike dillon
 * @version $Id: ParserRuleSet.java,v 1.23 2003/06/05 00:01:49 spestov Exp $
 */
public class ParserRuleSet
{
	//{{{ getStandardRuleSet() method
	/**
	 * Returns a parser rule set that highlights everything with the
	 * specified token type.
	 * @param id The token type
	 */
	public static ParserRuleSet getStandardRuleSet(byte id)
	{
		return standard[id];
	} //}}}
	//{{{ ParserRuleSet constructor
	public ParserRuleSet(String modeName, String setName)
	{
		this.modeName = modeName;
		this.setName = setName;
		ruleMapFirst = new ParserRule[RULE_BUCKET_COUNT];
		ruleMapLast = new ParserRule[RULE_BUCKET_COUNT];
		imports = new LinkedList();
	} //}}}
	//{{{ getModeName() method
	public String getModeName()
	{
		return modeName;
	} //}}}
	//{{{ getSetName() method
	public String getSetName()
	{
		return setName;
	} //}}}
	//{{{ getName() method
	public String getName()
	{
		return modeName + ""::"" + setName;
	} //}}}
	//{{{ getProperties() method
	public Hashtable getProperties()
	{
		return props;
	} //}}}
	//{{{ setProperties() method
	public void setProperties(Hashtable props)
	{
		this.props = props;
		_noWordSep = null;
	} //}}}
	//{{{ resolveImports() method
	/**
	 * Resolves all rulesets added with {@link #addRuleSet(ParserRuleSet)}.
	 * @since jEdit 4.2pre3
	 */
	public void resolveImports()
	{
		Iterator iter = imports.iterator();
		while(iter.hasNext())
		{
			ParserRuleSet ruleset = (ParserRuleSet)iter.next();
			for(int i = 0; i < ruleset.ruleMapFirst.length; i++)
			{
				ParserRule rule = ruleset.ruleMapFirst[i];
				while(rule != null)
				{
					addRule(rule);
					rule = rule.next;
				}
			}
			if(ruleset.keywords != null)
			{
				if(keywords == null)
					keywords = new KeywordMap(ignoreCase);
				keywords.add(ruleset.keywords);
			}
		}
		imports.clear();
	} //}}}
	//{{{ addRuleSet() method
	/**
	 * Adds all rules contained in the given ruleset.
	 * @param ruleset The ruleset
	 * @since jEdit 4.2pre3
	 */
	public void addRuleSet(ParserRuleSet ruleset)
	{
		imports.add(ruleset);
	} //}}}
	//{{{ addRule() method
	public void addRule(ParserRule r)
	{
		ruleCount++;
		int key = Character.toUpperCase(r.hashChar)
			% RULE_BUCKET_COUNT;
		ParserRule last = ruleMapLast[key];
		if(last == null)
			ruleMapFirst[key] = ruleMapLast[key] = r;
		else
		{
			last.next = r;
			ruleMapLast[key] = r;
		}
	} //}}}
	//{{{ getRules() method
	public ParserRule getRules(char ch)
	{
		int key = Character.toUpperCase(ch) % RULE_BUCKET_COUNT;
		return ruleMapFirst[key];
	} //}}}
	//{{{ getRuleCount() method
	public int getRuleCount()
	{
		return ruleCount;
	} //}}}
	//{{{ getTerminateChar() method
	public int getTerminateChar()
	{
		return terminateChar;
	} //}}}
	//{{{ setTerminateChar() method
	public void setTerminateChar(int atChar)
	{
		terminateChar = (atChar >= 0) ? atChar : -1;
	} //}}}
	//{{{ getIgnoreCase() method
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} //}}}
	//{{{ setIgnoreCase() method
	public void setIgnoreCase(boolean b)
	{
		ignoreCase = b;
	} //}}}
	//{{{ getKeywords() method
	public KeywordMap getKeywords()
	{
		return keywords;
	} //}}}
	//{{{ setKeywords() method
	public void setKeywords(KeywordMap km)
	{
		keywords = km;
		_noWordSep = null;
	} //}}}
	//{{{ getHighlightDigits() method
	public boolean getHighlightDigits()
	{
		return highlightDigits;
	} //}}}
	//{{{ setHighlightDigits() method
	public void setHighlightDigits(boolean highlightDigits)
	{
		this.highlightDigits = highlightDigits;
	} //}}}
	//{{{ getDigitRegexp() method
	public RE getDigitRegexp()
	{
		return digitRE;
	} //}}}
	//{{{ setDigitRegexp() method
	public void setDigitRegexp(RE digitRE)
	{
		this.digitRE = digitRE;
	} //}}}
	//{{{ getEscapeRule() method
	public ParserRule getEscapeRule()
	{
		return escapeRule;
	} //}}}
	//{{{ setEscapeRule() method
	public void setEscapeRule(ParserRule escapeRule)
	{
		addRule(escapeRule);
		this.escapeRule = escapeRule;
	} //}}}
	//{{{ getDefault() method
	public byte getDefault()
	{
		return defaultToken;
	} //}}}
	//{{{ setDefault() method
	public void setDefault(byte def)
	{
		defaultToken = def;
	} //}}}
	//{{{ getNoWordSep() method
	public String getNoWordSep()
	{
		if(_noWordSep == null)
		{
			_noWordSep = noWordSep;
			if(noWordSep == null)
				noWordSep = """";
			if(keywords != null)
				noWordSep += keywords.getNonAlphaNumericChars();
		}
		return noWordSep;
	} //}}}
	//{{{ setNoWordSep() method
	public void setNoWordSep(String noWordSep)
	{
		this.noWordSep = noWordSep;
		_noWordSep = null;
	} //}}}
	//{{{ isBuiltIn() method
	/**
	 * Returns if this is a built-in ruleset.
	 * @since jEdit 4.2pre1
	 */
	public boolean isBuiltIn()
	{
		return builtIn;
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		return getClass().getName() + ""["" + modeName + ""::"" + setName + ""]"";
	} //}}}
	//{{{ Private members
	private static ParserRuleSet[] standard;
	static
	{
		standard = new ParserRuleSet[Token.ID_COUNT];
		for(byte i = 0; i < standard.length; i++)
		{
			standard[i] = new ParserRuleSet(null,null);
			standard[i].setDefault(i);
			standard[i].builtIn = true;
		}
	}
	private static final int RULE_BUCKET_COUNT = 128;
	private String modeName, setName;
	private Hashtable props;
	private KeywordMap keywords;
	private int ruleCount;
	private ParserRule[] ruleMapFirst;
	private ParserRule[] ruleMapLast;
	private LinkedList imports;
	private int terminateChar = -1;
	private boolean ignoreCase = true;
	private byte defaultToken;
	private ParserRule escapeRule;
	private boolean highlightDigits;
	private RE digitRE;
	private String _noWordSep;
	private String noWordSep;
	private boolean builtIn;
	//}}}
}
"
org.gjt.sp.jedit.syntax.SyntaxStyle,"/*
 * SyntaxStyle.java - A simple text style class
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import java.awt.Font;
import java.awt.Color;
/**
 * A simple text style class. It can specify the color, italic flag,
 * and bold flag of a run of text.
 * @author Slava Pestov
 * @version $Id: SyntaxStyle.java,v 1.5 2003/03/14 02:51:25 spestov Exp $
 */
public class SyntaxStyle
{
	//{{{ SyntaxStyle constructor
	/**
	 * Creates a new SyntaxStyle.
	 * @param fgColor The text color
	 * @param bgColor The background color
	 * @param font The text font
	 */
	public SyntaxStyle(Color fgColor, Color bgColor, Font font)
	{
		this.fgColor = fgColor;
		this.bgColor = bgColor;
		this.font = font;
	} //}}}
	//{{{ getForegroundColor() method
	/**
	 * Returns the text color.
	 */
	public Color getForegroundColor()
	{
		return fgColor;
	} //}}}
	//{{{ getBackgroundColor() method
	/**
	 * Returns the background color.
	 */
	public Color getBackgroundColor()
	{
		return bgColor;
	} //}}}
	//{{{ getFont() method
	/**
	 * Returns the style font.
	 */
	public Font getFont()
	{
		return font;
	} //}}}
	//{{{ getCharWidth() method
	/**
	 * Returns the character width of the monospaced font.
	 * @since jEdit 4.2pre1
	 */
	public int getCharWidth()
	{
		return charWidth;
	} //}}}
	//{{{ setCharWidth() method
	/**
	 * Sets the character width of the monospaced font.
	 * @param charWidth The character width
	 * @since jEdit 4.2pre1
	 */
	public void setCharWidth(int charWidth)
	{
		this.charWidth = charWidth;
	} //}}}
	//{{{ Private members
	private Color fgColor;
	private Color bgColor;
	private Font font;
	private int charWidth;
	//}}}
}
"
org.gjt.sp.jedit.syntax.SyntaxUtilities,"/*
 * SyntaxUtilities.java - Utility functions
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.Segment;
/**
 * Contains utility functions used by the syntax highlighting code.
 * @since jEdit 4.2pre1
 * @version $Id: SyntaxUtilities.java,v 1.1 2003/04/28 01:35:28 spestov Exp $
 * @author Slava Pestov
 */
public class SyntaxUtilities
{
	//{{{ regionMatches() method
	/**
	 * Checks if a subregion of a <code>Segment</code> is equal to a
	 * character array.
	 * @param ignoreCase True if case should be ignored, false otherwise
	 * @param text The segment
	 * @param offset The offset into the segment
	 * @param match The character array to match
	 * @since jEdit 4.2pre1
	 */
	public static boolean regionMatches(boolean ignoreCase, Segment text,
		int offset, char[] match)
	{
		int length = offset + match.length;
		if(length > text.offset + text.count)
			return false;
		char[] textArray = text.array;
		for(int i = offset, j = 0; i < length; i++, j++)
		{
			char c1 = textArray[i];
			char c2 = match[j];
			if(ignoreCase)
			{
				c1 = Character.toUpperCase(c1);
				c2 = Character.toUpperCase(c2);
			}
			if(c1 != c2)
				return false;
		}
		return true;
	} //}}}
}
"
org.gjt.sp.jedit.syntax.Token,"/*
 * Token.java - Syntax token
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 1999, 2000, 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import java.lang.reflect.Field;
/**
 * A linked list of syntax tokens.
 *
 * @author Slava Pestov
 * @version $Id: Token.java,v 1.10 2003/03/16 20:55:48 spestov Exp $
 */
public class Token
{
	//{{{ stringToToken() method
	/**
	 * Converts a token type string to a token type constant.
	 * @param value The token type
	 * @since jEdit 4.1pre1
	 */
	public static byte stringToToken(String value)
	{
		try
		{
			Field f = Token.class.getField(value);
			return (byte)f.getByte(null);
		}
		catch(Exception e)
		{
			return -1;
		}
	} //}}}
	//{{{ tokenToString() method
	/**
	 * Converts a token type constant to a token type string.
	 * @since jEdit 4.2pre1
	 */
	public static String tokenToString(byte token)
	{
		return TOKEN_TYPES[token];
	} //}}}
	//{{{ Token types
	public static final String[] TOKEN_TYPES = new String[] {
		""NULL"",
		""COMMENT1"",
		""COMMENT2"",
		""COMMENT3"",
		""COMMENT4"",
		""DIGIT"",
		""FUNCTION"",
		""INVALID"",
		""KEYWORD1"",
		""KEYWORD2"",
		""KEYWORD3"",
		""KEYWORD4"",
		""LABEL"",
		""LITERAL1"",
		""LITERAL2"",
		""LITERAL3"",
		""LITERAL4"",
		""MARKUP"",
		""OPERATOR""
	};
	public static final byte NULL = 0;
	public static final byte COMMENT1 = 1;
	public static final byte COMMENT2 = 2;
	public static final byte COMMENT3 = 3;
	public static final byte COMMENT4 = 4;
	public static final byte DIGIT = 5;
	public static final byte FUNCTION = 6;
	public static final byte INVALID = 7;
	public static final byte KEYWORD1 = 8;
	public static final byte KEYWORD2 = 9;
	public static final byte KEYWORD3 = 10;
	public static final byte KEYWORD4 = 11;
	public static final byte LABEL = 12;
	public static final byte LITERAL1 = 13;
	public static final byte LITERAL2 = 14;
	public static final byte LITERAL3 = 15;
	public static final byte LITERAL4 = 16;
	public static final byte MARKUP = 17;
	public static final byte OPERATOR = 18;
	//}}}
	public static final byte ID_COUNT = 19;
	// Special:
	public static final byte END = 127;
	//{{{ Instance variables
	/**
	 * The id of this token.
	 */
	public byte id;
	/**
	 * The start offset of this token.
	 */
	public int offset;
	/**
	 * The length of this token.
	 */
	public int length;
	/**
	 * The rule set of this token.
	 */
	public ParserRuleSet rules;
	/**
	 * The next token in the linked list.
	 */
	public Token next;
	//}}}
	//{{{ Token constructor
	/**
	 * Creates a new token.
	 * @param id The id of the token
	 * @param offset The start offset of the token
	 * @param length The length of the token
	 * @param rules The parser rule set that generated this token
	 */
	public Token(byte id, int offset, int length, ParserRuleSet rules)
	{
		this.id = id;
		this.offset = offset;
		this.length = length;
		this.rules = rules;
	} //}}}
	//{{{ toString() method
	/**
	 * Returns a string representation of this token.
	 */
	public String toString()
	{
		return ""[id="" + id + "",offset="" + offset + "",length="" + length + ""]"";
	} //}}}
}
"
org.gjt.sp.jedit.syntax.TokenHandler,"/*
 * TokenHandler.java - Token markers send tokens to implementations of
 * this class
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.Segment;
/**
 * Token markers send tokens to implementations of this interface.
 *
 * @author Slava Pestov
 * @version $Id: TokenHandler.java,v 1.6 2003/10/26 19:43:58 spestov Exp $
 * @since jEdit 4.1pre1
 */
public interface TokenHandler
{
	/**
	 * Called by the token marker when a syntax token has been parsed.
	 * @param seg The segment containing the text
	 * @param id The token type (one of the constants in the
	 * {@link Token} class).
	 * @param offset The start offset of the token
	 * @param length The number of characters in the token
	 * @param context The line context
	 * @since jEdit 4.2pre3
	 */
	public void handleToken(Segment seg, byte id, int offset, int length,
		TokenMarker.LineContext context);
	/**
	 * The token handler can compare this object with the object
	 * previously given for this line to see if the token type at the end
	 * of the line has changed (meaning subsequent lines might need to be
	 * retokenized).
	 * @since jEdit 4.2pre6
	 */
	public void setLineContext(TokenMarker.LineContext lineContext);
}
"
org.gjt.sp.jedit.syntax.TokenMarker,"/*
 * TokenMarker.java - Tokenizes lines of text
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998, 2003 Slava Pestov
 * Copyright (C) 1999, 2000 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
//{{{ Imports
import gnu.regexp.*;
import javax.swing.text.Segment;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.CharIndexedSegment;
import org.gjt.sp.util.Log;
//}}}
/**
 * A token marker splits lines of text into tokens. Each token carries
 * a length field and an identification tag that can be mapped to a color
 * or font style for painting that token.
 *
 * @author Slava Pestov, mike dillon
 * @version $Id: TokenMarker.java,v 1.62 2003/12/27 05:14:46 spestov Exp $
 *
 * @see org.gjt.sp.jedit.syntax.Token
 * @see org.gjt.sp.jedit.syntax.TokenHandler
 */
public class TokenMarker
{
	//{{{ TokenMarker constructor
	public TokenMarker()
	{
		ruleSets = new Hashtable(64);
	} //}}}
	//{{{ addRuleSet() method
	public void addRuleSet(ParserRuleSet rules)
	{
		ruleSets.put(rules.getSetName(), rules);
		if (rules.getSetName().equals(""MAIN""))
			mainRuleSet = rules;
	} //}}}
	//{{{ getMainRuleSet() method
	public ParserRuleSet getMainRuleSet()
	{
		return mainRuleSet;
	} //}}}
	//{{{ getRuleSet() method
	public ParserRuleSet getRuleSet(String setName)
	{
		return (ParserRuleSet) ruleSets.get(setName);
	} //}}}
	//{{{ getRuleSets() method
	/**
	 * @since jEdit 4.2pre3
	 */
	public ParserRuleSet[] getRuleSets()
	{
		return (ParserRuleSet[])ruleSets.values().toArray(new ParserRuleSet[ruleSets.size()]);
	} //}}}
	//{{{ markTokens() method
	/**
	 * Do not call this method directly; call Buffer.markTokens() instead.
	 */
	public LineContext markTokens(LineContext prevContext,
		TokenHandler tokenHandler, Segment line)
	{
		//{{{ Set up some instance variables
		// this is to avoid having to pass around lots and lots of
		// parameters.
		this.tokenHandler = tokenHandler;
		this.line = line;
		lastOffset = line.offset;
		lineLength = line.count + line.offset;
		context = new LineContext();
		if(prevContext == null)
			context.rules = getMainRuleSet();
		else
		{
			context.parent = prevContext.parent;
			context.inRule = prevContext.inRule;
			context.rules = prevContext.rules;
			context.spanEndSubst = prevContext.spanEndSubst;
		}
		keywords = context.rules.getKeywords();
		escaped = false;
		seenWhitespaceEnd = false;
		whitespaceEnd = line.offset;
		//}}}
		//{{{ Main parser loop
		ParserRule rule;
		int terminateChar = context.rules.getTerminateChar();
		boolean terminated = false;
main_loop:	for(pos = line.offset; pos < lineLength; pos++)
		{
			//{{{ check if we have to stop parsing
			if(terminateChar >= 0 && pos - line.offset >= terminateChar
				&& !terminated)
			{
				terminated = true;
				context = new LineContext(ParserRuleSet
					.getStandardRuleSet(context.rules
					.getDefault()),context);
				keywords = context.rules.getKeywords();
			} //}}}
			//{{{ check for end of delegate
			if(context.parent != null)
			{
				rule = context.parent.inRule;
				if(rule != null)
				{
					if(checkDelegateEnd(rule))
					{
						seenWhitespaceEnd = true;
						continue main_loop;
					}
				}
			} //}}}
			//{{{ check every rule
			char ch = line.array[pos];
			rule = context.rules.getRules(ch);
			while(rule != null)
			{
				// stop checking rules if there was a match
				if (handleRule(rule,false))
				{
					seenWhitespaceEnd = true;
					continue main_loop;
				}
				rule = rule.next;
			} //}}}
			//{{{ check if current character is a word separator
			if(Character.isWhitespace(ch))
			{
				if(!seenWhitespaceEnd)
					whitespaceEnd = pos + 1;
				if(context.inRule != null)
					handleRule(context.inRule,true);
				handleNoWordBreak();
				markKeyword(false);
				if(lastOffset != pos)
				{
					tokenHandler.handleToken(line,
						context.rules.getDefault(),
						lastOffset - line.offset,
						pos - lastOffset,
						context);
				}
				tokenHandler.handleToken(line,
					context.rules.getDefault(),
					pos - line.offset,1,context);
				lastOffset = pos + 1;
				escaped = false;
			}
			else
			{
				if(keywords != null || context.rules.getRuleCount() != 0)
				{
					String noWordSep = context.rules.getNoWordSep();
					if(!Character.isLetterOrDigit(ch)
						&& noWordSep.indexOf(ch) == -1)
					{
						if(context.inRule != null)
							handleRule(context.inRule,true);
						handleNoWordBreak();
						markKeyword(true);
						tokenHandler.handleToken(line,
							context.rules.getDefault(),
							lastOffset - line.offset,1,
							context);
						lastOffset = pos + 1;
					}
				}
				seenWhitespaceEnd = true;
				escaped = false;
			} //}}}
		} //}}}
		//{{{ Mark all remaining characters
		pos = lineLength;
		if(context.inRule != null)
			handleRule(context.inRule,true);
		handleNoWordBreak();
		markKeyword(true);
		//}}}
		//{{{ Unwind any NO_LINE_BREAK parent delegates
unwind:		while(context.parent != null)
		{
			rule = context.parent.inRule;
			if((rule != null && (rule.action
				& ParserRule.NO_LINE_BREAK) == ParserRule.NO_LINE_BREAK)
				|| terminated)
			{
				context = context.parent;
				keywords = context.rules.getKeywords();
				context.inRule = null;
			}
			else
				break unwind;
		} //}}}
		tokenHandler.handleToken(line,Token.END,
			pos - line.offset,0,context);
		context = context.intern();
		tokenHandler.setLineContext(context);
		return context;
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private Hashtable ruleSets;
	private ParserRuleSet mainRuleSet;
	// Instead of passing these around to each method, we just store them
	// as instance variables. Note that this is not thread-safe.
	private TokenHandler tokenHandler;
	private Segment line;
	private LineContext context;
	private KeywordMap keywords;
	private Segment pattern = new Segment();
	private int lastOffset;
	private int lineLength;
	private int pos;
	private boolean escaped;
	private int whitespaceEnd;
	private boolean seenWhitespaceEnd;
	//}}}
	//{{{ checkDelegateEnd() method
	private boolean checkDelegateEnd(ParserRule rule)
	{
		if(rule.end == null)
			return false;
		LineContext tempContext = context;
		context = context.parent;
		keywords = context.rules.getKeywords();
		boolean tempEscaped = escaped;
		boolean b = handleRule(rule,true);
		context = tempContext;
		keywords = context.rules.getKeywords();
		if(b && !tempEscaped)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);
			markKeyword(true);
			context = (LineContext)context.parent.clone();
			tokenHandler.handleToken(line,
				(context.inRule.action & ParserRule.EXCLUDE_MATCH)
				== ParserRule.EXCLUDE_MATCH
				? context.rules.getDefault()
				: context.inRule.token,
				pos - line.offset,pattern.count,context);
			keywords = context.rules.getKeywords();
			context.inRule = null;
			lastOffset = pos + pattern.count;
			// move pos to last character of match sequence
			pos += (pattern.count - 1);
			return true;
		}
		// check escape rule of parent
		if((rule.action & ParserRule.NO_ESCAPE) == 0)
		{
			ParserRule escape = context.parent.rules.getEscapeRule();
			if(escape != null && handleRule(escape,false))
				return true;
		}
		return false;
	} //}}}
	//{{{ handleRule() method
	/**
	 * Checks if the rule matches the line at the current position
	 * and handles the rule if it does match
	 */
	private boolean handleRule(ParserRule checkRule, boolean end)
	{
		//{{{ Some rules can only match in certain locations
		if(!end)
		{
			if(Character.toUpperCase(checkRule.hashChar)
				!= Character.toUpperCase(line.array[pos]))
			{
				return false;
			}
		}
		int offset = ((checkRule.action & ParserRule.MARK_PREVIOUS) != 0) ?
			lastOffset : pos;
		int posMatch = (end ? checkRule.endPosMatch : checkRule.startPosMatch);
		if((posMatch & ParserRule.AT_LINE_START)
			== ParserRule.AT_LINE_START)
		{
			if(offset != line.offset)
				return false;
		}
		else if((posMatch & ParserRule.AT_WHITESPACE_END)
			== ParserRule.AT_WHITESPACE_END)
		{
			if(offset != whitespaceEnd)
				return false;
		}
		else if((posMatch & ParserRule.AT_WORD_START)
			== ParserRule.AT_WORD_START)
		{
			if(offset != lastOffset)
				return false;
		} //}}}
		int matchedChars = 1;
		CharIndexedSegment charIndexed = null;
		REMatch match = null;
		//{{{ See if the rule's start or end sequence matches here
		if(!end || (checkRule.action & ParserRule.MARK_FOLLOWING) == 0)
		{
			// the end cannot be a regular expression
			if((checkRule.action & ParserRule.REGEXP) == 0 || end)
			{
				if(end)
				{
					if(context.spanEndSubst != null)
						pattern.array = context.spanEndSubst;
					else
						pattern.array = checkRule.end;
				}
				else
					pattern.array = checkRule.start;
				pattern.offset = 0;
				pattern.count = pattern.array.length;
				matchedChars = pattern.count;
				if(!SyntaxUtilities.regionMatches(context.rules
					.getIgnoreCase(),line,pos,pattern.array))
				{
					return false;
				}
			}
			else
			{
				// note that all regexps start with \A so they only
				// match the start of the string
				int matchStart = pos - line.offset;
				charIndexed = new CharIndexedSegment(line,matchStart);
				match = checkRule.startRegexp.getMatch(
					charIndexed,0,RE.REG_ANCHORINDEX);
				if(match == null)
					return false;
				else if(match.getStartIndex() != 0)
					throw new InternalError(""Can't happen"");
				else
				{
					matchedChars = match.getEndIndex();
					/* workaround for hang if match was
					 * zero-width. not sure if there is
					 * a better way to handle this */
					if(matchedChars == 0)
						matchedChars = 1;
				}
			}
		} //}}}
		//{{{ Check for an escape sequence
		if((checkRule.action & ParserRule.IS_ESCAPE) == ParserRule.IS_ESCAPE)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);
			escaped = !escaped;
			pos += pattern.count - 1;
		}
		else if(escaped)
		{
			escaped = false;
			pos += pattern.count - 1;
		} //}}}
		//{{{ Handle start of rule
		else if(!end)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);
			markKeyword((checkRule.action & ParserRule.MARK_PREVIOUS)
				!= ParserRule.MARK_PREVIOUS);
			switch(checkRule.action & ParserRule.MAJOR_ACTIONS)
			{
			//{{{ SEQ
			case ParserRule.SEQ:
				context.spanEndSubst = null;
				if((checkRule.action & ParserRule.REGEXP) != 0)
				{
					handleTokenWithSpaces(tokenHandler,
						checkRule.token,
						pos - line.offset,
						matchedChars,
						context);
				}
				else
				{
					tokenHandler.handleToken(line,
						checkRule.token,
						pos - line.offset,
						matchedChars,context);
				}
				// a DELEGATE attribute on a SEQ changes the
				// ruleset from the end of the SEQ onwards
				if(checkRule.delegate != null)
				{
					context = new LineContext(
						checkRule.delegate,
						context.parent);
					keywords = context.rules.getKeywords();
				}
				break;
			//}}}
			//{{{ SPAN, EOL_SPAN
			case ParserRule.SPAN:
			case ParserRule.EOL_SPAN:
				context.inRule = checkRule;
				byte tokenType = ((checkRule.action & ParserRule.EXCLUDE_MATCH)
					== ParserRule.EXCLUDE_MATCH
					? context.rules.getDefault() : checkRule.token);
				if((checkRule.action & ParserRule.REGEXP) != 0)
				{
					handleTokenWithSpaces(tokenHandler,
						tokenType,
						pos - line.offset,
						matchedChars,
						context);
				}
				else
				{
					tokenHandler.handleToken(line,tokenType,
						pos - line.offset,
						matchedChars,context);
				}
				char[] spanEndSubst = null;
				/* substitute result of matching the rule start
				 * into the end string.
				 *
				 * eg, in shell script mode, <<\s*(\w+) is
				 * matched into \<$1\> to construct rules for
				 * highlighting read-ins like this <<EOF
				 * ...
				 * EOF
				 */
				if(charIndexed != null && checkRule.end != null)
				{
					spanEndSubst = substitute(match,
						checkRule.end);
				}
				context.spanEndSubst = spanEndSubst;
				context = new LineContext(
					checkRule.delegate,
					context);
				keywords = context.rules.getKeywords();
				break;
			//}}}
			//{{{ MARK_FOLLOWING
			case ParserRule.MARK_FOLLOWING:
				tokenHandler.handleToken(line,(checkRule.action
					& ParserRule.EXCLUDE_MATCH)
					== ParserRule.EXCLUDE_MATCH ?
					context.rules.getDefault()
					: checkRule.token,pos - line.offset,
					pattern.count,context);
				context.spanEndSubst = null;
				context.inRule = checkRule;
				break;
			//}}}
			//{{{ MARK_PREVIOUS
			case ParserRule.MARK_PREVIOUS:
				context.spanEndSubst = null;
				if ((checkRule.action & ParserRule.EXCLUDE_MATCH)
					== ParserRule.EXCLUDE_MATCH)
				{
					if(pos != lastOffset)
					{
						tokenHandler.handleToken(line,
							checkRule.token,
							lastOffset - line.offset,
							pos - lastOffset,
							context);
					}
					tokenHandler.handleToken(line,
						context.rules.getDefault(),
						pos - line.offset,pattern.count,
						context);
				}
				else
				{
					tokenHandler.handleToken(line,
						checkRule.token,
						lastOffset - line.offset,
						pos - lastOffset + pattern.count,
						context);
				}
				break;
			//}}}
			default:
				throw new InternalError(""Unhandled major action"");
			}
			// move pos to last character of match sequence
			pos += (matchedChars - 1);
			lastOffset = pos + 1;
			// break out of inner for loop to check next char
		} //}}}
		//{{{ Handle end of MARK_FOLLOWING
		else if((context.inRule.action & ParserRule.MARK_FOLLOWING) != 0)
		{
			if(pos != lastOffset)
			{
				tokenHandler.handleToken(line,
					context.inRule.token,
					lastOffset - line.offset,
					pos - lastOffset,context);
			}
			lastOffset = pos;
			context.inRule = null;
		} //}}}
		return true;
	} //}}}
	//{{{ handleNoWordBreak() method
	private void handleNoWordBreak()
	{
		if(context.parent != null)
		{
			ParserRule rule = context.parent.inRule;
			if(rule != null && (context.parent.inRule.action
				& ParserRule.NO_WORD_BREAK) != 0)
			{
				if(pos != lastOffset)
				{
					tokenHandler.handleToken(line,
						rule.token,
						lastOffset - line.offset,
						pos - lastOffset,context);
				}
				lastOffset = pos;
				context = context.parent;
				keywords = context.rules.getKeywords();
				context.inRule = null;
			}
		}
	} //}}}
	//{{{ handleTokenWithSpaces() method
	private void handleTokenWithSpaces(TokenHandler tokenHandler,
		byte tokenType, int start, int len, LineContext context)
	{
		int last = start;
		int end = start + len;
		for(int i = start; i < end; i++)
		{
			if(Character.isWhitespace(line.array[i + line.offset]))
			{
				if(last != i)
				{
					tokenHandler.handleToken(line,
					tokenType,last,i - last,context);
				}
				tokenHandler.handleToken(line,tokenType,i,1,context);
				last = i + 1;
			}
		}
		if(last != end)
		{
			tokenHandler.handleToken(line,tokenType,last,
				end - last,context);
		}
	} //}}}
	//{{{ markKeyword() method
	private void markKeyword(boolean addRemaining)
	{
		int len = pos - lastOffset;
		if(len == 0)
			return;
		//{{{ Do digits
		if(context.rules.getHighlightDigits())
		{
			boolean digit = false;
			boolean mixed = false;
			for(int i = lastOffset; i < pos; i++)
			{
				char ch = line.array[i];
				if(Character.isDigit(ch))
					digit = true;
				else
					mixed = true;
			}
			if(mixed)
			{
				RE digitRE = context.rules.getDigitRegexp();
				// only match against regexp if its not all
				// digits; if all digits, no point matching
				if(digit)
				{ 
					if(digitRE == null)
					{
						// mixed digit/alpha keyword,
						// and no regexp... don't
						// highlight as DIGIT
						digit = false;
					}
					else
					{
						CharIndexedSegment seg = new CharIndexedSegment(
							line,false);
						int oldCount = line.count;
						int oldOffset = line.offset;
						line.offset = lastOffset;
						line.count = len;
						if(!digitRE.isMatch(seg))
							digit = false;
						line.offset = oldOffset;
						line.count = oldCount;
					}
				}
			}
			if(digit)
			{
				tokenHandler.handleToken(line,Token.DIGIT,
					lastOffset - line.offset,
					len,context);
				lastOffset = pos;
				return;
			}
		} //}}}
		//{{{ Do keywords
		if(keywords != null)
		{
			byte id = keywords.lookup(line, lastOffset, len);
			if(id != Token.NULL)
			{
				tokenHandler.handleToken(line,id,
					lastOffset - line.offset,
					len,context);
				lastOffset = pos;
				return;
			}
		} //}}}
		//{{{ Handle any remaining crud
		if(addRemaining)
		{
			tokenHandler.handleToken(line,context.rules.getDefault(),
				lastOffset - line.offset,len,context);
			lastOffset = pos;
		} //}}}
	} //}}}
	//{{{ substitute() method
	private char[] substitute(REMatch match, char[] end)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < end.length; i++)
		{
			char ch = end[i];
			if(ch == '$')
			{
				if(i == end.length - 1)
					buf.append(ch);
				else
				{
					char digit = end[i + 1];
					if(!Character.isDigit(digit))
						buf.append(ch);
					else
					{
						buf.append(match.toString(
							digit - '0'));
						i++;
					}
				}
			}
			else
				buf.append(ch);
		}
		char[] returnValue = new char[buf.length()];
		buf.getChars(0,buf.length(),returnValue,0);
		return returnValue;
	} //}}}
	//}}}
	//{{{ LineContext class
	/**
	 * Stores persistent per-line syntax parser state.
	 */
	public static class LineContext
	{
		private static Hashtable intern = new Hashtable();
		public LineContext parent;
		public ParserRule inRule;
		public ParserRuleSet rules;
		// used for SPAN_REGEXP rules; otherwise null
		public char[] spanEndSubst;
		//{{{ LineContext constructor
		public LineContext(ParserRuleSet rs, LineContext lc)
		{
			rules = rs;
			parent = (lc == null ? null : (LineContext)lc.clone());
		} //}}}
		//{{{ LineContext constructor
		public LineContext()
		{
		} //}}}
		//{{{ intern() method
		public LineContext intern()
		{
			Object obj = intern.get(this);
			if(obj == null)
			{
				intern.put(this,this);
				return this;
			}
			else
				return (LineContext)obj;
		} //}}}
		//{{{ hashCode() method
		public int hashCode()
		{
			if(inRule != null)
				return inRule.hashCode();
			else if(rules != null)
				return rules.hashCode();
			else
				return 0;
		} //}}}
		//{{{ equals() method
		public boolean equals(Object obj)
		{
			if(obj instanceof LineContext)
			{
				LineContext lc = (LineContext)obj;
				return lc.inRule == inRule && lc.rules == rules
					&& MiscUtilities.objectsEqual(parent,lc.parent)
					&& charArraysEqual(spanEndSubst,lc.spanEndSubst);
			}
			else
				return false;
		} //}}}
		//{{{ clone() method
		public Object clone()
		{
			LineContext lc = new LineContext();
			lc.inRule = inRule;
			lc.rules = rules;
			lc.parent = (parent == null) ? null : (LineContext) parent.clone();
			lc.spanEndSubst = spanEndSubst;
			return lc;
		} //}}}
		//{{{ charArraysEqual() method
		private boolean charArraysEqual(char[] c1, char[] c2)
		{
			if(c1 == null)
				return (c2 == null);
			else if(c2 == null)
				return (c1 == null);
			if(c1.length != c2.length)
				return false;
			for(int i = 0; i < c1.length; i++)
			{
				if(c1[i] != c2[i])
					return false;
			}
			return true;
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.syntax.XModeHandler,"/*
 * XModeHandler.java - XML handler for mode files
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999 mike dillon
 * Portions copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
//{{{ Imports
import com.microstar.xml.*;
import gnu.regexp.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * XML handler for mode definition files.
 */
public abstract class XModeHandler extends HandlerBase
{
	//{{{ XModeHandler constructor
	public XModeHandler (String modeName)
	{
		this.modeName = modeName;
		marker = new TokenMarker();
		marker.addRuleSet(new ParserRuleSet(modeName,""MAIN""));
		stateStack = new Stack();
		// default value
		lastNoWordSep = ""_"";
	} //}}}
	//{{{ resolveEntity() method
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""xmode.dtd"".equals(systemId))
		{
			// this will result in a slight speed up, since we
			// don't need to read the DTD anyway, as AElfred is
			// non-validating
			return new StringReader(""<!-- -->"");
			/* try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(
					""/org/gjt/sp/jedit/syntax/xmode.dtd"")));
			}
			catch(Exception e)
			{
				error(""dtd"",e);
			} */
		}
		return null;
	} //}}}
	//{{{ attribute() method
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		if (aname == ""NAME"")
		{
			propName = value;
		}
		else if (aname == ""VALUE"")
		{
			propValue = value;
		}
		else if (aname == ""TYPE"")
		{
			lastTokenID = Token.stringToToken(value);
			if(lastTokenID == -1)
				error(""token-invalid"",value);
		}
		else if (aname == ""AT_LINE_START"")
		{
			lastAtLineStart = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""AT_WHITESPACE_END"")
		{
			lastAtWhitespaceEnd = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""AT_WORD_START"")
		{
			lastAtWordStart = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""NO_LINE_BREAK"")
		{
			lastNoLineBreak = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""NO_WORD_BREAK"")
		{
			lastNoWordBreak = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""NO_ESCAPE"")
		{
			lastNoEscape = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""EXCLUDE_MATCH"")
		{
			lastExcludeMatch = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""IGNORE_CASE"")
		{
			lastIgnoreCase = (isSpecified) ? (value.equals(""TRUE"")) :
				true;
		}
		else if (aname == ""HIGHLIGHT_DIGITS"")
		{
			lastHighlightDigits = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""DIGIT_RE"")
		{
			lastDigitRE = value;
		}
		else if (aname == ""NO_WORD_SEP"")
		{
			if(isSpecified)
				lastNoWordSep = value;
		}
		else if (aname == ""AT_CHAR"")
		{
			try
			{
				if (isSpecified) termChar =
					Integer.parseInt(value);
			}
			catch (NumberFormatException e)
			{
				error(""termchar-invalid"",value);
				termChar = -1;
			}
		}
		else if (aname == ""ESCAPE"")
		{
			lastEscape = value;
		}
		else if (aname == ""SET"")
		{
			lastSetName = value;
		}
		else if (aname == ""DELEGATE"")
		{
			String delegateMode, delegateSetName;
			if(value != null)
			{
				int index = value.indexOf(""::"");
				if(index != -1)
				{
					delegateMode = value.substring(0,index);
					delegateSetName = value.substring(index + 2);
				}
				else
				{
					delegateMode = modeName;
					delegateSetName = value;
				}
				TokenMarker delegateMarker = getTokenMarker(delegateMode);
				if(delegateMarker == null)
					error(""delegate-invalid"",value);
				else
				{
					lastDelegateSet = delegateMarker
						.getRuleSet(delegateSetName);
					if(delegateMarker == marker
						&& lastDelegateSet == null)
					{
						// stupid hack to handle referencing
						// a rule set that is defined later!
						lastDelegateSet = new ParserRuleSet(
							delegateMode,
							delegateSetName);
						lastDelegateSet.setDefault(Token.INVALID);
						marker.addRuleSet(lastDelegateSet);
					}
					else if(lastDelegateSet == null)
						error(""delegate-invalid"",value);
				}
			}
		}
		else if (aname == ""DEFAULT"")
		{
			lastDefaultID = Token.stringToToken(value);
			if(lastDefaultID == -1)
			{
				error(""token-invalid"",value);
				lastDefaultID = Token.NULL;
			}
		}
		else if (aname == ""HASH_CHAR"")
		{
			if(value.length() != 1)
			{
				error(""hash-char-invalid"",value);
				lastDefaultID = Token.NULL;
			}
			else
				lastHashChar = value.charAt(0);
		}
	} //}}}
	//{{{ doctypeDecl() method
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if (""MODE"".equalsIgnoreCase(name)) return;
		error(""doctype-invalid"",name);
	} //}}}
	//{{{ charData() method
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if (tag == ""EOL_SPAN"" ||
			tag == ""EOL_SPAN_REGEXP"" ||
			tag == ""MARK_PREVIOUS"" ||
			tag == ""MARK_FOLLOWING"" ||
			tag == ""SEQ"" ||
			tag == ""SEQ_REGEXP"" ||
			tag == ""BEGIN""
		)
		{
			lastStart = text;
			lastStartPosMatch = ((lastAtLineStart ? ParserRule.AT_LINE_START : 0)
				| (lastAtWhitespaceEnd ? ParserRule.AT_WHITESPACE_END : 0)
				| (lastAtWordStart ? ParserRule.AT_WORD_START : 0));
			lastAtLineStart = false;
			lastAtWordStart = false;
			lastAtWhitespaceEnd = false;
		}
		else if (tag == ""END"")
		{
			lastEnd = text;
			lastEndPosMatch = ((lastAtLineStart ? ParserRule.AT_LINE_START : 0)
				| (lastAtWhitespaceEnd ? ParserRule.AT_WHITESPACE_END : 0)
				| (lastAtWordStart ? ParserRule.AT_WORD_START : 0));
			lastAtLineStart = false;
			lastAtWordStart = false;
			lastAtWhitespaceEnd = false;
		}
		else
		{
			lastKeyword = text;
		}
	} //}}}
	//{{{ startElement() method
	public void startElement (String tag)
	{
		tag = pushElement(tag);
		if (tag == ""WHITESPACE"")
		{
			Log.log(Log.WARNING,this,modeName + "": WHITESPACE rule ""
				+ ""no longer needed"");
		}
		else if (tag == ""KEYWORDS"")
		{
			keywords = new KeywordMap(rules.getIgnoreCase());
		}
		else if (tag == ""RULES"")
		{
			if(lastSetName == null)
				lastSetName = ""MAIN"";
			rules = marker.getRuleSet(lastSetName);
			if(rules == null)
			{
				rules = new ParserRuleSet(modeName,lastSetName);
				marker.addRuleSet(rules);
			}
			rules.setIgnoreCase(lastIgnoreCase);
			rules.setHighlightDigits(lastHighlightDigits);
			if(lastDigitRE != null)
			{
				try
				{
					rules.setDigitRegexp(new RE(lastDigitRE,
						lastIgnoreCase
						? RE.REG_ICASE : 0,
						ParserRule.RE_SYNTAX_JEDIT));
				}
				catch(REException e)
				{
					error(""regexp"",e);
				}
			}
			if(lastEscape != null)
				rules.setEscapeRule(ParserRule.createEscapeRule(lastEscape));
			rules.setDefault(lastDefaultID);
			rules.setNoWordSep(lastNoWordSep);
		}
	} //}}}
	//{{{ endElement() method
	public void endElement (String name)
	{
		if (name == null) return;
		String tag = popElement();
		if (name.equals(tag))
		{
			//{{{ PROPERTY
			if (tag == ""PROPERTY"")
			{
				props.put(propName,propValue);
			} //}}}
			//{{{ PROPS
			else if (tag == ""PROPS"")
			{
				if(peekElement().equals(""RULES""))
					rules.setProperties(props);
				else
					modeProps = props;
				props = new Hashtable();
			} //}}}
			//{{{ RULES
			else if (tag == ""RULES"")
			{
				rules.setKeywords(keywords);
				keywords = null;
				lastSetName = null;
				lastEscape = null;
				lastIgnoreCase = true;
				lastHighlightDigits = false;
				lastDigitRE = null;
				lastDefaultID = Token.NULL;
				lastNoWordSep = ""_"";
				rules = null;
			} //}}}
			//{{{ IMPORT
			else if (tag == ""IMPORT"")
			{
				rules.addRuleSet(lastDelegateSet);
				lastDelegateSet = null;
			} //}}}
			//{{{ TERMINATE
			else if (tag == ""TERMINATE"")
			{
				rules.setTerminateChar(termChar);
				termChar = -1;
			} //}}}
			//{{{ SEQ
			else if (tag == ""SEQ"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""SEQ"");
					return;
				}
				rules.addRule(ParserRule.createSequenceRule(
					lastStartPosMatch,lastStart,lastDelegateSet,
					lastTokenID));
				reset();
			} //}}}
			//{{{ SEQ_REGEXP
			else if (tag == ""SEQ_REGEXP"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""SEQ_REGEXP"");
					return;
				}
				try
				{
					rules.addRule(ParserRule.createRegexpSequenceRule(
						lastHashChar,lastStartPosMatch,
						lastStart,lastDelegateSet,lastTokenID,
						lastIgnoreCase));
				}
				catch(REException re)
				{
					error(""regexp"",re);
				}
				reset();
			} //}}}
			//{{{ SPAN
			else if (tag == ""SPAN"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""BEGIN"");
					return;
				}
				if(lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				}
				rules.addRule(ParserRule
					.createSpanRule(
					lastStartPosMatch,lastStart,
					lastEndPosMatch,lastEnd,
					lastDelegateSet,
					lastTokenID,lastExcludeMatch,
					lastNoLineBreak,
					lastNoWordBreak,
					lastNoEscape));
				reset();
			} //}}}
			//{{{ SPAN_REGEXP
			else if (tag == ""SPAN_REGEXP"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""BEGIN"");
					return;
				}
				if(lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				}
				try
				{
					rules.addRule(ParserRule
						.createRegexpSpanRule(
						lastHashChar,
						lastStartPosMatch,lastStart,
						lastEndPosMatch,lastEnd,
						lastDelegateSet,
						lastTokenID,
						lastExcludeMatch,
						lastNoLineBreak,
						lastNoWordBreak,
						lastIgnoreCase,
						lastNoEscape));
				}
				catch(REException re)
				{
					error(""regexp"",re);
				}
				reset();
			} //}}}
			//{{{ EOL_SPAN
			else if (tag == ""EOL_SPAN"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN"");
					return;
				}
				rules.addRule(ParserRule.createEOLSpanRule(
					lastStartPosMatch,lastStart,
					lastDelegateSet,lastTokenID,
					lastExcludeMatch));
				reset();
			} //}}}
			//{{{ EOL_SPAN_REGEXP
			else if (tag == ""EOL_SPAN_REGEXP"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN_REGEXP"");
					return;
				}
				try
				{
					rules.addRule(ParserRule.createRegexpEOLSpanRule(
						lastHashChar,lastStartPosMatch,lastStart,
						lastDelegateSet,lastTokenID,
						lastExcludeMatch,lastIgnoreCase));
				}
				catch(REException re)
				{
					error(""regexp"",re);
				}
				reset();
			} //}}}
			//{{{ MARK_FOLLOWING
			else if (tag == ""MARK_FOLLOWING"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_FOLLOWING"");
					return;
				}
				rules.addRule(ParserRule
					.createMarkFollowingRule(
					lastStartPosMatch,lastStart,
					lastTokenID,lastExcludeMatch));
				reset();
			} //}}}
			//{{{ MARK_PREVIOUS
			else if (tag == ""MARK_PREVIOUS"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_PREVIOUS"");
					return;
				}
				rules.addRule(ParserRule
					.createMarkPreviousRule(
					lastStartPosMatch,lastStart,
					lastTokenID,lastExcludeMatch));
				reset();
			} //}}}
			//{{{ Keywords
			else
			{
				byte token = Token.stringToToken(tag);
				if(token != -1)
					addKeyword(lastKeyword,token);
			} //}}}
		}
		else
		{
			// can't happen
			throw new InternalError();
		}
	} //}}}
	//{{{ startDocument() method
	public void startDocument()
	{
		props = new Hashtable();
		pushElement(null);
	} //}}}
	//{{{ endDocument() method
	public void endDocument()
	{
		ParserRuleSet[] rulesets = marker.getRuleSets();
		for(int i = 0; i < rulesets.length; i++)
		{
			rulesets[i].resolveImports();
		}
	} //}}}
	//{{{ getTokenMarker() method
	public TokenMarker getTokenMarker()
	{
		return marker;
	} //}}}
	//{{{ getModeProperties() method
	public Hashtable getModeProperties()
	{
		return modeProps;
	} //}}}
	//{{{ Protected members
	//{{{ error() method
	/**
	 * Reports an error.
	 * You must override this method so that the mode loader can do error
	 * reporting.
	 * @param msg The error type
	 * @param subst A <code>String</code> or a <code>Throwable</code>
	 * containing specific information
	 * @since jEdit 4.2pre1
	 */
	protected abstract void error(String msg, Object subst);
	//}}}
	//{{{ getTokenMarker() method
	/**
	 * Returns the token marker for the given mode.
	 * You must override this method so that the mode loader can resolve
	 * delegate targets.
	 * @param mode The mode name
	 * @since jEdit 4.2pre1
	 */
	protected abstract TokenMarker getTokenMarker(String mode);
	//}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private String modeName;
	private TokenMarker marker;
	private KeywordMap keywords;
	private Stack stateStack;
	private String propName;
	private String propValue;
	private Hashtable props;
	private Hashtable modeProps;
	private String lastStart;
	private String lastEnd;
	private String lastKeyword;
	private String lastSetName;
	private String lastEscape;
	private ParserRuleSet lastDelegateSet;
	private String lastNoWordSep;
	private ParserRuleSet rules;
	private byte lastDefaultID = Token.NULL;
	private byte lastTokenID;
	private int termChar = -1;
	private boolean lastNoLineBreak;
	private boolean lastNoWordBreak;
	private boolean lastExcludeMatch;
	private boolean lastIgnoreCase = true;
	private boolean lastHighlightDigits;
	private boolean lastAtLineStart;
	private boolean lastAtWhitespaceEnd;
	private boolean lastAtWordStart;
	private boolean lastNoEscape;
	private int lastStartPosMatch;
	private int lastEndPosMatch;
	private String lastDigitRE;
	private char lastHashChar;
	//}}}
	//{{{ reset() method
	private void reset()
	{
		lastHashChar = '\0';
		lastStartPosMatch = 0;
		lastStart = null;
		lastEndPosMatch = 0;
		lastEnd = null;
		lastDelegateSet = null;
		lastTokenID = Token.NULL;
		lastExcludeMatch = false;
		lastNoLineBreak = false;
		lastNoWordBreak = false;
		lastNoEscape = false;
	} //}}}
	//{{{ addKeyword() method
	private void addKeyword(String k, byte id)
	{
		if(k == null)
		{
			error(""empty-keyword"",null);
			return;
		}
		if (keywords == null) return;
		keywords.add(k,id);
	} //}}}
	//{{{ pushElement() method
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	} //}}}
	//{{{ peekElement() method
	private String peekElement()
	{
		return (String) stateStack.peek();
	} //}}}
	//{{{ popElement() method
	private String popElement()
	{
		return (String) stateStack.pop();
	} //}}}
	//}}}
}
"
org.gjt.sp.jedit.textarea.ChunkCache,"/*
 * ChunkCache.java - Intermediate layer between token lists from a TokenMarker
 * and what you see on screen
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import java.util.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Manages low-level text display tasks.
 *
 * @author Slava Pestov
 * @version $Id: ChunkCache.java,v 1.96 2004/07/11 06:00:36 spestov Exp $
 */
class ChunkCache
{
	//{{{ ChunkCache constructor
	ChunkCache(JEditTextArea textArea)
	{
		this.textArea = textArea;
		out = new ArrayList();
		tokenHandler = new DisplayTokenHandler();
	} //}}}
	//{{{ getMaxHorizontalScrollWidth() method
	int getMaxHorizontalScrollWidth()
	{
		int max = 0;
		for(int i = 0; i < firstInvalidLine; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.width > max)
				max = info.width;
		}
		return max;
	} //}}}
	//{{{ getScreenLineOfOffset() method
	int getScreenLineOfOffset(int line, int offset)
	{
		if(lineInfo.length == 0)
			return -1;
		if(line < textArea.getFirstPhysicalLine())
			return -1;
		else if(line == textArea.getFirstPhysicalLine()
			&& offset < getLineInfo(0).offset)
			return -1;
		else if(line > textArea.getLastPhysicalLine())
			return -1;
		else
		{
			int screenLine;
			if(line == lastScreenLineP)
			{
				LineInfo last = getLineInfo(lastScreenLine);
				if(offset >= last.offset
					&& offset < last.offset + last.length)
				{
					return lastScreenLine;
				}
			}
			screenLine = -1;
			// Find the screen line containing this offset
			for(int i = 0; i < textArea.getVisibleLines(); i++)
			{
				LineInfo info = getLineInfo(i);
				if(info.physicalLine > line)
				{
					// line is invisible?
					return i - 1;
					//return -1;
				}
				else if(info.physicalLine == line)
				{
					if(offset >= info.offset
						&& offset < info.offset + info.length)
					{
						screenLine = i;
						break;
					}
				}
			}
			if(screenLine == -1)
				return -1;
			else
			{
				lastScreenLineP = line;
				lastScreenLine = screenLine;
				return screenLine;
			}
		}
	} //}}}
	//{{{ recalculateVisibleLines() method
	void recalculateVisibleLines()
	{
		LineInfo[] newLineInfo = new LineInfo[textArea.getVisibleLines()];
		int start;
		if(lineInfo == null)
			start = 0;
		else
		{
			start = Math.min(lineInfo.length,newLineInfo.length);
			System.arraycopy(lineInfo,0,newLineInfo,0,start);
		}
		for(int i = start; i < newLineInfo.length; i++)
			newLineInfo[i] = new LineInfo();
		lineInfo = newLineInfo;
		lastScreenLine = lastScreenLineP = -1;
	} //}}}
	//{{{ setBuffer() method
	void setBuffer(Buffer buffer)
	{
		this.buffer = buffer;
		lastScreenLine = lastScreenLineP = -1;
	} //}}}
	//{{{ scrollDown() method
	void scrollDown(int amount)
	{
		int visibleLines = textArea.getVisibleLines();
		System.arraycopy(lineInfo,amount,lineInfo,0,visibleLines - amount);
		for(int i = visibleLines - amount; i < visibleLines; i++)
		{
			lineInfo[i] = new LineInfo();
		}
		firstInvalidLine -= amount;
		if(firstInvalidLine < 0)
			firstInvalidLine = 0;
		if(Debug.CHUNK_CACHE_DEBUG)
		{
			System.err.println(""f > t.f: only "" + amount
				+ "" need updates"");
		}
		lastScreenLine = lastScreenLineP = -1;
	} //}}}
	//{{{ scrollUp() method
	void scrollUp(int amount)
	{
		System.arraycopy(lineInfo,0,lineInfo,amount,
			textArea.getVisibleLines() - amount);
		for(int i = 0; i < amount; i++)
		{
			lineInfo[i] = new LineInfo();
		}
		// don't try this at home
		int oldFirstInvalidLine = firstInvalidLine;
		firstInvalidLine = 0;
		updateChunksUpTo(amount);
		firstInvalidLine = oldFirstInvalidLine + amount;
		if(firstInvalidLine > textArea.getVisibleLines())
			firstInvalidLine = textArea.getVisibleLines();
		if(Debug.CHUNK_CACHE_DEBUG)
		{
			Log.log(Log.DEBUG,this,""f > t.f: only "" + amount
				+ "" need updates"");
		}
		lastScreenLine = lastScreenLineP = -1;
	} //}}}
	//{{{ invalidateAll() method
	void invalidateAll()
	{
		firstInvalidLine = 0;
		lastScreenLine = lastScreenLineP = -1;
	} //}}}
	//{{{ invalidateChunksFrom() method
	void invalidateChunksFrom(int screenLine)
	{
		if(Debug.CHUNK_CACHE_DEBUG)
			Log.log(Log.DEBUG,this,""Invalidate from "" + screenLine);
		firstInvalidLine = Math.min(screenLine,firstInvalidLine);
		if(screenLine <= lastScreenLine)
			lastScreenLine = lastScreenLineP = -1;
	} //}}}
	//{{{ invalidateChunksFromPhys() method
	void invalidateChunksFromPhys(int physicalLine)
	{
		for(int i = 0; i < firstInvalidLine; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.physicalLine == -1 || info.physicalLine >= physicalLine)
			{
				firstInvalidLine = i;
				if(i <= lastScreenLine)
					lastScreenLine = lastScreenLineP = -1;
				break;
			}
		}
	} //}}}
	//{{{ getLineInfo() method
	LineInfo getLineInfo(int screenLine)
	{
		updateChunksUpTo(screenLine);
		return lineInfo[screenLine];
	} //}}}
	//{{{ getLineSubregionCount() method
	int getLineSubregionCount(int physicalLine)
	{
		if(!textArea.displayManager.softWrap)
			return 1;
		out.clear();
		lineToChunkList(physicalLine,out);
		int size = out.size();
		if(size == 0)
			return 1;
		else
			return size;
	} //}}}
	//{{{ getSubregionOfOffset() method
	/**
	 * Returns the subregion containing the specified offset. A subregion
	 * is a subset of a physical line. Each screen line corresponds to one
	 * subregion. Unlike the {@link #getScreenLineOfOffset()} method,
	 * this method works with non-visible lines too.
	 */
	int getSubregionOfOffset(int offset, LineInfo[] lineInfos)
	{
		for(int i = 0; i < lineInfos.length; i++)
		{
			LineInfo info = lineInfos[i];
			if(offset >= info.offset && offset < info.offset + info.length)
				return i;
		}
		return -1;
	} //}}}
	//{{{ xToSubregionOffset() method
	/**
	 * Converts an x co-ordinate within a subregion into an offset from the
	 * start of that subregion.
	 * @param physicalLine The physical line number
	 * @param subregion The subregion; if -1, then this is the last
	 * subregion.
	 * @param x The x co-ordinate
	 * @param round Round up to next character if x is past the middle of a
	 * character?
	 */
	int xToSubregionOffset(int physicalLine, int subregion, int x,
		boolean round)
	{
		LineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);
		if(subregion == -1)
			subregion += infos.length;
		return xToSubregionOffset(infos[subregion],x,round);
	} //}}}
	//{{{ xToSubregionOffset() method
	/**
	 * Converts an x co-ordinate within a subregion into an offset from the
	 * start of that subregion.
	 * @param info The line info object
	 * @param x The x co-ordinate
	 * @param round Round up to next character if x is past the middle of a
	 * character?
	 */
	int xToSubregionOffset(LineInfo info, int x,
		boolean round)
	{
		int offset = Chunk.xToOffset(info.chunks,x,round);
		if(offset == -1 || offset == info.offset + info.length)
			offset = info.offset + info.length - 1;
		return offset;
	} //}}}
	//{{{ subregionOffsetToX() method
	/**
	 * Converts an offset within a subregion into an x co-ordinate.
	 * @param physicalLine The physical line
	 * @param offset The offset
	 */
	int subregionOffsetToX(int physicalLine, int offset)
	{
		LineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);
		LineInfo info = infos[getSubregionOfOffset(offset,infos)];
		return subregionOffsetToX(info,offset);
	} //}}}
	//{{{ subregionOffsetToX() method
	/**
	 * Converts an offset within a subregion into an x co-ordinate.
	 * @param info The line info object
	 * @param offset The offset
	 */
	int subregionOffsetToX(LineInfo info, int offset)
	{
		return (int)Chunk.offsetToX(info.chunks,offset);
	} //}}}
	//{{{ getSubregionStartOffset() method
	/**
	 * Returns the start offset of the specified subregion of the specified
	 * physical line.
	 * @param line The physical line number
	 * @param offset An offset
	 */
	int getSubregionStartOffset(int line, int offset)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(line);
		LineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];
		return textArea.getLineStartOffset(info.physicalLine)
			+ info.offset;
	} //}}}
	//{{{ getSubregionEndOffset() method
	/**
	 * Returns the end offset of the specified subregion of the specified
	 * physical line.
	 * @param line The physical line number
	 * @param offset An offset
	 */
	int getSubregionEndOffset(int line, int offset)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(line);
		LineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];
		return textArea.getLineStartOffset(info.physicalLine)
			+ info.offset + info.length;
	} //}}}
	//{{{ getBelowPosition() method
	/**
	 * @param physicalLine The physical line number
	 * @param offset The offset
	 * @param x The location
	 * @param ignoreWrap If true, behave as if soft wrap is off even if it
	 * is on
	 */
	int getBelowPosition(int physicalLine, int offset, int x,
		boolean ignoreWrap)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);
		int subregion = getSubregionOfOffset(offset,lineInfos);
		if(subregion != lineInfos.length - 1 && !ignoreWrap)
		{
			return textArea.getLineStartOffset(physicalLine)
				+ xToSubregionOffset(lineInfos[subregion + 1],
				x,true);
		}
		else
		{
			int nextLine = textArea.displayManager
				.getNextVisibleLine(physicalLine);
			if(nextLine == -1)
				return -1;
			else
			{
				return textArea.getLineStartOffset(nextLine)
					+ xToSubregionOffset(nextLine,0,
					x,true);
			}
		}
	} //}}}
	//{{{ getAbovePosition() method
	/**
	 * @param physicalLine The physical line number
	 * @param offset The offset
	 * @param x The location
	 * @param ignoreWrap If true, behave as if soft wrap is off even if it
	 * is on
	 */
	int getAbovePosition(int physicalLine, int offset, int x,
		boolean ignoreWrap)
	{
		LineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);
		int subregion = getSubregionOfOffset(offset,lineInfos);
		if(subregion != 0 && !ignoreWrap)
		{
			return textArea.getLineStartOffset(physicalLine)
				+ xToSubregionOffset(lineInfos[subregion - 1],
				x,true);
		}
		else
		{
			int prevLine = textArea.displayManager
				.getPrevVisibleLine(physicalLine);
			if(prevLine == -1)
				return -1;
			else
			{
				return textArea.getLineStartOffset(prevLine)
					+ xToSubregionOffset(prevLine,-1,
					x,true);
			}
		}
	} //}}}
	//{{{ needFullRepaint() method
	/**
	 * The needFullRepaint variable becomes true when the number of screen
	 * lines in a physical line changes.
	 */
	boolean needFullRepaint()
	{
		boolean retVal = needFullRepaint;
		needFullRepaint = false;
		return retVal;
	} //}}}
	//{{{ getLineInfosForPhysicalLine() method
	LineInfo[] getLineInfosForPhysicalLine(int physicalLine)
	{
		out.clear();
		if(buffer.isLoaded())
			lineToChunkList(physicalLine,out);
		if(out.size() == 0)
			out.add(null);
		ArrayList returnValue = new ArrayList(out.size());
		getLineInfosForPhysicalLine(physicalLine,returnValue);
		return (LineInfo[])returnValue.toArray(new LineInfo[out.size()]);
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private JEditTextArea textArea;
	private Buffer buffer;
	private LineInfo[] lineInfo;
	private ArrayList out;
	private int firstInvalidLine;
	private int lastScreenLineP;
	private int lastScreenLine;
	private boolean needFullRepaint;
	private DisplayTokenHandler tokenHandler;
	//}}}
	//{{{ getLineInfosForPhysicalLine() method
	private void getLineInfosForPhysicalLine(int physicalLine, List list)
	{
		for(int i = 0; i < out.size(); i++)
		{
			Chunk chunks = (Chunk)out.get(i);
			LineInfo info = new LineInfo();
			info.physicalLine = physicalLine;
			if(i == 0)
			{
				info.firstSubregion = true;
				info.offset = 0;
			}
			else
				info.offset = chunks.offset;
			if(i == out.size() - 1)
			{
				info.lastSubregion = true;
				info.length = textArea.getLineLength(physicalLine)
					- info.offset + 1;
			}
			else
			{
				info.length = ((Chunk)out.get(i + 1)).offset
					- info.offset;
			}
			info.chunks = chunks;
			list.add(info);
		}
	} //}}}
	//{{{ updateChunksUpTo() method
	private void updateChunksUpTo(int lastScreenLine)
	{
		// this method is a nightmare
		if(lastScreenLine >= lineInfo.length)
		{
			throw new ArrayIndexOutOfBoundsException(lastScreenLine);
		}
		// if one line's chunks are invalid, remaining lines are also
		// invalid
		if(lastScreenLine < firstInvalidLine)
			return;
		// find a valid line closest to the last screen line
		int firstScreenLine = 0;
		for(int i = firstInvalidLine - 1; i >= 0; i--)
		{
			if(lineInfo[i].lastSubregion)
			{
				firstScreenLine = i + 1;
				break;
			}
		}
		int physicalLine;
		// for the first line displayed, take its physical line to be
		// the text area's first physical line
		if(firstScreenLine == 0)
		{
			physicalLine = textArea.getFirstPhysicalLine();
		}
		// otherwise, determine the next visible line
		else
		{
			int prevPhysLine = lineInfo[
				firstScreenLine - 1]
				.physicalLine;
			// if -1, the empty space at the end of the text area
			// when the buffer has less lines than are visible
			if(prevPhysLine == -1)
				physicalLine = -1;
			else
			{
				physicalLine = textArea
					.displayManager
					.getNextVisibleLine(prevPhysLine);
			}
		}
		if(Debug.CHUNK_CACHE_DEBUG)
		{
			Log.log(Log.DEBUG,this,""Updating chunks from "" + firstScreenLine
				+ "" to "" + lastScreenLine);
		}
		// Note that we rely on the fact that when a physical line is
		// invalidated, all screen lines/subregions of that line are
		// invalidated as well. See below comment for code that tries
		// to uphold this assumption.
		out.clear();
		int offset = 0;
		int length = 0;
		for(int i = firstScreenLine; i <= lastScreenLine; i++)
		{
			LineInfo info = lineInfo[i];
			Chunk chunks;
			// get another line of chunks
			if(out.size() == 0)
			{
				// unless this is the first time, increment
				// the line number
				if(physicalLine != -1 && i != firstScreenLine)
				{
					physicalLine = textArea.displayManager
						.getNextVisibleLine(physicalLine);
				}
				// empty space
				if(physicalLine == -1)
				{
					info.chunks = null;
					info.physicalLine = -1;
					// fix the bug where the horiz.
					// scroll bar was not updated
					// after creating a new file.
					info.width = 0;
					continue;
				}
				// chunk the line.
				lineToChunkList(physicalLine,out);
				info.firstSubregion = true;
				// if the line has no text, out.size() == 0
				if(out.size() == 0)
				{
					textArea.displayManager
						.setScreenLineCount(
						physicalLine,1);
					if(i == 0)
					{
						if(textArea.displayManager.firstLine.skew > 0)
						{
							Log.log(Log.ERROR,this,""BUG: skew="" + textArea.displayManager.firstLine.skew + "",out.size()="" + out.size());
							textArea.displayManager.firstLine.skew = 0;
							needFullRepaint = true;
							lastScreenLine = lineInfo.length - 1;
						}
					}
					chunks = null;
					offset = 0;
					length = 1;
				}
				// otherwise, the number of subregions
				else
				{
					textArea.displayManager
						.setScreenLineCount(
						physicalLine,out.size());
					if(i == 0)
					{
						int skew = textArea.displayManager.firstLine.skew;
						if(skew >= out.size())
						{
							Log.log(Log.ERROR,this,""BUG: skew="" + skew + "",out.size()="" + out.size());
							skew = 0;
							needFullRepaint = true;
							lastScreenLine = lineInfo.length - 1;
						}
						else if(skew > 0)
						{
							info.firstSubregion = false;
							for(int j = 0; j < skew; j++)
								out.remove(0);
						}
					}
					chunks = (Chunk)out.get(0);
					out.remove(0);
					offset = chunks.offset;
					if(out.size() != 0)
						length = ((Chunk)out.get(0)).offset - offset;
					else
						length = textArea.getLineLength(physicalLine) - offset + 1;
				}
			}
			else
			{
				info.firstSubregion = false;
				chunks = (Chunk)out.get(0);
				out.remove(0);
				offset = chunks.offset;
				if(out.size() != 0)
					length = ((Chunk)out.get(0)).offset - offset;
				else
					length = textArea.getLineLength(physicalLine) - offset + 1;
			}
			boolean lastSubregion = (out.size() == 0);
			if(i == lastScreenLine
				&& lastScreenLine != lineInfo.length - 1)
			{
				/* if the user changes the syntax token at the
				 * end of a line, need to do a full repaint. */
				if(tokenHandler.getLineContext() !=
					info.lineContext)
				{
					lastScreenLine++;
					needFullRepaint = true;
				}
				/* If this line has become longer or shorter
				 * (in which case the new physical line number
				 * is different from the cached one) we need to:
				 * - continue updating past the last line
				 * - advise the text area to repaint
				 * On the other hand, if the line wraps beyond
				 * lastScreenLine, we need to keep updating the
				 * chunk list to ensure proper alignment of
				 * invalidation flags (see start of method) */
				else if(info.physicalLine != physicalLine
					|| info.lastSubregion != lastSubregion)
				{
					lastScreenLine++;
					needFullRepaint = true;
				}
				/* We only cache entire physical lines at once;
				 * don't want to split a physical line into
				 * screen lines and only have some valid. */
				else if(out.size() != 0)
					lastScreenLine++;
			}
			info.physicalLine = physicalLine;
			info.lastSubregion = lastSubregion;
			info.offset = offset;
			info.length = length;
			info.chunks = chunks;
			info.lineContext = tokenHandler.getLineContext();
		}
		firstInvalidLine = Math.max(lastScreenLine + 1,firstInvalidLine);
	} //}}}
	//{{{ lineToChunkList() method
	private void lineToChunkList(int physicalLine, List out)
	{
		TextAreaPainter painter = textArea.getPainter();
		tokenHandler.init(painter.getStyles(),
			painter.getFontRenderContext(),
			painter,out,
			(textArea.displayManager.softWrap
			? textArea.displayManager.wrapMargin : 0.0f));
		buffer.markTokens(physicalLine,tokenHandler);
	} //}}}
	//}}}
	//{{{ LineInfo class
	static class LineInfo
	{
		int physicalLine;
		int offset;
		int length;
		boolean firstSubregion;
		boolean lastSubregion;
		Chunk chunks;
		int width;
		TokenMarker.LineContext lineContext;
	} //}}}
}
"
org.gjt.sp.jedit.textarea.DisplayManager,"/*
 * DisplayManager.java - Low-level text display
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2004 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import java.awt.Toolkit;
import java.util.*;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * Manages low-level text display tasks.
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: DisplayManager.java,v 1.93 2004/08/28 08:12:47 spestov Exp $
 */
public class DisplayManager
{
	//{{{ Static part
	public static long scanCount, scannedLines;
	//{{{ getDisplayManager() method
	static DisplayManager getDisplayManager(Buffer buffer,
		JEditTextArea textArea)
	{
		List l = (List)bufferMap.get(buffer);
		DisplayManager dmgr;
		if(l == null)
		{
			l = new LinkedList();
			bufferMap.put(buffer,l);
		}
		Iterator liter = l.iterator();
		while(liter.hasNext())
		{
			dmgr = (DisplayManager)liter.next();
			if(!dmgr.inUse && dmgr.textArea == textArea)
			{
				dmgr.inUse = true;
				return dmgr;
			}
		}
		// if we got here, no unused display manager in list
		dmgr = new DisplayManager(buffer,textArea);
		dmgr.inUse = true;
		l.add(dmgr);
		return dmgr;
	} //}}}
	//{{{ releaseDisplayManager() method
	static void releaseDisplayManager(DisplayManager dmgr)
	{
		dmgr.inUse = false;
	} //}}}
	//{{{ bufferClosed() method
	public static void bufferClosed(Buffer buffer)
	{
		bufferMap.remove(buffer);
	} //}}}
	//{{{ textAreaDisposed() method
	static void textAreaDisposed(JEditTextArea textArea)
	{
		Iterator biter = bufferMap.values().iterator();
		while(biter.hasNext())
		{
			List l = (List)biter.next();
			Iterator liter = l.iterator();
			while(liter.hasNext())
			{
				DisplayManager dmgr = (DisplayManager)
					liter.next();
				if(dmgr.textArea == textArea)
				{
					dmgr.dispose();
					liter.remove();
				}
			}
		}
	} //}}}
	//{{{ _notifyScreenLineChanges() method
	/* static void _notifyScreenLineChanges(Buffer buffer)
	{
		Iterator iter = ((List)bufferMap.get(buffer)).iterator();
		while(iter.hasNext())
		{
			((DisplayManager)iter.next())._notifyScreenLineChanges();
		}
	} */ //}}}
	private static Map bufferMap = new HashMap();
	//}}}
	//{{{ isLineVisible() method
	/**
	 * Returns if the specified line is visible.
	 * @param line A physical line index
	 * @since jEdit 4.2pre1
	 */
	public final boolean isLineVisible(int line)
	{
		return fvmget(line) % 2 == 0;
	} //}}}
	//{{{ getFirstVisibleLine() method
	/**
	 * Returns the physical line number of the first visible line.
	 * @since jEdit 4.2pre1
	 */
	public int getFirstVisibleLine()
	{
		return fvm[0];
	} //}}}
	//{{{ getLastVisibleLine() method
	/**
	 * Returns the physical line number of the last visible line.
	 * @since jEdit 4.2pre1
	 */
	public int getLastVisibleLine()
	{
		return fvm[fvmcount - 1] - 1;
	} //}}}
	//{{{ getNextVisibleLine() method
	/**
	 * Returns the next visible line after the specified line index.
	 * @param line A physical line index
	 * @since jEdit 4.0pre1
	 */
	public int getNextVisibleLine(int line)
	{
		if(line < 0 || line >= buffer.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);
		int index = fvmget(line);
		/* in collapsed range */
		if(index % 2 != 0)
		{
			/* beyond last visible line */
			if(fvmcount == index + 1)
				return - 1;
			/* start of next expanded range */
			else
				return fvm[index + 1];
		}
		/* last in expanded range */
		else if(line == fvm[index + 1] - 1)
		{
			/* equal to last visible line */
			if(fvmcount == index + 2)
				return -1;
			/* start of next expanded range */
			else
				return fvm[index + 2];
		}
		/* next in expanded range */
		else
			return line + 1;
	} //}}}
	//{{{ getPrevVisibleLine() method
	/**
	 * Returns the previous visible line before the specified line index.
	 * @param line A physical line index
	 * @since jEdit 4.0pre1
	 */
	public int getPrevVisibleLine(int line)
	{
		if(line < 0 || line >= buffer.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);
		int index = fvmget(line);
		/* before first visible line */
		if(index == -1)
			return -1;
		/* in collapsed range */
		else if(index % 2 == 1)
		{
			/* end of prev expanded range */
			return fvm[index] - 1;
		}
		/* first in expanded range */
		else if(line == fvm[index])
		{
			/* equal to first visible line */
			if(index == 0)
				return -1;
			/* end of prev expanded range */
			else
				return fvm[index - 1] - 1;
		}
		/* prev in expanded range */
		else
			return line - 1;
	} //}}}
	//{{{ getScreenLineCount() method
	public final int getScreenLineCount(int line)
	{
		if(lineMgr.isScreenLineCountValid(line))
			return lineMgr.getScreenLineCount(line);
		else
		{
			int newCount = textArea.chunkCache
				.getLineSubregionCount(line);
			setScreenLineCount(line,newCount);
			return newCount;
		}
	} //}}}
	//{{{ getScrollLineCount() method
	public final int getScrollLineCount()
	{
		return scrollLineCount.scrollLine;
	} //}}}
	//{{{ collapseFold() method
	/**
	 * Collapses the fold at the specified physical line index.
	 * @param line A physical line index
	 * @since jEdit 4.2pre1
	 */
	public void collapseFold(int line)
	{
		int lineCount = buffer.getLineCount();
		int start = 0;
		int end = lineCount - 1;
		// if the caret is on a collapsed fold, collapse the
		// parent fold
		if(line != 0
			&& line != buffer.getLineCount() - 1
			&& buffer.isFoldStart(line)
			&& !isLineVisible(line + 1))
		{
			line--;
		}
		int initialFoldLevel = buffer.getFoldLevel(line);
		//{{{ Find fold start and end...
		if(line != lineCount - 1
			&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
		{
			// this line is the start of a fold
			start = line + 1;
			for(int i = line + 1; i < lineCount; i++)
			{
				if(buffer.getFoldLevel(i) <= initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		}
		else
		{
			boolean ok = false;
			// scan backwards looking for the start
			for(int i = line - 1; i >= 0; i--)
			{
				if(buffer.getFoldLevel(i) < initialFoldLevel)
				{
					start = i + 1;
					ok = true;
					break;
				}
			}
			if(!ok)
			{
				// no folds in buffer
				return;
			}
			for(int i = line + 1; i < lineCount; i++)
			{
				if(buffer.getFoldLevel(i) < initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		} //}}}
		// Collapse the fold...
		hideLineRange(start,end);
		_notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} //}}}
	//{{{ expandFold() method
	/**
	 * Expands the fold at the specified physical line index.
	 * @param line A physical line index
	 * @param fully If true, all subfolds will also be expanded
	 * @since jEdit 4.2pre1
	 */
	public int expandFold(int line, boolean fully)
	{
		// the first sub-fold. used by JEditTextArea.expandFold().
		int returnValue = -1;
		int lineCount = buffer.getLineCount();
		int start = 0;
		int end = lineCount - 1;
		int initialFoldLevel = buffer.getFoldLevel(line);
		//{{{ Find fold start and fold end...
		if(line != lineCount - 1
			&& isLineVisible(line)
			&& !isLineVisible(line + 1)
			&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
		{
			// this line is the start of a fold
			int index = fvmget(line + 1);
			if(index == -1)
			{
				expandAllFolds();
				return -1;
			}
			start = fvm[index];
			if(index != fvmcount - 1)
				end = fvm[index + 1] - 1;
			else
			{
				start = line + 1;
				for(int i = line + 1; i < lineCount; i++)
				{
					if(/* isLineVisible(i) && */
						buffer.getFoldLevel(i) <= initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			}
		}
		else
		{
			int index = fvmget(line);
			if(index == -1)
			{
				expandAllFolds();
				return -1;
			}
			start = fvm[index];
			if(index != fvmcount - 1)
				end = fvm[index + 1] - 1;
			else
			{
				for(int i = line + 1; i < lineCount; i++)
				{
					//XXX
					if((isLineVisible(i) &&
						buffer.getFoldLevel(i) < initialFoldLevel)
						|| i == getLastVisibleLine())
					{
						end = i - 1;
						break;
					}
				}
			}
		} //}}}
		//{{{ Expand the fold...
		if(fully)
		{
			showLineRange(start,end);
		}
		else
		{
			// we need a different value of initialFoldLevel here!
			initialFoldLevel = buffer.getFoldLevel(start);
			int firstVisible = start;
			for(int i = start; i <= end; i++)
			{
				if(buffer.getFoldLevel(i) > initialFoldLevel)
				{
					if(returnValue == -1
						&& i != 0
						&& buffer.isFoldStart(i - 1))
					{
						returnValue = i - 1;
					}
					if(firstVisible != i)
					{
						showLineRange(firstVisible,i - 1);
					}
					firstVisible = i + 1;
				}
			}
			if(firstVisible != end + 1)
				showLineRange(firstVisible,end);
			if(!isLineVisible(line))
			{
				// this is a hack, and really needs to be done better.
				expandFold(line,false);
				return returnValue;
			}
		} //}}}
		_notifyScreenLineChanges();
		textArea.foldStructureChanged();
		return returnValue;
	} //}}}
	//{{{ expandAllFolds() method
	/**
	 * Expands all folds.
	 * @since jEdit 4.2pre1
	 */
	public void expandAllFolds()
	{
		showLineRange(0,buffer.getLineCount() - 1);
		_notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} //}}}
	//{{{ expandFolds() method
	/**
	 * This method should only be called from <code>actions.xml</code>.
	 * @since jEdit 4.2pre1
	 */
	public void expandFolds(char digit)
	{
		if(digit < '1' || digit > '9')
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		else
			expandFolds((int)(digit - '1') + 1);
	} //}}}
	//{{{ expandFolds() method
	/**
	 * Expands all folds with the specified fold level.
	 * @param foldLevel The fold level
	 * @since jEdit 4.2pre1
	 */
	public void expandFolds(int foldLevel)
	{
		if(buffer.getFoldHandler() instanceof IndentFoldHandler)
			foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;
		showLineRange(0,buffer.getLineCount() - 1);
		/* this ensures that the first line is always visible */
		boolean seenVisibleLine = false;
		int firstInvisible = 0;
		for(int i = 0; i < buffer.getLineCount(); i++)
		{
			if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)
			{
				if(firstInvisible != i)
				{
					hideLineRange(firstInvisible,
						i - 1);
				}
				firstInvisible = i + 1;
				seenVisibleLine = true;
			}
		}
		if(firstInvisible != buffer.getLineCount())
			hideLineRange(firstInvisible,buffer.getLineCount() - 1);
		_notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} //}}}
	//{{{ narrow() method
	/**
	 * Narrows the visible portion of the buffer to the specified
	 * line range.
	 * @param start The first line
	 * @param end The last line
	 * @since jEdit 4.2pre1
	 */
	public void narrow(int start, int end)
	{
		if(start > end || start < 0 || end >= buffer.getLineCount())
			throw new ArrayIndexOutOfBoundsException(start + "", "" + end);
		if(start < getFirstVisibleLine() || end > getLastVisibleLine())
			expandAllFolds();
		if(start != 0)
			hideLineRange(0,start - 1);
		if(end != buffer.getLineCount() - 1)
			hideLineRange(end + 1,buffer.getLineCount() - 1);
		// if we narrowed to a single collapsed fold
		if(start != buffer.getLineCount() - 1
			&& !isLineVisible(start + 1))
			expandFold(start,false);
		// Hack... need a more direct way of obtaining a view?
		// JEditTextArea.getView() method?
		GUIUtilities.getView(textArea).getStatus().setMessageAndClear(
			jEdit.getProperty(""view.status.narrow""));
		_notifyScreenLineChanges();
		textArea.foldStructureChanged();
	} //}}}
	//{{{ Package-private members
	boolean softWrap;
	int wrapMargin;
	FirstLine firstLine;
	ScrollLineCount scrollLineCount;
	//{{{ init() method
	void init()
	{
		if(!initialized)
		{
			initialized = true;
			fvm = new int[2];
			if(buffer.isLoaded())
				bufferChangeHandler.foldHandlerChanged(buffer);
			else
				fvmreset();
			_notifyScreenLineChanges();
		}
		else
		{
			updateWrapSettings();
			if(buffer.isLoaded())
			{
				_notifyScreenLineChanges();
				textArea.updateScrollBars();
				textArea.recalculateLastPhysicalLine();
			}
		}
	} //}}}
	//{{{ setScreenLineCount() method
	/**
	 * Sets the number of screen lines that the specified physical line
	 * is split into.
	 * @since jEdit 4.2pre1
	 */
	void setScreenLineCount(int line, int count)
	{
		int oldCount = lineMgr.getScreenLineCount(line);
		// still have to call this even if it equals the
		// old one so that the offset manager sets the
		// validity flag!
		lineMgr.setScreenLineCount(line,count);
		// this notifies each display manager editing this
		// buffer of the screen line count change
		if(count != oldCount)
		{
			Iterator iter = ((List)bufferMap.get(buffer))
				.iterator();
			while(iter.hasNext())
			{
				((DisplayManager)iter.next())._setScreenLineCount(
					line,oldCount,count);
			}
		}
	} //}}}
	//{{{ updateWrapSettings() method
	void updateWrapSettings()
	{
		String wrap = buffer.getStringProperty(""wrap"");
		softWrap = wrap.equals(""soft"");
		if(textArea.maxLineLen <= 0)
		{
			softWrap = false;
			wrapMargin = 0;
		}
		else
		{
			// stupidity
			char[] foo = new char[textArea.maxLineLen];
			for(int i = 0; i < foo.length; i++)
			{
				foo[i] = ' ';
			}
			TextAreaPainter painter = textArea.getPainter();
			wrapMargin = (int)painter.getFont().getStringBounds(
				foo,0,foo.length,
				painter.getFontRenderContext())
				.getWidth();
		}
	} //}}}
	//{{{ _notifyScreenLineChanges() method
	void _notifyScreenLineChanges()
	{
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""_notifyScreenLineChanges()"");
		// when the text area switches to us, it will do
		// a reset anyway
		if(textArea.getDisplayManager() == this)
		{
			try
			{
				if(firstLine.callReset)
					firstLine.reset();
				else if(firstLine.callChanged)
					firstLine.changed();
				if(scrollLineCount.callReset)
					scrollLineCount.reset();
				else if(scrollLineCount.callChanged)
					scrollLineCount.changed();
			}
			finally
			{
				firstLine.callReset = firstLine.callChanged = false;
				scrollLineCount.callReset = scrollLineCount.callChanged = false;
			}
		}
	} //}}}
	//}}}
	//{{{ Private members
	private boolean initialized;
	private boolean inUse;
	private Buffer buffer;
	private LineManager lineMgr;
	private JEditTextArea textArea;
	private BufferChangeHandler bufferChangeHandler;
	/**
	 * The fold visibility map.
	 *
	 * All lines from fvm[2*n] to fvm[2*n+1]-1 inclusive are visible.
	 * All lines from position fvm[2*n+1] to fvm[2*n+2]-1 inclusive are
	 * invisible.
	 *
	 * Examples:
	 * ---------
	 * All lines visible: { 0, buffer.getLineCount() }
	 * Narrow from a to b: { a, b + 1 }
	 * Collapsed fold from a to b: { 0, a + 1, b, buffer.getLineCount() }
	 *
	 * Note: length is always even.
	 */
	private int[] fvm;
	private int fvmcount;
	private int lastfvmget = -1;
	//{{{ DisplayManager constructor
	private DisplayManager(Buffer buffer, JEditTextArea textArea)
	{
		this.buffer = buffer;
		this.lineMgr = buffer._getLineManager();
		this.textArea = textArea;
		scrollLineCount = new ScrollLineCount();
		firstLine = new FirstLine();
		bufferChangeHandler = new BufferChangeHandler();
		// this listener priority thing is a bad hack...
		buffer.addBufferChangeListener(bufferChangeHandler,
			Buffer.HIGH_PRIORITY);
	} //}}}
	//{{{ dispose() method
	private void dispose()
	{
		buffer.removeBufferChangeListener(bufferChangeHandler);
	} //}}}
	//{{{ fvmreset() method
	private void fvmreset()
	{
		lastfvmget = -1;
		fvmcount = 2;
		fvm[0] = 0;
		fvm[1] = buffer.getLineCount();
	} //}}}
	//{{{ fvmget() method
	/**
	 * Returns the fold visibility map index for the given line.
	 */
	private int fvmget(int line)
	{
		scanCount++;
		if(line < fvm[0])
			return -1;
		if(line >= fvm[fvmcount - 1])
			return fvmcount - 1;
		if(lastfvmget != -1)
		{
			if(line >= fvm[lastfvmget])
			{
				if(lastfvmget == fvmcount - 1
					|| line < fvm[lastfvmget + 1])
				{
					return lastfvmget;
				}
			}
		}
		int start = 0;
		int end = fvmcount - 1;
loop:		for(;;)
		{
			scannedLines++;
			switch(end - start)
			{
			case 0:
				lastfvmget = start;
				break loop;
			case 1:
				int value = fvm[end];
				if(value <= line)
					lastfvmget = end;
				else
					lastfvmget = start;
				break loop;
			default:
				int pivot = (end + start) / 2;
				value = fvm[pivot];
				if(value == line)
				{
					lastfvmget = pivot;
					break loop;
				}
				else if(value < line)
					start = pivot;
				else
					end = pivot - 1;
				break;
			}
		}
		return lastfvmget;
	} //}}}
	//{{{ fvmput() method
	/**
	 * Replaces from <code>start</code> to <code>end-1</code> inclusive with
	 * <code>put</code>. Update <code>fvmcount</code>.
	 */
	private void fvmput(int start, int end, int[] put)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			StringBuffer buf = new StringBuffer(""{"");
			if(put != null)
			{
				for(int i = 0; i < put.length; i++)
				{
					if(i != 0)
						buf.append(',');
					buf.append(put[i]);
				}
			}
			buf.append(""}"");
			Log.log(Log.DEBUG,this,""fvmput("" + start + "",""
				+ end + "","" + buf + "")"");
		}
		int putl = (put == null ? 0 : put.length);
		int delta = putl - (end - start);
		if(fvmcount + delta > fvm.length)
		{
			int[] newfvm = new int[fvm.length * 2 + 1];
			System.arraycopy(fvm,0,newfvm,0,fvmcount);
			fvm = newfvm;
		}
		if(delta != 0)
		{
			System.arraycopy(fvm,end,fvm,start + putl,
				fvmcount - end);
		}
		if(putl != 0)
		{
			System.arraycopy(put,0,fvm,start,put.length);
		}
		fvmcount += delta;
		fvmdump();
		if(fvmcount == 0)
			throw new InternalError();
	} //}}}
	//{{{ fvmput2() method
	/**
	 * Merge previous and next entry if necessary.
	 */
	private void fvmput2(int starti, int endi, int start, int end)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			Log.log(Log.DEBUG,this,""*fvmput2("" + starti + "",""
				+ endi + "","" + start + "","" + end + "")"");
		}
		if(starti != -1 && fvm[starti] == start)
		{
			if(endi <= fvmcount - 2 && fvm[endi + 1]
				== end + 1)
			{
				fvmput(starti,endi + 2,null);
			}
			else
			{
				fvmput(starti,endi + 1,
					new int[] { end + 1 });
			}
		}
		else
		{
			if(endi != fvmcount - 1 && fvm[endi + 1]
				== end + 1)
			{
				fvmput(starti + 1,endi + 2,
					new int[] { start });
			}
			else
			{
				fvmput(starti + 1,endi + 1,
					new int[] { start,
					end + 1 });
			}
		}
	} //}}}
	//{{{ fvmdump() method
	private void fvmdump()
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			StringBuffer buf = new StringBuffer(""{"");
			for(int i = 0; i < fvmcount; i++)
			{
				if(i != 0)
					buf.append(',');
				buf.append(fvm[i]);
			}
			buf.append(""}"");
			Log.log(Log.DEBUG,this,""fvm = "" + buf);
		}
	} //}}}
	//{{{ showLineRange() method
	private void showLineRange(int start, int end)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			Log.log(Log.DEBUG,this,""showLineRange("" + start
				+ "","" + end + "")"");
		}
		for(int i = start; i <= end; i++)
		{
			//XXX
			if(!isLineVisible(i))
			{
				// important: not lineMgr.getScreenLineCount()
				int screenLines = getScreenLineCount(i);
				if(firstLine.physicalLine >= i)
				{
					firstLine.scrollLine += screenLines;
					firstLine.callChanged = true;
				}
				scrollLineCount.scrollLine += screenLines;
				scrollLineCount.callChanged = true;
			}
		}
		/* update fold visibility map. */
		int starti = fvmget(start);
		int endi = fvmget(end);
		if(starti % 2 == 0)
		{
			if(endi % 2 == 0)
				fvmput(starti + 1,endi + 1,null);
			else
			{
				if(endi != fvmcount - 1
					&& fvm[endi + 1] == end + 1)
					fvmput(starti + 1,endi + 2,null);
				else
				{
					fvmput(starti + 1,endi,null);
					fvm[starti + 1] = end + 1;
				}
			}
		}
		else
		{
			if(endi % 2 == 0)
			{
				if(starti != -1 && fvm[starti] == start)
					fvmput(starti,endi + 1,null);
				else
				{
					fvmput(starti + 1,endi,null);
					fvm[starti + 1] = start;
				}
			}
			else
				fvmput2(starti,endi,start,end);
		}
		lastfvmget = -1;
	} //}}}
	//{{{ hideLineRange() method
	private void hideLineRange(int start, int end)
	{
		if(Debug.FOLD_VIS_DEBUG)
		{
			Log.log(Log.DEBUG,this,""hideLineRange("" + start
				+ "","" + end + "")"");
		}
		int i = start;
		if(!isLineVisible(i))
			i = getNextVisibleLine(i);
		while(i != -1 && i <= end)
		{
			int screenLines = lineMgr.getScreenLineCount(i);
			if(i < firstLine.physicalLine)
			{
				firstLine.scrollLine -= screenLines;
				firstLine.skew = 0;
				firstLine.callChanged = true;
			}
			scrollLineCount.scrollLine -= screenLines;
			scrollLineCount.callChanged = true;
			i = getNextVisibleLine(i);
		}
		/* update fold visibility map. */
		int starti = fvmget(start);
		int endi = fvmget(end);
		if(starti % 2 == 0)
		{
			if(endi % 2 == 0)
				fvmput2(starti,endi,start,end);
			else
			{
				if(start == fvm[0])
					fvmput(starti,endi + 1,null);
				else
				{
					fvmput(starti + 1,endi,null);
					fvm[starti + 1] = start;
				}
			}
		}
		else
		{
			if(endi % 2 == 0)
			{
				if(end + 1 == fvm[fvmcount - 1])
					fvmput(starti + 1,endi + 2,null);
				else
				{
					fvmput(starti + 1,endi,null);
					fvm[starti + 1] = end + 1;
				}
			}
			else
				fvmput(starti + 1,endi + 1,null);
		}
		lastfvmget = -1;
		if(!isLineVisible(firstLine.physicalLine))
		{
			int firstVisible = getFirstVisibleLine();
			if(firstLine.physicalLine < firstVisible)
			{
				firstLine.physicalLine = firstVisible;
				firstLine.scrollLine = 0;
			}
			else
			{
				firstLine.physicalLine = getPrevVisibleLine(
					firstLine.physicalLine);
				firstLine.scrollLine -=
					lineMgr.getScreenLineCount(
					firstLine.physicalLine);
			}
			firstLine.callChanged = true;
		}
	} //}}}
	//{{{ _setScreenLineCount() method
	private void _setScreenLineCount(int line, int oldCount, int count)
	{
		if(!isLineVisible(line))
			return;
		if(firstLine.physicalLine >= line)
		{
			if(firstLine.physicalLine == line)
				firstLine.callChanged = true;
			else
			{
				firstLine.scrollLine += (count - oldCount);
				firstLine.callChanged = true;
			}
		}
		scrollLineCount.scrollLine += (count - oldCount);
		scrollLineCount.callChanged = true;
	} //}}}
	//}}}
	//{{{ Anchor class
	static abstract class Anchor
	{
		int physicalLine;
		int scrollLine;
		boolean callChanged;
		boolean callReset;
		abstract void reset();
		abstract void changed();
		public String toString()
		{
			return getClass().getName() + ""["" + physicalLine + "",""
				+ scrollLine + ""]"";
		}
	} //}}}
	//{{{ ScrollLineCount class
	class ScrollLineCount extends Anchor
	{
		//{{{ changed() method
		public void changed()
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""changed()"");
			textArea.updateScrollBars();
			textArea.recalculateLastPhysicalLine();
		} //}}}
		//{{{ reset() method
		public void reset()
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""reset()"");
			physicalLine = getFirstVisibleLine();
			scrollLine = 0;
			while(physicalLine != -1)
			{
				scrollLine += getScreenLineCount(physicalLine);
				physicalLine = getNextVisibleLine(physicalLine);
			}
			physicalLine = buffer.getLineCount();
			firstLine.ensurePhysicalLineIsVisible();
			textArea.recalculateLastPhysicalLine();
			textArea.updateScrollBars();
		} //}}}
	} //}}}
	//{{{ FirstLine class
	class FirstLine extends Anchor
	{
		int skew;
		//{{{ changed() method
		public void changed()
		{
			//{{{ Debug code
			if(Debug.SCROLL_DEBUG)
			{
				Log.log(Log.DEBUG,this,""changed() before: ""
					+ physicalLine + "":"" + scrollLine);
			} //}}}
			ensurePhysicalLineIsVisible();
			int screenLines = getScreenLineCount(physicalLine);
			if(skew >= screenLines)
				skew = screenLines - 1;
			//{{{ Debug code
			if(Debug.SCROLL_VERIFY)
			{
				System.err.println(""SCROLL_VERIFY"");
				int verifyScrollLine = 0;
				for(int i = 0; i < buffer.getLineCount(); i++)
				{
					if(!isLineVisible(i))
						continue;
					if(i >= physicalLine)
						break;
					verifyScrollLine += getScreenLineCount(i);
				}
				if(verifyScrollLine != scrollLine)
				{
					Exception ex = new Exception(scrollLine + "":"" + verifyScrollLine);
					Log.log(Log.ERROR,this,ex);
					new org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);
				}
			}
			if(Debug.SCROLL_DEBUG)
			{
				Log.log(Log.DEBUG,this,""changed() after: ""
					+ physicalLine + "":"" + scrollLine);
			} //}}}
			if(!scrollLineCount.callChanged
				&& !scrollLineCount.callReset)
			{
				textArea.updateScrollBars();
				textArea.recalculateLastPhysicalLine();
			}
			else
			{
				// ScrollLineCount.changed() does the same
				// thing
			}
		} //}}}
		//{{{ reset() method
		public void reset()
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""reset()"");
			String wrap = buffer.getStringProperty(""wrap"");
			softWrap = wrap.equals(""soft"");
			if(textArea.maxLineLen <= 0)
			{
				softWrap = false;
				wrapMargin = 0;
			}
			else
			{
				// stupidity
				char[] foo = new char[textArea.maxLineLen];
				for(int i = 0; i < foo.length; i++)
				{
					foo[i] = ' ';
				}
				TextAreaPainter painter = textArea.getPainter();
				wrapMargin = (int)painter.getFont().getStringBounds(
					foo,0,foo.length,
					painter.getFontRenderContext())
					.getWidth();
			}
			scrollLine = 0;
			int i = getFirstVisibleLine();
			for(;;)
			{
				if(i >= physicalLine)
					break;
				scrollLine += getScreenLineCount(i);
				int nextLine = getNextVisibleLine(i);
				if(nextLine == -1)
					break;
				else
					i = nextLine;
			}
			physicalLine = i;
			int screenLines = getScreenLineCount(physicalLine);
			if(skew >= screenLines)
				skew = screenLines - 1;
			textArea.updateScrollBars();
		} //}}}
		//{{{ physDown() method
		// scroll down by physical line amount
		void physDown(int amount, int screenAmount)
		{
			if(Debug.SCROLL_DEBUG)
			{
				Log.log(Log.DEBUG,this,""physDown() start: ""
					+ physicalLine + "":"" + scrollLine);
			}
			skew = 0;
			if(!isLineVisible(physicalLine))
			{
				int lastVisibleLine = getLastVisibleLine();
				if(physicalLine > lastVisibleLine)
					physicalLine = lastVisibleLine;
				else
				{
					int nextPhysicalLine = getNextVisibleLine(physicalLine);
					amount -= (nextPhysicalLine - physicalLine);
					scrollLine += getScreenLineCount(physicalLine);
					physicalLine = nextPhysicalLine;
				}
			}
			for(;;)
			{
				int nextPhysicalLine = getNextVisibleLine(
					physicalLine);
				if(nextPhysicalLine == -1)
					break;
				else if(nextPhysicalLine > physicalLine + amount)
					break;
				else
				{
					scrollLine += getScreenLineCount(physicalLine);
					amount -= (nextPhysicalLine - physicalLine);
					physicalLine = nextPhysicalLine;
				}
			}
			if(Debug.SCROLL_DEBUG)
			{
				Log.log(Log.DEBUG,this,""physDown() end: ""
					+ physicalLine + "":"" + scrollLine);
			}
			callChanged = true;
			// JEditTextArea.scrollTo() needs this to simplify
			// its code
			if(screenAmount < 0)
				scrollUp(-screenAmount);
			else if(screenAmount > 0)
				scrollDown(screenAmount);
		} //}}}
		//{{{ physUp() method
		// scroll up by physical line amount
		void physUp(int amount, int screenAmount)
		{
			if(Debug.SCROLL_DEBUG)
			{
				Log.log(Log.DEBUG,this,""physUp() start: ""
					+ physicalLine + "":"" + scrollLine);
			}
			skew = 0;
			if(!isLineVisible(physicalLine))
			{
				int firstVisibleLine = getFirstVisibleLine();
				if(physicalLine < firstVisibleLine)
					physicalLine = firstVisibleLine;
				else
				{
					int prevPhysicalLine = getPrevVisibleLine(physicalLine);
					amount -= (physicalLine - prevPhysicalLine);
				}
			}
			for(;;)
			{
				int prevPhysicalLine = getPrevVisibleLine(
					physicalLine);
				if(prevPhysicalLine == -1)
					break;
				else if(prevPhysicalLine < physicalLine - amount)
					break;
				else
				{
					amount -= (physicalLine - prevPhysicalLine);
					physicalLine = prevPhysicalLine;
					scrollLine -= getScreenLineCount(
						prevPhysicalLine);
				}
			}
			if(Debug.SCROLL_DEBUG)
			{
				Log.log(Log.DEBUG,this,""physUp() end: ""
					+ physicalLine + "":"" + scrollLine);
			}
			callChanged = true;
			// JEditTextArea.scrollTo() needs this to simplify
			// its code
			if(screenAmount < 0)
				scrollUp(-screenAmount);
			else if(screenAmount > 0)
				scrollDown(screenAmount);
		} //}}}
		//{{{ scrollDown() method
		// scroll down by screen line amount
		void scrollDown(int amount)
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""scrollDown()"");
			ensurePhysicalLineIsVisible();
			amount += skew;
			skew = 0;
			while(amount > 0)
			{
				int screenLines = getScreenLineCount(physicalLine);
				if(amount < screenLines)
				{
					skew = amount;
					break;
				}
				else
				{
					int nextLine = getNextVisibleLine(physicalLine);
					if(nextLine == -1)
						break;
					boolean visible = isLineVisible(physicalLine);
					physicalLine = nextLine;
					if(visible)
					{
						amount -= screenLines;
						scrollLine += screenLines;
					}
				}
			}
			callChanged = true;
		} //}}}
		//{{{ scrollUp() method
		// scroll up by screen line amount
		void scrollUp(int amount)
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""scrollUp()"");
			ensurePhysicalLineIsVisible();
			if(amount <= skew)
			{
				skew -= amount;
			}
			else
			{
				amount -= skew;
				skew = 0;
				while(amount > 0)
				{
					int prevLine = getPrevVisibleLine(physicalLine);
					if(prevLine == -1)
						break;
					physicalLine = prevLine;
					int screenLines = getScreenLineCount(physicalLine);
					scrollLine -= screenLines;
					if(amount < screenLines)
					{
						skew = screenLines - amount;
						break;
					}
					else
						amount -= screenLines;
				}
			}
			callChanged = true;
		} //}}}
		//{{{ ensurePhysicalLineIsVisible() method
		private void ensurePhysicalLineIsVisible()
		{
			if(!isLineVisible(physicalLine))
			{
				if(physicalLine > getLastVisibleLine())
				{
					physicalLine = getLastVisibleLine();
					scrollLine = getScrollLineCount() - 1;
				}
				else if(physicalLine < getFirstVisibleLine())
				{
					physicalLine = getFirstVisibleLine();
					scrollLine = 0;
				}
				else
				{
					physicalLine = getNextVisibleLine(physicalLine);
					scrollLine += getScreenLineCount(physicalLine);
				}
			}
		} //}}}
	} //}}}
	//{{{ BufferChangeHandler class
	/**
	 * Note that in this class we take great care to defer complicated
	 * calculations to the end of the current transaction if the buffer
	 * informs us a compound edit is in progress
	 * (<code>isTransactionInProgress()</code>).
	 *
	 * This greatly speeds up replace all for example, by only doing certain
	 * things once, particularly in <code>moveCaretPosition()</code>.
	 *
	 * Try doing a replace all in a large file, for example. It is very slow
	 * in 3.2, faster in 4.0 (where the transaction optimization was
	 * introduced) and faster still in 4.1 (where it was further improved).
	 *
	 * There is still work to do; see TODO.txt.
	 */
	class BufferChangeHandler extends BufferChangeAdapter
	{
		boolean delayedUpdate;
		boolean delayedMultilineUpdate;
		int delayedUpdateStart;
		int delayedUpdateEnd;
		//{{{ foldHandlerChanged() method
		public void foldHandlerChanged(Buffer buffer)
		{
			fvmreset();
			firstLine.callReset = true;
			scrollLineCount.callReset = true;
			int collapseFolds = buffer.getIntegerProperty(
				""collapseFolds"",0);
			if(collapseFolds != 0)
				expandFolds(collapseFolds);
			_notifyScreenLineChanges();
		} //}}}
		//{{{ foldLevelChanged() method
		public void foldLevelChanged(Buffer buffer, int start, int end)
		{
			//System.err.println(""foldLevelChanged "" + (start-1) + "" to "" + textArea.getLastPhysicalLine() + "","" + end);
			if(textArea.getDisplayManager() == DisplayManager.this
				&& end != 0 && buffer.isLoaded())
			{
				textArea.invalidateLineRange(start - 1,
					textArea.getLastPhysicalLine());
			}
		} //}}}
		//{{{ contentInserted() method
		public void contentInserted(Buffer buffer, int startLine,
			int offset, int numLines, int length)
		{
			if(!buffer.isLoaded())
			{
				fvmreset();
				return;
			}
			int endLine = startLine + numLines;
			if(numLines != 0)
			{
				delayedMultilineUpdate = true;
				/* this is a sloppy hack to fix bug
				   ""[ 677902 ] hitting return after collapsed
				   fold""
				   the idea is that if we extend the range then
				   the problem described in the bug happends, so
				   if the insert is at the very end of the range
				   we don't extend it, instead we push the
				   insert into the next range, however for this
				   to work properly we also have to mess with
				   screen line counts. */
				int index = fvmget(startLine);
				int start = index + 1;
				/* if(start + 1 < fvmcount && fvm[start]
					== startLine + 1)
				{
					if(index % 2 == 0)
					{
						System.err.println(""case 1"");
						scrollLineCount.scrollLine -=
							getScreenLineCount(
							startLine + 1);
						start++;
					}
				} */
				for(int i = start; i < fvmcount; i++)
				{
					fvm[i] += numLines;
				}
				lastfvmget = -1;
				fvmdump();
			}
			if(textArea.getDisplayManager() == DisplayManager.this)
			{
				if(numLines != 0)
				{
					contentInserted(firstLine,startLine,numLines);
					contentInserted(scrollLineCount,startLine,numLines);
				}
				if(delayedUpdateEnd >= startLine)
					delayedUpdateEnd += numLines;
				delayedUpdate(startLine,endLine);
				//{{{ resize selections if necessary
				for(int i = 0; i < textArea.selection.size(); i++)
				{
					Selection s = (Selection)textArea
						.selection.elementAt(i);
					if(s.contentInserted(buffer,startLine,offset,
						numLines,length))
					{
						delayedUpdate(s.startLine,s.endLine);
					}
				} //}}}
				int caret = textArea.getCaretPosition();
				if(caret >= offset)
				{
					int scrollMode = (caretAutoScroll()
						? JEditTextArea.ELECTRIC_SCROLL
						: JEditTextArea.NO_SCROLL);
					textArea.moveCaretPosition(
						caret + length,scrollMode);
				}
				else
				{
					int scrollMode = (caretAutoScroll()
						? JEditTextArea.NORMAL_SCROLL
						: JEditTextArea.NO_SCROLL);
					textArea.moveCaretPosition(
						caret,scrollMode);
				}
			}
			else
			{
				firstLine.callReset = true;
				scrollLineCount.callReset = true;
			}
		} //}}}
		//{{{ preContentRemoved() method
		public void preContentRemoved(Buffer buffer, int startLine,
			int offset, int numLines, int length)
		{
			if(!buffer.isLoaded())
				return;
			if(textArea.getDisplayManager() == DisplayManager.this)
			{
				if(numLines != 0)
				{
					preContentRemoved(firstLine,startLine,numLines);
					preContentRemoved(scrollLineCount,startLine,numLines);
				}
				if(delayedUpdateEnd >= startLine)
					delayedUpdateEnd -= numLines;
				delayedUpdate(startLine,startLine);
			}
			else
			{
				firstLine.callReset = true;
				scrollLineCount.callReset = true;
			}
			if(numLines == 0)
				return;
			delayedMultilineUpdate = true;
			int endLine = startLine + numLines;
			/* update fold visibility map. */
			int starti = fvmget(startLine);
			int endi = fvmget(endLine);
			/* both have same visibility; just remove
			 * anything in between. */
			if(Math.abs(starti % 2) == Math.abs(endi % 2))
			{
				if(endi - starti == fvmcount)
				{
					// we're removing from before
					// the first visible to after
					// the last visible
					fvmreset();
					firstLine.callReset = true;
					scrollLineCount.callReset = true;
					starti = 1;
				}
				else
				{
					fvmput(starti + 1,endi + 1,null);
					starti++;
				}
			}
			/* collapse 2 */
			else if(starti != -1 && fvm[starti] == startLine)
			{
				if(endi - starti == fvmcount - 1)
				{
					// we're removing from
					// the first visible to after
					// the last visible
					fvmreset();
					firstLine.callReset = true;
					scrollLineCount.callReset = true;
					starti = 1;
				}
				else
					fvmput(starti,endi + 1,null);
			}
			/* shift */
			else
			{
				fvmput(starti + 1,endi,null);
				fvm[starti + 1] = startLine;
				starti += 2;
			}
			/* update */
			for(int i = starti; i < fvmcount; i++)
				fvm[i] -= numLines;
			if(firstLine.physicalLine
				> getLastVisibleLine()
				|| firstLine.physicalLine
				< getFirstVisibleLine())
			{
				// will be handled later.
				// see comments at the end of
				// transactionComplete().
			}
			// very subtle... if we leave this for
			// ensurePhysicalLineIsVisible(), an
			// extra line will be added to the
			// scroll line count.
			else if(!isLineVisible(
				firstLine.physicalLine))
			{
				firstLine.physicalLine =
					getNextVisibleLine(
					firstLine.physicalLine);
			}
			lastfvmget = -1;
			fvmdump();
		} //}}}
		//{{{ contentRemoved() method
		public void contentRemoved(Buffer buffer, int startLine,
			int start, int numLines, int length)
		{
			if(!buffer.isLoaded())
				return;
			if(textArea.getDisplayManager() == DisplayManager.this)
			{
				//{{{ resize selections if necessary
				for(int i = 0; i < textArea.selection.size(); i++)
				{
					Selection s = (Selection)textArea
						.selection.elementAt(i);
					if(s.contentRemoved(buffer,startLine,
						start,numLines,length))
					{
						delayedUpdate(s.startLine,s.endLine);
						if(s.start == s.end)
						{
							textArea.selection.removeElementAt(i);
							i--;
						}
					}
				} //}}}
				int caret = textArea.getCaretPosition();
				if(caret >= start + length)
				{
					int scrollMode = (caretAutoScroll()
						? JEditTextArea.ELECTRIC_SCROLL
						: JEditTextArea.NO_SCROLL);
					textArea.moveCaretPosition(
						caret - length,
						scrollMode);
				}
				else if(caret >= start)
				{
					int scrollMode = (caretAutoScroll()
						? JEditTextArea.ELECTRIC_SCROLL
						: JEditTextArea.NO_SCROLL);
					textArea.moveCaretPosition(
						start,scrollMode);
				}
				else
				{
					int scrollMode = (caretAutoScroll()
						? JEditTextArea.NORMAL_SCROLL
						: JEditTextArea.NO_SCROLL);
					textArea.moveCaretPosition(caret,scrollMode);
				}
			}
		}
		//}}}
		//{{{ transactionComplete() method
		public void transactionComplete(Buffer buffer)
		{
			if(textArea.getDisplayManager() != DisplayManager.this)
			{
				delayedUpdate = false;
				return;
			}
			if(delayedUpdate)
				doDelayedUpdate();
			textArea._finishCaretUpdate();
			delayedUpdate = false;
			//{{{ Debug code
			/* if(Debug.SCROLL_VERIFY)
			{
				int scrollLineCount = 0;
				int line = delayedUpdateStart;
				if(!isLineVisible(line))
					line = getNextVisibleLine(line);
				System.err.println(delayedUpdateStart + "":"" + delayedUpdateEnd + "":"" + textArea.getLineCount());
				while(line != -1 && line <= delayedUpdateEnd)
				{
					scrollLineCount += getScreenLineCount(line);
					line = getNextVisibleLine(line);
				}
				if(scrollLineCount != getScrollLineCount())
				{
					throw new InternalError(scrollLineCount
						+ "" != ""
						+ getScrollLineCount());
				}
			} */ //}}}
		} //}}}
		//{{{ doDelayedUpdate() method
		private void doDelayedUpdate()
		{
			// must update screen line counts before we call
			// _notifyScreenLineChanges() since that calls
			// updateScrollBars() which needs valid info
			int _firstLine = textArea.getFirstPhysicalLine();
			int _lastLine = textArea.getLastPhysicalLine();
			int line = delayedUpdateStart;
			if(!isLineVisible(line))
				line = getNextVisibleLine(line);
			while(line != -1 && line <= delayedUpdateEnd)
			{
				if(line < _firstLine || line > _lastLine)
				{
					getScreenLineCount(line);
				}
				line = getNextVisibleLine(line);
			}
			// must be before the below call
			// so that the chunk cache is not
			// updated with an invisible first
			// line (see above)
			_notifyScreenLineChanges();
			if(delayedMultilineUpdate)
			{
				textArea.invalidateScreenLineRange(
					textArea.chunkCache
					.getScreenLineOfOffset(
					delayedUpdateStart,0),
					textArea.getVisibleLines());
				delayedMultilineUpdate = false;
			}
			else
			{
				textArea.invalidateLineRange(
					delayedUpdateStart,
					delayedUpdateEnd);
			}
			// update visible lines
			int visibleLines = textArea.getVisibleLines();
			if(visibleLines != 0)
			{
				textArea.chunkCache.getLineInfo(
					visibleLines - 1);
			}
			// force the fold levels to be
			// updated.
			// when painting the last line of
			// a buffer, Buffer.isFoldStart()
			// doesn't call getFoldLevel(),
			// hence the foldLevelChanged()
			// event might not be sent for the
			// previous line.
			buffer.getFoldLevel(delayedUpdateEnd);
		} //}}}
		//{{{ contentInserted() method
		private void contentInserted(Anchor anchor, int startLine,
			int numLines)
		{
			if(anchor.physicalLine >= startLine)
			{
				if(anchor.physicalLine != startLine)
					anchor.physicalLine += numLines;
				anchor.callChanged = true;
			}
		} //}}}
		//{{{ preContentRemoved() method
		private void preContentRemoved(Anchor anchor, int startLine,
			int numLines)
		{
			if(anchor.physicalLine >= startLine)
			{
				if(anchor.physicalLine == startLine)
					anchor.callChanged = true;
				else
				{
					int end = Math.min(startLine + numLines,
						anchor.physicalLine);
					for(int i = startLine; i < end; i++)
					{
						//XXX
						if(isLineVisible(i))
						{
							anchor.scrollLine -=
								lineMgr
								.getScreenLineCount(i);
						}
					}
					anchor.physicalLine -= (end - startLine);
					anchor.callChanged = true;
				}
			}
		} //}}}
		//{{{ delayedUpdate() method
		private void delayedUpdate(int startLine, int endLine)
		{
			textArea.chunkCache.invalidateChunksFromPhys(startLine);
			if(!delayedUpdate)
			{
				delayedUpdateStart = startLine;
				delayedUpdateEnd = endLine;
				delayedUpdate = true;
			}
			else
			{
				delayedUpdateStart = Math.min(
					delayedUpdateStart,
					startLine);
				delayedUpdateEnd = Math.max(
					delayedUpdateEnd,
					endLine);
			}
		} //}}}
		//{{{ caretAutoScroll() method
		/**
		 * Return if change in buffer should scroll this text area.
		 */
		private boolean caretAutoScroll()
		{
			View view = textArea.getView();
			return view == jEdit.getActiveView()
				&& view.getTextArea() == textArea;
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.textarea.ExtensionManager,"/*
 * ExtensionManager.java - Handles 'layers'
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.Graphics2D;
import java.util.*;
import org.gjt.sp.util.Log;
class ExtensionManager
{
	//{{{ addExtension() method
	void addExtension(int layer, TextAreaExtension ext)
	{
		Entry entry = new Entry(layer,ext);
		int i = 0;
		Iterator iter = extensions.iterator();
		while(iter.hasNext())
		{
			int _layer = ((Entry)iter.next()).layer;
			if(layer < _layer)
			{
				extensions.add(i,entry);
				return;
			}
			i++;
		}
		extensions.add(entry);
	} //}}}
	//{{{ removeExtension() method
	void removeExtension(TextAreaExtension ext)
	{
		Iterator iter = extensions.iterator();
		while(iter.hasNext())
		{
			if(((Entry)iter.next()).ext == ext)
			{
				iter.remove();
				return;
			}
		}
	} //}}}
	//{{{ getExtensions() method
	TextAreaExtension[] getExtensions()
	{
		TextAreaExtension[] retVal = new TextAreaExtension[
			extensions.size()];
		Iterator iter = extensions.iterator();
		int i = 0;
		while(iter.hasNext())
		{
			retVal[i++] = ((Entry)iter.next()).ext;
		}
		return retVal;
	} //}}}
	//{{{ paintScreenLineRange() method
	void paintScreenLineRange(JEditTextArea textArea, Graphics2D gfx,
		int firstLine, int lastLine, int y, int lineHeight)
	{
		try
		{
			int[] physicalLines = new int[lastLine - firstLine + 1];
			int[] start = new int[physicalLines.length];
			int[] end = new int[physicalLines.length];
			for(int i = 0; i < physicalLines.length; i++)
			{
				int screenLine = i + firstLine;
				ChunkCache.LineInfo lineInfo = textArea
					.chunkCache.getLineInfo(screenLine);
				if(lineInfo.physicalLine == -1)
					physicalLines[i] = -1;
				else
				{
					physicalLines[i] = lineInfo.physicalLine;
					start[i] = textArea.getScreenLineStartOffset(screenLine);
					end[i] = textArea.getScreenLineEndOffset(screenLine);
				}
			}
			paintScreenLineRange(gfx,firstLine,lastLine,physicalLines,
				start,end,y,lineHeight);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Error repainting line""
				+ "" range {"" + firstLine + "",""
				+ lastLine + ""}:"");
			Log.log(Log.ERROR,this,e);
		}
	} //}}}
	//{{{ getToolTipText() method
	String getToolTipText(int x, int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			String toolTip = ext.getToolTipText(x,y);
			if(toolTip != null)
				return toolTip;
		}
		return null;
	} //}}}
	//{{{ Private members
	private List extensions = new LinkedList();
	//{{{ paintScreenLineRange() method
	private void paintScreenLineRange(Graphics2D gfx, int firstLine,
		int lastLine, int[] physicalLines, int[] start, int[] end,
		int y, int lineHeight)
	{
		Iterator iter = extensions.iterator();
		while(iter.hasNext())
		{
			TextAreaExtension ext = ((Entry)iter.next()).ext;
			try
			{
				ext.paintScreenLineRange(gfx,firstLine,lastLine,
					physicalLines,start,end,y,lineHeight);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);
				// remove it so editor can continue
				// functioning
				iter.remove();
			}
		}
	} //}}}
	//}}}
	//{{{ Entry class
	static class Entry
	{
		int layer;
		TextAreaExtension ext;
		Entry(int layer, TextAreaExtension ext)
		{
			this.layer = layer;
			this.ext = ext;
		}
	} //}}}
}
"
org.gjt.sp.jedit.textarea.Gutter,"/*
 * Gutter.java
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2000 mike dillon
 * Portions copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * The gutter is the component that displays folding triangles and line
 * numbers to the left of the text area. The only methods in this class
 * that should be called by plugins are those for adding and removing
 * text area extensions.
 *
 * @see #addExtension(TextAreaExtension)
 * @see #addExtension(int,TextAreaExtension)
 * @see #removeExtension(TextAreaExtension)
 * @see TextAreaExtension
 * @see JEditTextArea
 *
 * @author Mike Dillon and Slava Pestov
 * @version $Id: Gutter.java,v 1.51 2004/08/12 22:42:44 spestov Exp $
 */
public class Gutter extends JComponent implements SwingConstants
{
	//{{{ Layers
	/**
	 * The lowest possible layer.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre4
	 */
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;
	/**
	 * Default extension layer. This is above the wrap guide but below the
	 * bracket highlight.
	 * @since jEdit 4.0pre4
	 */
	public static final int DEFAULT_LAYER = 0;
	/**
	 * Highest possible layer.
	 * @since jEdit 4.0pre4
	 */
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	//}}}
	//{{{ Gutter constructor
	public Gutter(View view, JEditTextArea textArea)
	{
		this.view = view;
		this.textArea = textArea;
		setAutoscrolls(true);
		setOpaque(true);
		setRequestFocusEnabled(false);
		extensionMgr = new ExtensionManager();
		MouseHandler ml = new MouseHandler();
		addMouseListener(ml);
		addMouseMotionListener(ml);
		addExtension(new MarkerHighlight());
		updateBorder();
	} //}}}
	//{{{ paintComponent() method
	public void paintComponent(Graphics _gfx)
	{
		Graphics2D gfx = (Graphics2D)_gfx;
		// fill the background
		Rectangle clip = gfx.getClipBounds();
		gfx.setColor(getBackground());
		gfx.fillRect(clip.x, clip.y, clip.width, clip.height);
		// if buffer is loading, don't paint anything
		if (!textArea.getBuffer().isLoaded())
			return;
		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();
		if(lineHeight == 0)
			return;
		int firstLine = clip.y / lineHeight;
		int lastLine = (clip.y + clip.height - 1) / lineHeight;
		if(lastLine - firstLine > textArea.getVisibleLines())
		{
			Log.log(Log.ERROR,this,""BUG: firstLine="" + firstLine);
			Log.log(Log.ERROR,this,""     lastLine="" + lastLine);
			Log.log(Log.ERROR,this,""     visibleLines="" + textArea.getVisibleLines());
			Log.log(Log.ERROR,this,""     height="" + getHeight());
			Log.log(Log.ERROR,this,""     painter.height="" + textArea.getPainter().getHeight());
			Log.log(Log.ERROR,this,""     clip.y="" + clip.y);
			Log.log(Log.ERROR,this,""     clip.height="" + clip.height);
			Log.log(Log.ERROR,this,""     lineHeight="" + lineHeight);
		}
		int y = (clip.y - clip.y % lineHeight);
		extensionMgr.paintScreenLineRange(textArea,gfx,
			firstLine,lastLine,y,lineHeight);
		for (int line = firstLine; line <= lastLine;
			line++, y += lineHeight)
		{
			paintLine(gfx,line,y);
		}
	} //}}}
	//{{{ addExtension() method
	/**
	 * Adds a text area extension, which can perform custom painting and
	 * tool tip handling.
	 * @param extension The extension
	 * @since jEdit 4.0pre4
	 */
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} //}}}
	//{{{ addExtension() method
	/**
	 * Adds a text area extension, which can perform custom painting and
	 * tool tip handling.
	 * @param layer The layer to add the extension to. Note that more than
	 * extension can share the same layer.
	 * @param extension The extension
	 * @since jEdit 4.0pre4
	 */
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} //}}}
	//{{{ removeExtension() method
	/**
	 * Removes a text area extension. It will no longer be asked to
	 * perform custom painting and tool tip handling.
	 * @param extension The extension
	 * @since jEdit 4.0pre4
	 */
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} //}}}
	//{{{ getExtensions() method
	/**
	 * Returns an array of registered text area extensions. Useful for
	 * debugging purposes.
	 * @since jEdit 4.1pre5
	 */
	public TextAreaExtension[] getExtensions()
	{
		return extensionMgr.getExtensions();
	} //}}}
	//{{{ getToolTipText() method
	/**
	 * Returns the tool tip to display at the specified location.
	 * @param evt The mouse event
	 */
	public String getToolTipText(MouseEvent evt)
	{
		if(!textArea.getBuffer().isLoaded())
			return null;
		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} //}}}
	//{{{ setBorder() method
	/**
	 * Convenience method for setting a default matte border on the right
	 * with the specified border width and color
	 * @param width The border width (in pixels)
	 * @param color1 The focused border color
	 * @param color2 The unfocused border color
	 * @param color3 The gutter/text area gap color
	 */
	public void setBorder(int width, Color color1, Color color2, Color color3)
	{
		this.borderWidth = width;
		focusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color1));
		noFocusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color2));
		updateBorder();
	} //}}}
	//{{{ updateBorder() method
	/**
	 * Sets the border differently if the text area has focus or not.
	 */
	public void updateBorder()
	{
		if(view.getEditPane() == null)
			setBorder(noFocusBorder);
		else if(view.getEditPane().getTextArea() == textArea)
			setBorder(focusBorder);
		else
			setBorder(noFocusBorder);
	} //}}}
	//{{{ setBorder() method
	/*
	 * JComponent.setBorder(Border) is overridden here to cache the left
	 * inset of the border (if any) to avoid having to fetch it during every
	 * repaint.
	 */
	public void setBorder(Border border)
	{
		super.setBorder(border);
		if (border == null)
		{
			collapsedSize.width = 0;
			collapsedSize.height = 0;
		}
		else
		{
			Insets insets = border.getBorderInsets(this);
			collapsedSize.width = FOLD_MARKER_SIZE + insets.right;
			collapsedSize.height = gutterSize.height
				= insets.top + insets.bottom;
			gutterSize.width = FOLD_MARKER_SIZE + insets.right
				+ fm.stringWidth(""12345"");
		}
		revalidate();
	} //}}}
	//{{{ setFont() method
	/*
	 * JComponent.setFont(Font) is overridden here to cache the baseline for
	 * the font. This avoids having to get the font metrics during every
	 * repaint.
	 */
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		baseline = fm.getAscent();
		Border border = getBorder();
		if(border != null)
		{
			gutterSize.width = FOLD_MARKER_SIZE
				+ border.getBorderInsets(this).right
				+ fm.stringWidth(""12345"");
			revalidate();
		}
	} //}}}
	//{{{ Getters and setters
	//{{{ getHighlightedForeground() method
	/**
	 * Get the foreground color for highlighted line numbers
	 * @return The highlight color
	 */
	public Color getHighlightedForeground()
	{
		return intervalHighlight;
	} //}}}
	//{{{ setHighlightedForeground() method
	public void setHighlightedForeground(Color highlight)
	{
		intervalHighlight = highlight;
	} //}}}
	//{{{ getCurrentLineForeground() method
	public Color getCurrentLineForeground()
 	{
		return currentLineHighlight;
	} //}}}
	//{{{ setCurrentLineForeground() method
	public void setCurrentLineForeground(Color highlight)
	{
		currentLineHighlight = highlight;
 	} //}}}
	//{{{ getFoldColor() method
	public Color getFoldColor()
 	{
		return foldColor;
	} //}}}
	//{{{ setFoldColor() method
	public void setFoldColor(Color foldColor)
	{
		this.foldColor = foldColor;
 	} //}}}
	//{{{ getPreferredSize() method
	/*
	 * Component.getPreferredSize() is overridden here to support the
	 * collapsing behavior.
	 */
	public Dimension getPreferredSize()
	{
		if (expanded)
			return gutterSize;
		else
			return collapsedSize;
	} //}}}
	//{{{ getMinimumSize() method
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} //}}}
	//{{{ getLineNumberAlignment() method
	/**
	 * Identifies whether the horizontal alignment of the line numbers.
	 * @return Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT
	 */
	public int getLineNumberAlignment()
	{
		return alignment;
	} //}}}
	//{{{ setLineNumberAlignment() method
	/**
	 * Sets the horizontal alignment of the line numbers.
	 * @param alignment Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT
	 */
	public void setLineNumberAlignment(int alignment)
	{
		if (this.alignment == alignment) return;
		this.alignment = alignment;
		repaint();
	} //}}}
	//{{{ isExpanded() method
	/**
	 * Identifies whether the gutter is collapsed or expanded.
	 * @return true if the gutter is expanded, false if it is collapsed
	 */
	public boolean isExpanded()
	{
		return expanded;
	} //}}}
	//{{{ setExpanded() method
	/**
	 * Sets whether the gutter is collapsed or expanded and force the text
	 * area to update its layout if there is a change.
	 * @param expanded true if the gutter is expanded,
	 *                   false if it is collapsed
	 */
	public void setExpanded(boolean expanded)
	{
		if (this.expanded == expanded) return;
		this.expanded = expanded;
		textArea.revalidate();
	} //}}}
	//{{{ toggleExpanded() method
	/**
	 * Toggles whether the gutter is collapsed or expanded.
	 */
	public void toggleExpanded()
	{
		setExpanded(!expanded);
	} //}}}
	//{{{ getHighlightInterval() method
	/**
	 * Sets the number of lines between highlighted line numbers.
	 * @return The number of lines between highlighted line numbers or
	 *          zero if highlighting is disabled
	 */
	public int getHighlightInterval()
	{
		return interval;
	} //}}}
	//{{{ setHighlightInterval() method
	/**
	 * Sets the number of lines between highlighted line numbers. Any value
	 * less than or equal to one will result in highlighting being disabled.
	 * @param interval The number of lines between highlighted line numbers
	 */
	public void setHighlightInterval(int interval)
	{
		if (interval <= 1) interval = 0;
		this.interval = interval;
		repaint();
	} //}}}
	//{{{ isCurrentLineHighlightEnabled() method
	public boolean isCurrentLineHighlightEnabled()
	{
		return currentLineHighlightEnabled;
	} //}}}
	//{{{ setCurrentLineHighlightEnabled() method
	public void setCurrentLineHighlightEnabled(boolean enabled)
	{
		if (currentLineHighlightEnabled == enabled) return;
		currentLineHighlightEnabled = enabled;
		repaint();
	} //}}}
	//{{{ getStructureHighlightColor() method
	/**
	 * Returns the structure highlight color.
	 * @since jEdit 4.2pre3
	 */
	public final Color getStructureHighlightColor()
	{
		return structureHighlightColor;
	} //}}}
	//{{{ setStructureHighlightColor() method
	/**
	 * Sets the structure highlight color.
	 * @param structureHighlightColor The structure highlight color
	 * @since jEdit 4.2pre3
	 */
	public final void setStructureHighlightColor(Color structureHighlightColor)
	{
		this.structureHighlightColor = structureHighlightColor;
		repaint();
	} //}}}
	//{{{ isStructureHighlightEnabled() method
	/**
	 * Returns true if structure highlighting is enabled, false otherwise.
	 * @since jEdit 4.2pre3
	 */
	public final boolean isStructureHighlightEnabled()
	{
		return structureHighlight;
	} //}}}
	//{{{ setStructureHighlightEnabled() method
	/**
	 * Enables or disables structure highlighting.
	 * @param structureHighlight True if structure highlighting should be
	 * enabled, false otherwise
	 * @since jEdit 4.2pre3
	 */
	public final void setStructureHighlightEnabled(boolean structureHighlight)
	{
		this.structureHighlight = structureHighlight;
		repaint();
	} //}}}
	//{{{ getMarkerHighlightColor() method
	public Color getMarkerHighlightColor()
	{
		return markerHighlightColor;
	} //}}}
	//{{{ setMarkerHighlightColor() method
	public void setMarkerHighlightColor(Color markerHighlightColor)
	{
		this.markerHighlightColor = markerHighlightColor;
	} //}}}
	//{{{ isMarkerHighlightEnabled() method
	public boolean isMarkerHighlightEnabled()
	{
		return markerHighlight;
	} //}}}
	//{{{ isMarkerHighlightEnabled()
	public void setMarkerHighlightEnabled(boolean markerHighlight)
	{
		this.markerHighlight = markerHighlight;
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private static final int FOLD_MARKER_SIZE = 12;
	private View view;
	private JEditTextArea textArea;
	private ExtensionManager extensionMgr;
	private int baseline;
	private Dimension gutterSize = new Dimension(0,0);
	private Dimension collapsedSize = new Dimension(0,0);
	private Color intervalHighlight;
	private Color currentLineHighlight;
	private Color foldColor;
	private FontMetrics fm;
	private int alignment;
	private int interval;
	private boolean currentLineHighlightEnabled;
	private boolean expanded;
	private boolean structureHighlight;
	private Color structureHighlightColor;
	private boolean markerHighlight;
	private Color markerHighlightColor;
	private int borderWidth;
	private Border focusBorder, noFocusBorder;
	//}}}
	//{{{ paintLine() method
	private void paintLine(Graphics2D gfx, int line, int y)
	{
		Buffer buffer = textArea.getBuffer();
		if(!buffer.isLoaded())
			return;
		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();
		ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(line);
		int physicalLine = info.physicalLine;
		// Skip lines beyond EOF
		if(physicalLine == -1)
			return;
		//{{{ Paint fold triangles
		if(info.firstSubregion && buffer.isFoldStart(physicalLine))
		{
			int _y = y + lineHeight / 2;
			gfx.setColor(foldColor);
			if(textArea.displayManager
				.isLineVisible(physicalLine + 1))
			{
				gfx.drawLine(1,_y - 3,10,_y - 3);
				gfx.drawLine(2,_y - 2,9,_y - 2);
				gfx.drawLine(3,_y - 1,8,_y - 1);
				gfx.drawLine(4,_y,7,_y);
				gfx.drawLine(5,_y + 1,6,_y + 1);
			}
			else
			{
				gfx.drawLine(4,_y - 5,4,_y + 4);
				gfx.drawLine(5,_y - 4,5,_y + 3);
				gfx.drawLine(6,_y - 3,6,_y + 2);
				gfx.drawLine(7,_y - 2,7,_y + 1);
				gfx.drawLine(8,_y - 1,8,_y);
			}
		}
		else if(info.lastSubregion && buffer.isFoldEnd(physicalLine))
		{
			gfx.setColor(foldColor);
			int _y = y + lineHeight / 2;
			gfx.drawLine(4,_y,4,_y + 3);
			gfx.drawLine(4,_y + 3,7,_y + 3);
		} //}}}
		//{{{ Paint bracket scope
		else if(structureHighlight)
		{
			StructureMatcher.Match match = textArea.getStructureMatch();
			int caretLine = textArea.getCaretLine();
			if(textArea.isStructureHighlightVisible()
				&& physicalLine >= Math.min(caretLine,match.startLine)
				&& physicalLine <= Math.max(caretLine,match.startLine))
			{
				int caretScreenLine;
				if(caretLine > textArea.getLastPhysicalLine())
					caretScreenLine = Integer.MAX_VALUE;
				else if(textArea.displayManager.isLineVisible(
						textArea.getCaretLine()))
				{
					caretScreenLine = textArea
						.getScreenLineOfOffset(
						textArea.getCaretPosition());
				}
				else
				{
					caretScreenLine = -1;
				}
				int structScreenLine;
				if(match.startLine > textArea.getLastPhysicalLine())
					structScreenLine = Integer.MAX_VALUE;
				else if(textArea.displayManager.isLineVisible(
						match.startLine))
				{
					structScreenLine = textArea
						.getScreenLineOfOffset(
						match.start);
				}
				else
				{
					structScreenLine = -1;
				}
				if(caretScreenLine > structScreenLine)
				{
					int tmp = caretScreenLine;
					caretScreenLine = structScreenLine;
					structScreenLine = tmp;
				}
				gfx.setColor(structureHighlightColor);
				if(structScreenLine == caretScreenLine)
				{
					// do nothing
				}
				// draw |^
				else if(line == caretScreenLine)
				{
					gfx.fillRect(5,
						y
						+ lineHeight / 2,
						5,
						2);
					gfx.fillRect(5,
						y
						+ lineHeight / 2,
						2,
						lineHeight - lineHeight / 2);
				}
				// draw |_
				else if(line == structScreenLine)
				{
					gfx.fillRect(5,
						y,
						2,
						lineHeight / 2);
					gfx.fillRect(5,
						y + lineHeight / 2,
						5,
						2);
				}
				// draw |
				else if(line > caretScreenLine
					&& line < structScreenLine)
				{
					gfx.fillRect(5,
						y,
						2,
						lineHeight);
				}
			}
		} //}}}
		//{{{ Paint line numbers
		if(info.firstSubregion && expanded)
		{
			String number = Integer.toString(physicalLine + 1);
			int offset;
			switch (alignment)
			{
			case RIGHT:
				offset = gutterSize.width - collapsedSize.width
					- (fm.stringWidth(number) + 1);
				break;
			case CENTER:
				offset = ((gutterSize.width - collapsedSize.width)
					- fm.stringWidth(number)) / 2;
				break;
			case LEFT: default:
				offset = 0;
				break;
			}
			boolean highlightCurrentLine = currentLineHighlightEnabled
				&& textArea.selection.size() == 0;
			if (physicalLine == textArea.getCaretLine() && highlightCurrentLine)
			{
				gfx.setColor(currentLineHighlight);
			}
			else if (interval > 1 && (line
				+ textArea.getFirstLine() + 1)
				% interval == 0)
				gfx.setColor(intervalHighlight);
			else
				gfx.setColor(getForeground());
			gfx.drawString(number, FOLD_MARKER_SIZE + offset,
				baseline + y);
		} //}}}
	} //}}}
	//}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseInputAdapter
	{
		MouseActions mouseActions = new MouseActions(""gutter"");
		boolean drag;
		int toolTipInitialDelay, toolTipReshowDelay;
		//{{{ mouseEntered() method
		public void mouseEntered(MouseEvent e)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			toolTipInitialDelay = ttm.getInitialDelay();
			toolTipReshowDelay = ttm.getReshowDelay();
			ttm.setInitialDelay(0);
			ttm.setReshowDelay(0);
		} //}}}
		//{{{ mouseExited() method
		public void mouseExited(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			ttm.setInitialDelay(toolTipInitialDelay);
			ttm.setReshowDelay(toolTipReshowDelay);
		} //}}}
		//{{{ mousePressed() method
		public void mousePressed(MouseEvent e)
		{
			textArea.requestFocus();
			if(GUIUtilities.isPopupTrigger(e)
				|| e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mousePressed(e);
				drag = true;
			}
			else
			{
				Buffer buffer = textArea.getBuffer();
				int screenLine = e.getY() / textArea.getPainter()
					.getFontMetrics().getHeight();
				int line = textArea.chunkCache.getLineInfo(screenLine)
					.physicalLine;
				if(line == -1)
					return;
				//{{{ Determine action
				String defaultAction;
				String variant;
				if(buffer.isFoldStart(line))
				{
					defaultAction = ""toggle-fold"";
					variant = ""fold"";
				}
				else if(structureHighlight
					&& textArea.isStructureHighlightVisible()
					&& textArea.lineInStructureScope(line))
				{
					defaultAction = ""match-struct"";
					variant = ""struct"";
				}
				else
					return;
				String action = mouseActions.getActionForEvent(
					e,variant);
				if(action == null)
					action = defaultAction;
				//}}}
				//{{{ Handle actions
				StructureMatcher.Match match = textArea
					.getStructureMatch();
				if(action.equals(""select-fold""))
				{
					textArea.displayManager.expandFold(line,true);
					textArea.selectFold(line);
				}
				else if(action.equals(""narrow-fold""))
				{
					int[] lines = buffer.getFoldAtLine(line);
					textArea.displayManager.narrow(lines[0],lines[1]);
				}
				else if(action.startsWith(""toggle-fold""))
				{
					if(textArea.displayManager
						.isLineVisible(line + 1))
					{
						textArea.displayManager.collapseFold(line);
					}
					else
					{
						if(action.endsWith(""-fully""))
						{
							textArea.displayManager
								.expandFold(line,
								true);
						}
						else
						{
							textArea.displayManager
								.expandFold(line,
								false);
						}
					}
				}
				else if(action.equals(""match-struct""))
				{
					if(match != null)
						textArea.setCaretPosition(match.end);
				}
				else if(action.equals(""select-struct""))
				{
					if(match != null)
					{
						match.matcher.selectMatch(
							textArea);
					}
				}
				else if(action.equals(""narrow-struct""))
				{
					if(match != null)
					{
						int start = Math.min(
							match.startLine,
							textArea.getCaretLine());
						int end = Math.max(
							match.endLine,
							textArea.getCaretLine());
						textArea.displayManager.narrow(start,end);
					}
				} //}}}
			}
		} //}}}
		//{{{ mouseDragged() method
		public void mouseDragged(MouseEvent e)
		{
			if(drag /* && e.getX() >= getWidth() - borderWidth * 2 */)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseDragged(e);
			}
		} //}}}
		//{{{ mouseReleased() method
		public void mouseReleased(MouseEvent e)
		{
			if(drag && e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseReleased(e);
			}
			drag = false;
		} //}}}
	} //}}}
	//{{{ MarkerHighlight class
	class MarkerHighlight extends TextAreaExtension
	{
		//{{{ paintValidLine() method
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				Buffer buffer = textArea.getBuffer();
				if(buffer.getMarkerInRange(start,end) != null)
				{
					gfx.setColor(getMarkerHighlightColor());
					FontMetrics fm = textArea.getPainter().getFontMetrics();
					gfx.fillRect(0,y,textArea.getGutter()
						.getWidth(),fm.getHeight());
				}
			}
		} //}}}
		//{{{ getToolTipText() method
		public String getToolTipText(int x, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				int lineHeight = textArea.getPainter().getFontMetrics().getHeight();
				if(lineHeight == 0)
					return null;
				int line = y / lineHeight;
				int start = textArea.getScreenLineStartOffset(line);
				int end = textArea.getScreenLineEndOffset(line);
				if(start == -1 || end == -1)
					return null;
				Marker marker = textArea.getBuffer().getMarkerInRange(start,end);
				if(marker != null)
				{
					char shortcut = marker.getShortcut();
					if(shortcut == '\0')
						return jEdit.getProperty(""view.gutter.marker.no-name"");
					else
					{
						String[] args = { String.valueOf(shortcut) };
						return jEdit.getProperty(""view.gutter.marker"",args);
					}
				}
			}
			return null;
		} //}}}
	} //}}}
}
"
org.gjt.sp.jedit.textarea.JEditTextArea,"/*
 * JEditTextArea.java - jEdit's text component
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2004 Slava Pestov
 * Portions copyright (C) 2000 Ollie Rutherfurd
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import java.awt.*;
import java.awt.event.*;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.Vector;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.util.Log;
//}}}
/**
 * jEdit's text component.<p>
 *
 * Unlike most other text editors, the selection API permits selection and
 * concurrent manipulation of multiple, non-contiguous regions of text.
 * Methods in this class that deal with selecting text rely upon classes derived
 * the {@link Selection} class.
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: JEditTextArea.java,v 1.320 2004/08/12 22:42:45 spestov Exp $
 */
public class JEditTextArea extends JComponent
{
	//{{{ JEditTextArea constructor
	/**
	 * Creates a new JEditTextArea.
	 */
	public JEditTextArea(View view)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);
		this.view = view;
		//{{{ Initialize some misc. stuff
		selection = new Vector();
		chunkCache = new ChunkCache(this);
		painter = new TextAreaPainter(this);
		gutter = new Gutter(view,this);
		listenerList = new EventListenerList();
		caretEvent = new MutableCaretEvent();
		blink = true;
		lineSegment = new Segment();
		returnValue = new Point();
		structureMatchers = new LinkedList();
		structureMatchers.add(new StructureMatcher.BracketMatcher());
		//}}}
		//{{{ Initialize the GUI
		setLayout(new ScrollLayout());
		add(CENTER,painter);
		add(LEFT,gutter);
		// some plugins add stuff in a ""right-hand"" gutter
		verticalBox = new Box(BoxLayout.X_AXIS);
		verticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));
		vertical.setRequestFocusEnabled(false);
		add(RIGHT,verticalBox);
		add(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));
		horizontal.setRequestFocusEnabled(false);
		horizontal.setValues(0,0,0,0);
		//}}}
		//{{{ this ensures that the text area's look is slightly
		// more consistent with the rest of the metal l&f.
		// while it depends on not-so-well-documented portions
		// of Swing, it only affects appearance, so future
		// breakage shouldn't matter
		if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
		{
			setBorder(new TextAreaBorder());
			vertical.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			horizontal.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			//horizontal.setBorder(null);
		}
		//}}}
		//{{{ Add some event listeners
		vertical.addAdjustmentListener(new AdjustHandler());
		horizontal.addAdjustmentListener(new AdjustHandler());
		mouseHandler = new MouseHandler();
		painter.addMouseListener(mouseHandler);
		painter.addMouseMotionListener(mouseHandler);
		addFocusListener(new FocusHandler());
		//}}}
		// This doesn't seem very correct, but it fixes a problem
		// when setting the initial caret position for a buffer
		// (eg, from the recent file list)
		focusedComponent = this;
		popupEnabled = true;
	} //}}}
	//{{{ dispose() method
	/**
	 * Plugins and macros should not call this method.
	 * @since jEdit 4.2pre1
	 */
	public void dispose()
	{
		DisplayManager.textAreaDisposed(this);
	} //}}}
	//{{{ Getters and setters
	//{{{ getView() method
	/**
	 * Returns this text area's view.
	 * @since jEdit 4.2pre5
	 */
	public View getView()
	{
		return view;
	} //}}}
	//{{{ getPainter() method
	/**
	 * Returns the object responsible for painting this text area.
	 */
	public final TextAreaPainter getPainter()
	{
		return painter;
	} //}}}
	//{{{ getGutter() method
 	/**
	 * Returns the gutter to the left of the text area or null if the gutter
	 * is disabled
	 */
	public final Gutter getGutter()
	{
		return gutter;
	} //}}}
	//{{{ getDisplayManager() method
	/**
	 * Returns the display manager used by this text area.
	 * @since jEdit 4.2pre1
	 */
	public DisplayManager getDisplayManager()
	{
		return displayManager;
	} //}}}
	//{{{ isCaretBlinkEnabled() method
	/**
	 * Returns true if the caret is blinking, false otherwise.
	 */
	public final boolean isCaretBlinkEnabled()
	{
		return caretBlinks;
	} //}}}
	//{{{ setCaretBlinkEnabled() method
	/**
	 * Toggles caret blinking.
	 * @param caretBlinks True if the caret should blink, false otherwise
	 */
	public void setCaretBlinkEnabled(boolean caretBlinks)
	{
		this.caretBlinks = caretBlinks;
		if(!caretBlinks)
			blink = false;
		if(buffer != null)
			invalidateLine(caretLine);
	} //}}}
	//{{{ getElectricScroll() method
	/**
	 * Returns the number of lines from the top and button of the
	 * text area that are always visible.
	 */
	public final int getElectricScroll()
	{
		return electricScroll;
	} //}}}
	//{{{ setElectricScroll() method
	/**
	 * Sets the number of lines from the top and bottom of the text
	 * area that are always visible
	 * @param electricScroll The number of lines always visible from
	 * the top or bottom
	 */
	public final void setElectricScroll(int electricScroll)
	{
		this.electricScroll = electricScroll;
	} //}}}
	//{{{ isQuickCopyEnabled() method
	/**
	 * Returns if clicking the middle mouse button pastes the most
	 * recent selection (% register), and if Control-dragging inserts
	 * the selection at the caret.
	 */
	public final boolean isQuickCopyEnabled()
	{
		return quickCopy;
	} //}}}
	//{{{ setQuickCopyEnabled() method
	/**
	 * Sets if clicking the middle mouse button pastes the most
	 * recent selection (% register), and if Control-dragging inserts
	 * the selection at the caret.
	 * @param quickCopy A boolean flag
	 */
	public final void setQuickCopyEnabled(boolean quickCopy)
	{
		this.quickCopy = quickCopy;
	} //}}}
	//{{{ getBuffer() method
	/**
	 * Returns the buffer this text area is editing.
	 */
	public final Buffer getBuffer()
	{
		return buffer;
	} //}}}
	//{{{ setBuffer() method
	/**
	 * Sets the buffer this text area is editing. Do not call this method -
	 * use {@link org.gjt.sp.jedit.EditPane#setBuffer(Buffer)} instead.
	 * @param buffer The buffer
	 */
	public void setBuffer(Buffer buffer)
	{
		if(this.buffer == buffer)
			return;
		try
		{
			bufferChanging = true;
			if(this.buffer != null)
			{
				// dubious?
				//setFirstLine(0);
				selectNone();
				caretLine = caret = caretScreenLine = 0;
				match = null;
			}
			this.buffer = buffer;
			chunkCache.setBuffer(buffer);
			propertiesChanged();
			if(displayManager != null)
			{
				DisplayManager.releaseDisplayManager(
					displayManager);
			}
			displayManager = DisplayManager.getDisplayManager(
				buffer,this);
			displayManager.init();
			if(!buffer.isLoaded())
				updateScrollBars();
			repaint();
			fireScrollEvent(true);
		}
		finally
		{
			bufferChanging = false;
		}
	} //}}}
	//{{{ isEditable() method
	/**
	 * Returns true if this text area is editable, false otherwise.
	 */
	public final boolean isEditable()
	{
		return buffer.isEditable();
	} //}}}
	//{{{ getDragAndDropCallback() method
	/**
	 * Drag and drop of text in jEdit is implementing using jEdit 1.4 APIs,
	 * however since jEdit must run with Java 1.3, this class only has the
	 * necessary support to call a hook method via reflection. The method
	 * is provided by the {@link org.gjt.sp.jedit.Java14} class and handles
	 * the drag and drop API calls themselves.
	 * @since jEdit 4.2pre5
	 */
	public Method getDragAndDropCallback()
	{
		return dndCallback;
	} //}}}
	//{{{ setDragAndDropCallback() method
	/**
	 * Drag and drop of text in jEdit is implementing using jEdit 1.4 APIs,
	 * however since jEdit must run with Java 1.3, this class only has the
	 * necessary support to call a hook method via reflection. The method
	 * is provided by the {@link org.gjt.sp.jedit.Java14} class and handles
	 * the drag and drop API calls themselves.
	 * @since jEdit 4.2pre5
	 */
	public void setDragAndDropCallback(Method meth)
	{
		dndCallback = meth;
	} //}}}
	//{{{ isDragInProgress() method
	/**
	 * Drag and drop of text in jEdit is implementing using jEdit 1.4 APIs,
	 * however since jEdit must run with Java 1.3, this class only has the
	 * necessary support to call a hook method via reflection. This method
	 * is called by the {@link org.gjt.sp.jedit.Java14} class to signal that
	 * a drag is in progress.
	 * @since jEdit 4.2pre5
	 */
	public boolean isDragInProgress()
	{
		return dndInProgress;
	} //}}}
	//{{{ setDragInProgress() method
	/**
	 * Drag and drop of text in jEdit is implementing using jEdit 1.4 APIs,
	 * however since jEdit must run with Java 1.3, this class only has the
	 * necessary support to call a hook method via reflection. This method
	 * is called by the {@link org.gjt.sp.jedit.Java14} class to signal that
	 * a drag is in progress.
	 * @since jEdit 4.2pre5
	 */
	public void setDragInProgress(boolean dndInProgress)
	{
		this.dndInProgress = dndInProgress;
	} //}}}
	//{{{ isDragEnabled() method
	/**
	 * Returns if drag and drop of text is enabled.
	 * @since jEdit 4.2pre5
	 */
	public boolean isDragEnabled()
	{
		return dndEnabled;
	} //}}}
	//{{{ setDragEnabled() method
	/**
	 * Sets if drag and drop of text is enabled.
	 * @since jEdit 4.2pre5
	 */
	public void setDragEnabled(boolean dndEnabled)
	{
		this.dndEnabled = dndEnabled;
	} //}}}
	//}}}
	//{{{ Scrolling
	//{{{ Debugging code
	/* public void scrollTest(boolean paint)
	{
		Image im = painter.createImage(painter.getWidth(),painter.getHeight());
		Graphics gfx = im.getGraphics();
		gfx.setFont(painter.getFont());
		gfx.setColor(painter.getForeground());
		gfx.clipRect(0,0,painter.getWidth(),painter.getHeight());
		long start = System.currentTimeMillis();
		for(int i = 0; i < displayManager.getScrollLineCount(); i++)
		{
			setFirstLine(i);
			if(!paint)
				chunkCache.getLineInfo(visibleLines - 1);
			else
				painter.paintComponent(gfx);
		}
		System.err.println(System.currentTimeMillis() - start);
	} */ //}}}
	//{{{ getFirstLine() method
	/**
	 * Returns the vertical scroll bar position.
	 * @since jEdit 4.2pre1
	 */
	public final int getFirstLine()
	{
		return displayManager.firstLine.scrollLine
			+ displayManager.firstLine.skew;
	} //}}}
	//{{{ setFirstLine() method
	public Exception trace;
	/**
	 * Sets the vertical scroll bar position
	 *
	 * @param firstLine The scroll bar position
	 */
	public void setFirstLine(int firstLine)
	{
		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""setFirstLine() from ""
				+ getFirstLine() + "" to "" + firstLine);
		}
		//{{{ ensure we don't have empty space at the bottom or top, etc
		int max = displayManager.getScrollLineCount() - visibleLines
			+ (lastLinePartial ? 1 : 0);
		if(firstLine > max)
			firstLine = max;
		if(firstLine < 0)
			firstLine = 0;
		//}}}
		int oldFirstLine = getFirstLine();
		if(firstLine == oldFirstLine)
			return;
		trace = new Exception();
		if(firstLine >= oldFirstLine + visibleLines)
		{
			displayManager.firstLine.scrollDown(firstLine - oldFirstLine);
			chunkCache.invalidateAll();
		}
		else if(firstLine <= oldFirstLine - visibleLines)
		{
			displayManager.firstLine.scrollUp(oldFirstLine - firstLine);
			chunkCache.invalidateAll();
		}
		else if(firstLine > oldFirstLine)
		{
			displayManager.firstLine.scrollDown(firstLine - oldFirstLine);
			chunkCache.scrollDown(firstLine - oldFirstLine);
		}
		else if(firstLine < oldFirstLine)
		{
			displayManager.firstLine.scrollUp(oldFirstLine - firstLine);
			chunkCache.scrollUp(oldFirstLine - firstLine);
		}
		// we have to be careful
		displayManager._notifyScreenLineChanges();
		//if(buffer.isLoaded())
		//	recalculateLastPhysicalLine();
		repaint();
		fireScrollEvent(true);
	} //}}}
	//{{{ getFirstPhysicalLine() method
	/**
	 * Returns the first visible physical line index.
	 * @since jEdit 4.0pre4
	 */
	public final int getFirstPhysicalLine()
	{
		return displayManager.firstLine.physicalLine;
	} //}}}
	//{{{ setFirstPhysicalLine() method
	/**
	 * Sets the vertical scroll bar position.
	 * @param physFirstLine The first physical line to display
	 * @since jEdit 4.2pre1
	 */
	public void setFirstPhysicalLine(int physFirstLine)
	{
		setFirstPhysicalLine(physFirstLine,0);
	} //}}}
	//{{{ setFirstPhysicalLine() method
	/**
	 * Sets the vertical scroll bar position.
	 * @param physFirstLine The first physical line to display
	 * @param skew A local screen line delta
	 * @since jEdit 4.2pre1
	 */
	public void setFirstPhysicalLine(int physFirstLine, int skew)
	{
		if(Debug.SCROLL_DEBUG)
		{
			Log.log(Log.DEBUG,this,""setFirstPhysicalLine(""
				+ physFirstLine + "","" + skew + "")"");
		}
		//{{{ ensure we don't have empty space at the bottom or top, etc
		/* int screenLineCount = 0;
		int physicalLine = displayManager.getLastVisibleLine();
		int visibleLines = this.visibleLines - (lastLinePartial ? 1 : 0);
		for(;;)
		{
			screenLineCount += displayManager.getScreenLineCount(physicalLine);
			if(screenLineCount >= visibleLines)
				break;
			int prevLine = displayManager.getPrevVisibleLine(physicalLine);
			if(prevLine == -1)
				break;
			physicalLine = prevLine;
		}
		if(physFirstLine > physicalLine)
			physFirstLine = physicalLine; */
		//}}}
		int amount = (physFirstLine - displayManager.firstLine.physicalLine);
		int oldFirstLine = getFirstLine();
		if(amount == 0)
		{
			skew -= displayManager.firstLine.skew;
			// JEditTextArea.scrollTo() needs this to simplify
			// its code
			if(skew < 0)
				displayManager.firstLine.scrollUp(-skew);
			else if(skew > 0)
				displayManager.firstLine.scrollDown(skew);
			else
			{
				// nothing to do
				return;
			}
		}
		else if(amount > 0)
			displayManager.firstLine.physDown(amount,skew);
		else if(amount < 0)
			displayManager.firstLine.physUp(-amount,skew);
		int firstLine = getFirstLine();
		if(firstLine == oldFirstLine)
			/* do nothing */;
		else if(firstLine >= oldFirstLine + visibleLines
			|| firstLine <= oldFirstLine - visibleLines)
		{
			chunkCache.invalidateAll();
		}
		else if(firstLine > oldFirstLine)
		{
			chunkCache.scrollDown(firstLine - oldFirstLine);
		}
		else if(firstLine < oldFirstLine)
		{
			chunkCache.scrollUp(oldFirstLine - firstLine);
		}
		// we have to be careful
		displayManager._notifyScreenLineChanges();
		//if(buffer.isLoaded())
		//	recalculateLastPhysicalLine();
		repaint();
		fireScrollEvent(true);
	} //}}}
	//{{{ getLastPhysicalLine() method
	/**
	 * Returns the last visible physical line index.
	 * @since jEdit 4.0pre4
	 */
	public final int getLastPhysicalLine()
	{
		return physLastLine;
	} //}}}
	//{{{ getVisibleLines() method
	/**
	 * Returns the number of lines visible in this text area.
	 */
	public final int getVisibleLines()
	{
		return visibleLines;
	} //}}}
	//{{{ getHorizontalOffset() method
	/**
	 * Returns the horizontal offset of drawn lines.
	 */
	public final int getHorizontalOffset()
	{
		return horizontalOffset;
	} //}}}
	//{{{ setHorizontalOffset() method
	/**
	 * Sets the horizontal offset of drawn lines. This can be used to
	 * implement horizontal scrolling.
	 * @param horizontalOffset offset The new horizontal offset
	 */
	public void setHorizontalOffset(int horizontalOffset)
	{
		if(horizontalOffset > 0)
			horizontalOffset = 0;
		if(horizontalOffset == this.horizontalOffset)
			return;
		this.horizontalOffset = horizontalOffset;
		if(horizontalOffset != horizontal.getValue())
			updateScrollBars();
		painter.repaint();
		fireScrollEvent(false);
	} //}}}
	//{{{ scrollUpLine() method
	/**
	 * Scrolls up by one line.
	 * @since jEdit 2.7pre2
	 */
	public void scrollUpLine()
	{
		setFirstLine(getFirstLine() - 1);
	} //}}}
	//{{{ scrollUpPage() method
	/**
	 * Scrolls up by one page.
	 * @since jEdit 2.7pre2
	 */
	public void scrollUpPage()
	{
		setFirstLine(getFirstLine() - getVisibleLines()
			+ (lastLinePartial ? 1 : 0));
	} //}}}
	//{{{ scrollDownLine() method
	/**
	 * Scrolls down by one line.
	 * @since jEdit 2.7pre2
	 */
	public void scrollDownLine()
	{
		setFirstLine(getFirstLine() + 1);
	} //}}}
	//{{{ scrollDownPage() method
	/**
	 * Scrolls down by one page.
	 * @since jEdit 2.7pre2
	 */
	public void scrollDownPage()
	{
		setFirstLine(getFirstLine() + getVisibleLines()
			- (lastLinePartial ? 1 : 0));
	} //}}}
	//{{{ scrollToCaret() method
	/**
	 * Ensures that the caret is visible by scrolling the text area if
	 * necessary.
	 * @param doElectricScroll If true, electric scrolling will be performed
	 */
	public void scrollToCaret(boolean doElectricScroll)
	{
		scrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),
			doElectricScroll);
	} //}}}
	//{{{ scrollTo() method
	/**
	 * Ensures that the specified location in the buffer is visible.
	 * @param offset The offset from the start of the buffer
	 * @param doElectricScroll If true, electric scrolling will be performed
	 * @since jEdit 4.2pre3
	 */
	public void scrollTo(int offset, boolean doElectricScroll)
	{
		int line = buffer.getLineOfOffset(offset);
		scrollTo(line,offset - buffer.getLineStartOffset(line),
			doElectricScroll);
	} //}}}
	//{{{ scrollTo() method
	/**
	 * Ensures that the specified location in the buffer is visible.
	 * @param line The line number
	 * @param offset The offset from the start of the line
	 * @param doElectricScroll If true, electric scrolling will be performed
	 * @since jEdit 4.0pre6
	 */
	public void scrollTo(int line, int offset, boolean doElectricScroll)
	{
		if(Debug.SCROLL_TO_DEBUG)
			Log.log(Log.DEBUG,this,""scrollTo(), lineCount=""
				+ getLineCount());
		//{{{ Get ready
		int extraEndVirt;
		int lineLength = buffer.getLineLength(line);
		if(offset > lineLength)
		{
			extraEndVirt = charWidth * (offset - lineLength);
			offset = lineLength;
		}
		else
			extraEndVirt = 0;
		int _electricScroll = (doElectricScroll
			&& visibleLines - 1 > electricScroll * 2
			? electricScroll : 0); //}}}
		if(visibleLines <= 1)
		{
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""visibleLines <= 0"");
			setFirstPhysicalLine(line,_electricScroll);
			return;
		}
		//{{{ Scroll vertically
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		int visibleLines = getVisibleLines();
		if(screenLine == -1)
		{
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""screenLine == -1"");
			ChunkCache.LineInfo[] infos = chunkCache
				.getLineInfosForPhysicalLine(line);
			int subregion = chunkCache.getSubregionOfOffset(
				offset,infos);
			int prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());
			int nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());
			if(line == getFirstPhysicalLine())
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + getFirstPhysicalLine());
				setFirstPhysicalLine(line,subregion
					- _electricScroll);
			}
			else if(line == prevLine)
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + prevLine);
				setFirstPhysicalLine(prevLine,subregion
					- _electricScroll);
			}
			else if(line == getLastPhysicalLine())
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + getLastPhysicalLine());
				setFirstPhysicalLine(line,
					subregion + _electricScroll
					- visibleLines
					+ (lastLinePartial ? 2 : 1));
			}
			else if(line == nextLine)
			{
				if(Debug.SCROLL_TO_DEBUG)
					Log.log(Log.DEBUG,this,line + "" == "" + nextLine);
				setFirstPhysicalLine(nextLine,
					subregion + electricScroll
					- visibleLines
					+ (lastLinePartial ? 2 : 1));
			}
			else
			{
				if(Debug.SCROLL_TO_DEBUG)
				{
					Log.log(Log.DEBUG,this,""neither"");
					Log.log(Log.DEBUG,this,""Last physical line is "" + getLastPhysicalLine());
				}
				setFirstPhysicalLine(line,subregion
					- visibleLines / 2);
				if(Debug.SCROLL_TO_DEBUG)
				{
					Log.log(Log.DEBUG,this,""Last physical line is "" + getLastPhysicalLine());
				}
			}
		}
		else if(screenLine < _electricScroll)
		{
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""electric up"");
			setFirstLine(getFirstLine() - _electricScroll + screenLine);
		}
		else if(screenLine > visibleLines - _electricScroll
			- (lastLinePartial ? 2 : 1))
		{
			if(Debug.SCROLL_TO_DEBUG)
				Log.log(Log.DEBUG,this,""electric down"");
			setFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));
		} //}}}
		//{{{ Scroll horizontally
		if(!displayManager.isLineVisible(line))
			return;
		Point point = offsetToXY(line,offset,returnValue);
		if(point == null)
		{
			Log.log(Log.ERROR,this,""BUG: screenLine="" + screenLine
				+ "",visibleLines="" + visibleLines
				+ "",physicalLine="" + line
				+ "",firstPhysicalLine="" + getFirstPhysicalLine()
				+ "",lastPhysicalLine="" + getLastPhysicalLine());
		}
		point.x += extraEndVirt;
		if(point.x < 0)
		{
			setHorizontalOffset(horizontalOffset
				- point.x + charWidth + 5);
		}
		else if(point.x >= painter.getWidth() - charWidth - 5)
		{
			setHorizontalOffset(horizontalOffset +
				(painter.getWidth() - point.x)
				- charWidth - 5);
		} //}}}
	} //}}}
	//{{{ addScrollListener() method
	/**
	 * Adds a scroll listener to this text area.
	 * @param listener The listener
	 * @since jEdit 3.2pre2
	 */
	public final void addScrollListener(ScrollListener listener)
	{
		listenerList.add(ScrollListener.class,listener);
	} //}}}
	//{{{ removeScrollListener() method
	/**
	 * Removes a scroll listener from this text area.
	 * @param listener The listener
	 * @since jEdit 3.2pre2
	 */
	public final void removeScrollListener(ScrollListener listener)
	{
		listenerList.remove(ScrollListener.class,listener);
	} //}}}
	//}}}
	//{{{ Screen line stuff
	//{{{ getPhysicalLineOfScreenLine() method
	/**
	 * Returns the physical line number that contains the specified screen
	 * line.
	 * @param screenLine The screen line
	 * @since jEdit 4.0pre6
	 */
	public int getPhysicalLineOfScreenLine(int screenLine)
	{
		return chunkCache.getLineInfo(screenLine).physicalLine;
	} //}}}
	//{{{ getScreenLineOfOffset() method
	/**
	 * Returns the screen (wrapped) line containing the specified offset.
	 * Returns -1 if the line is not currently visible on the screen.
	 * @param offset The offset
	 * @since jEdit 4.0pre4
	 */
	public int getScreenLineOfOffset(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		return chunkCache.getScreenLineOfOffset(line,offset);
	} //}}}
	//{{{ getScreenLineStartOffset() method
	/**
	 * Returns the start offset of the specified screen (wrapped) line.
	 * @param line The line
	 * @since jEdit 4.0pre4
	 */
	public int getScreenLineStartOffset(int line)
	{
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;
		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset;
	} //}}}
	//{{{ getScreenLineEndOffset() method
	/**
	 * Returns the end offset of the specified screen (wrapped) line.
	 * @param line The line
	 * @since jEdit 4.0pre4
	 */
	public int getScreenLineEndOffset(int line)
	{
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;
		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset + lineInfo.length;
	} //}}}
	//}}}
	//{{{ Offset conversion
	//{{{ xyToOffset() method
	/**
	 * Converts a point to an offset.
	 * Note that unlike in previous jEdit versions, this method now returns
	 * -1 if the y co-ordinate is out of bounds.
	 *
	 * @param x The x co-ordinate of the point
	 * @param y The y co-ordinate of the point
	 */
	public int xyToOffset(int x, int y)
	{
		return xyToOffset(x,y,true);
	} //}}}
	//{{{ xyToOffset() method
	/**
	 * Converts a point to an offset.
	 * Note that unlike in previous jEdit versions, this method now returns
	 * -1 if the y co-ordinate is out of bounds.
	 *
	 * @param x The x co-ordinate of the point
	 * @param y The y co-ordinate of the point
	 * @param round Round up to next letter if past the middle of a letter?
	 * @since jEdit 3.2pre6
	 */
	public int xyToOffset(int x, int y, boolean round)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		int line = y / height;
		if(line < 0 || line >= visibleLines)
			return -1;
		return xToScreenLineOffset(line,x,round);
	} //}}}
	//{{{ xToScreenLineOffset() method
	/**
	 * Converts a point in a given screen line to an offset.
	 * Note that unlike in previous jEdit versions, this method now returns
	 * -1 if the y co-ordinate is out of bounds.
	 *
	 * @param x The x co-ordinate of the point
	 * @param screenLine The screen line
	 * @param round Round up to next letter if past the middle of a letter?
	 * @since jEdit 3.2pre6
	 */
	public int xToScreenLineOffset(int screenLine, int x, boolean round)
	{
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);
		if(lineInfo.physicalLine == -1)
		{
			return getLineEndOffset(displayManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			int offset = Chunk.xToOffset(lineInfo.chunks,
				x - horizontalOffset,round);
			if(offset == -1 || offset == lineInfo.offset + lineInfo.length)
				offset = lineInfo.offset + lineInfo.length - 1;
			return getLineStartOffset(lineInfo.physicalLine) + offset;
		}
	} //}}}
	//{{{ offsetToXY() method
	/**
	 * Converts an offset into a point in the text area painter's
	 * co-ordinate space.
	 * @param offset The offset
	 * @return The location of the offset on screen, or <code>null</code>
	 * if the specified offset is not visible
	 */
	public Point offsetToXY(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		Point retVal = new Point();
		return offsetToXY(line,offset,retVal);
	} //}}}
	//{{{ offsetToXY() method
	/**
	 * Converts an offset into a point in the text area painter's
	 * co-ordinate space.
	 * @param line The physical line number
	 * @param offset The offset, from the start of the line
	 * @param retVal The point to store the return value in
	 * @return <code>retVal</code> for convenience, or <code>null</code>
	 * if the specified offset is not visible
	 * @since jEdit 4.0pre4
	 */
	public Point offsetToXY(int line, int offset, Point retVal)
	{
		if(!displayManager.isLineVisible(line))
			return null;
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		if(screenLine == -1)
			return null;
		FontMetrics fm = painter.getFontMetrics();
		retVal.y = screenLine * fm.getHeight();
		ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);
		retVal.x = (int)(horizontalOffset + Chunk.offsetToX(
			info.chunks,offset));
		return retVal;
	} //}}}
	//}}}
	//{{{ Painting
	//{{{ invalidateScreenLineRange() method
	/**
	 * Marks a range of screen lines as needing a repaint.
	 * @param start The first line
	 * @param end The last line
	 * @since jEdit 4.0pre4
	 */
	public void invalidateScreenLineRange(int start, int end)
	{
		if(!buffer.isLoaded())
			return;
		//if(start != end)
		//	System.err.println(start + "":"" + end + "":"" + chunkCache.needFullRepaint());
		if(start > end)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}
		if(chunkCache.needFullRepaint())
			end = visibleLines;
		FontMetrics fm = painter.getFontMetrics();
		int y = start * fm.getHeight();
		int height = (end - start + 1) * fm.getHeight();
		painter.repaint(0,y,painter.getWidth(),height);
		gutter.repaint(0,y,gutter.getWidth(),height);
	} //}}}
	//{{{ invalidateLine() method
	/**
	 * Marks a line as needing a repaint.
	 * @param line The physical line to invalidate
	 */
	public void invalidateLine(int line)
	{
		if(!isShowing()
			|| !buffer.isLoaded()
			|| line < getFirstPhysicalLine()
			|| line > physLastLine
			|| !displayManager.isLineVisible(line))
			return;
		int startLine = -1;
		int endLine = -1;
		for(int i = 0; i < visibleLines; i++)
		{
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if((info.physicalLine >= line || info.physicalLine == -1)
				&& startLine == -1)
			{
				startLine = i;
			}
			if((info.physicalLine >= line && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endLine = i;
				break;
			}
		}
		if(chunkCache.needFullRepaint() || endLine == -1)
			endLine = visibleLines;
		//if(startLine != endLine)
		//	System.err.println(startLine + "":"" + endLine);
		invalidateScreenLineRange(startLine,endLine);
	} //}}}
	//{{{ invalidateLineRange() method
	/**
	 * Marks a range of physical lines as needing a repaint.
	 * @param start The first line to invalidate
	 * @param end The last line to invalidate
	 */
	public void invalidateLineRange(int start, int end)
	{
		if(!isShowing() || !buffer.isLoaded())
			return;
		if(end < start)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}
		if(end < getFirstPhysicalLine() || start > getLastPhysicalLine())
			return;
		int startScreenLine = -1;
		int endScreenLine = -1;
		for(int i = 0; i < visibleLines; i++)
		{
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if((info.physicalLine >= start || info.physicalLine == -1)
				&& startScreenLine == -1)
			{
				startScreenLine = i;
			}
			if((info.physicalLine >= end && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endScreenLine = i;
				break;
			}
		}
		if(startScreenLine == -1)
			startScreenLine = 0;
		if(chunkCache.needFullRepaint() || endScreenLine == -1)
			endScreenLine = visibleLines;
		invalidateScreenLineRange(startScreenLine,endScreenLine);
	} //}}}
	//{{{ invalidateSelectedLines() method
	/**
	 * Repaints the lines containing the selection.
	 */
	public void invalidateSelectedLines()
	{
		// to hide line highlight if selections are being added later on
		invalidateLine(caretLine);
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			invalidateLineRange(s.startLine,s.endLine);
		}
	} //}}}
	//}}}
	//{{{ Convenience methods
	//{{{ getBufferLength() method
	/**
	 * Returns the length of the buffer.
	 */
	public final int getBufferLength()
	{
		return buffer.getLength();
	} //}}}
	//{{{ getLineCount() method
	/**
	 * Returns the number of physical lines in the buffer.
	 */
	public final int getLineCount()
	{
		return buffer.getLineCount();
	} //}}}
	//{{{ getLineOfOffset() method
	/**
	 * Returns the line containing the specified offset.
	 * @param offset The offset
	 */
	public final int getLineOfOffset(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} //}}}
	//{{{ getLineStartOffset() method
	/**
	 * Returns the start offset of the specified line.
	 * @param line The line
	 * @return The start offset of the specified line, or -1 if the line is
	 * invalid
	 */
	public int getLineStartOffset(int line)
	{
		return buffer.getLineStartOffset(line);
	} //}}}
	//{{{ getLineEndOffset() method
	/**
	 * Returns the end offset of the specified line.
	 * @param line The line
	 * @return The end offset of the specified line, or -1 if the line is
	 * invalid.
	 */
	public int getLineEndOffset(int line)
	{
		return buffer.getLineEndOffset(line);
	} //}}}
	//{{{ getLineLength() method
	/**
	 * Returns the length of the specified line.
	 * @param line The line
	 */
	public int getLineLength(int line)
	{
		return buffer.getLineLength(line);
	} //}}}
	//{{{ getText() method
	/**
	 * Returns the specified substring of the buffer.
	 * @param start The start offset
	 * @param len The length of the substring
	 * @return The substring
	 */
	public final String getText(int start, int len)
	{
		return buffer.getText(start,len);
	} //}}}
	//{{{ getText() method
	/**
	 * Copies the specified substring of the buffer into a segment.
	 * @param start The start offset
	 * @param len The length of the substring
	 * @param segment The segment
	 */
	public final void getText(int start, int len, Segment segment)
	{
		buffer.getText(start,len,segment);
	} //}}}
	//{{{ getLineText() method
	/**
	 * Returns the text on the specified line.
	 * @param lineIndex The line
	 * @return The text, or null if the line is invalid
	 */
	public final String getLineText(int lineIndex)
	{
		return buffer.getLineText(lineIndex);
	} //}}}
	//{{{ getLineText() method
	/**
	 * Copies the text on the specified line into a segment. If the line
	 * is invalid, the segment will contain a null string.
	 * @param lineIndex The line
	 */
	public final void getLineText(int lineIndex, Segment segment)
	{
		buffer.getLineText(lineIndex,segment);
	} //}}}
	//{{{ getText() method
	/**
	 * Returns the entire text of this text area.
	 */
	public String getText()
	{
		return buffer.getText(0,buffer.getLength());
	} //}}}
	//{{{ setText() method
	/**
	 * Sets the entire text of this text area.
	 */
	public void setText(String text)
	{
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(0,buffer.getLength());
			buffer.insert(0,text);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} //}}}
	//}}}
	//{{{ Selection
	//{{{ selectAll() method
	/**
	 * Selects all text in the buffer.
	 */
	public final void selectAll()
	{
		setSelection(new Selection.Range(0,buffer.getLength()));
		moveCaretPosition(buffer.getLength(),true);
	} //}}}
	//{{{ selectLine() method
	/**
	 * Selects the current line.
	 * @since jEdit 2.7pre2
	 */
	public void selectLine()
	{
		int caretLine = getCaretLine();
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine) - 1;
		Selection s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} //}}}
	//{{{ selectParagraph() method
	/**
	 * Selects the paragraph at the caret position.
	 * @since jEdit 2.7pre2
	 */
	public void selectParagraph()
	{
		int caretLine = getCaretLine();
		if(getLineLength(caretLine) == 0)
		{
			getToolkit().beep();
			return;
		}
		int start = caretLine;
		int end = caretLine;
		while(start >= 0)
		{
			if(getLineLength(start) == 0)
				break;
			else
				start--;
		}
		while(end < getLineCount())
		{
			if(getLineLength(end) == 0)
				break;
			else
				end++;
		}
		int selectionStart = getLineStartOffset(start + 1);
		int selectionEnd = getLineEndOffset(end - 1) - 1;
		Selection s = new Selection.Range(selectionStart,selectionEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(selectionEnd);
	} //}}}
	//{{{ selectWord() method
	/**
	 * Selects the word at the caret position.
	 * @since jEdit 2.7pre2
	 */
	public void selectWord()
	{
		int line = getCaretLine();
		int lineStart = getLineStartOffset(line);
		int offset = getCaretPosition() - lineStart;
		if(getLineLength(line) == 0)
			return;
		String lineText = getLineText(line);
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		if(offset == getLineLength(line))
			offset--;
		int wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);
		int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);
		Selection s = new Selection.Range(lineStart + wordStart,
			lineStart + wordEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(lineStart + wordEnd);
	} //}}}
	//{{{ selectToMatchingBracket() method
	/**
	 * Selects from the bracket at the specified position to the 
	 * corresponding bracket.
	 * @since jEdit 4.2pre1
	 */
	public Selection selectToMatchingBracket(int position,
		boolean quickCopy)
	{
		int positionLine = buffer.getLineOfOffset(position);
		int lineOffset = position - buffer.getLineStartOffset(positionLine);
		if(getLineLength(positionLine) != 0)
		{
			int bracket = TextUtilities.findMatchingBracket(buffer,
				positionLine,Math.max(0,lineOffset - 1));
			if(bracket != -1)
			{
				Selection s;
				if(bracket < position)
				{
					if(!quickCopy)
						moveCaretPosition(position,false);
					s = new Selection.Range(bracket,position);
				}
				else
				{
					if(!quickCopy)
						moveCaretPosition(bracket + 1,false);
					s = new Selection.Range(position - 1,bracket + 1);
				}
				if(!multi && !quickCopy)
					selectNone();
				addToSelection(s);
				return s;
			}
		}
		return null;
	} //}}}
	//{{{ selectToMatchingBracket() method
	/**
	 * Selects from the bracket at the caret position to the corresponding
	 * bracket.
	 * @since jEdit 4.0pre2
	 */
	public void selectToMatchingBracket()
	{
		selectToMatchingBracket(caret,false);
	} //}}}
	//{{{ selectBlock() method
	/**
	 * Selects the code block surrounding the caret.
	 * @since jEdit 2.7pre2
	 */
	public void selectBlock()
	{
		String openBrackets = ""([{"";
		String closeBrackets = "")]}"";
		Selection s = getSelectionAtOffset(caret);
		int start, end;
		if(s == null)
			start = end = caret;
		else
		{
			start = s.start;
			end = s.end;
		}
		String text = getText(0,buffer.getLength());
		// Scan backwards, trying to find a bracket
		int count = 1;
		char openBracket = '\0';
		char closeBracket = '\0';
		// We can't do the backward scan if start == 0
		if(start == 0)
		{
			getToolkit().beep();
			return;
		}
backward_scan:	while(--start > 0)
		{
			char c = text.charAt(start);
			int index = openBrackets.indexOf(c);
			if(index != -1)
			{
				if(--count == 0)
				{
					openBracket = c;
					closeBracket = closeBrackets.charAt(index);
					break backward_scan;
				}
			}
			else if(closeBrackets.indexOf(c) != -1)
				count++;
		}
		// Reset count
		count = 1;
		// Scan forward, matching that bracket
		if(openBracket == '\0')
		{
			getToolkit().beep();
			return;
		}
		else
		{
forward_scan:		do
			{
				char c = text.charAt(end);
				if(c == closeBracket)
				{
					if(--count == 0)
					{
						end++;
						break forward_scan;
					}
				}
				else if(c == openBracket)
					count++;
			}
			while(++end < buffer.getLength());
		}
		s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} //}}}
	//{{{ lineInStructureScope() method
	/**
	 * Returns if the specified line is contained in the currently
	 * matched structure's scope.
	 * @since jEdit 4.2pre3
	 */
	public boolean lineInStructureScope(int line)
	{
		if(match == null)
			return false;
		if(match.startLine < caretLine)
			return (line >= match.startLine && line <= caretLine);
		else
			return (line <= match.endLine && line >= caretLine);
	} //}}}
	//{{{ invertSelection() method
	/**
	 * Inverts the selection.
	 * @since jEdit 4.0pre1
	 */
	public final void invertSelection()
	{
		Selection[] newSelection = new Selection[selection.size() + 1];
		int lastOffset = 0;
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			newSelection[i] = new Selection.Range(lastOffset,
				s.getStart());
			lastOffset = s.getEnd();
		}
		newSelection[selection.size()] = new Selection.Range(
			lastOffset,buffer.getLength());
		setSelection(newSelection);
	} //}}}
	//{{{ getSelectionCount() method
	/**
	 * Returns the number of selections. This can be used to test
	 * for the existence of selections.
	 * @since jEdit 3.2pre2
	 */
	public int getSelectionCount()
	{
		return selection.size();
	} //}}}
	//{{{ getSelection() method
	/**
	 * Returns the current selection.
	 * @since jEdit 3.2pre1
	 */
	public Selection[] getSelection()
	{
		Selection[] sel = new Selection[selection.size()];
		selection.copyInto(sel);
		return sel;
	} //}}}
	//{{{ selectNone() method
	/**
	 * Deselects everything.
	 */
	public void selectNone()
	{
		setSelection((Selection)null);
	} //}}}
	//{{{ setSelection() method
	/**
	 * Sets the selection. Nested and overlapping selections are merged
	 * where possible.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void setSelection(Selection[] selection)
	{
		// invalidate the old selection
		invalidateSelectedLines();
		this.selection.removeAllElements();
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}
		fireCaretEvent();
	} //}}}
	//{{{ setSelection() method
	/**
	 * Sets the selection. Nested and overlapping selections are merged
	 * where possible.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void setSelection(Selection selection)
	{
		invalidateSelectedLines();
		this.selection.removeAllElements();
		if(selection != null)
			_addToSelection(selection);
		fireCaretEvent();
	} //}}}
	//{{{ addToSelection() method
	/**
	 * Adds to the selection. Nested and overlapping selections are merged
	 * where possible.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void addToSelection(Selection[] selection)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}
		// to hide current line highlight
		invalidateLine(caretLine);
		fireCaretEvent();
	} //}}}
	//{{{ addToSelection() method
	/**
	 * Adds to the selection. Nested and overlapping selections are merged
	 * where possible.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void addToSelection(Selection selection)
	{
		_addToSelection(selection);
		// to hide current line highlight
		invalidateLine(caretLine);
		fireCaretEvent();
	} //}}}
	//{{{ getSelectionAtOffset() method
	/**
	 * Returns the selection containing the specific offset, or <code>null</code>
	 * if there is no selection at that offset.
	 * @param offset The offset
	 * @since jEdit 3.2pre1
	 */
	public Selection getSelectionAtOffset(int offset)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);
				if(offset >= s.start && offset <= s.end)
					return s;
			}
		}
		return null;
	} //}}}
	//{{{ removeFromSelection() method
	/**
	 * Deactivates the specified selection.
	 * @param sel The selection
	 * @since jEdit 3.2pre1
	 */
	public void removeFromSelection(Selection sel)
	{
		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);
		// to hide current line highlight
		invalidateLine(caretLine);
		fireCaretEvent();
	} //}}}
	//{{{ removeFromSelection() method
	/**
	 * Deactivates the selection at the specified offset. If there is
	 * no selection at that offset, does nothing.
	 * @param offset The offset
	 * @since jEdit 3.2pre1
	 */
	public void removeFromSelection(int offset)
	{
		Selection sel = getSelectionAtOffset(offset);
		if(sel == null)
			return;
		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);
		// to hide current line highlight
		invalidateLine(caretLine);
		fireCaretEvent();
	} //}}}
	//{{{ resizeSelection() method
	/**
	 * Resizes the selection at the specified offset, or creates a new
	 * one if there is no selection at the specified offset. This is a
	 * utility method that is mainly useful in the mouse event handler
	 * because it handles the case of end being before offset gracefully
	 * (unlike the rest of the selection API).
	 * @param offset The offset
	 * @param end The new selection end
	 * @param extraEndVirt Only for rectangular selections - specifies how
	 * far it extends into virtual space.
	 * @param rect Make the selection rectangular?
	 * @since jEdit 3.2pre1
	 */
	public void resizeSelection(int offset, int end, int extraEndVirt,
		boolean rect)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);
		}
		boolean reversed = false;
		if(end < offset)
		{
			int tmp = offset;
			offset = end;
			end = tmp;
			reversed = true;
		}
		Selection newSel;
		if(rect)
		{
			Selection.Rect rectSel = new Selection.Rect(offset,end);
			if(reversed)
				rectSel.extraStartVirt = extraEndVirt;
			else
				rectSel.extraEndVirt = extraEndVirt;
			newSel = rectSel;
		}
		else
			newSel = new Selection.Range(offset,end);
		_addToSelection(newSel);
		fireCaretEvent();
	} //}}}
	//{{{ extendSelection() method
	/**
	 * Extends the selection at the specified offset, or creates a new
	 * one if there is no selection at the specified offset. This is
	 * different from resizing in that the new chunk is added to the
	 * selection in question, instead of replacing it.
	 * @param offset The offset
	 * @param end The new selection end
	 * @since jEdit 3.2pre1
	 */
	public void extendSelection(int offset, int end)
	{
		extendSelection(offset,end,0,0);
	} //}}}
	//{{{ extendSelection() method
	/**
	 * Extends the selection at the specified offset, or creates a new
	 * one if there is no selection at the specified offset. This is
	 * different from resizing in that the new chunk is added to the
	 * selection in question, instead of replacing it.
	 * @param offset The offset
	 * @param end The new selection end
	 * @param extraStartVirt Extra virtual space at the start
	 * @param extraEndVirt Extra virtual space at the end
	 * @since jEdit 4.2pre1
	 */
	public void extendSelection(int offset, int end,
		int extraStartVirt, int extraEndVirt)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);
			if(offset == s.start)
			{
				offset = end;
				end = s.end;
			}
			else if(offset == s.end)
			{
				offset = s.start;
			}
		}
		if(end < offset)
		{
			int tmp = end;
			end = offset;
			offset = tmp;
		}
		if(rectangularSelectionMode)
		{
			s = new Selection.Rect(offset,end);
			((Selection.Rect)s).extraStartVirt = extraStartVirt;
			((Selection.Rect)s).extraEndVirt = extraEndVirt;
		}
		else
			s = new Selection.Range(offset,end);
		_addToSelection(s);
		fireCaretEvent();
		if(rectangularSelectionMode && extraEndVirt != 0)
		{
			int line = getLineOfOffset(end);
			scrollTo(line,getLineLength(line) + extraEndVirt,false);
		}
	} //}}}
	//{{{ getSelectedText() method
	/**
	 * Returns the text in the specified selection.
	 * @param s The selection
	 * @since jEdit 3.2pre1
	 */
	public String getSelectedText(Selection s)
	{
		StringBuffer buf = new StringBuffer();
		s.getText(buffer,buf);
		return buf.toString();
	} //}}}
	//{{{ getSelectedText() method
	/**
	 * Returns the text in all active selections.
	 * @param separator The string to insert between each text chunk
	 * (for example, a newline)
	 * @since jEdit 3.2pre1
	 */
	public String getSelectedText(String separator)
	{
		if(selection.size() == 0)
			return null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < selection.size(); i++)
		{
			if(i != 0)
				buf.append(separator);
			((Selection)selection.elementAt(i)).getText(buffer,buf);
		}
		return buf.toString();
	} //}}}
	//{{{ getSelectedText() method
	/**
	 * Returns the text in all active selections, with a newline
	 * between each text chunk.
	 */
	public String getSelectedText()
	{
		return getSelectedText(""\n"");
	} //}}}
	//{{{ setSelectedText() method
	/**
	 * Replaces the selection with the specified text.
	 * @param s The selection
	 * @param selectedText The new text
	 * @since jEdit 3.2pre1
	 */
	public void setSelectedText(Selection s, String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}
		try
		{
			buffer.beginCompoundEdit();
			moveCaretPosition(s.setText(buffer,selectedText));
		}
		// No matter what happends... stops us from leaving buffer
		// in a bad state
		finally
		{
			buffer.endCompoundEdit();
		}
		// no no no!!!!
		//selectNone();
	} //}}}
	//{{{ setSelectedText() method
	/**
	 * Replaces the selection at the caret with the specified text.
	 * If there is no selection at the caret, the text is inserted at
	 * the caret position.
	 */
	public void setSelectedText(String selectedText)
	{
		setSelectedText(selectedText,true);
	} //}}}
	//{{{ setSelectedText() method
	/**
	 * Replaces the selection at the caret with the specified text.
	 * If there is no selection at the caret, the text is inserted at
	 * the caret position.
	 * @param selectedText The new selection
	 * @param moveCaret Move caret to insertion location if necessary
	 * @since jEdit 4.2pre5
	 */
	public void setSelectedText(String selectedText, boolean moveCaret)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}
		Selection[] selection = getSelection();
		if(selection.length == 0)
		{
			// for compatibility with older jEdit versions
			buffer.insert(caret,selectedText);
		}
		else
		{
			try
			{
				int newCaret = -1;
				buffer.beginCompoundEdit();
				for(int i = 0; i < selection.length; i++)
				{
					newCaret = selection[i].setText(buffer,selectedText);
				}
				if(moveCaret)
					moveCaretPosition(newCaret);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		selectNone();
	} //}}}
	//{{{ getSelectedLines() method
	/**
	 * Returns a sorted array of line numbers on which a selection or
	 * selections are present.<p>
	 *
	 * This method is the most convenient way to iterate through selected
	 * lines in a buffer. The line numbers in the array returned by this
	 * method can be passed as a parameter to such methods as
	 * {@link org.gjt.sp.jedit.Buffer#getLineText(int)}.
	 *
	 * @since jEdit 3.2pre1
	 */
	public int[] getSelectedLines()
	{
		if(selection.size() == 0)
			return new int[] { caretLine };
		Integer line;
		Set set = new TreeSet();
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			int endLine = (s.end == getLineStartOffset(s.endLine)
				? s.endLine - 1
				: s.endLine);
			for(int j = s.startLine; j <= endLine; j++)
			{
				line = new Integer(j);
				set.add(line);
			}
		}
		int[] returnValue = new int[set.size()];
		int i = 0;
		Iterator iter = set.iterator();
		while(iter.hasNext())
		{
			line = (Integer)iter.next();
			returnValue[i++] = line.intValue();
		}
		return returnValue;
	} //}}}
	//{{{ showSelectLineRangeDialog() method
	/**
	 * Displays the 'select line range' dialog box, and selects the
	 * specified range of lines.
	 * @since jEdit 2.7pre2
	 */
	public void showSelectLineRangeDialog()
	{
		new SelectLineRange(view);
	} //}}}
	//}}}
	//{{{ Caret
	//{{{ addStructureMatcher() method
	/**
	 * Adds a structure matcher.
	 * @since jEdit 4.2pre3
	 */
	public void addStructureMatcher(StructureMatcher matcher)
	{
		structureMatchers.add(matcher);
	} //}}}
	//{{{ removeStructureMatcher() method
	/**
	 * Removes a structure matcher.
	 * @since jEdit 4.2pre3
	 */
	public void removeStructureMatcher(StructureMatcher matcher)
	{
		structureMatchers.remove(matcher);
	} //}}}
	//{{{ getStructureMatch() method
	/**
	 * Returns the structure element (bracket, or XML tag, etc) matching the
	 * one before the caret.
	 * @since jEdit 4.2pre3
	 */
	public StructureMatcher.Match getStructureMatch()
	{
		return match;
	} //}}}
	//{{{ blinkCaret() method
	/**
	 * Blinks the caret.
	 */
	public final void blinkCaret()
	{
		if(caretBlinks)
		{
			blink = !blink;
			invalidateLine(caretLine);
		}
		else
			blink = true;
	} //}}}
	//{{{ centerCaret() method
	/**
	 * Centers the caret on the screen.
	 * @since jEdit 2.7pre2
	 */
	public void centerCaret()
	{
		int offset = getScreenLineStartOffset(visibleLines / 2);
		if(offset == -1)
			getToolkit().beep();
		else
			setCaretPosition(offset);
	} //}}}
	//{{{ setCaretPosition() method
	/**
	 * Sets the caret position and deactivates the selection.
	 * @param newCaret The caret position
	 */
	public void setCaretPosition(int newCaret)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,true);
	} //}}}
	//{{{ setCaretPosition() method
	/**
	 * Sets the caret position and deactivates the selection.
	 * @param newCaret The caret position
	 * @param doElectricScroll Do electric scrolling?
	 */
	public void setCaretPosition(int newCaret, boolean doElectricScroll)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,doElectricScroll);
	} //}}}
	//{{{ moveCaretPosition() method
	/**
	 * Sets the caret position without deactivating the selection.
	 * @param newCaret The caret position
	 */
	public void moveCaretPosition(int newCaret)
	{
		moveCaretPosition(newCaret,true);
	} //}}}
	//{{{ moveCaretPosition() method
	/**
	 * Sets the caret position without deactivating the selection.
	 * @param newCaret The caret position
	 * @param doElectricScroll Do electric scrolling?
	 */
	public void moveCaretPosition(int newCaret, boolean doElectricScroll)
	{
		moveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL
			: NORMAL_SCROLL);
	} //}}}
	//{{{ moveCaretPosition() method
	public static int NO_SCROLL = 0;
	public static int NORMAL_SCROLL = 1;
	public static int ELECTRIC_SCROLL = 2;
	/**
	 * Sets the caret position without deactivating the selection.
	 * @param newCaret The caret position
	 * @param scrollMode The scroll mode (NO_SCROLL, NORMAL_SCROLL, or
	 * ELECTRIC_SCROLL).
	 * @since jEdit 4.2pre1
	 */
	public void moveCaretPosition(int newCaret, int scrollMode)
	{
		if(newCaret < 0 || newCaret > buffer.getLength())
		{
			throw new IllegalArgumentException(""caret out of bounds: ""
				+ newCaret);
		}
		if(match != null)
		{
			if(caretLine < match.startLine)
				invalidateLineRange(caretLine,match.endLine);
			else
				invalidateLineRange(match.startLine,caretLine);
			match = null;
		}
		if(caret == newCaret)
		{
			if(scrollMode == NORMAL_SCROLL)
				finishCaretUpdate(false,false);
			else if(scrollMode == ELECTRIC_SCROLL)
				finishCaretUpdate(true,false);
		}
		else
		{
			int newCaretLine = getLineOfOffset(newCaret);
			magicCaret = -1;
			if(caretLine == newCaretLine)
			{
				if(caretScreenLine != -1)
					invalidateScreenLineRange(caretScreenLine,caretScreenLine);
			}
			else
			{
				int newCaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,
					newCaret - buffer.getLineStartOffset(newCaretLine));
				if(caretScreenLine == -1)
					invalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);
				else
					invalidateScreenLineRange(caretScreenLine,newCaretScreenLine);
				caretScreenLine = newCaretScreenLine;
			}
			caret = newCaret;
			caretLine = newCaretLine;
			if(scrollMode == NORMAL_SCROLL)
				finishCaretUpdate(false,true);
			else if(scrollMode == ELECTRIC_SCROLL)
				finishCaretUpdate(true,true);
		}
	} //}}}
	//{{{ getCaretPosition() method
	/**
	 * Returns a zero-based index of the caret position.
	 */
	public int getCaretPosition()
	{
		return caret;
	} //}}}
	//{{{ getCaretLine() method
	/**
	 * Returns the line number containing the caret.
	 */
	public int getCaretLine()
	{
		return caretLine;
	} //}}}
	//{{{ getMagicCaretPosition() method
	/**
	 * Returns an internal position used to keep the caret in one
	 * column while moving around lines of varying lengths.
	 * @since jEdit 4.2pre1
	 */
	public int getMagicCaretPosition()
	{
		if(magicCaret == -1)
		{
			magicCaret = chunkCache.subregionOffsetToX(
				caretLine,caret - getLineStartOffset(caretLine));
		}
		return magicCaret;
	} //}}}
	//{{{ setMagicCaretPosition() method
	/**
	 * Sets the `magic' caret position. This can be used to preserve
	 * the column position when moving up and down lines.
	 * @param magicCaret The magic caret position
	 * @since jEdit 4.2pre1
	 */
	public void setMagicCaretPosition(int magicCaret)
	{
		this.magicCaret = magicCaret;
	} //}}}
	//{{{ addCaretListener() method
	/**
	 * Adds a caret change listener to this text area.
	 * @param listener The listener
	 */
	public final void addCaretListener(CaretListener listener)
	{
		listenerList.add(CaretListener.class,listener);
	} //}}}
	//{{{ removeCaretListener() method
	/**
	 * Removes a caret change listener from this text area.
	 * @param listener The listener
	 */
	public final void removeCaretListener(CaretListener listener)
	{
		listenerList.remove(CaretListener.class,listener);
	} //}}}
	//{{{ goToNextBracket() method
	/**
	 * Moves the caret to the next closing bracket.
	 * @since jEdit 2.7pre2.
	 */
	public void goToNextBracket(boolean select)
	{
		int newCaret = -1;
		if(caret != buffer.getLength())
		{
			String text = getText(caret,buffer.getLength()
				- caret - 1);
loop:			for(int i = 0; i < text.length(); i++)
			{
				switch(text.charAt(i))
				{
				case ')': case ']': case '}':
					newCaret = caret + i + 1;
					break loop;
				}
			}
		}
		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} //}}}
	//{{{ goToNextCharacter() method
	/**
	 * Moves the caret to the next character.
	 * @since jEdit 2.7pre2.
	 */
	public void goToNextCharacter(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		if(!select && s instanceof Selection.Range)
		{
			if(multi)
			{
				if(caret != s.end)
				{
					moveCaretPosition(s.end);
					return;
				}
			}
			else
			{
				setCaretPosition(s.end);
				return;
			}
		}
		int extraStartVirt, extraEndVirt;
		if(s instanceof Selection.Rect)
		{
			extraStartVirt = ((Selection.Rect)s).extraStartVirt;
			extraEndVirt = ((Selection.Rect)s).extraEndVirt;
		}
		else
		{
			extraStartVirt = 0;
			extraEndVirt = 0;
		}
		int newCaret = caret;
		if(caret == buffer.getLength())
		{
			if(select && (rectangularSelectionMode || s instanceof Selection.Rect))
			{
				if(s != null && caret == s.start)
					extraStartVirt++;
				else
					extraEndVirt++;
			}
			else
			{
				getToolkit().beep();
				return;
			}
		}
		else if(caret == getLineEndOffset(caretLine) - 1)
		{
			if(select && (rectangularSelectionMode || s instanceof Selection.Rect))
			{
				if(s != null && caret == s.start)
					extraStartVirt++;
				else
					extraEndVirt++;
			}
			else
			{
				int line = displayManager.getNextVisibleLine(caretLine);
				if(line == -1)
				{
					getToolkit().beep();
					return;
				}
				else
					newCaret = getLineStartOffset(line);
			}
		}
		else
			newCaret = caret + 1;
		if(select)
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ goToNextLine() method
	/**
	 * Move the caret to the next line.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		boolean rectSelect = (s == null ? rectangularSelectionMode
			: s instanceof Selection.Rect);
		int magic = getMagicCaretPosition();
		int newCaret = chunkCache.getBelowPosition(caretLine,
			caret - buffer.getLineStartOffset(caretLine),magic + 1,
			rectSelect && select);
		if(newCaret == -1)
		{
			int end = getLineEndOffset(caretLine) - 1;
			if(caret == end)
			{
				getToolkit().beep();
				return;
			}
			else
				newCaret = end;
		}
		if(select)
		{
			RectParams params = getRectParams(caret,newCaret);
			int extraStartVirt;
			int extraEndVirt;
			if(params == null)
			{
				extraStartVirt = 0;
				extraEndVirt = 0;
			}
			else
			{
				extraStartVirt = params.extraStartVirt;
				extraEndVirt = params.extraEndVirt;
				newCaret = params.newCaret;
			}
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		}
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ goToNextMarker() method
	/**
	 * Moves the caret to the next marker.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			getToolkit().beep();
			return;
		}
		Marker marker = null;
		for(int i = 0; i < markers.size(); i++)
		{
			Marker _marker = (Marker)markers.get(i);
			if(_marker.getPosition() > caret)
			{
				marker = _marker;
				break;
			}
		}
		if(marker == null)
			marker = (Marker)markers.get(0);
		if(select)
			extendSelection(caret,marker.getPosition());
		else if(!multi)
			selectNone();
		moveCaretPosition(marker.getPosition());
	} //}}}
	//{{{ goToNextPage() method
	/**
	 * Moves the caret to the next screenful.
	 * @since jEdit 2.7pre2.
	 */
	public void goToNextPage(boolean select)
	{
		scrollToCaret(false);
		int magic = getMagicCaretPosition();
		if(caretLine < displayManager.getFirstVisibleLine())
		{
			caretLine = displayManager.getNextVisibleLine(
				caretLine);
		}
		int newCaret;
		if(getFirstLine() + getVisibleLines() >= displayManager
			.getScrollLineCount())
		{
			int lastVisibleLine = displayManager
				.getLastVisibleLine();
			newCaret = getLineEndOffset(lastVisibleLine) - 1;
		}
		else
		{
			int caretScreenLine = getScreenLineOfOffset(caret);
			scrollDownPage();
			newCaret = xToScreenLineOffset(caretScreenLine,
				magic,true);
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret,false);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ goToNextParagraph() method
	/**
	 * Moves the caret to the start of the next paragraph.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextParagraph(boolean select)
	{
		int lineNo = getCaretLine();
		int newCaret = getBufferLength();
		boolean foundBlank = false;
loop:		for(int i = lineNo + 1; i < getLineCount(); i++)
		{
			if(!displayManager.isLineVisible(i))
				continue;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineStartOffset(i);
						break loop;
					}
					else
						continue loop;
				}
			}
			foundBlank = true;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ goToNextWord() method
	/**
	 * Moves the caret to the start of the next word.
	 * Note that if the ""view.eatWhitespace"" boolean propery is false,
	 * this method moves the caret to the end of the current word instead.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextWord(boolean select)
	{
		goToNextWord(select,false);
	} //}}}
	//{{{ goToNextWord() method
	/**
	 * Moves the caret to the start of the next word.
	 * @since jEdit 4.1pre5
	 */
	public void goToNextWord(boolean select, boolean eatWhitespace)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(newCaret == lineText.length())
		{
			int nextLine = displayManager.getNextVisibleLine(caretLine);
			if(nextLine == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineStartOffset(nextLine);
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordEnd(lineText,
				newCaret + 1,noWordSep,true,eatWhitespace);
			newCaret += lineStart;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ goToPrevBracket() method
	/**
	 * Moves the caret to the previous bracket.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevBracket(boolean select)
	{
		String text = getText(0,caret);
		int newCaret = -1;
loop:		for(int i = getCaretPosition() - 1; i >= 0; i--)
		{
			switch(text.charAt(i))
			{
			case '(': case '[': case '{':
				newCaret = i;
				break loop;
			}
		}
		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} //}}}
	//{{{ goToPrevCharacter() method
	/**
	 * Moves the caret to the previous character.
	 * @since jEdit 2.7pre2.
	 */
	public void goToPrevCharacter(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		if(!select && s instanceof Selection.Range)
		{
			if(multi)
			{
				if(caret != s.start)
				{
					moveCaretPosition(s.start);
					return;
				}
			}
			else
			{
				setCaretPosition(s.start);
				return;
			}
		}
		int extraStartVirt = 0;
		int extraEndVirt = 0;
		int newCaret = caret;
		if(select && caret == getLineEndOffset(caretLine) - 1)
		{
			if(s instanceof Selection.Rect)
			{
				extraStartVirt = ((Selection.Rect)s).extraStartVirt;
				extraEndVirt = ((Selection.Rect)s).extraEndVirt;
				if(caret == s.start)
				{
					if(extraStartVirt == 0)
						newCaret = caret - 1;
					else
						extraStartVirt--;
				}
				else
				{
					if(extraEndVirt == 0)
						newCaret = caret - 1;
					else
						extraEndVirt--;
				}
			}
			else
				newCaret = caret - 1;
		}
		else if(caret == getLineStartOffset(caretLine))
		{
			int line = displayManager.getPrevVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineEndOffset(line) - 1;
		}
		else
			newCaret = caret - 1;
		if(select)
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ goToPrevLine() method
	/**
	 * Moves the caret to the previous line.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		boolean rectSelect = (s == null ? rectangularSelectionMode
			: s instanceof Selection.Rect);
		int magic = getMagicCaretPosition();
		int newCaret = chunkCache.getAbovePosition(caretLine,
			caret - buffer.getLineStartOffset(caretLine),magic + 1,
			rectSelect && select);
		if(newCaret == -1)
		{
			int start = getLineStartOffset(caretLine);
			if(caret == start)
			{
				getToolkit().beep();
				return;
			}
			else
				newCaret = start;
		}
		if(select)
		{
			RectParams params = getRectParams(caret,newCaret);
			int extraStartVirt;
			int extraEndVirt;
			if(params == null)
			{
				extraStartVirt = 0;
				extraEndVirt = 0;
			}
			else
			{
				extraStartVirt = params.extraStartVirt;
				extraEndVirt = params.extraEndVirt;
				newCaret = params.newCaret;
			}
			extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);
		}
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ goToPrevMarker() method
	/**
	 * Moves the caret to the previous marker.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			getToolkit().beep();
			return;
		}
		Marker marker = null;
		for(int i = markers.size() - 1; i >= 0; i--)
		{
			Marker _marker = (Marker)markers.elementAt(i);
			if(_marker.getPosition() < caret)
			{
				marker = _marker;
				break;
			}
		}
		if(marker == null)
			marker = (Marker)markers.get(markers.size() - 1);
		if(select)
			extendSelection(caret,marker.getPosition());
		else if(!multi)
			selectNone();
		moveCaretPosition(marker.getPosition());
	} //}}}
	//{{{ goToPrevPage() method
	/**
	 * Moves the caret to the previous screenful.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevPage(boolean select)
	{
		scrollToCaret(false);
		int magic = getMagicCaretPosition();
		if(caretLine < displayManager.getFirstVisibleLine())
		{
			caretLine = displayManager.getNextVisibleLine(
				caretLine);
		}
		int newCaret;
		if(getFirstLine() == 0)
		{
			int firstVisibleLine = displayManager
				.getFirstVisibleLine();
			newCaret = getLineStartOffset(firstVisibleLine);
		}
		else
		{
			int caretScreenLine = getScreenLineOfOffset(caret);
			scrollUpPage();
			newCaret = xToScreenLineOffset(caretScreenLine,
				magic,true);
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret,false);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ goToPrevParagraph() method
	/**
	 * Moves the caret to the start of the previous paragraph.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevParagraph(boolean select)
	{
		int lineNo = caretLine;
		int newCaret = 0;
		boolean foundBlank = false;
loop:		for(int i = lineNo - 1; i >= 0; i--)
		{
			if(!displayManager.isLineVisible(i))
				continue;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineEndOffset(i) - 1;
						break loop;
					}
					else
						continue loop;
				}
			}
			foundBlank = true;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ goToPrevWord() method
	/**
	 * Moves the caret to the start of the previous word.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevWord(boolean select)
	{
		goToPrevWord(select,false);
	} //}}}
	//{{{ goToPrevWord() method
	/**
	 * Moves the caret to the start of the previous word.
	 * @since jEdit 4.1pre5
	 */
	public void goToPrevWord(boolean select, boolean eatWhitespace)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(newCaret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			else
			{
				int prevLine = displayManager.getPrevVisibleLine(caretLine);
				if(prevLine == -1)
				{
					getToolkit().beep();
					return;
				}
				newCaret = getLineEndOffset(prevLine) - 1;
			}
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordStart(lineText,
				newCaret - 1,noWordSep,true,eatWhitespace);
			newCaret += lineStart;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ smartHome() method
	/**
	 * On subsequent invocations, first moves the caret to the first
	 * non-whitespace character of the line, then the beginning of the
	 * line, then to the first visible line.
	 * @since jEdit 2.7pre2
	 */
	public void smartHome(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();
		switch(view.getInputHandler().getLastActionCount())
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");"");
			goToStartOfWhiteSpace(select);
			break;
		case 2:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfLine("" + select + "");"");
			goToStartOfLine(select);
			break;
		default: //case 3:
			if(recorder != null)
				recorder.record(""textArea.goToFirstVisibleLine("" + select + "");"");
			goToFirstVisibleLine(select);
			break;
		}
	} //}}}
	//{{{ smartEnd() method
	/**
	 * On subsequent invocations, first moves the caret to the last
	 * non-whitespace character of the line, then the end of the
	 * line, then to the last visible line.
	 * @since jEdit 2.7pre2
	 */
	public void smartEnd(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();
		switch(view.getInputHandler().getLastActionCount())
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");"");
			goToEndOfWhiteSpace(select);
			break;
		case 2:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfLine("" + select + "");"");
			goToEndOfLine(select);
			break;
		default: //case 3:
			if(recorder != null)
				recorder.record(""textArea.goToLastVisibleLine("" + select + "");"");
			goToLastVisibleLine(select);
			break;
		}
	} //}}}
	//{{{ goToStartOfLine() method
	/**
	 * Moves the caret to the beginning of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void goToStartOfLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null
			? caretLine : s.startLine);
		int newCaret = getLineStartOffset(line);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ goToEndOfLine() method
	/**
	 * Moves the caret to the end of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void goToEndOfLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null
			? caretLine : s.endLine);
		int newCaret = getLineEndOffset(line) - 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		// so that end followed by up arrow will always put caret at
		// the end of the previous line, for example
		//setMagicCaretPosition(Integer.MAX_VALUE);
	} //}}}
	//{{{ goToStartOfWhiteSpace() method
	/**
	 * Moves the caret to the first non-whitespace character of the current
	 * line.
	 * @since jEdit 2.7pre2
	 */
	public void goToStartOfWhiteSpace(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - buffer.getLineStartOffset(line);
		}
		else
		{
			line = s.startLine;
			offset = s.start - buffer.getLineStartOffset(line);
		}
		int firstIndent = chunkCache.getSubregionStartOffset(line,offset);
		if(firstIndent == getLineStartOffset(line))
		{
			firstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));
			if(firstIndent == getLineLength(line))
				firstIndent = 0;
			firstIndent += getLineStartOffset(line);
		}
		if(select)
			extendSelection(caret,firstIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstIndent);
	} //}}}
	//{{{ goToEndOfWhiteSpace() method
	/**
	 * Moves the caret to the last non-whitespace character of the current
	 * line.
	 * @since jEdit 2.7pre2
	 */
	public void goToEndOfWhiteSpace(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - getLineStartOffset(line);
		}
		else
		{
			line = s.endLine;
			offset = s.end - getLineStartOffset(line);
		}
		int lastIndent = chunkCache.getSubregionEndOffset(line,offset);
		if(lastIndent == getLineEndOffset(line))
		{
			lastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));
			if(lastIndent == 0)
				lastIndent = getLineLength(line);
			lastIndent += getLineStartOffset(line);
		}
		else
		{
			lastIndent--;
		}
		if(select)
			extendSelection(caret,lastIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastIndent);
	} //}}}
	//{{{ goToFirstVisibleLine() method
	/**
	 * Moves the caret to the first visible line.
	 * @since jEdit 2.7pre2
	 */
	public void goToFirstVisibleLine(boolean select)
	{
		int firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;
		int firstVisible = getScreenLineStartOffset(firstVisibleLine);
		if(firstVisible == -1)
		{
			firstVisible = getLineStartOffset(displayManager
				.getFirstVisibleLine());
		}
		if(select)
			extendSelection(caret,firstVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstVisible);
	} //}}}
	//{{{ goToLastVisibleLine() method
	/**
	 * Moves the caret to the last visible line.
	 * @since jEdit 2.7pre2
	 */
	public void goToLastVisibleLine(boolean select)
	{
		int lastVisible;
		if(getFirstLine() + visibleLines >=
			displayManager.getScrollLineCount())
		{
			lastVisible = getLineEndOffset(displayManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			lastVisible = visibleLines - electricScroll - 1;
			if(lastLinePartial)
				lastVisible--;
			if(lastVisible < 0)
				lastVisible = 0;
			lastVisible = getScreenLineEndOffset(lastVisible) - 1;
			if(lastVisible == -1)
			{
				lastVisible = getLineEndOffset(displayManager
					.getLastVisibleLine()) - 1;
			}
		}
		if(select)
			extendSelection(caret,lastVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastVisible);
	} //}}}
	//{{{ goToBufferStart() method
	/**
	 * Moves the caret to the beginning of the buffer.
	 * @since jEdit 4.0pre3
	 */
	public void goToBufferStart(boolean select)
	{
		int start = buffer.getLineStartOffset(
			displayManager.getFirstVisibleLine());
		if(select)
			extendSelection(caret,start);
		else if(!multi)
			selectNone();
		moveCaretPosition(start);
	} //}}}
	//{{{ goToBufferEnd() method
	/**
	 * Moves the caret to the end of the buffer.
	 * @since jEdit 4.0pre3
	 */
	public void goToBufferEnd(boolean select)
	{
		int end = buffer.getLineEndOffset(
			displayManager.getLastVisibleLine()) - 1;
		if(select)
			extendSelection(caret,end);
		else if(!multi)
			selectNone();
		moveCaretPosition(end);
	} //}}}
	//{{{ goToMatchingBracket() method
	/**
	 * Moves the caret to the bracket matching the one before the caret.
	 * @since jEdit 2.7pre3
	 */
	public void goToMatchingBracket()
	{
		if(getLineLength(caretLine) != 0)
		{
			int dot = caret - getLineStartOffset(caretLine);
			int bracket = TextUtilities.findMatchingBracket(
				buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1)
			{
				selectNone();
				moveCaretPosition(bracket + 1,false);
				return;
			}
		}
		getToolkit().beep();
	} //}}}
	//{{{ showGoToLineDialog() method
	/**
	 * Displays the 'go to line' dialog box, and moves the caret to the
	 * specified line number.
	 * @since jEdit 2.7pre2
	 */
	public void showGoToLineDialog()
	{
		String line = GUIUtilities.input(view,""goto-line"",null);
		if(line == null)
			return;
		try
		{
			int lineNumber = Integer.parseInt(line) - 1;
			setCaretPosition(getLineStartOffset(lineNumber));
		}
		catch(Exception e)
		{
			getToolkit().beep();
		}
	} //}}}
	//}}}
	//{{{ User input
	//{{{ userInput() method
	/**
	 * Handles the insertion of the specified character. It performs the
	 * following operations above and beyond simply inserting the text:
	 * <ul>
	 * <li>Inserting a TAB with a selection will shift to the right
	 * <li>Inserting a space with automatic abbrev expansion enabled will
	 * try to expand the abbrev
	 * <li>Inserting an indent open/close bracket will re-indent the current
	 * line as necessary
	 * </ul>
	 *
	 * @param ch The character
	 * @see #setSelectedText(String)
	 * @see #isOverwriteEnabled()
	 * @since jEdit 2.7pre3
	 */
	public void userInput(char ch)
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(ch == ' ' && Abbrevs.getExpandOnInput()
			&& Abbrevs.expandAbbrev(view,false))
			return;
		else if(ch == '\t')
		{
			if(selection.size() == 1)
			{
				Selection sel = (Selection)selection.elementAt(0);
				if(sel instanceof Selection.Rect ||
					(sel.startLine == sel.endLine
					&& (sel.start != buffer.getLineStartOffset(sel.startLine)
					|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1)))
				{
					insertTab();
				}
				else
					shiftIndentRight();
			}
			else if(selection.size() != 0)
				shiftIndentRight();
			else
				insertTab();
			return;
		}
		else
		{
			boolean indent;
			// check if the user entered a bracket
			String indentOpenBrackets = (String)buffer
				.getProperty(""indentOpenBrackets"");
			String indentCloseBrackets = (String)buffer
				.getProperty(""indentCloseBrackets"");
			if((indentCloseBrackets != null
				&& indentCloseBrackets.indexOf(ch) != -1)
				|| (indentOpenBrackets != null
				&& indentOpenBrackets.indexOf(ch) != -1))
			{
				indent = true;
			}
			else
			{
				indent = false;
			}
			String str = String.valueOf(ch);
			Selection[] selection = getSelection();
			if(selection.length != 0)
			{
				for(int i = 0; i < selection.length; i++)
				{
					Selection s = selection[i];
					setSelectedText(s,str);
					/* if(s instanceof Selection.Rect)
					{
						addToSelection(new Selection.Rect(
							s.start + 1,s.end + 1));
					} */
				}
				return;
			}
			if(ch == ' ')
			{
				if(doWordWrap(true))
					return;
			}
			else
				doWordWrap(false);
			try
			{
				// Don't overstrike if we're on the end of
				// the line
				if(overwrite || indent)
					buffer.beginCompoundEdit();
				if(overwrite)
				{
					int caretLineEnd = getLineEndOffset(caretLine);
					if(caretLineEnd - caret > 1)
						buffer.remove(caret,1);
				}
				buffer.insert(caret,str);
				if(indent)
					buffer.indentLine(caretLine,true);
			}
			finally
			{
				if(overwrite || indent)
					buffer.endCompoundEdit();
			}
		}
	} //}}}
	//{{{ isOverwriteEnabled() method
	/**
	 * Returns true if overwrite mode is enabled, false otherwise.
	 */
	public final boolean isOverwriteEnabled()
	{
		return overwrite;
	} //}}}
	//{{{ setOverwriteEnabled() method
	/**
	 * Sets overwrite mode.
	 */
	public final void setOverwriteEnabled(boolean overwrite)
	{
		blink = true;
		caretTimer.restart();
		this.overwrite = overwrite;
		invalidateLine(caretLine);
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	} //}}}
	//{{{ toggleOverwriteEnabled() method
	/**
	 * Toggles overwrite mode.
	 * @since jEdit 2.7pre2
	 */
	public final void toggleOverwriteEnabled()
	{
		setOverwriteEnabled(!overwrite);
		if(view.getStatus() != null)
		{
			view.getStatus().setMessageAndClear(
				jEdit.getProperty(""view.status.overwrite-changed"",
				new Integer[] { new Integer(overwrite ? 1 : 0) }));
		}
	} //}}}
	//{{{ backspace() method
	/**
	 * Deletes the character before the caret, or the selection, if one is
	 * active.
	 * @since jEdit 2.7pre2
	 */
	public void backspace()
	{
		delete(false);
	} //}}}
	//{{{ backspaceWord() method
	/**
	 * Deletes the word before the caret.
	 * @since jEdit 2.7pre2
	 */
	public void backspaceWord()
	{
		backspaceWord(false);
	} //}}}
	//{{{ backspaceWord() method
	/**
	 * Deletes the word before the caret.
	 * @param eatWhitespace If true, will eat whitespace
	 * @since jEdit 4.2pre5
	 */
	public void backspaceWord(boolean eatWhitespace)
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}
		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(_caret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			_caret--;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordStart(lineText,_caret-1,
				noWordSep,true,eatWhitespace);
		}
		buffer.remove(_caret + lineStart,
			caret - (_caret + lineStart));
	} //}}}
	//{{{ delete() method
	/**
	 * Deletes the character after the caret.
	 * @since jEdit 2.7pre2
	 */
	public void delete()
	{
		delete(true);
	} //}}}
	//{{{ deleteToEndOfLine() method
	/**
	 * Deletes from the caret to the end of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void deleteToEndOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		buffer.remove(caret,getLineEndOffset(caretLine)
			- caret - 1);
	} //}}}
	//{{{ deleteLine() method
	/**
	 * Deletes the line containing the caret.
	 * @since jEdit 2.7pre2
	 */
	public void deleteLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		int x = chunkCache.subregionOffsetToX(caretLine,caret - start);
		// otherwise a bunch of consecutive C+d's would be merged
		// into one edit
		try
		{
			if(end > buffer.getLength())
			{
				if(start != 0)
					start--;
				end--;
			}
			buffer.beginCompoundEdit();
			buffer.remove(start,end - start);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		int lastLine = displayManager.getLastVisibleLine();
		if(caretLine == lastLine)
		{
			int offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);
			setCaretPosition(buffer.getLineStartOffset(lastLine)
				+ offset);
		}
		else
		{
			int offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);
			setCaretPosition(start + offset);
		}
	} //}}}
	//{{{ deleteParagraph() method
	/**
	 * Deletes the paragraph containing the caret.
	 * @since jEdit 2.7pre2
	 */
	public void deleteParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		int start = 0, end = buffer.getLength();
loop:		for(int i = caretLine - 1; i >= 0; i--)
		{
			//if(!displayManager.isLineVisible(i))
			//	continue loop;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}
			start = getLineStartOffset(i);
			break loop;
		}
loop:		for(int i = caretLine + 1; i < getLineCount(); i++)
		{
			//if(!displayManager.isLineVisible(i))
			//	continue loop;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}
			end = getLineEndOffset(i) - 1;
			break loop;
		}
		buffer.remove(start,end - start);
	} //}}}
	//{{{ deleteToStartOfLine() method
	/**
	 * Deletes from the caret to the beginning of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void deleteToStartOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		buffer.remove(getLineStartOffset(caretLine),
			caret - getLineStartOffset(caretLine));
	} //}}}
	//{{{ deleteWord() method
	/**
	 * Deletes the word in front of the caret.
	 * @since jEdit 2.7pre2
	 */
	public void deleteWord()
	{
		deleteWord(false);
	} //}}}
	//{{{ deleteWord() method
	/**
	 * Deletes the word in front of the caret.
	 *
.	 * @param eatWhitespace If true, will eat whitespace
	 * @since jEdit 4.2pre5
	 */
	public void deleteWord(boolean eatWhitespace)
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}
		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(_caret == lineText.length())
		{
			if(lineStart + _caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			_caret++;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordEnd(lineText,
				_caret+1,noWordSep,true,eatWhitespace);
		}
		buffer.remove(caret,(_caret + lineStart) - caret);
	} //}}}
	//{{{ isMultipleSelectionEnabled() method
	/**
	 * Returns if multiple selection is enabled.
	 * @since jEdit 3.2pre1
	 */
	public final boolean isMultipleSelectionEnabled()
	{
		return multi;
	} //}}}
	//{{{ toggleMultipleSelectionEnabled() method
	/**
	 * Toggles multiple selection.
	 * @since jEdit 3.2pre1
	 */
	public final void toggleMultipleSelectionEnabled()
	{
		setMultipleSelectionEnabled(!multi);
		if(view.getStatus() != null)
		{
			view.getStatus().setMessageAndClear(
				jEdit.getProperty(""view.status.multi-changed"",
				new Integer[] { new Integer(multi ? 1 : 0) }));
		}
	} //}}}
	//{{{ setMultipleSelectionEnabled() method
	/**
	 * Set multiple selection on or off according to the value of
	 * <code>multi</code>. This only affects the ability to
	 * make multiple selections in the user interface; macros and plugins
	 * can manipulate them regardless of the setting of this flag. In fact,
	 * in most cases, calling this method should not be necessary.
	 *
	 * @param multi Should multiple selection be enabled?
	 * @since jEdit 3.2pre1
	 */
	public final void setMultipleSelectionEnabled(boolean multi)
	{
		this.multi = multi;
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
		painter.repaint();
	} //}}}
	//{{{ isRectangularSelectionEnabled() method
	/**
	 * Returns if rectangular selection is enabled.
	 * @since jEdit 4.2pre1
	 */
	public final boolean isRectangularSelectionEnabled()
	{
		return rectangularSelectionMode;
	} //}}}
	//{{{ toggleRectangularSelectionEnabled() method
	/**
	 * Toggles rectangular selection.
	 * @since jEdit 4.2pre1
	 */
	public final void toggleRectangularSelectionEnabled()
	{
		setRectangularSelectionEnabled(!rectangularSelectionMode);
		if(view.getStatus() != null)
		{
			view.getStatus().setMessageAndClear(
				jEdit.getProperty(""view.status.rect-select-changed"",
				new Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));
		}
	} //}}}
	//{{{ setRectangularSelectionEnabled() method
	/**
	 * Set rectangular selection on or off according to the value of
	 * <code>rectangularSelectionMode</code>. This only affects the ability
	 * to make multiple selections from the keyboard. A rectangular
	 * selection can always be created by dragging with the mouse by holding
	 * down <b>Control</b>, regardless of the state of this flag.
	 *
	 * @param rectangularSelectionMode Should rectangular selection be
	 * enabled?
	 * @since jEdit 4.2pre1
	 */
	public final void setRectangularSelectionEnabled(
		boolean rectangularSelectionMode)
	{
		this.rectangularSelectionMode = rectangularSelectionMode;
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
		painter.repaint();
	} //}}}
	//}}}
	//{{{ Markers
	//{{{ goToMarker() method
	/**
	 * Moves the caret to the marker with the specified shortcut.
	 * @param shortcut The shortcut
	 * @param select True if the selection should be extended,
	 * false otherwise
	 * @since jEdit 3.2pre2
	 */
	public void goToMarker(char shortcut, boolean select)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}
		int pos = marker.getPosition();
		if(select)
			extendSelection(caret,pos);
		else if(!multi)
			selectNone();
		moveCaretPosition(pos);
	} //}}}
	//{{{ addMarker() method
	/**
	 * Adds a marker at the caret position.
	 * @since jEdit 3.2pre1
	 */
	public void addMarker()
	{
		// always add markers on selected lines
		Selection[] selection = getSelection();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			if(s.startLine != s.endLine)
			{
				if(s.startLine != caretLine)
					buffer.addMarker('\0',s.start);
			}
			if(s.endLine != caretLine)
				buffer.addMarker('\0',s.end);
		}
		// toggle marker on caret line
		buffer.addOrRemoveMarker('\0',caret);
	} //}}}
	//{{{ swapMarkerAndCaret() method
	/**
	 * Moves the caret to the marker with the specified shortcut,
	 * then sets the marker position to the former caret position.
	 * @param shortcut The shortcut
	 * @since jEdit 3.2pre2
	 */
	public void swapMarkerAndCaret(char shortcut)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}
		int caret = getCaretPosition();
		setCaretPosition(marker.getPosition());
		buffer.addMarker(shortcut,caret);
	} //}}}
	//}}}
	//{{{ Folding
	//{{{ goToParentFold() method
	/**
	 * Moves the caret to the fold containing the one at the caret
	 * position.
	 * @since jEdit 4.0pre3
	 */
	public void goToParentFold()
	{
		int line = -1;
		int level = buffer.getFoldLevel(caretLine);
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.getFoldLevel(i) < level)
			{
				line = i;
				break;
			}
		}
		if(line == -1)
		{
			getToolkit().beep();
			return;
		}
		int magic = getMagicCaretPosition();
		int newCaret = buffer.getLineStartOffset(line)
			+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);
		if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ goToNextFold() method
	/**
	 * Moves the caret to the next fold.
	 * @since jEdit 4.0pre3
	 */
	public void goToNextFold(boolean select)
	{
		int nextFold = -1;
		for(int i = caretLine + 1; i < buffer.getLineCount(); i++)
		{
			if(buffer.isFoldStart(i)
				&& displayManager.isLineVisible(i))
			{
				nextFold = i;
				break;
			}
		}
		if(nextFold == -1)
		{
			getToolkit().beep();
			return;
		}
		int magic = getMagicCaretPosition();
		int newCaret = buffer.getLineStartOffset(nextFold)
			+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ goToPrevFold() method
	/**
	 * Moves the caret to the previous fold.
	 * @since jEdit 4.0pre3
	 */
	public void goToPrevFold(boolean select)
	{
		int prevFold = -1;
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.isFoldStart(i)
				&& displayManager.isLineVisible(i))
			{
				prevFold = i;
				break;
			}
		}
		if(prevFold == -1)
		{
			getToolkit().beep();
			return;
		}
		int magic = getMagicCaretPosition();
		int newCaret = buffer.getLineStartOffset(prevFold)
			+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} //}}}
	//{{{ collapseFold() method
	/**
	 * Like {@link DisplayManager#collapseFold(int)}, but
	 * also moves the caret to the first line of the fold.
	 * @since jEdit 4.0pre3
	 */
	public void collapseFold()
	{
		int x = chunkCache.subregionOffsetToX(caretLine,
			caret - getLineStartOffset(caretLine));
		displayManager.collapseFold(caretLine);
		if(displayManager.isLineVisible(caretLine))
			return;
		int line = displayManager.getPrevVisibleLine(caretLine);
		if(!multi)
			selectNone();
		moveCaretPosition(buffer.getLineStartOffset(line)
			+ chunkCache.xToSubregionOffset(line,0,x,true));
	} //}}}
	//{{{ expandFold() method
	/**
	 * Like {@link DisplayManager#expandFold(int,boolean)}, but
	 * also moves the caret to the first sub-fold.
	 * @since jEdit 4.0pre3
	 */
	public void expandFold(boolean fully)
	{
		int x = chunkCache.subregionOffsetToX(caretLine,
			caret - getLineStartOffset(caretLine));
		int line = displayManager.expandFold(caretLine,fully);
		if(!fully && line != -1)
		{
			if(!multi)
				selectNone();
			moveCaretPosition(getLineStartOffset(line)
				+ chunkCache.xToSubregionOffset(line,0,x,true));
		}
	} //}}}
	//{{{ selectFold() method
	/**
	 * Selects the fold that contains the caret line number.
	 * @since jEdit 3.1pre3
	 */
	public void selectFold()
	{
		selectFold(caretLine);
	} //}}}
	//{{{ selectFold() method
	/**
	 * Selects the fold that contains the specified line number.
	 * @param line The line number
	 * @since jEdit 4.0pre1
	 */
	public void selectFold(int line)
	{
		int[] lines = buffer.getFoldAtLine(line);
		int newCaret = getLineEndOffset(lines[1]) - 1;
		Selection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(newCaret);
	} //}}}
	//{{{ narrowToFold() method
	/**
	 * Hides all lines except those in the fold containing the caret.
	 * @since jEdit 4.0pre1
	 */
	public void narrowToFold()
	{
		int[] lines = buffer.getFoldAtLine(caretLine);
		if(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)
			getToolkit().beep();
		else
			displayManager.narrow(lines[0],lines[1]);
	} //}}}
	//{{{ narrowToSelection() method
	/**
	 * Hides all lines except those in the selection.
	 * @since jEdit 4.0pre1
	 */
	public void narrowToSelection()
	{
		if(selection.size() != 1)
		{
			getToolkit().beep();
			return;
		}
		Selection sel = (Selection)selection.elementAt(0);
		displayManager.narrow(sel.getStartLine(),sel.getEndLine());
		selectNone();
	} //}}}
	//{{{ addExplicitFold() method
	/**
	 * Surrounds the selection with explicit fold markers.
	 * @since jEdit 4.0pre3
	 */
	public void addExplicitFold()
	{
		if(!buffer.getStringProperty(""folding"").equals(""explicit""))
		{
			GUIUtilities.error(view,""folding-not-explicit"",null);
			return;
		}
		// BUG: if there are multiple selections in different
		// contexts, the wrong comment strings will be inserted.
		String lineComment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		String start, end;
		if(lineComment != null)
		{
			start = lineComment + ""{{{ \n"";
			end = lineComment + ""}}}"";
		}
		else if(commentStart != null && commentEnd != null)
		{
			start = commentStart + ""{{{  "" + commentEnd + ""\n"";
			end = commentStart + ""}}}"" + commentEnd;
		}
		else
		{
			start = ""{{{ \n"";
			end = ""}}}"";
		}
		try
		{
			buffer.beginCompoundEdit();
			if(selection.size() == 0)
			{
				String line = buffer.getLineText(caretLine);
				String whitespace = line.substring(0,
					MiscUtilities.getLeadingWhiteSpace(line));
				int loc = caret + start.length() - 1;
				start = start + whitespace;
				buffer.insert(caret,start);
				// stupid: caret will automatically be incremented
				buffer.insert(caret,end);
				moveCaretPosition(loc,false);
			}
			else
			{
				int loc = -1;
				for(int i = 0; i < selection.size(); i++)
				{
					Selection s = (Selection)selection.elementAt(i);
					String line = buffer.getLineText(s.startLine);
					String whitespace = line.substring(0,
						MiscUtilities.getLeadingWhiteSpace(line));
					loc = s.start + start.length() - 1;
					buffer.insert(s.start,start + whitespace);
					if(s.end == buffer.getLineStartOffset(
						s.endLine))
					{
						buffer.insert(s.end,end);
					}
					else
					{
						buffer.insert(s.end,"" "" + end);
					}
				}
				setCaretPosition(loc,false);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} //}}}
	//}}}
	//{{{ Text editing
	//{{{ lineComment() method
	/**
	 * Prepends each line of the selection with the line comment string.
	 * @since jEdit 3.2pre1
	 */
	public void lineComment()
	{
		String comment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		if(!buffer.isEditable() || comment == null || comment.length() == 0)
		{
			getToolkit().beep();
			return;
		}
		comment = comment + ' ';
		buffer.beginCompoundEdit();
		int[] lines = getSelectedLines();
		try
		{
			for(int i = 0; i < lines.length; i++)
			{
				String text = getLineText(lines[i]);
				buffer.insert(getLineStartOffset(lines[i])
					+ MiscUtilities.getLeadingWhiteSpace(text),
					comment);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		selectNone();
	} //}}}
	//{{{ rangeComment() method
	/**
	 * Adds comment start and end strings to the beginning and end of the
	 * selection.
	 * @since jEdit 3.2pre1
	 */
	public void rangeComment()
	{
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null
			|| commentStart.length() == 0 || commentEnd.length() == 0)
		{
			getToolkit().beep();
			return;
		}
		commentStart = commentStart + ' ';
		commentEnd = ' ' + commentEnd;
		try
		{
			buffer.beginCompoundEdit();
			Selection[] selection = getSelection();
			if(selection.length == 0)
			{
				int oldCaret = caret;
				buffer.insert(caret,commentStart);
				buffer.insert(caret,commentEnd);
				setCaretPosition(oldCaret + commentStart.length());
			}
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Range)
				{
					buffer.insert(s.start,commentStart);
					buffer.insert(s.end,commentEnd);
				}
				else if(s instanceof Selection.Rect)
				{
					Selection.Rect rect = (Selection.Rect)s;
					int start = rect.getStartColumn(buffer);
					int end = rect.getEndColumn(buffer);
					for(int j = s.startLine; j <= s.endLine; j++)
					{
						buffer.insertAtColumn(j,end,
							commentEnd);
						buffer.insertAtColumn(j,start,
							commentStart);
					}
				}
			}
			selectNone();
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} //}}}
	//{{{ formatParagraph() method
	/**
	 * Formats the paragraph containing the caret.
	 * @since jEdit 2.7pre2
	 */
	public void formatParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(maxLineLen <= 0)
		{
			GUIUtilities.error(view,""format-maxlinelen"",null);
			return;
		}
		Selection[] selection = getSelection();
		if(selection.length != 0)
		{
			buffer.beginCompoundEdit();
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.format(
					getSelectedText(s),maxLineLen,
					buffer.getTabSize()));
			}
			buffer.endCompoundEdit();
		}
		else
		{
			int lineNo = getCaretLine();
			int start = 0, end = buffer.getLength();
loop:			for(int i = lineNo - 1; i >= 0; i--)
			{
				getLineText(i,lineSegment);
				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}
				start = getLineEndOffset(i);
				break loop;
			}
loop:			for(int i = lineNo + 1; i < getLineCount(); i++)
			{
				getLineText(i,lineSegment);
				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}
				end = getLineStartOffset(i) - 1;
				break loop;
			}
			try
			{
				buffer.beginCompoundEdit();
				String text = buffer.getText(start,end - start);
				buffer.remove(start,end - start);
				buffer.insert(start,TextUtilities.format(
					text,maxLineLen,buffer.getTabSize()));
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} //}}}
	//{{{ spacesToTabs() method
	/**
	 * Converts spaces to tabs in the selection.
	 * @since jEdit 2.7pre2
	 */
	public void spacesToTabs()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		buffer.beginCompoundEdit();
		if(selection.length == 0)
		{
			setText(TextUtilities.spacesToTabs(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.spacesToTabs(
					getSelectedText(s),buffer.getTabSize()));
			}
		}
		buffer.endCompoundEdit();
	} //}}}
	//{{{ tabsToSpaces() method
	/**
	 * Converts tabs to spaces in the selection.
	 * @since jEdit 2.7pre2
	 */
	public void tabsToSpaces()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		buffer.beginCompoundEdit();
		if(selection.length == 0)
		{
			setText(TextUtilities.tabsToSpaces(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.tabsToSpaces(
					getSelectedText(s),buffer.getTabSize()));
			}
		}
		buffer.endCompoundEdit();
	} //}}}
	//{{{ toUpperCase() method
	/**
	 * Converts the selected text to upper case.
	 * @since jEdit 2.7pre2
	 */
	public void toUpperCase()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }
		buffer.beginCompoundEdit();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toUpperCase());
		}
		buffer.endCompoundEdit();
	} //}}}
	//{{{ toLowerCase() method
	/**
	 * Converts the selected text to lower case.
	 * @since jEdit 2.7pre2
	 */
	public void toLowerCase()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }
		buffer.beginCompoundEdit();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toLowerCase());
		}
		buffer.endCompoundEdit();
	} //}}}
	//{{{ removeTrailingWhiteSpace() method
	/**
	 * Removes trailing whitespace from all lines in the selection.
	 * @since jEdit 2.7pre2
	 */
	public void removeTrailingWhiteSpace()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.removeTrailingWhiteSpace(getSelectedLines());
		}
	} //}}}
	//{{{ insertEnterAndIndent() method
	public void insertEnterAndIndent()
	{
		if(!isEditable())
			getToolkit().beep();
		else
		{
			try
			{
				buffer.beginCompoundEdit();
				setSelectedText(""\n"");
				buffer.indentLine(caretLine,true);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} //}}}
	//{{{ insertTabAndIndent() method
	public void insertTabAndIndent()
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() == 0)
		{
			// if caret is inside leading whitespace, indent.
			String text = buffer.getLineText(caretLine);
			int start = buffer.getLineStartOffset(caretLine);
			int whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);
			if(caret - start <= whiteSpace
				&& buffer.indentLine(caretLine,false))
				return;
		}
		userInput('\t');
	} //}}}
	//{{{ indentSelectedLines() method
	/**
	 * Indents all selected lines.
	 * @since jEdit 3.1pre3
	 */
	public void indentSelectedLines()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.indentLines(getSelectedLines());
			selectNone();
		}
	} //}}}
	//{{{ shiftIndentLeft() method
	/**
	 * Shifts the indent to the left.
	 * @since jEdit 2.7pre2
	 */
	public void shiftIndentLeft()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.shiftIndentLeft(getSelectedLines());
		}
	} //}}}
	//{{{ shiftIndentRight() method
	/**
	 * Shifts the indent to the right.
	 * @since jEdit 2.7pre2
	 */
	public void shiftIndentRight()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
			buffer.shiftIndentRight(getSelectedLines());
	} //}}}
	//{{{ joinLines() method
	/**
	 * Joins the current and the next line.
	 * @since jEdit 2.7pre2
	 */
	public void joinLines()
	{
		int end = getLineEndOffset(caretLine);
		if(!buffer.isEditable() || end > buffer.getLength())
		{
			getToolkit().beep();
			return;
		}
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(
				end - 1,MiscUtilities.getLeadingWhiteSpace(
				buffer.getLineText(caretLine + 1)) + 1);
			buffer.insert(end - 1, "" "");
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		setCaretPosition(end - 1);
	} //}}}
	//{{{ showWordCountDialog() method
	/**
	 * Displays the 'word count' dialog box.
	 * @since jEdit 2.7pre2
	 */
	public void showWordCountDialog()
	{
		String selection = getSelectedText();
		if(selection != null)
		{
			doWordCount(view,selection);
			return;
		}
		doWordCount(view,buffer.getText(0,buffer.getLength()));
	} //}}}
	//}}}
	//{{{ Right click popup
	//{{{ isRightClickPopupEnabled() method
	/**
	 * Returns if the right click popup menu is enabled. The Gestures
	 * plugin uses this API.
	 * @since jEdit 4.2pre13
	 */
	public boolean isRightClickPopupEnabled()
	{
		return popupEnabled;
	} //}}}
	//{{{ setRightClickPopupEnabled() method
	/**
	 * Sets if the right click popup menu is enabled. The Gestures
	 * plugin uses this API.
	 * @since jEdit 4.2pre13
	 */
	public void setRightClickPopupEnabled(boolean popupEnabled)
	{
		this.popupEnabled = popupEnabled;
	} //}}}
	//{{{ getRightClickPopup() method
	/**
	 * Returns the right click popup menu.
	 */
	public final JPopupMenu getRightClickPopup()
	{
		return popup;
	} //}}}
	//{{{ setRightClickPopup() method
	/**
	 * Sets the right click popup menu.
	 * @param popup The popup
	 */
	public final void setRightClickPopup(JPopupMenu popup)
	{
		this.popup = popup;
	} //}}}
	//{{{ handlePopupTrigger() method
	/**
	 * Do the same thing as right-clicking on the text area. The Gestures
	 * plugin uses this API.
	 * @since jEdit 4.2pre13
	 */
	public void handlePopupTrigger(MouseEvent evt)
	{
		if(popup.isVisible())
			popup.setVisible(false);
		else
		{
			int x = evt.getX();
			int y = evt.getY();
			int dragStart = xyToOffset(x,y,
				!(painter.isBlockCaretEnabled()
				|| isOverwriteEnabled()));
			if(getSelectionCount() == 0 || multi)
				moveCaretPosition(dragStart,false);
			GUIUtilities.showPopupMenu(popup,painter,x,y);
		}
	} //}}}
	//}}}
	//{{{ AWT stuff
	//{{{ addLeftOfScrollBar() method
	/**
	 * Adds a component to the box left of the vertical scroll bar. The
	 * ErrorList plugin uses this to show a global error overview, for
	 * example.
	 *
	 * @param comp The component
	 * @since jEdit 4.2pre1
	 */
	public void addLeftOfScrollBar(Component comp)
	{
		verticalBox.add(comp,verticalBox.getComponentCount() - 1);
	} //}}}
	//{{{ removeLeftOfScrollBar() method
	/**
	 * Removes a component from the box left of the vertical scroll bar.
	 *
	 * @param comp The component
	 * @since jEdit 4.2pre1
	 */
	public void removeLeftOfScrollBar(Component comp)
	{
		verticalBox.remove(comp);
	} //}}}
	//{{{ addNotify() method
	/**
	 * Called by the AWT when this component is added to a parent.
	 * Adds document listener.
	 */
	public void addNotify()
	{
		super.addNotify();
		ToolTipManager.sharedInstance().registerComponent(painter);
		ToolTipManager.sharedInstance().registerComponent(gutter);
		recalculateVisibleLines();
		if(buffer.isLoaded())
			recalculateLastPhysicalLine();
		propertiesChanged();
	} //}}}
	//{{{ removeNotify() method
	/**
	 * Called by the AWT when this component is removed from it's parent.
	 * This clears the pointer to the currently focused component.
	 * Also removes document listener.
	 */
	public void removeNotify()
	{
		super.removeNotify();
		ToolTipManager.sharedInstance().unregisterComponent(painter);
		ToolTipManager.sharedInstance().unregisterComponent(gutter);
		if(focusedComponent == this)
			focusedComponent = null;
	} //}}}
	//{{{ getFocusTraversalKeysEnabled() method
	/**
	 * Java 1.4 compatibility fix to make Tab key work.
	 * @since jEdit 3.2pre4
	 */
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} //}}}
	//{{{ getFocusCycleRoot() method
	/**
	 * Java 1.4 compatibility fix to make Tab traversal work in a sane
	 * manner.
	 * @since jEdit 4.2pre3
	 */
	public boolean getFocusCycleRoot()
	{
		return true;
	} //}}}
	//{{{ processKeyEvent() method
	public void processKeyEvent(KeyEvent evt)
	{
		view.processKeyEvent(evt,View.TEXT_AREA);
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} //}}}
	//{{{ addTopComponent() method
	/**
	 * Adds a component above the gutter, text area, and vertical scroll bar.
	 *
	 * @since jEdit 4.2pre3
	 */
	public void addTopComponent(Component comp)
	{
		add(TOP,comp);
	} //}}}
	//{{{ removeTopComponent() method
	/**
	 * Removes a component from above the gutter, text area, and vertical scroll bar.
	 *
	 * @since jEdit 4.2pre3
	 */
	public void removeTopComponent(Component comp)
	{
		remove(comp);
	} //}}}
	//}}}
	//{{{ propertiesChanged() method
	/**
	 * Called by jEdit when necessary. Plugins should not call this method.
	 */
	public void propertiesChanged()
	{
		if(buffer == null)
			return;
		int _tabSize = buffer.getTabSize();
		char[] foo = new char[_tabSize];
		for(int i = 0; i < foo.length; i++)
		{
			foo[i] = ' ';
		}
		tabSize = (float)painter.getStringWidth(new String(foo));
		charWidth = (int)Math.round(
			painter.getFont().getStringBounds(foo,0,1,
			painter.getFontRenderContext()).getWidth());
		boolean invalidateCachedScreenLineCounts = false;
		String wrap = buffer.getStringProperty(""wrap"");
		if(!wrap.equals(this.wrap))
		{
			this.wrap = wrap;
			hardWrap = wrap.equals(""hard"");
			if(displayManager != null && !bufferChanging)
			{
				displayManager.firstLine.callReset = true;
				displayManager.scrollLineCount.callReset = true;
			}
			invalidateCachedScreenLineCounts = true;
		}
		int maxLineLen = buffer.getIntegerProperty(""maxLineLen"",0);
		if(maxLineLen != this.maxLineLen)
		{
			this.maxLineLen = maxLineLen;
			if(displayManager != null && !bufferChanging)
			{
				displayManager.firstLine.callReset = true;
				displayManager.scrollLineCount.callReset = true;
			}
			invalidateCachedScreenLineCounts = true;
		}
		if(invalidateCachedScreenLineCounts)
			buffer.invalidateCachedScreenLineCounts();
		chunkCache.invalidateAll();
		if(displayManager != null && !bufferChanging)
		{
			displayManager.updateWrapSettings();
			displayManager._notifyScreenLineChanges();
		}
		gutter.repaint();
		painter.repaint();
	} //}}}
	//{{{ Deprecated methods
	//{{{ getSelectionStart() method
	/**
	 * @deprecated Instead, obtain a Selection instance using
	 * any means, and call its <code>getStart()</code> method
	 */
	public final int getSelectionStart()
	{
		if(selection.size() != 1)
			return caret;
		return ((Selection)selection.elementAt(0)).getStart();
	} //}}}
	//{{{ getSelectionStart() method
	/**
	 * @deprecated Instead, obtain a Selection instance using
	 * any means, and call its <code>getStart(int)</code> method
	 */
	public int getSelectionStart(int line)
	{
		if(selection.size() != 1)
			return caret;
		return ((Selection)selection.elementAt(0)).getStart(
			buffer,line);
	} //}}}
	//{{{ getSelectionStartLine() method
	/**
	 * @deprecated Instead, obtain a Selection instance using
	 * any means, and call its <code>getStartLine()</code> method
	 */
	public final int getSelectionStartLine()
	{
		if(selection.size() != 1)
			return caret;
		return ((Selection)selection.elementAt(0)).getStartLine();
	} //}}}
	//{{{ setSelectionStart() method
	/**
	 * @deprecated Do not use.
	 */
	public final void setSelectionStart(int selectionStart)
	{
		select(selectionStart,getSelectionEnd(),true);
	} //}}}
	//{{{ getSelectionEnd() method
	/**
	 * @deprecated Instead, obtain a Selection instance using
	 * any means, and call its <code>getEnd()</code> method
	 */
	public final int getSelectionEnd()
	{
		if(selection.size() != 1)
			return caret;
		return ((Selection)selection.elementAt(0)).getEnd();
	} //}}}
	//{{{ getSelectionEnd() method
	/**
	 * @deprecated Instead, obtain a Selection instance using
	 * any means, and call its <code>getEnd(int)</code> method
	 */
	public int getSelectionEnd(int line)
	{
		if(selection.size() != 1)
			return caret;
		return ((Selection)selection.elementAt(0)).getEnd(
			buffer,line);
	} //}}}
	//{{{ getSelectionEndLine() method
	/**
	 * @deprecated Instead, obtain a Selection instance using
	 * any means, and call its <code>getEndLine()</code> method
	 */
	public final int getSelectionEndLine()
	{
		if(selection.size() != 1)
			return caret;
		return ((Selection)selection.elementAt(0)).getEndLine();
	} //}}}
	//{{{ setSelectionEnd() method
	/**
	 * @deprecated Do not use.
	 */
	public final void setSelectionEnd(int selectionEnd)
	{
		select(getSelectionStart(),selectionEnd,true);
	} //}}}
	//{{{ getMarkPosition() method
	/**
	 * @deprecated Do not use.
	 */
	public final int getMarkPosition()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return caret;
		if(s.start == caret)
			return s.end;
		else if(s.end == caret)
			return s.start;
		else
			return caret;
	} //}}}
	//{{{ getMarkLine() method
	/**
	 * @deprecated Do not use.
	 */
	public final int getMarkLine()
	{
		if(selection.size() != 1)
			return caretLine;
		Selection s = (Selection)selection.elementAt(0);
		if(s.start == caret)
			return s.endLine;
		else if(s.end == caret)
			return s.startLine;
		else
			return caretLine;
	} //}}}
	//{{{ select() method
	/**
	 * @deprecated Instead, call either <code>addToSelection()</code>,
	 * or <code>setSelection()</code> with a new Selection instance.
	 */
	public void select(int start, int end)
	{
		select(start,end,true);
	} //}}}
	//{{{ select() method
	/**
	 * @deprecated Instead, call either <code>addToSelection()</code>,
	 * or <code>setSelection()</code> with a new Selection instance.
	 */
	public void select(int start, int end, boolean doElectricScroll)
	{
		selectNone();
		int newStart, newEnd;
		if(start < end)
		{
			newStart = start;
			newEnd = end;
		}
		else
		{
			newStart = end;
			newEnd = start;
		}
		setSelection(new Selection.Range(newStart,newEnd));
		moveCaretPosition(end,doElectricScroll);
	} //}}}
	//{{{ isSelectionRectangular() method
	/**
	 * @deprecated Instead, check if the appropriate Selection
	 * is an instance of the Selection.Rect class.
	 */
	public boolean isSelectionRectangular()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return false;
		else
			return (s instanceof Selection.Rect);
	} //}}}
	//}}}
	//{{{ Package-private members
	//{{{ Instance variables
	Segment lineSegment;
	MouseHandler mouseHandler;
	ChunkCache chunkCache;
	DisplayManager displayManager;
	boolean bufferChanging;
	int maxHorizontalScrollWidth;
	String wrap;
	boolean hardWrap;
	float tabSize;
	int charWidth;
	int maxLineLen;
	boolean scrollBarsInitialized;
	// this is package-private so that the painter can use it without
	// having to call getSelection() (which involves an array copy)
	Vector selection;
	// used to store offsetToXY() results
	Point returnValue;
	boolean lastLinePartial;
	//}}}
	//{{{ isCaretVisible() method
	/**
	 * Returns true if the caret is visible, false otherwise.
	 */
	final boolean isCaretVisible()
	{
		return blink && hasFocus();
	} //}}}
	//{{{ isStructureHighlightVisible() method
	/**
	 * Returns true if the structure highlight is visible, false otherwise.
	 * @since jEdit 4.2pre3
	 */
	final boolean isStructureHighlightVisible()
	{
		return match != null
			&& hasFocus()
			&& displayManager.isLineVisible(match.startLine)
			&& displayManager.isLineVisible(match.endLine);
	} //}}}
	//{{{ updateMaxHorizontalScrollWidth() method
	void updateMaxHorizontalScrollWidth()
	{
		int max = chunkCache.getMaxHorizontalScrollWidth();
		if(max != maxHorizontalScrollWidth)
		{
			maxHorizontalScrollWidth = max;
			horizontal.setValues(Math.max(0,
				Math.min(maxHorizontalScrollWidth + charWidth
				- painter.getWidth(),
				-horizontalOffset)),
				painter.getWidth(),
				0,maxHorizontalScrollWidth
				+ charWidth);
		}
	} //}}}
	//{{{ recalculateVisibleLines() method
	void recalculateVisibleLines()
	{
		if(painter == null)
			return;
		int height = painter.getHeight();
		int lineHeight = painter.getFontMetrics().getHeight();
		if(lineHeight == 0)
			visibleLines = 0;
		else if(height <= 0)
		{
			visibleLines = 0;
			lastLinePartial = false;
		}
		else
		{
			visibleLines = height / lineHeight;
			lastLinePartial = (height % lineHeight != 0);
			if(lastLinePartial)
				visibleLines++;
		}
		chunkCache.recalculateVisibleLines();
		// this does the ""trick"" to eliminate blank space at the end
		if(displayManager != null && buffer != null && buffer.isLoaded())
			setFirstLine(getFirstLine());
		updateScrollBars();
	} //}}}
	//{{{ foldStructureChanged() method
	void foldStructureChanged()
	{
		chunkCache.invalidateAll();
		recalculateLastPhysicalLine();
		repaint();
	} //}}}
	//{{{ updateScrollBars() method
	/**
	 * Updates the state of the scroll bars. This should be called
	 * if the number of lines in the buffer changes, or when the
	 * size of the text are changes.
	 */
	void updateScrollBars()
	{
		if(buffer == null)
			return;
		if(Debug.SCROLL_DEBUG)
			Log.log(Log.DEBUG,this,""updateScrollBars(), slc=""
				+ displayManager.getScrollLineCount());
		if(vertical != null && visibleLines != 0)
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""Vertical ok"");
			int lineCount = displayManager.getScrollLineCount();
			int firstLine = getFirstLine();
			int visible = visibleLines - (lastLinePartial ? 1 : 0);
			vertical.setValues(firstLine,visible,0,lineCount);
			vertical.setUnitIncrement(2);
			vertical.setBlockIncrement(visible);
		}
		int width = painter.getWidth();
		if(horizontal != null && width != 0)
		{
			if(Debug.SCROLL_DEBUG)
				Log.log(Log.DEBUG,this,""Horizontal ok"");
			painter.repaint();
			horizontal.setValue(-horizontalOffset);
			horizontal.setUnitIncrement(painter.getFontMetrics()
				.charWidth('w'));
			horizontal.setBlockIncrement(width / 2);
		}
	} //}}}
	//{{{ _finishCaretUpdate() method
	/* called by DisplayManager.BufferChangeHandler.transactionComplete() */
	void _finishCaretUpdate()
	{
		if(!queuedCaretUpdate)
			return;
		try
		{
			// When the user is typing, etc, we don't want the caret
			// to blink
			blink = true;
			caretTimer.restart();
			if(!displayManager.isLineVisible(caretLine))
			{
				if(caretLine < displayManager.getFirstVisibleLine()
					|| caretLine > displayManager.getLastVisibleLine())
				{
					int collapseFolds = buffer.getIntegerProperty(
						""collapseFolds"",0);
					if(collapseFolds != 0)
					{
						displayManager.expandFolds(collapseFolds);
						displayManager.expandFold(caretLine,false);
					}
					else
						displayManager.expandAllFolds();
				}
				else
					displayManager.expandFold(caretLine,false);
			}
			scrollToCaret(queuedScrollToElectric);
			updateBracketHighlightWithDelay();
			if(queuedFireCaretEvent)
				fireCaretEvent();
		}
		// in case one of the above fails, we still want to
		// clear these flags.
		finally
		{
			queuedCaretUpdate = queuedScrollToElectric
				= queuedFireCaretEvent = false;
		}
	} //}}}
	//{{{ getSelectionStartEndOnLine() method
	/**
	 * Returns the x co-ordinates of the selection start and end on the
	 * given line. May return null.
	 */
	int[] getSelectionStartAndEnd(int screenLine, int physicalLine,
		Selection s)
	{
		int start = getScreenLineStartOffset(screenLine);
		int end = getScreenLineEndOffset(screenLine);
		if(end <= s.start || start > s.end)
			return null;
		int selStartScreenLine;
		if(displayManager.isLineVisible(s.startLine))
			selStartScreenLine = getScreenLineOfOffset(s.start);
		else
			selStartScreenLine = -1;
		int selEndScreenLine;
		if(displayManager.isLineVisible(s.endLine))
			selEndScreenLine = getScreenLineOfOffset(s.end);
		else
			selEndScreenLine = -1;
		int lineStart = buffer.getLineStartOffset(physicalLine);
		int x1, x2;
		if(s instanceof Selection.Rect)
		{
			start -= lineStart;
			end -= lineStart;
			Selection.Rect rect = (Selection.Rect)s;
			int _start = rect.getStartColumn(buffer);
			int _end = rect.getEndColumn(buffer);
			int lineLen = buffer.getLineLength(physicalLine);
			int[] total = new int[1];
			int rectStart = buffer.getOffsetOfVirtualColumn(
				physicalLine,_start,total);
			if(rectStart == -1)
			{
				x1 = (_start - total[0]) * charWidth;
				rectStart = lineLen;
			}
			else
				x1 = 0;
			int rectEnd = buffer.getOffsetOfVirtualColumn(
				physicalLine,_end,total);
			if(rectEnd == -1)
			{
				x2 = (_end - total[0]) * charWidth;
				rectEnd = lineLen;
			}
			else
				x2 = 0;
			if(end <= rectStart || start > rectEnd)
				return null;
			x1 = (rectStart < start ? 0
				: x1 + offsetToXY(physicalLine,
				rectStart,returnValue).x);
			x2 = (rectEnd > end ? getWidth()
				: x2 + offsetToXY(physicalLine,
				rectEnd,returnValue).x);
		}
		else if(selStartScreenLine == selEndScreenLine
			&& selStartScreenLine != -1)
		{
			x1 = offsetToXY(physicalLine,
				s.start - lineStart,returnValue).x;
			x2 = offsetToXY(physicalLine,
				s.end - lineStart,returnValue).x;
		}
		else if(screenLine == selStartScreenLine)
		{
			x1 = offsetToXY(physicalLine,
				s.start - lineStart,returnValue).x;
			x2 = getWidth();
		}
		else if(screenLine == selEndScreenLine)
		{
			x1 = 0;
			x2 = offsetToXY(physicalLine,
				s.end - lineStart,returnValue).x;
		}
		else
		{
			x1 = 0;
			x2 = getWidth();
		}
		if(x1 < 0)
			x1 = 0;
		if(x2 < 0)
			x2 = 0;
		if(x1 == x2)
			x2++;
		return new int[] { x1, x2 };
	} //}}}
	//{{{ insideSelection() method
	/**
	 * Returns if the given point is inside a selection.
	 * Used by drag and drop code in MouseHandler below.
	 */
	boolean insideSelection(int x, int y)
	{
		int offset = xyToOffset(x,y);
		Selection s = getSelectionAtOffset(offset);
		if(s == null)
			return false;
		int screenLine = getScreenLineOfOffset(offset);
		if(screenLine == -1)
			return false;
		int[] selectionStartAndEnd = getSelectionStartAndEnd(
			screenLine,buffer.getLineOfOffset(offset),s);
		if(selectionStartAndEnd == null)
			return false;
		return x >= selectionStartAndEnd[0]
			&& x <= selectionStartAndEnd[1];
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Static variables
	private static final String CENTER = ""center"";
	private static final String RIGHT = ""right"";
	private static final String LEFT = ""left"";
	private static final String BOTTOM = ""bottom"";
	private static final String TOP = ""top"";
	private static Timer caretTimer;
	private static Timer structureTimer;
	private static JEditTextArea focusedComponent;
	//}}}
	//{{{ Instance variables
	private View view;
	private Gutter gutter;
	private TextAreaPainter painter;
	private JPopupMenu popup;
	private boolean popupEnabled;
	private EventListenerList listenerList;
	private MutableCaretEvent caretEvent;
	private boolean caretBlinks;
	private boolean blink;
	private int physLastLine;
	private int screenLastLine;
	private int visibleLines;
	private int electricScroll;
	private int horizontalOffset;
	private boolean quickCopy;
	// JDiff, error list add stuff here
	private Box verticalBox;
	private JScrollBar vertical;
	private JScrollBar horizontal;
	private Buffer buffer;
	private int caret;
	private int caretLine;
	private int caretScreenLine;
	private List structureMatchers;
	private StructureMatcher.Match match;
	private int magicCaret;
	private boolean multi;
	private boolean overwrite;
	private boolean rectangularSelectionMode;
	/* on JDK 1.4, this is set to a method by Java14. The method must take
	* these parameters:
	* - a JEditTextArea
	* - an InputEvent
	* - a boolean (copy text or move, depending on modifier user held down)
	*/
	private boolean dndEnabled;
	private Method dndCallback;
	private boolean dndInProgress;
	// see finishCaretUpdate() & _finishCaretUpdate()
	private boolean queuedCaretUpdate;
	private boolean queuedScrollToElectric;
	private boolean queuedFireCaretEvent;
	//}}}
	//{{{ startDragAndDrop() method
	// calls dndCallback via reflection
	private void startDragAndDrop(InputEvent evt, boolean copy)
	{
		try
		{
			dndCallback.invoke(null,new Object[] { this, evt,
				new Boolean(copy) });
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} //}}}
	//{{{ _addToSelection() method
	private void _addToSelection(Selection addMe)
	{
		if(addMe.start > addMe.end)
		{
			throw new IllegalArgumentException(addMe.start
				+ "" > "" + addMe.end);
		}
		else if(addMe.start == addMe.end)
		{
			if(addMe instanceof Selection.Range)
				return;
			else if(addMe instanceof Selection.Rect)
			{
				if(((Selection.Rect)addMe).extraEndVirt == 0)
					return;
			}
		}
		for(int i = 0; i < selection.size(); i++)
		{
			// try and merge existing selections one by
			// one with the new selection
			Selection s = (Selection)selection.elementAt(i);
			if(s.overlaps(addMe))
			{
				addMe.start = Math.min(s.start,addMe.start);
				addMe.end = Math.max(s.end,addMe.end);
				selection.removeElement(s);
				i--;
			}
		}
		addMe.startLine = getLineOfOffset(addMe.start);
		addMe.endLine = getLineOfOffset(addMe.end);
		boolean added = false;
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			if(addMe.start < s.start)
			{
				selection.insertElementAt(addMe,i);
				added = true;
				break;
			}
		}
		if(!added)
			selection.addElement(addMe);
		invalidateLineRange(addMe.startLine,addMe.endLine);
	} //}}}
	//{{{ finishCaretUpdate() method
	/**
	 * the collapsing of scrolling/event firing inside compound edits
	 * greatly speeds up replace-all.
	 */
	private void finishCaretUpdate(boolean doElectricScroll,
		boolean fireCaretEvent)
	{
		this.queuedScrollToElectric |= doElectricScroll;
		this.queuedFireCaretEvent |= fireCaretEvent;
		if(queuedCaretUpdate)
			return;
		queuedCaretUpdate = true;
		if(!buffer.isTransactionInProgress())
			_finishCaretUpdate();
		/* otherwise DisplayManager.BufferChangeHandler calls */
	} //}}}
	//{{{ fireCaretEvent() method
	private void fireCaretEvent()
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == CaretListener.class)
			{
				try
				{
					((CaretListener)listeners[i+1]).caretUpdate(caretEvent);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} //}}}
	//{{{ fireScrollEvent() method
	private void fireScrollEvent(boolean vertical)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == ScrollListener.class)
			{
				try
				{
					if(vertical)
						((ScrollListener)listeners[i+1]).scrolledVertically(this);
					else
						((ScrollListener)listeners[i+1]).scrolledHorizontally(this);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} //}}}
	//{{{ insertTab() method
	private void insertTab()
	{
		int tabSize = buffer.getTabSize();
		if(buffer.getBooleanProperty(""noTabs""))
		{
			int lineStart = getLineStartOffset(caretLine);
			String line = getText(lineStart,caret - lineStart);
			int pos = 0;
			for(int i = 0; i < line.length(); i++)
			{
				switch(line.charAt(pos))
				{
				case '\t':
					pos = 0;
					break;
				default:
					if(++pos >= tabSize)
						pos = 0;
					break;
				}
			}
			setSelectedText(MiscUtilities.createWhiteSpace(
				tabSize - pos,0));
		}
		else
			setSelectedText(""\t"");
	} //}}}
	//{{{ doWordWrap() method
	/**
	 * Does hard wrap.
	 */
	private boolean doWordWrap(boolean spaceInserted)
	{
		if(!hardWrap || maxLineLen <= 0)
			return false;
		buffer.getLineText(caretLine,lineSegment);
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		int len = end - start - 1;
		int caretPos = caret - start;
		// only wrap if we're at the end of a line, or the rest of the
		// line text is whitespace
		for(int i = caretPos; i < len; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch != ' ' && ch != '\t')
				return false;
		}
		int tabSize = buffer.getTabSize();
		String wordBreakChars = buffer.getStringProperty(""wordBreakChars"");
		int lastInLine = 0; // last character before wrap
		int logicalLength = 0; // length with tabs expanded
		int lastWordOffset = -1;
		boolean lastWasSpace = true;
		for(int i = 0; i < caretPos; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch == '\t')
			{
				logicalLength += tabSize - (logicalLength % tabSize);
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(ch == ' ')
			{
				logicalLength++;
				if(!lastWasSpace &&
					logicalLength <= maxLineLen + 1)
				{
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)
			{
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastInLine = i;
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else
			{
				lastInLine = i;
				logicalLength++;
				lastWasSpace = false;
			}
		}
		boolean returnValue;
		int insertNewLineAt;
		if(spaceInserted && logicalLength == maxLineLen
			&& lastInLine == caretPos - 1)
		{
			insertNewLineAt = caretPos;
			returnValue = true;
		}
		else if(logicalLength >= maxLineLen && lastWordOffset != -1)
		{
			insertNewLineAt = lastWordOffset;
			returnValue = false;
		}
		else
			return false;
		try
		{
			buffer.beginCompoundEdit();
			buffer.insert(start + insertNewLineAt,""\n"");
			// caretLine would have been incremented
			// since insertNewLineAt <= caretPos
			buffer.indentLine(caretLine,true);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		/* only ever return true if space was pressed
		 * with logicalLength == maxLineLen */
		return returnValue;
	} //}}}
	//{{{ doWordCount() method
	private void doWordCount(View view, String text)
	{
		char[] chars = text.toCharArray();
		int characters = chars.length;
		int words;
		if(characters == 0)
			words = 0;
		else
			words = 1;
		int lines = 1;
		boolean word = false;
		for(int i = 0; i < chars.length; i++)
		{
			switch(chars[i])
			{
			case '\r': case '\n':
				lines++;
			case ' ': case '\t':
				if(word)
				{
					words++;
					word = false;
				}
				break;
			default:
				word = true;
				break;
			}
		}
		// Fix bug #922951 Off-by-one error in Word Count
		if(!word)
			words--;
		Object[] args = { new Integer(characters), new Integer(words),
			new Integer(lines) };
		GUIUtilities.message(view,""wordcount"",args);
	} //}}}
	//{{{ updateStructureHighlightWithDelay() method
	private void updateBracketHighlightWithDelay()
	{
		structureTimer.stop();
		structureTimer.start();
	} //}}}
	//{{{ updateStructureHighlight() method
	private void updateStructureHighlight()
	{
		if(!painter.isStructureHighlightEnabled()
			&& !gutter.isStructureHighlightEnabled())
			return;
		Iterator iter = structureMatchers.iterator();
		while(iter.hasNext())
		{
			StructureMatcher matcher = (StructureMatcher)
				iter.next();
			match = matcher.getMatch(this);
			if(match != null)
				break;
		}
		if(match != null)
		{
			if(caretLine < match.startLine)
				invalidateLineRange(caretLine,match.endLine);
			else
				invalidateLineRange(match.startLine,caretLine);
			if(!displayManager.isLineVisible(match.startLine)
				|| chunkCache.getScreenLineOfOffset(
				match.startLine,match.start - getLineStartOffset(match.startLine))
				== -1)
			{
				showStructureStatusMessage(match.startLine < caretLine);
			}
		}
	} //}}}
	//{{{ showStructureStatusMessage() method
	private void showStructureStatusMessage(boolean backward)
	{
		String text = buffer.getLineText(match.startLine).trim();
		if(backward && match.startLine != 0 && text.length() == 1)
		{
			switch(text.charAt(0))
			{
			case '{': case '}':
			case '[': case ']':
			case '(': case ')':
				text = buffer.getLineText(match.startLine - 1)
					.trim() + "" "" + text;
				break;
			}
		}
		// get rid of embedded tabs not removed by trim()
		text = text.replace('\t',' ');
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.bracket"",new Object[] { 
			new Integer(match.startLine + 1), text }));
	} //}}}
	//{{{ recalculateLastPhysicalLine() method
	void recalculateLastPhysicalLine()
	{
		int oldScreenLastLine = screenLastLine;
		for(int i = visibleLines - 1; i >= 0; i--)
		{
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
			if(info.physicalLine != -1)
			{
				physLastLine = info.physicalLine;
				screenLastLine = i;
				break;
			}
		}
		invalidateScreenLineRange(oldScreenLastLine,screenLastLine);
	} //}}}
	//{{{ getRectParams() method
	static class RectParams
	{
		int extraStartVirt;
		int extraEndVirt;
		int newCaret;
		RectParams(int extraStartVirt, int extraEndVirt, int newCaret)
		{
			this.extraStartVirt = extraStartVirt;
			this.extraEndVirt = extraEndVirt;
			this.newCaret = newCaret;
		}
	}
	/**
	 * Used when doing S+UP/DOWN to simplify dealing with virtual space.
	 */
	private RectParams getRectParams(int caret, int newCaret)
	{
		Selection s = getSelectionAtOffset(caret);
		int virtualWidth;
		if(s instanceof Selection.Rect)
		{
			if(caret == s.end)
			{
				virtualWidth = buffer.getVirtualWidth(
					s.endLine,s.end - getLineStartOffset(
					s.endLine)) + ((Selection.Rect)s).extraEndVirt;
			}
			else
			{
				virtualWidth = buffer.getVirtualWidth(
					s.startLine,s.start - getLineStartOffset(
					s.startLine)) + ((Selection.Rect)s).extraStartVirt;
			}
		}
		else if(rectangularSelectionMode)
		{
			virtualWidth = buffer.getVirtualWidth(
				caretLine,caret - buffer.getLineStartOffset(caretLine));
		}
		else
			return null;
		int newLine = getLineOfOffset(newCaret);
		int[] totalVirtualWidth = new int[1];
		int newOffset = buffer.getOffsetOfVirtualColumn(newLine,
			virtualWidth,totalVirtualWidth);
		if(newOffset == -1)
		{
			int extraVirt = virtualWidth - totalVirtualWidth[0];
			newCaret = getLineEndOffset(newLine) - 1;
			RectParams returnValue;
			boolean bias;
			if(s == null)
				bias = (newCaret < caret);
			else if(s.start == caret)
				bias = (newCaret <= s.end);
			else if(s.end == caret)
				bias = (newCaret <= s.start);
			else
				bias = false;
			if(bias)
				returnValue = new RectParams(extraVirt,0,newCaret);
			else
				returnValue = new RectParams(0,extraVirt,newCaret);
			return returnValue;
		}
		else
		{
			return new RectParams(0,0,getLineStartOffset(newLine)
				+ newOffset);
		}
	} //}}}
	//{{{ delete() method
	private void delete(boolean forward)
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
		{
			Selection[] selections = getSelection();
			for(int i = 0; i < selections.length; i++)
			{
				Selection s = selections[i];
				if(s instanceof Selection.Rect)
				{
					Selection.Rect r = (Selection.Rect)s;
					int startColumn = r.getStartColumn(buffer);
					if(startColumn == r.getEndColumn(buffer))
					{
						if(!forward && startColumn == 0)
							getToolkit().beep();
						else
							tallCaretDelete(r,forward);
					}
					else
						setSelectedText(s,null);
				}
				else
					setSelectedText(s,null);
			}
		}
		else if(forward)
		{
			if(caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			buffer.remove(caret,1);
		}
		else
		{
			if(caret == 0)
			{
				getToolkit().beep();
				return;
			}
			buffer.remove(caret - 1,1);
		}
	} //}}}
	//{{{ tallCaretDelete() method
	private void tallCaretDelete(Selection.Rect s, boolean forward)
	{
		try
		{
			buffer.beginCompoundEdit();
			int[] width = new int[1];
			int startCol = s.getStartColumn(buffer);
			int startLine = s.startLine;
			int endLine = s.endLine;
			for(int i = startLine; i <= endLine; i++)
			{
				int offset = buffer.getOffsetOfVirtualColumn(
					i,startCol,width);
				if(offset == -1)
				{
					if(width[0] == startCol)
						offset = getLineLength(i);
					else
					{
						if(i == startLine && !forward)
							shiftTallCaretLeft(s);
						continue;
					}
				}
				offset += buffer.getLineStartOffset(i);
				if(forward)
				{
					if(offset != buffer.getLineEndOffset(i) - 1)
						buffer.remove(offset,1);
				}
				else
					buffer.remove(offset-1,1);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} //}}}
	//{{{ shiftTallCaretLeft() method
	private void shiftTallCaretLeft(Selection.Rect s)
	{
		removeFromSelection(s);
		addToSelection(new Selection.Rect(
			buffer,
			s.getStartLine(),s.getStartColumn(buffer) - 1,
			s.getEndLine(),s.getEndColumn(buffer) - 1));
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ TextAreaBorder class
	static class TextAreaBorder extends AbstractBorder
	{
		//{{{ paintBorder() method
		public void paintBorder(Component c, Graphics g, int x, int y,
			int width, int height)
		{
			g.translate(x,y);
			g.setColor(MetalLookAndFeel.getControlDarkShadow());
			g.drawRect(0,0,width-2,height-2);
			g.setColor(MetalLookAndFeel.getControlHighlight());
			g.drawLine(width-1,1,width-1,height-1);
			g.drawLine(1,height-1,width-1,height-1);
			g.setColor(MetalLookAndFeel.getControl());
			g.drawLine(width-2,2,width-2,2);
			g.drawLine(1,height-2,1,height-2);
			g.translate(-x,-y);
		} //}}}
		//{{{ getBorderInsets() method
		public Insets getBorderInsets(Component c)
		{
			return new Insets(1,1,2,2);
		} //}}}
	} //}}}
	//{{{ ScrollLayout class
	class ScrollLayout implements LayoutManager
	{
		//{{{ addLayoutComponent() method
		public void addLayoutComponent(String name, Component comp)
		{
			if(name.equals(CENTER))
				center = comp;
			else if(name.equals(RIGHT))
				right = comp;
			else if(name.equals(LEFT))
				left = comp;
			else if(name.equals(BOTTOM))
				bottom = comp;
			else if(name.equals(TOP))
				top = comp;
		} //}}}
		//{{{ removeLayoutComponent() method
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			else if(right == comp)
				right = null;
			else if(left == comp)
				left = null;
			else if(bottom == comp)
				bottom = null;
			else if(top == comp)
				top = null;
		} //}}}
		//{{{ preferredLayoutSize() method
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}
			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;
			Dimension leftPref = left.getPreferredSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getPreferredSize();
			dim.width += centerPref.width;
			dim.height += centerPref.height;
			Dimension rightPref = right.getPreferredSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getPreferredSize();
			dim.height += bottomPref.height;
			if(top != null)
			{
				Dimension topPref = top.getPreferredSize();
				dim.height += topPref.height;
			}
			return dim;
		} //}}}
		//{{{ minimumLayoutSize() method
		public Dimension minimumLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}
			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;
			Dimension leftPref = left.getMinimumSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getMinimumSize();
			dim.width += centerPref.width; 
			dim.height += centerPref.height;
			Dimension rightPref = right.getMinimumSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getMinimumSize();
			dim.height += bottomPref.height;
			if(top != null)
			{
				Dimension topPref = top.getMinimumSize();
				dim.height += topPref.height;
			}
			return dim;
		} //}}}
		//{{{ layoutContainer() method
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}
			int itop = insets.top;
			int ileft = insets.left;
			int ibottom = insets.bottom;
			int iright = insets.right;
			int rightWidth = right.getPreferredSize().width;
			int leftWidth = left.getPreferredSize().width;
			int topHeight;
			if(top != null)
			{
				topHeight = top.getPreferredSize().height;
			}
			else
			{
				topHeight = 0;
			}
			int bottomHeight = bottom.getPreferredSize().height;
			int centerWidth = Math.max(0,size.width - leftWidth
				- rightWidth - ileft - iright);
			int centerHeight = Math.max(0,size.height - topHeight
				- bottomHeight - itop - ibottom);
			left.setBounds(
				ileft,
				itop+topHeight,
				leftWidth,
				centerHeight);
			center.setBounds(
				ileft + leftWidth,
				itop+topHeight,
				centerWidth,
				centerHeight);
			right.setBounds(
				ileft + leftWidth + centerWidth,
				itop+topHeight,
				rightWidth,
				centerHeight);
			bottom.setBounds(
				ileft,
				itop + topHeight + centerHeight,
				/* silly that we reference the vertical
				   scroll bar here directly. we do this so
				   that the horizontal scroll bar is flush
				   with the vertical scroll bar */
				Math.max(0,size.width - vertical.getWidth()
					- ileft - iright),
				bottomHeight);
			if(top != null)
			{
				top.setBounds(
					ileft,
					itop,
					leftWidth+centerWidth+rightWidth,
					topHeight);
			}
		} //}}}
		Component center;
		Component left;
		Component right;
		Component bottom;
		Component top;
	} //}}}
	//{{{ CaretBlinker class
	static class CaretBlinker implements ActionListener
	{
		//{{{ actionPerformed() method
		public void actionPerformed(ActionEvent evt)
		{
			if(focusedComponent != null && focusedComponent.hasFocus())
				focusedComponent.blinkCaret();
		} //}}}
	} //}}}
	//{{{ MutableCaretEvent class
	class MutableCaretEvent extends CaretEvent
	{
		//{{{ MutableCaretEvent constructor
		MutableCaretEvent()
		{
			super(JEditTextArea.this);
		} //}}}
		//{{{ getDot() method
		public int getDot()
		{
			return getCaretPosition();
		} //}}}
		//{{{ getMark() method
		public int getMark()
		{
			return getMarkPosition();
		} //}}}
	} //}}}
	//{{{ AdjustHandler class
	class AdjustHandler implements AdjustmentListener
	{
		//{{{ adjustmentValueChanged() method
		public void adjustmentValueChanged(final AdjustmentEvent evt)
		{
			if(!scrollBarsInitialized)
				return;
			if(evt.getAdjustable() == vertical)
				setFirstLine(vertical.getValue());
			else
				setHorizontalOffset(-horizontal.getValue());
		} //}}}
	} //}}}
	//{{{ FocusHandler class
	class FocusHandler implements FocusListener
	{
		//{{{ focusGained() method
		public void focusGained(FocusEvent evt)
		{
			if(bufferChanging)
				return;
			if(match != null)
			{
				if(caretLine < match.startLine)
					invalidateLineRange(caretLine,match.endLine);
				else
					invalidateLineRange(match.startLine,caretLine);
			}
			else
				invalidateLine(caretLine);
			focusedComponent = JEditTextArea.this;
		} //}}}
		//{{{ focusLost() method
		public void focusLost(FocusEvent evt)
		{
			if(!isShowing())
				return;
			if(match != null)
			{
				if(caretLine < match.startLine)
					invalidateLineRange(caretLine,match.endLine);
				else
					invalidateLineRange(match.startLine,caretLine);
			}
			else
				invalidateLine(caretLine);
		} //}}}
	} //}}}
	//{{{ MouseHandler class
	class MouseHandler extends MouseInputAdapter
	{
		private int dragStartLine;
		private int dragStartOffset;
		private int dragStart;
		private int clickCount;
		private boolean dragged;
		private boolean quickCopyDrag;
		private boolean clearStatus;
		private boolean control;
		/* with drag and drop on, a mouse down in a selection does not
		immediately deselect */
		private boolean maybeDragAndDrop;
		//{{{ mousePressed() method
		public void mousePressed(MouseEvent evt)
		{
			control = (OperatingSystem.isMacOS() && evt.isMetaDown())
				|| (!OperatingSystem.isMacOS() && evt.isControlDown());
			// so that Home <mouse click> Home is not the same
			// as pressing Home twice in a row
			view.getInputHandler().resetLastActionCount();
			quickCopyDrag = (isQuickCopyEnabled() &&
				GUIUtilities.isMiddleButton(evt.getModifiers()));
			if(!quickCopyDrag)
			{
				requestFocus();
				focusedComponent = JEditTextArea.this;
			}
			if(!buffer.isLoaded())
				return;
			int x = evt.getX();
			int y = evt.getY();
			dragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()
				|| isOverwriteEnabled()));
			dragStartLine = getLineOfOffset(dragStart);
			dragStartOffset = dragStart - getLineStartOffset(dragStartLine);
			if(GUIUtilities.isPopupTrigger(evt) && popup != null)
			{
				if(popupEnabled)
					handlePopupTrigger(evt);
				return;
			}
			dragged = false;
			blink = true;
			invalidateLine(caretLine);
			clickCount = evt.getClickCount();
			if(isDragEnabled() && getDragAndDropCallback() != null
				&& insideSelection(x,y)
				&& clickCount == 1 && !evt.isShiftDown())
			{
				maybeDragAndDrop = true;
				moveCaretPosition(dragStart,false);
				return;
			}
			else
				maybeDragAndDrop = false;
			switch(clickCount)
			{
			case 1:
				doSingleClick(evt);
				break;
			case 2:
				doDoubleClick();
				break;
			default: //case 3:
				doTripleClick();
				break;
			}
		} //}}}
		//{{{ doSingleClick() method
		private void doSingleClick(MouseEvent evt)
		{
			/* if(buffer.insideCompoundEdit())
				buffer.endCompoundEdit(); */
			int x = evt.getX();
			int extraEndVirt = 0;
			if(chunkCache.getLineInfo(screenLastLine).lastSubregion)
			{
				float dragStartLineWidth = offsetToXY(
					dragStartLine,getLineLength(dragStartLine),
					returnValue).x;
				if(x > dragStartLineWidth)
				{
					extraEndVirt = (int)(
						(x - dragStartLineWidth)
						/ charWidth);
					if(!getPainter().isBlockCaretEnabled()
						&& !isOverwriteEnabled()
						&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)
					{
						extraEndVirt++;
					}
				}
			}
			if(control || isRectangularSelectionEnabled())
			{
				int screenLine = (evt.getY() / getPainter()
					.getFontMetrics().getHeight());
				if(screenLine > screenLastLine)
					screenLine = screenLastLine;
				ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);
				if(info.lastSubregion && extraEndVirt != 0)
				{
					if(!isEditable())
					{
						getToolkit().beep();
						return;
					}
					// control-click in virtual space inserts
					// whitespace and moves caret
					String whitespace = MiscUtilities
						.createWhiteSpace(extraEndVirt,0);
					buffer.insert(dragStart,whitespace);
					dragStart += whitespace.length();
				}
			}
			if(evt.isShiftDown())
			{
				// XXX: getMarkPosition() deprecated!
				resizeSelection(getMarkPosition(),dragStart,extraEndVirt,
					isRectangularSelectionEnabled()
					|| control);
				if(!quickCopyDrag)
					moveCaretPosition(dragStart,false);
				// so that shift-click-drag works
				dragStartLine = getMarkLine();
				dragStart = getMarkPosition();
				dragStartOffset = dragStart
					- getLineStartOffset(dragStartLine);
				// so that quick copy works
				dragged = true;
				return;
			}
			if(!quickCopyDrag)
				moveCaretPosition(dragStart,false);
			if(!(multi || quickCopyDrag))
				selectNone();
		} //}}}
		//{{{ doDoubleClick() method
		private void doDoubleClick()
		{
			// Ignore empty lines
			if(getLineLength(dragStartLine) == 0)
				return;
			String lineText = getLineText(dragStartLine);
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			if(dragStartOffset == getLineLength(dragStartLine))
				dragStartOffset--;
			boolean joinNonWordChars =
				jEdit.getBooleanProperty(""view.joinNonWordChars"");
			int wordStart = TextUtilities.findWordStart(lineText,
				dragStartOffset,noWordSep,joinNonWordChars);
			int wordEnd = TextUtilities.findWordEnd(lineText,
				dragStartOffset+1,noWordSep,joinNonWordChars);
			int lineStart = getLineStartOffset(dragStartLine);
			Selection sel = new Selection.Range(
				lineStart + wordStart,
				lineStart + wordEnd);
			if(isMultipleSelectionEnabled())
				addToSelection(sel);
			else
				setSelection(sel);
			if(quickCopyDrag)
				quickCopyDrag = false;
			moveCaretPosition(lineStart + wordEnd,false);
			dragged = true;
		} //}}}
		//{{{ doTripleClick() method
		private void doTripleClick()
		{
			int newCaret = getLineEndOffset(dragStartLine);
			if(dragStartLine == buffer.getLineCount() - 1)
				newCaret--;
			Selection sel = new Selection.Range(
				getLineStartOffset(dragStartLine),
				newCaret);
			if(isMultipleSelectionEnabled())
				addToSelection(sel);
			else
				setSelection(sel);
			if(quickCopyDrag)
				quickCopyDrag = false;
			moveCaretPosition(newCaret,false);
			dragged = true;
		} //}}}
		//{{{ mouseDragged() method
		public void mouseDragged(MouseEvent evt)
		{
			if(maybeDragAndDrop)
			{
				startDragAndDrop(evt,control);
				return;
			}
			if(dndInProgress)
				return;
			if(GUIUtilities.isPopupTrigger(evt)
				|| (popup != null && popup.isVisible()))
				return;
			if(!buffer.isLoaded())
				return;
			if(evt.getY() < 0)
			{
				int delta = Math.min(-1,evt.getY()
					/ painter.getFontMetrics()
					.getHeight());
				setFirstLine(getFirstLine() + delta);
			}
			else if(evt.getY() >= painter.getHeight())
			{
				int delta = Math.max(1,(evt.getY()
					- painter.getHeight()) /
					painter.getFontMetrics()
					.getHeight());
				if(lastLinePartial)
					delta--;
				setFirstLine(getFirstLine() + delta);
			}
			if(quickCopyDrag)
			{
				view.getStatus().setMessage(jEdit.getProperty(
					""view.status.rect-quick-copy""));
				clearStatus = true;
			}
			switch(clickCount)
			{
			case 1:
				doSingleDrag(evt);
				break;
			case 2:
				doDoubleDrag(evt);
				break;
			default: //case 3:
				doTripleDrag(evt);
				break;
			}
		} //}}}
		//{{{ doSingleDrag() method
		private void doSingleDrag(MouseEvent evt)
		{
			dragged = true;
			int x = evt.getX();
			int y = evt.getY();
			if(y < 0)
				y = 0;
			else if(y >= painter.getHeight())
				y = painter.getHeight() - 1;
			int dot = xyToOffset(x,y,
				(!painter.isBlockCaretEnabled()
				&& !isOverwriteEnabled())
				|| quickCopyDrag);
			int dotLine = buffer.getLineOfOffset(dot);
			int extraEndVirt = 0;
			if(chunkCache.getLineInfo(screenLastLine).lastSubregion)
			{
				float dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),
					returnValue).x;
				if(x > dotLineWidth)
				{
					extraEndVirt = (int)((x - dotLineWidth) / charWidth);
					if(!getPainter().isBlockCaretEnabled()
						&& !isOverwriteEnabled()
						&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)
						extraEndVirt++;
				}
			}
			resizeSelection(dragStart,dot,extraEndVirt,
				isRectangularSelectionEnabled()
				|| control);
			if(quickCopyDrag)
			{
				// just scroll to the dragged location
				scrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);
			}
			else
			{
				if(dot != caret)
					moveCaretPosition(dot,false);
				if(isRectangularSelectionEnabled()
					&& extraEndVirt != 0)
				{
					scrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)
						+ extraEndVirt,false);
				}
			}
		} //}}}
		//{{{ doDoubleDrag() method
		private void doDoubleDrag(MouseEvent evt)
		{
			int markLineStart = getLineStartOffset(dragStartLine);
			int markLineLength = getLineLength(dragStartLine);
			int mark = dragStartOffset;
			int pos = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				!(painter.isBlockCaretEnabled() || isOverwriteEnabled()));
			int line = getLineOfOffset(pos);
			int lineStart = getLineStartOffset(line);
			int lineLength = getLineLength(line);
			int offset = pos - lineStart;
			String lineText = getLineText(line);
			String markLineText = getLineText(dragStartLine);
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			boolean joinNonWordChars =
				jEdit.getBooleanProperty(""view.joinNonWordChars"");
			if(markLineStart + dragStartOffset > lineStart + offset)
			{
				if(offset != 0 && offset != lineLength)
				{
					offset = TextUtilities.findWordStart(
						lineText,offset,noWordSep,
						joinNonWordChars);
				}
				if(markLineLength != 0)
				{
					mark = TextUtilities.findWordEnd(
						markLineText,mark,noWordSep,
						joinNonWordChars);
				}
			}
			else
			{
				if(offset != 0 && lineLength != 0)
				{
					offset = TextUtilities.findWordEnd(
						lineText,offset,noWordSep,
						joinNonWordChars);
				}
				if(mark != 0 && mark != markLineLength)
				{
					mark = TextUtilities.findWordStart(
						markLineText,mark,noWordSep,
						joinNonWordChars);
				}
			}
			if(lineStart + offset == caret)
				return;
			resizeSelection(markLineStart + mark,lineStart + offset,
				0,false);
			moveCaretPosition(lineStart + offset,false);
			dragged = true;
		} //}}}
		//{{{ doTripleDrag() method
		private void doTripleDrag(MouseEvent evt)
		{
			int offset = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				false);
			int mouseLine = getLineOfOffset(offset);
			int mark;
			int mouse;
			if(dragStartLine > mouseLine)
			{
				mark = getLineEndOffset(dragStartLine) - 1;
				if(offset == getLineEndOffset(mouseLine) - 1)
					mouse = offset;
				else
					mouse = getLineStartOffset(mouseLine);
			}
			else
			{
				mark = getLineStartOffset(dragStartLine);
				if(offset == getLineStartOffset(mouseLine))
					mouse = offset;
				else if(offset == getLineEndOffset(mouseLine) - 1
					&& mouseLine != getBuffer().getLineCount() - 1)
					mouse = getLineEndOffset(mouseLine);
				else
					mouse = getLineEndOffset(mouseLine) - 1;
			}
			mouse = Math.min(getBuffer().getLength(),mouse);
			if(mouse == caret)
				return;
			resizeSelection(mark,mouse,0,false);
			moveCaretPosition(mouse,false);
			dragged = true;
		} //}}}
		//{{{ mouseReleased() method
		public void mouseReleased(MouseEvent evt)
		{
			// middle mouse button drag inserts selection
			// at caret position
			Selection sel = getSelectionAtOffset(dragStart);
			if(dragged && sel != null)
			{
				Registers.setRegister('%',getSelectedText(sel));
				if(quickCopyDrag)
				{
					removeFromSelection(sel);
					Registers.paste(focusedComponent,
						'%',sel instanceof Selection.Rect);
					focusedComponent.requestFocus();
				}
			}
			else if(!dragged && isQuickCopyEnabled() &&
				GUIUtilities.isMiddleButton(evt.getModifiers()))
			{
				JEditTextArea.this.requestFocus();
				focusedComponent = JEditTextArea.this;
				setCaretPosition(dragStart,false);
				if(!isEditable())
					getToolkit().beep();
				else
					Registers.paste(JEditTextArea.this,'%',control);
			}
			else if(maybeDragAndDrop && !isMultipleSelectionEnabled())
			{
				selectNone();
			}
			dragged = false;
			if(clearStatus)
			{
				clearStatus = false;
				view.getStatus().setMessage(null);
			}
		} //}}}
	} //}}}
	//}}}
	//{{{ Class initializer
	static
	{
		caretTimer = new Timer(500,new CaretBlinker());
		caretTimer.setInitialDelay(500);
		caretTimer.start();
		structureTimer = new Timer(100,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(focusedComponent != null)
					focusedComponent.updateStructureHighlight();
			}
		});
		structureTimer.setInitialDelay(100);
		structureTimer.setRepeats(false);
	} //}}}
}
"
org.gjt.sp.jedit.textarea.MouseActions,"/*
 * MouseActions.java - Simplifies mouse handling
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.event.MouseEvent;
import org.gjt.sp.jedit.gui.DefaultInputHandler;
import org.gjt.sp.jedit.jEdit;
public class MouseActions
{
	//{{{ MouseActions constructor
	MouseActions(String name)
	{
		this.name = name;
	} //}}}
	//{{{ getActionForEvent() method
	String getActionForEvent(MouseEvent evt, String variant)
	{
		String modStr = DefaultInputHandler.getModifierString(evt);
		if(modStr == null)
		{
			return jEdit.getProperty(""view."" + name + "".""
				+ variant + ""Click"");
		}
		else
		{
			return jEdit.getProperty(""view."" + name + "".""
				+ DefaultInputHandler.getModifierString(evt)
				+ variant + ""Click"");
		}
	} //}}}
	private String name;
}
"
org.gjt.sp.jedit.textarea.ScrollListener,"/*
 * ScrollListener.java - Text area scroll listener
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
/**
 * A scroll listener will be notified when the text area is scrolled, either
 * horizontally or vertically.
 * @author Slava Pestov
 * @version $Id: ScrollListener.java,v 1.1.1.1 2001/09/02 05:38:14 spestov Exp $
 * @since jEdit 3.2pre2
 */
public interface ScrollListener extends java.util.EventListener
{
	void scrolledVertically(JEditTextArea textArea);
	void scrolledHorizontally(JEditTextArea textArea);
}
"
org.gjt.sp.jedit.textarea.Selection,"/*
 * Selection.java - Selected text
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001, 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import java.util.ArrayList;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.MiscUtilities;
//}}}
/**
 * An abstract class that holds data on a region of selected text.
 * As an abstract class, it cannot be used
 * directly, but instead serves as a parent class for two specific types
 * of selection structures:
 * <ul>
 * <li>{@link Selection.Range} - represents an ordinary range of selected text.</li>
 * <li>{@link Selection.Rect} - represents a rectangular selection.</li>
 * </ul>
 *
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: Selection.java,v 1.22 2004/04/06 19:05:31 spestov Exp $
 * @since jEdit 3.2pre1
 */
public abstract class Selection implements Cloneable
{
	//{{{ getStart() method
	/**
	 * Returns the start offset of this selection.
	 */
	public int getStart()
	{
		return start;
	} //}}}
	//{{{ getEnd() method
	/**
	 * Returns the end offset of this selection.
	 */
	public int getEnd()
	{
		return end;
	} //}}}
	//{{{ getStart() method
	/**
	 * Returns the beginning of the portion of the selection
	 * falling on the specified line. Used to manipulate
         * selection text on a line-by-line basis.
	 * @param buffer The buffer
	 * @param line The line number
	 * @since jEdit 4.1pre1
	 */
	public abstract int getStart(Buffer buffer, int line);
	//}}}
	//{{{ getEnd() method
	/**
	 * Returns the end of the portion of the selection
	 * falling on the specified line. Used to manipulate
         * selection text on a line-by-line basis.
	 * @param buffer The buffer
	 * @param line The line number
	 * @since jEdit 4.1pre1
	 */
	public abstract int getEnd(Buffer buffer, int line);
	//}}}
	//{{{ getStartLine() method
	/**
	 * Returns the starting line number of this selection.
	 */
	public int getStartLine()
	{
		return startLine;
	} //}}}
	//{{{ getEndLine() method
	/**
	 * Returns the ending line number of this selection.
	 */
	public int getEndLine()
	{
		return endLine;
	} //}}}
	//{{{ overlaps() method
	/**
	 * Returns if this selection and the specified selection overlap.
	 * @param s The other selection
	 * @since jEdit 4.1pre1
	 */
	public boolean overlaps(Selection s)
	{
		if((start >= s.start && start <= s.end)
			|| (end >= s.start && end <= s.end))
			return true;
		else
			return false;
	} //}}}
	//{{{ toString() method
	public String toString()
	{
		return getClass().getName() + ""[start="" + start
			+ "",end="" + end + "",startLine="" + startLine
			+ "",endLine="" + endLine + ""]"";
	} //}}}
	//{{{ clone() method
	public Object clone()
	{
		try
		{
			return super.clone();
		}
		catch(CloneNotSupportedException e)
		{
			throw new InternalError(""I just drank a whole ""
				+ ""bottle of cough syrup and I feel ""
				+ ""funny!"");
		}
	} //}}}
	//{{{ Package-private members
	int start, end;
	int startLine, endLine;
	//{{{ Selection constructor
	Selection()
	{
	} //}}}
	//{{{ Selection constructor
	Selection(Selection sel)
	{
		this.start = sel.start;
		this.end = sel.end;
	} //}}}
	//{{{ Selection constructor
	Selection(int start, int end)
	{
		this.start = start;
		this.end = end;
	} //}}}
	// should the next two be public, maybe?
	abstract void getText(Buffer buffer, StringBuffer buf);
	abstract int setText(Buffer buffer, String text);
	abstract boolean contentInserted(Buffer buffer, int startLine, int start,
		int numLines, int length);
	abstract boolean contentRemoved(Buffer buffer, int startLine, int start,
		int numLines, int length);
	//}}}
	//{{{ Range class
	/**
	 * An ordinary range selection.
	 * @since jEdit 3.2pre1
	 */
	public static class Range extends Selection
	{
		//{{{ Range constructor
		public Range()
		{
		} //}}}
		//{{{ Range constructor
		public Range(Selection sel)
		{
			super(sel);
		} //}}}
		//{{{ Range constructor
		public Range(int start, int end)
		{
			super(start,end);
		} //}}}
		//{{{ getStart() method
		public int getStart(Buffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
				return buffer.getLineStartOffset(line);
		} //}}}
		//{{{ getEnd() method
		public int getEnd(Buffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
				return buffer.getLineEndOffset(line) - 1;
		} //}}}
		//{{{ Package-private members
		//{{{ getText() method
		void getText(Buffer buffer, StringBuffer buf)
		{
			buf.append(buffer.getText(start,end - start));
		} //}}}
		//{{{ setText() method
		int setText(Buffer buffer, String text)
		{
			buffer.remove(start,end - start);
			if(text != null && text.length() != 0)
			{
				buffer.insert(start,text);
				return start + text.length();
			}
			else
				return start;
		} //}}}
		//{{{ contentInserted() method
		boolean contentInserted(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			boolean changed = false;
			if(this.start >= start)
			{
				this.start += length;
				if(numLines != 0)
					this.startLine = buffer.getLineOfOffset(this.start);
				changed = true;
			}
			if(this.end >= start)
			{
				this.end += length;
				if(numLines != 0)
					this.endLine = buffer.getLineOfOffset(this.end);
				changed = true;
			}
			return changed;
		} //}}}
		//{{{ contentRemoved() method
		boolean contentRemoved(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			int end = start + length;
			boolean changed = false;
			if(this.start > start && this.start <= end)
			{
				this.start = start;
				changed = true;
			}
			else if(this.start > end)
			{
				this.start -= length;
				changed = true;
			}
			if(this.end > start && this.end <= end)
			{
				this.end = start;
				changed = true;
			}
			else if(this.end > end)
			{
				this.end -= length;
				changed = true;
			}
			if(changed && numLines != 0)
			{
				this.startLine = buffer.getLineOfOffset(this.start);
				this.endLine = buffer.getLineOfOffset(this.end);
			}
			return changed;
		} //}}}
		//}}}
	} //}}}
	//{{{ Rect class
	/**
	 * A rectangular selection.
	 * @since jEdit 3.2pre1
	 */
	// this class is not very fast...
	public static class Rect extends Selection
	{
		//{{{ Rect constructor
		public Rect()
		{
			super();
		} //}}}
		//{{{ Rect constructor
		public Rect(Selection sel)
		{
			super(sel);
		} //}}}
		//{{{ Rect constructor
		public Rect(int start, int end)
		{
			super(start,end);
		} //}}}
		//{{{ Rect constructor
		public Rect(int startLine, int start, int endLine, int end)
		{
			this.startLine = startLine;
			this.start = start;
			this.endLine = endLine;
			this.end = end;
		} //}}}
		//{{{ Rect constructor
		public Rect(Buffer buffer, int startLine, int startColumn,
			int endLine, int endColumn)
		{
			this.startLine = startLine;
			this.endLine = endLine;
			int[] width = new int[1];
			int startOffset = buffer.getOffsetOfVirtualColumn(startLine,
				startColumn,width);
			if(startOffset == -1)
			{
				extraStartVirt = startColumn - width[0];
				startOffset = buffer.getLineEndOffset(startLine) - 1;
			}
			else
				startOffset += buffer.getLineStartOffset(startLine);
			int endOffset = buffer.getOffsetOfVirtualColumn(endLine,
				endColumn,width);
			if(endOffset == -1)
			{
				extraEndVirt = endColumn - width[0];
				endOffset = buffer.getLineEndOffset(endLine) - 1;
			}
			else
				endOffset += buffer.getLineStartOffset(endLine);
		} //}}}
		//{{{ getStartColumn() method
		public int getStartColumn(Buffer buffer)
		{
			int virtColStart = buffer.getVirtualWidth(startLine,
				start - buffer.getLineStartOffset(startLine)) + extraStartVirt;
			int virtColEnd = buffer.getVirtualWidth(endLine,
				end - buffer.getLineStartOffset(endLine)) + extraEndVirt;
			return Math.min(virtColStart,virtColEnd);
		} //}}}
		//{{{ getEndColumn() method
		public int getEndColumn(Buffer buffer)
		{
			int virtColStart = buffer.getVirtualWidth(startLine,
				start - buffer.getLineStartOffset(startLine)) + extraStartVirt;
			int virtColEnd = buffer.getVirtualWidth(endLine,
				end - buffer.getLineStartOffset(endLine)) + extraEndVirt;
			return Math.max(virtColStart,virtColEnd);
		} //}}}
		//{{{ getStart() method
		public int getStart(Buffer buffer, int line)
		{
			return getColumnOnOtherLine(buffer,line,
				getStartColumn(buffer));
		} //}}}
		//{{{ getEnd() method
		public int getEnd(Buffer buffer, int line)
		{
			return getColumnOnOtherLine(buffer,line,
				getEndColumn(buffer));
		} //}}}
		//{{{ Package-private members
		int extraStartVirt;
		int extraEndVirt;
		//{{{ getText() method
		void getText(Buffer buffer, StringBuffer buf)
		{
			int start = getStartColumn(buffer);
			int end = getEndColumn(buffer);
			for(int i = startLine; i <= endLine; i++)
			{
				int lineStart = buffer.getLineStartOffset(i);
				int lineLen = buffer.getLineLength(i);
				int rectStart = buffer.getOffsetOfVirtualColumn(
					i,start,null);
				if(rectStart == -1)
					rectStart = lineLen;
				int rectEnd = buffer.getOffsetOfVirtualColumn(
					i,end,null);
				if(rectEnd == -1)
					rectEnd = lineLen;
				if(rectEnd < rectStart)
					System.err.println(i + "":::"" + start + "":"" + end
						+ "" ==> "" + rectStart + "":"" + rectEnd);
				buf.append(buffer.getText(lineStart + rectStart,
					rectEnd - rectStart));
				if(i != endLine)
					buf.append('\n');
			}
		} //}}}
		//{{{ setText() method
		int setText(Buffer buffer, String text)
		{
			int startColumn = getStartColumn(buffer);
			int endColumn = getEndColumn(buffer);
			int[] total = new int[1];
			int tabSize = buffer.getTabSize();
			int maxWidth = 0;
			int totalLines = 0;
			ArrayList lines = new ArrayList();
			//{{{ Split the text into lines
			if(text != null)
			{
				int lastNewline = 0;
				int currentWidth = startColumn;
				for(int i = 0; i < text.length(); i++)
				{
					char ch = text.charAt(i);
					if(ch == '\n')
					{
						totalLines++;
						lines.add(text.substring(
							lastNewline,i));
						lastNewline = i + 1;
						maxWidth = Math.max(maxWidth,currentWidth);
						lines.add(new Integer(currentWidth));
						currentWidth = startColumn;
					}
					else if(ch == '\t')
						currentWidth += tabSize - (currentWidth % tabSize);
					else
						currentWidth++;
				}
				if(lastNewline != text.length())
				{
					totalLines++;
					lines.add(text.substring(lastNewline));
					lines.add(new Integer(currentWidth));
					maxWidth = Math.max(maxWidth,currentWidth);
				}
			} //}}}
			//{{{ Insert the lines into the buffer
			int endOffset = 0;
			int lastLine = Math.max(startLine + totalLines - 1,endLine);
			for(int i = startLine; i <= lastLine; i++)
			{
				if(i == buffer.getLineCount())
					buffer.insert(buffer.getLength(),""\n"");
				int lineStart = buffer.getLineStartOffset(i);
				int lineLen = buffer.getLineLength(i);
				int rectStart = buffer.getOffsetOfVirtualColumn(
					i,startColumn,total);
				int startWhitespace;
				if(rectStart == -1)
				{
					startWhitespace = (startColumn - total[0]);
					rectStart = lineLen;
				}
				else
					startWhitespace = 0;
				int rectEnd = buffer.getOffsetOfVirtualColumn(
					i,endColumn,null);
				if(rectEnd == -1)
					rectEnd = lineLen;
				buffer.remove(rectStart + lineStart,rectEnd - rectStart);
				if(startWhitespace != 0)
				{
					buffer.insert(rectStart + lineStart,
						MiscUtilities.createWhiteSpace(startWhitespace,0));
				}
				int endWhitespace;
				if(totalLines == 0)
				{
					if(rectEnd == lineLen)
						endWhitespace = 0;
					else
						endWhitespace = maxWidth - startColumn;
				}
				else
				{
					int index = 2 * ((i - startLine) % totalLines);
					String str = (String)lines.get(index);
					buffer.insert(rectStart + lineStart + startWhitespace,str);
					if(rectEnd == lineLen)
						endWhitespace = 0;
					else
					{
						endWhitespace = maxWidth
							- ((Integer)lines.get(index+1))
							.intValue();
					}
					startWhitespace += str.length();
				}
				if(endWhitespace != 0)
				{
					buffer.insert(rectStart + lineStart
						+ startWhitespace,
						MiscUtilities.createWhiteSpace(endWhitespace,0));
				}
				endOffset = rectStart + lineStart
					+ startWhitespace
					+ endWhitespace;
			} //}}}
			//{{{ Move the caret down a line
			if(text == null || text.length() == 0)
				return end;
			else
				return endOffset;
			//}}}
		} //}}}
		//{{{ contentInserted() method
		boolean contentInserted(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			if(this.end < start)
				return false;
			this.end += length;
			if(this.startLine > startLine)
			{
				this.start += length;
				if(numLines != 0)
				{
					this.startLine = buffer.getLineOfOffset(
						this.start);
					this.endLine = buffer.getLineOfOffset(
						this.end);
				}
				return true;
			}
			int endVirtualColumn = buffer.getVirtualWidth(
				this.endLine,end
				- buffer.getLineStartOffset(this.endLine));
			if(this.start == start)
			{
				int startVirtualColumn = buffer.getVirtualWidth(
					this.startLine,start
					- buffer.getLineStartOffset(
					this.startLine));
				this.start += length;
				int newStartVirtualColumn
					= buffer.getVirtualWidth(
						startLine,start -
						buffer.getLineStartOffset(
						this.startLine));
				int[] totalVirtualWidth = new int[1];
				int newEnd = buffer.getOffsetOfVirtualColumn(
					this.endLine,endVirtualColumn +
					newStartVirtualColumn -
					startVirtualColumn,
					totalVirtualWidth);
				if(newEnd != -1)
				{
					end = buffer.getLineStartOffset(
						this.endLine) + newEnd;
				}
				else
				{
					end = buffer.getLineEndOffset(
						this.endLine) - 1;
					extraEndVirt = totalVirtualWidth[0]
						- endVirtualColumn;
				}
			}
			else if(this.start > start)
			{
				this.start += length;
				if(numLines != 0)
				{
					this.startLine = buffer.getLineOfOffset(
						this.start);
				}
			}
			if(numLines != 0)
				this.endLine = buffer.getLineOfOffset(this.end);
			int newEndVirtualColumn = buffer.getVirtualWidth(
				endLine,
				end - buffer.getLineStartOffset(this.endLine));
			if(startLine == this.endLine && extraEndVirt != 0)
			{
				extraEndVirt += (endVirtualColumn
					- newEndVirtualColumn);
			}
			else if(startLine == this.startLine
				&& extraStartVirt != 0)
			{
				extraStartVirt += (endVirtualColumn
					- newEndVirtualColumn);
			}
			return true;
		} //}}}
		//{{{ contentRemoved() method
		boolean contentRemoved(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			int end = start + length;
			boolean changed = false;
			if(this.start > start && this.start <= end)
			{
				this.start = start;
				changed = true;
			}
			else if(this.start > end)
			{
				this.start -= length;
				changed = true;
			}
			if(this.end > start && this.end <= end)
			{
				this.end = start;
				changed = true;
			}
			else if(this.end > end)
			{
				this.end -= length;
				changed = true;
			}
			if(changed && numLines != 0)
			{
				this.startLine = buffer.getLineOfOffset(this.start);
				this.endLine = buffer.getLineOfOffset(this.end);
			}
			return changed;
		} //}}}
		//}}}
		//{{{ Private members
		//{{{ getColumnOnOtherLine() method
		private int getColumnOnOtherLine(Buffer buffer, int line,
			int col)
		{
			int returnValue = buffer.getOffsetOfVirtualColumn(
				line,col,null);
			if(returnValue == -1)
				return buffer.getLineEndOffset(line) - 1;
			else
				return buffer.getLineStartOffset(line) + returnValue;
		} //}}}
		//}}}
	} //}}}
}
"
org.gjt.sp.jedit.textarea.StructureMatcher,"/*
 * StructureMatcher.java - Abstract interface for bracket matching, etc.
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import java.awt.*;
import org.gjt.sp.jedit.TextUtilities;
//}}}
/**
 * An interface for matching parts of a source file's stucture. The default
 * implementation matches brackets. The XML plugin provides an implementation
 * for matching XML tags.
 *
 * @author Slava Pestov
 * @version $Id: StructureMatcher.java,v 1.7 2004/08/08 03:41:35 spestov Exp $
 * @since jEdit 4.2pre3
 */
public interface StructureMatcher
{
	//{{{ getMatch() method
	/**
	 * Returns the element matching the one at the given text area's
	 * caret position, or null.
	 * @since jEdit 4.2pre3
	 */
	Match getMatch(JEditTextArea textArea);
	//}}}
	//{{{ selectMatch() method
	/**
	 * Selects from the caret to the matching structure element (if there is
	 * one, otherwise the behavior of this method is undefined).
	 * @since jEdit 4.2pre3
	 */
	void selectMatch(JEditTextArea textArea);
	//}}}
	//{{{ BracketMatcher class
	static class BracketMatcher implements StructureMatcher
	{
		public Match getMatch(JEditTextArea textArea)
		{
			int offset = textArea.getCaretPosition()
				- textArea.getLineStartOffset(
				textArea.getCaretLine());
			if(offset != 0)
			{
				int bracketOffset = TextUtilities.findMatchingBracket(
					textArea.getBuffer(),
					textArea.getCaretLine(),
					offset - 1);
				if(bracketOffset != -1)
				{
					int bracketLine = textArea
						.getLineOfOffset(
						bracketOffset);
					return new Match(this,
						bracketLine,
						bracketOffset,
						bracketLine,
						bracketOffset + 1);
				}
			}
			return null;
		}
		public void selectMatch(JEditTextArea textArea)
		{
			textArea.selectToMatchingBracket();
		}
	} //}}}
	//{{{ Match class
	/**
	 * A structure match, denoted by a start and end position.
	 * @since jEdit 4.2pre3
	 */
	public static class Match
	{
		public StructureMatcher matcher;
		public int startLine;
		public int start;
		public int endLine;
		public int end;
		public Match() {}
		public Match(StructureMatcher matcher)
		{
			this.matcher = matcher;
		}
		public Match(StructureMatcher matcher, int startLine,
			int start, int endLine, int end)
		{
			this(matcher);
			this.startLine = startLine;
			this.start = start;
			this.endLine = endLine;
			this.end = end;
		}
	} //}}}
	//{{{ Highlight class
	/**
	 * Paints the structure match highlight.
	 */
	static class Highlight extends TextAreaExtension
	{
		Highlight(JEditTextArea textArea)
		{
			this.textArea = textArea;
		}
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(!textArea.getPainter().isStructureHighlightEnabled())
				return;
			Match match = textArea.getStructureMatch();
			if(match != null)
			{
				paintHighlight(gfx,screenLine,
					start,end,y,match);
			}
		}
		private int[] getOffsets(int screenLine, Match match)
		{
			int x1, x2;
			int matchStartLine = textArea.getScreenLineOfOffset(
				match.start);
			int matchEndLine = textArea.getScreenLineOfOffset(
				match.end);
			if(matchStartLine == screenLine)
			{
				x1 = match.start;
			}
			else
			{
				x1 = textArea.getScreenLineStartOffset(
					screenLine);
			}
			if(matchEndLine == screenLine)
			{
				x2 = match.end;
			}
			else
			{
				x2 = textArea.getScreenLineEndOffset(
					screenLine) - 1;
			}
			return new int[] {
				textArea.offsetToXY(x1).x,
				textArea.offsetToXY(x2).x
			};
		}
		private void paintHighlight(Graphics gfx, int screenLine,
			int start, int end, int y,
			Match match)
		{
			if(!textArea.isStructureHighlightVisible())
				return;
			if(match.start >= end || match.end < start)
			{
				return;
			}
			int matchStartLine = textArea.getScreenLineOfOffset(
				match.start);
			int matchEndLine = textArea.getScreenLineOfOffset(
				match.end);
			FontMetrics fm = textArea.getPainter().getFontMetrics();
			int height = fm.getHeight();
			int[] offsets = getOffsets(screenLine,match);
			int x1 = offsets[0];
			int x2 = offsets[1];
			gfx.setColor(textArea.getPainter().getStructureHighlightColor());
			gfx.drawLine(x1,y,x1,y + height - 1);
			gfx.drawLine(x2,y,x2,y + height - 1);
			if(matchStartLine == screenLine || screenLine == 0)
				gfx.drawLine(x1,y,x2,y);
			else
			{
				offsets = getOffsets(screenLine - 1,match);
				int prevX1 = offsets[0];
				int prevX2 = offsets[1];
				gfx.drawLine(Math.min(x1,prevX1),y,
					Math.max(x1,prevX1),y);
				gfx.drawLine(Math.min(x2,prevX2),y,
					Math.max(x2,prevX2),y);
			}
			if(matchEndLine == screenLine)
			{
				gfx.drawLine(x1,y + height - 1,
					x2,y + height - 1);
			}
		}
		private JEditTextArea textArea;
	} //}}}
}
"
org.gjt.sp.jedit.textarea.TextAreaExtension,"/*
 * TextAreaExtension.java - Custom painter and tool tip handler
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2002 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.Graphics2D;
/**
 * Subclasses of this class can perform custom painting and tool tip
 * handling in the text area and gutter.
 *
 * @see TextAreaPainter#addExtension(TextAreaExtension)
 * @see TextAreaPainter#removeExtension(TextAreaExtension)
 * @see Gutter#addExtension(TextAreaExtension)
 * @see Gutter#removeExtension(TextAreaExtension)
 *
 * @since jEdit 4.0pre4
 *
 * @author Slava Pestov
 * @version $Id: TextAreaExtension.java,v 1.5 2004/03/28 00:07:27 spestov Exp $
 */
public abstract class TextAreaExtension
{
	//{{{ paintScreenLineRange() method
	/**
	 * Paints a range of screen lines. The default implementation calls
	 * {@link #paintValidLine(Graphics2D,int,int,int,int,int)} and
	 * {@link #paintInvalidLine(Graphics2D,int,int)}.
	 * @param gfx A graphics context
	 * @param firstLine The first screen line
	 * @param lastLine The last screen line
	 * @param physicalLines The list of physical line numbers. Entries are
	 * -1 if the screen line is out of range.
	 * @param start An array of screen line start offsets.
	 * @param end An array of screen line end offsets
	 * @param y The y co-ordinate
	 * @param lineHeight The line height
	 * @since jEdit 4.2pre2
	 */
	public void paintScreenLineRange(Graphics2D gfx, int firstLine,
		int lastLine, int[] physicalLines, int[] start, int[] end,
		int y, int lineHeight)
	{
		for(int i = 0; i < physicalLines.length; i++)
		{
			int screenLine = i + firstLine;
			if(physicalLines[i] == -1)
				paintInvalidLine(gfx,screenLine,y);
			else
			{
				paintValidLine(gfx,screenLine,physicalLines[i],
					start[i],end[i],y);
			}
			y += lineHeight;
		}
	} //}}}
	//{{{ paintValidLine() method
	/**
	 * Called by the text area when the extension is to paint a
	 * screen line which has an associated physical line number in
	 * the buffer. Note that since one physical line may consist of
	 * several screen lines due to soft wrap, the start and end
	 * offsets of the screen line are passed in as well.
	 *
	 * @param gfx The graphics context
	 * @param screenLine The screen line number
	 * @param physicalLine The physical line number
	 * @param start The offset where the screen line begins, from
	 * the start of the buffer
	 * @param end The offset where the screen line ends, from the
	 * start of the buffer
	 * @param y The y co-ordinate of the top of the line's
	 * bounding box
	 * @since jEdit 4.0pre4
	 */
	public void paintValidLine(Graphics2D gfx, int screenLine,
		int physicalLine, int start, int end, int y) {} //}}}
	//{{{ paintInvalidLine() method
	/**
	 * Called by the text area when the extension is to paint a
	 * screen line which is not part of the buffer. This can happen
	 * if the buffer is shorter than the height of the text area,
	 * for example.
	 *
	 * @param gfx The graphics context
	 * @param screenLine The screen line number
	 * @param y The y co-ordinate of the top of the line's
	 * bounding box
	 * @since jEdit 4.0pre4
	 */
	public void paintInvalidLine(Graphics2D gfx, int screenLine,
		int y) {} //}}}
	//{{{ getToolTipText() method
	/**
	 * Called by the text area when the mouse hovers over the
	 * location specified in the mouse event.
	 *
	 * @param x The x co-ordinate
	 * @param y The y co-ordinate
	 * @since jEdit 4.0pre4
	 */
	public String getToolTipText(int x, int y)
	{
		return null;
	} //}}}
}
"
org.gjt.sp.jedit.textarea.TextAreaPainter,"/*
 * TextAreaPainter.java - Paints the text area
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
//{{{ Imports
import javax.swing.text.*;
import javax.swing.JComponent;
import java.awt.event.MouseEvent;
import java.awt.font.*;
import java.awt.*;
import java.util.HashMap;
import org.gjt.sp.jedit.buffer.IndentFoldHandler;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.Debug;
import org.gjt.sp.util.Log;
//}}}
/**
 * The text area painter is the component responsible for displaying the
 * text of the current buffer. The only methods in this class that should
 * be called by plugins are those for adding and removing
 * text area extensions.
 *
 * @see #addExtension(TextAreaExtension)
 * @see #addExtension(int,TextAreaExtension)
 * @see #removeExtension(TextAreaExtension)
 * @see TextAreaExtension
 * @see JEditTextArea
 *
 * @author Slava Pestov
 * @version $Id: TextAreaPainter.java,v 1.100 2004/07/22 00:55:26 spestov Exp $
 */
public class TextAreaPainter extends JComponent implements TabExpander
{
	//{{{ Layers
	/**
	 * The lowest possible layer.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre4
	 */
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;
	/**
	 * Below selection layer. The JDiff plugin will use this.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre4
	 */
	public static final int BACKGROUND_LAYER = -60;
	/**
	 * The line highlight and collapsed fold highlight layer.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre7
	 */
	public static final int LINE_BACKGROUND_LAYER = -50;
	/**
	 * Below selection layer.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre4
	 */
	public static final int BELOW_SELECTION_LAYER = -40;
	/**
	 * Selection layer. Most extensions will be above this layer, but some
	 * (eg, JDiff) will want to be below the selection.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre4
	 */
	public static final int SELECTION_LAYER = -30;
	/**
	 * Wrap guide layer. Most extensions will be above this layer.
	 * @since jEdit 4.0pre4
	 */
	public static final int WRAP_GUIDE_LAYER = -20;
	/**
	 * Below most extensions layer.
	 * @see #addExtension(int,TextAreaExtension)
	 * @since jEdit 4.0pre4
	 */
	public static final int BELOW_MOST_EXTENSIONS_LAYER = -10;
	/**
	 * Default extension layer. This is above the wrap guide but below the
	 * structure highlight.
	 * @since jEdit 4.0pre4
	 */
	public static final int DEFAULT_LAYER = 0;
	/**
	 * Block caret layer. Most extensions will be below this layer.
	 * @since jEdit 4.2pre1
	 */
	public static final int BLOCK_CARET_LAYER = 50;
	/**
	 * Bracket highlight layer. Most extensions will be below this layer.
	 * @since jEdit 4.0pre4
	 */
	public static final int BRACKET_HIGHLIGHT_LAYER = 100;
	/**
	 * Text layer. Most extensions will be below this layer.
	 * @since jEdit 4.2pre1
	 */
	public static final int TEXT_LAYER = 200;
	/**
	 * Caret layer. Most extensions will be below this layer.
	 * @since jEdit 4.2pre1
	 */
	public static final int CARET_LAYER = 300;
	/**
	 * Highest possible layer.
	 * @since jEdit 4.0pre4
	 */
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	//}}}
	//{{{ setBounds() method
	/**
	 * It is a bad idea to override this, but we need to get the component
	 * event before the first repaint.
	 */
	public void setBounds(int x, int y, int width, int height)
	{
		if(x == getX() && y == getY() && width == getWidth()
			&& height == getHeight())
		{
			return;
		}
		super.setBounds(x,y,width,height);
		textArea.recalculateVisibleLines();
		if(textArea.getBuffer().isLoaded())
			textArea.recalculateLastPhysicalLine();
		textArea.propertiesChanged();
		textArea.updateMaxHorizontalScrollWidth();
		textArea.scrollBarsInitialized = true;
	} //}}}
	//{{{ isManagingFocus() method
	/**
	 * Returns if this component can be traversed by pressing the
	 * Tab key. This returns false.
	 */
	public boolean isManagingFocus()
	{
		return false;
	} //}}}
	//{{{ getFocusTraversalKeysEnabled() method
	/**
	 * Makes the tab key work in Java 1.4.
	 * @since jEdit 3.2pre4
	 */
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} //}}}
	//{{{ Getters and setters
	//{{{ getStyles() method
	/**
	 * Returns the syntax styles used to paint colorized text. Entry <i>n</i>
	 * will be used to paint tokens with id = <i>n</i>.
	 * @see org.gjt.sp.jedit.syntax.Token
	 */
	public final SyntaxStyle[] getStyles()
	{
		return styles;
	} //}}}
	//{{{ setStyles() method
	/**
	 * Sets the syntax styles used to paint colorized text. Entry <i>n</i>
	 * will be used to paint tokens with id = <i>n</i>.
	 * @param styles The syntax styles
	 * @see org.gjt.sp.jedit.syntax.Token
	 */
	public final void setStyles(SyntaxStyle[] styles)
	{
		// assumed this is called after a font render context is set up.
		// changing font render context settings without a setStyles()
		// call will not reset cached monospaced font info.
		fonts.clear();
		this.styles = styles;
		styles[Token.NULL] = new SyntaxStyle(getForeground(),null,getFont());
		for(int i = 0; i < styles.length; i++)
		{
			styles[i].setCharWidth(getCharWidth(styles[i].getFont()));
		}
		repaint();
	} //}}}
	//{{{ getCaretColor() method
	/**
	 * Returns the caret color.
	 */
	public final Color getCaretColor()
	{
		return caretColor;
	} //}}}
	//{{{ setCaretColor() method
	/**
	 * Sets the caret color.
	 * @param caretColor The caret color
	 */
	public final void setCaretColor(Color caretColor)
	{
		this.caretColor = caretColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} //}}}
	//{{{ getSelectionColor() method
	/**
	 * Returns the selection color.
	 */
	public final Color getSelectionColor()
	{
		return selectionColor;
	} //}}}
	//{{{ setSelectionColor() method
	/**
	 * Sets the selection color.
	 * @param selectionColor The selection color
	 */
	public final void setSelectionColor(Color selectionColor)
	{
		this.selectionColor = selectionColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} //}}}
	//{{{ getMultipleSelectionColor() method
	/**
	 * Returns the multiple selection color.
	 * @since jEdit 4.2pre1
	 */
	public final Color getMultipleSelectionColor()
	{
		return multipleSelectionColor;
	} //}}}
	//{{{ setMultipleSelectionColor() method
	/**
	 * Sets the multiple selection color.
	 * @param multipleSelectionColor The multiple selection color
	 * @since jEdit 4.2pre1
	 */
	public final void setMultipleSelectionColor(Color multipleSelectionColor)
	{
		this.multipleSelectionColor = multipleSelectionColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} //}}}
	//{{{ getLineHighlightColor() method
	/**
	 * Returns the line highlight color.
	 */
	public final Color getLineHighlightColor()
	{
		return lineHighlightColor;
	} //}}}
	//{{{ setLineHighlightColor() method
	/**
	 * Sets the line highlight color.
	 * @param lineHighlightColor The line highlight color
	 */
	public final void setLineHighlightColor(Color lineHighlightColor)
	{
		this.lineHighlightColor = lineHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} //}}}
	//{{{ isLineHighlightEnabled() method
	/**
	 * Returns true if line highlight is enabled, false otherwise.
	 */
	public final boolean isLineHighlightEnabled()
	{
		return lineHighlight;
	} //}}}
	//{{{ setLineHighlightEnabled() method
	/**
	 * Enables or disables current line highlighting.
	 * @param lineHighlight True if current line highlight should be enabled,
	 * false otherwise
	 */
	public final void setLineHighlightEnabled(boolean lineHighlight)
	{
		this.lineHighlight = lineHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} //}}}
	//{{{ getStructureHighlightColor() method
	/**
	 * Returns the structure highlight color.
	 * @since jEdit 4.2pre3
	 */
	public final Color getStructureHighlightColor()
	{
		return structureHighlightColor;
	} //}}}
	//{{{ setStructureHighlightColor() method
	/**
	 * Sets the structure highlight color.
	 * @param structureHighlightColor The bracket highlight color
	 * @since jEdit 4.2pre3
	 */
	public final void setStructureHighlightColor(
		Color structureHighlightColor)
	{
		this.structureHighlightColor = structureHighlightColor;
		StructureMatcher.Match match = textArea.getStructureMatch();
		if(match != null)
		{
			textArea.invalidateLineRange(
				match.startLine,match.endLine
			);
		}
	} //}}}
	//{{{ isStructureHighlightEnabled() method
	/**
	 * Returns true if structure highlighting is enabled, false otherwise.
	 * @since jEdit 4.2pre3
	 */
	public final boolean isStructureHighlightEnabled()
	{
		return structureHighlight;
	} //}}}
	//{{{ setStructureHighlightEnabled() method
	/**
	 * Enables or disables structure highlighting.
	 * @param structureHighlight True if structure highlighting should be
	 * enabled, false otherwise
	 * @since jEdit 4.2pre3
	 */
	public final void setStructureHighlightEnabled(boolean structureHighlight)
	{
		this.structureHighlight = structureHighlight;
		StructureMatcher.Match match = textArea.getStructureMatch();
		if(match != null)
		{
			textArea.invalidateLineRange(
				match.startLine,
				match.endLine
			);
		}
	} //}}}
	//{{{ isBlockCaretEnabled() method
	/**
	 * Returns true if the caret should be drawn as a block, false otherwise.
	 */
	public final boolean isBlockCaretEnabled()
	{
		return blockCaret;
	} //}}}
	//{{{ setBlockCaretEnabled() method
	/**
	 * Sets if the caret should be drawn as a block, false otherwise.
	 * @param blockCaret True if the caret should be drawn as a block,
	 * false otherwise.
	 */
	public final void setBlockCaretEnabled(boolean blockCaret)
	{
		this.blockCaret = blockCaret;
		extensionMgr.removeExtension(caretExtension);
		if(blockCaret)
			addExtension(BLOCK_CARET_LAYER,caretExtension);
		else
			addExtension(CARET_LAYER,caretExtension);
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} //}}}
	//{{{ getEOLMarkerColor() method
	/**
	 * Returns the EOL marker color.
	 */
	public final Color getEOLMarkerColor()
	{
		return eolMarkerColor;
	} //}}}
	//{{{ setEOLMarkerColor() method
	/**
	 * Sets the EOL marker color.
	 * @param eolMarkerColor The EOL marker color
	 */
	public final void setEOLMarkerColor(Color eolMarkerColor)
	{
		this.eolMarkerColor = eolMarkerColor;
		repaint();
	} //}}}
	//{{{ getEOLMarkersPainted() method
	/**
	 * Returns true if EOL markers are drawn, false otherwise.
	 */
	public final boolean getEOLMarkersPainted()
	{
		return eolMarkers;
	} //}}}
	//{{{ setEOLMarkersPainted() method
	/**
	 * Sets if EOL markers are to be drawn.
	 * @param eolMarkers True if EOL markers should be drawn, false otherwise
	 */
	public final void setEOLMarkersPainted(boolean eolMarkers)
	{
		this.eolMarkers = eolMarkers;
		repaint();
	} //}}}
	//{{{ getWrapGuideColor() method
	/**
	 * Returns the wrap guide color.
	 */
	public final Color getWrapGuideColor()
	{
		return wrapGuideColor;
	} //}}}
	//{{{ setWrapGuideColor() method
	/**
	 * Sets the wrap guide color.
	 * @param wrapGuideColor The wrap guide color
	 */
	public final void setWrapGuideColor(Color wrapGuideColor)
	{
		this.wrapGuideColor = wrapGuideColor;
		repaint();
	} //}}}
	//{{{ isWrapGuidePainted() method
	/**
	 * Returns true if the wrap guide is drawn, false otherwise.
	 * @since jEdit 4.0pre4
	 */
	public final boolean isWrapGuidePainted()
	{
		return wrapGuide;
	} //}}}
	//{{{ setWrapGuidePainted() method
	/**
	 * Sets if the wrap guide is to be drawn.
	 * @param wrapGuide True if the wrap guide should be drawn, false otherwise
	 */
	public final void setWrapGuidePainted(boolean wrapGuide)
	{
		this.wrapGuide = wrapGuide;
		repaint();
	} //}}}
	//{{{ getFoldLineStyle() method
	/**
	 * Returns the fold line style. The first element is the style for
	 * lines with a fold level greater than 3. The remaining elements
	 * are for fold levels 1 to 3.
	 */
	public final SyntaxStyle[] getFoldLineStyle()
	{
		return foldLineStyle;
	} //}}}
	//{{{ setFoldLineStyle() method
	/**
	 * Sets the fold line style. The first element is the style for
	 * lines with a fold level greater than 3. The remaining elements
	 * are for fold levels 1 to 3.
	 * @param foldLineStyle The fold line style
	 */
	public final void setFoldLineStyle(SyntaxStyle[] foldLineStyle)
	{
		this.foldLineStyle = foldLineStyle;
		repaint();
	} //}}}
	//{{{ setAntiAliasEnabled() method
	/**
	 * Sets if anti-aliasing should be enabled. Has no effect when
	 * running on Java 1.1.
	 * @since jEdit 3.2pre6
	 */
	public void setAntiAliasEnabled(boolean antiAlias)
	{
		this.antiAlias = antiAlias;
		updateRenderingHints();
	} //}}}
	//{{{ isAntiAliasEnabled() method
	/**
	 * Returns if anti-aliasing is enabled.
	 * @since jEdit 3.2pre6
	 */
	public boolean isAntiAliasEnabled()
	{
		return antiAlias;
	} //}}}
	//{{{ setFractionalFontMetricsEnabled() method
	/**
	 * Sets if fractional font metrics should be enabled. Has no effect when
	 * running on Java 1.1.
	 * @since jEdit 3.2pre6
	 */
	public void setFractionalFontMetricsEnabled(boolean fracFontMetrics)
	{
		this.fracFontMetrics = fracFontMetrics;
		updateRenderingHints();
	} //}}}
	//{{{ isFractionalFontMetricsEnabled() method
	/**
	 * Returns if fractional font metrics are enabled.
	 * @since jEdit 3.2pre6
	 */
	public boolean isFractionalFontMetricsEnabled()
	{
		return fracFontMetrics;
	} //}}}
	//{{{ getFontRenderContext() method
	/**
	 * Returns the font render context.
	 * @since jEdit 4.0pre4
	 */
	public FontRenderContext getFontRenderContext()
	{
		return fontRenderContext;
	} //}}}
	//}}}
	//{{{ addExtension() method
	/**
	 * Adds a text area extension, which can perform custom painting and
	 * tool tip handling.
	 * @param extension The extension
	 * @since jEdit 4.0pre4
	 */
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} //}}}
	//{{{ addExtension() method
	/**
	 * Adds a text area extension, which can perform custom painting and
	 * tool tip handling.
	 * @param layer The layer to add the extension to. Note that more than
	 * extension can share the same layer.
	 * @param extension The extension
	 * @since jEdit 4.0pre4
	 */
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} //}}}
	//{{{ removeExtension() method
	/**
	 * Removes a text area extension. It will no longer be asked to
	 * perform custom painting and tool tip handling.
	 * @param extension The extension
	 * @since jEdit 4.0pre4
	 */
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} //}}}
	//{{{ getExtensions() method
	/**
	 * Returns an array of registered text area extensions. Useful for
	 * debugging purposes.
	 * @since jEdit 4.1pre5
	 */
	public TextAreaExtension[] getExtensions()
	{
		return extensionMgr.getExtensions();
	} //}}}
	//{{{ getToolTipText() method
	/**
	 * Returns the tool tip to display at the specified location.
	 * @param evt The mouse event
	 */
	public String getToolTipText(MouseEvent evt)
	{
		if(!textArea.getBuffer().isLoaded())
			return null;
		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} //}}}
	//{{{ getFontMetrics() method
	/**
	 * Returns the font metrics used by this component.
	 */
	public FontMetrics getFontMetrics()
	{
		return fm;
	} //}}}
	//{{{ setFont() method
	/**
	 * Sets the font for this component. This is overridden to update the
	 * cached font metrics and to recalculate which lines are visible.
	 * @param font The font
	 */
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		textArea.recalculateVisibleLines();
		if(textArea.getBuffer() != null
			&& textArea.getBuffer().isLoaded())
			textArea.recalculateLastPhysicalLine();
		textArea.propertiesChanged();
	} //}}}
	//{{{ getStringWidth() method
	/**
	 * Returns the width of the given string, in pixels, using the text
	 * area's current font.
	 *
	 * @since jEdit 4.2final
	 */
	public float getStringWidth(String str)
	{
		if(textArea.charWidth != 0)
			return textArea.charWidth * str.length();
		else
		{
			return (float)getFont().getStringBounds(
				str,getFontRenderContext()).getWidth();
		}
	} //}}}
	//{{{ paintComponent() method
	/**
	 * Repaints the text.
	 * @param _gfx The graphics context
	 */
	public void paintComponent(Graphics _gfx)
	{
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setRenderingHints(renderingHints);
		fontRenderContext = gfx.getFontRenderContext();
		Rectangle clipRect = gfx.getClipBounds();
		gfx.setColor(getBackground());
		gfx.fillRect(clipRect.x,clipRect.y,clipRect.width,clipRect.height);
		Buffer buffer = textArea.getBuffer();
		if(!buffer.isLoaded())
			return;
		int height = fm.getHeight();
		if(height == 0)
			return;
		int firstInvalid = clipRect.y / height;
		// Because the clipRect's height is usually an even multiple
		// of the font height, we subtract 1 from it, otherwise one
		// too many lines will always be painted.
		int lastInvalid = (clipRect.y + clipRect.height - 1) / height;
		if(Debug.PAINT_TIMER && lastInvalid - firstInvalid >= 1)
			Log.log(Log.DEBUG,this,""repainting "" + (lastInvalid - firstInvalid) + "" lines"");
		int y = (clipRect.y - clipRect.y % height);
		extensionMgr.paintScreenLineRange(textArea,gfx,
			firstInvalid,lastInvalid,y,height);
		textArea.updateMaxHorizontalScrollWidth();
		textArea.displayManager._notifyScreenLineChanges();
	} //}}}
	//{{{ nextTabStop() method
	/**
	 * Implementation of TabExpander interface. Returns next tab stop after
	 * a specified point.
	 * @param x The x co-ordinate
	 * @param tabOffset Ignored
	 * @return The next tab stop after <i>x</i>
	 */
	public float nextTabStop(float x, int tabOffset)
	{
		int ntabs = (int)(x / textArea.tabSize);
		return (ntabs + 1) * textArea.tabSize;
	} //}}}
	//{{{ getPreferredSize() method
	/**
	 * Returns the painter's preferred size.
	 */
	public Dimension getPreferredSize()
	{
		Dimension dim = new Dimension();
		char[] foo = new char[80];
		for(int i = 0; i < foo.length; i++)
			foo[i] = ' ';
		dim.width = (int)getStringWidth(new String(foo));
		dim.height = fm.getHeight() * 25;
		return dim;
	} //}}}
	//{{{ getMinimumSize() method
	/**
	 * Returns the painter's minimum size.
	 */
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} //}}}
	//{{{ Package-private members
	//{{{ Instance variables
	/* package-private since they are accessed by inner classes and we
	 * want this to be fast */
	JEditTextArea textArea;
	SyntaxStyle[] styles;
	Color caretColor;
	Color selectionColor;
	Color multipleSelectionColor;
	Color lineHighlightColor;
	Color structureHighlightColor;
	Color eolMarkerColor;
	Color wrapGuideColor;
	SyntaxStyle[] foldLineStyle;
	boolean blockCaret;
	boolean lineHighlight;
	boolean structureHighlight;
	boolean eolMarkers;
	boolean wrapGuide;
	boolean antiAlias;
	boolean fracFontMetrics;
	// should try to use this as little as possible.
	FontMetrics fm;
	//}}}
	//{{{ TextAreaPainter constructor
	/**
	 * Creates a new painter. Do not create instances of this class
	 * directly.
	 */
	TextAreaPainter(JEditTextArea textArea)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK
			| AWTEvent.KEY_EVENT_MASK
			| AWTEvent.MOUSE_EVENT_MASK);
		this.textArea = textArea;
		fonts = new HashMap();
		extensionMgr = new ExtensionManager();
		setAutoscrolls(true);
		setOpaque(true);
		setRequestFocusEnabled(false);
		setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
		fontRenderContext = new FontRenderContext(null,false,false);
		addExtension(LINE_BACKGROUND_LAYER,new PaintLineBackground());
		addExtension(SELECTION_LAYER,new PaintSelection());
		addExtension(WRAP_GUIDE_LAYER,new PaintWrapGuide());
		addExtension(BRACKET_HIGHLIGHT_LAYER,new StructureMatcher
			.Highlight(textArea));
		addExtension(TEXT_LAYER,new PaintText());
		caretExtension = new PaintCaret();
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private ExtensionManager extensionMgr;
	private PaintCaret caretExtension;
	private RenderingHints renderingHints;
	private FontRenderContext fontRenderContext;
	private HashMap fonts;
	//}}}
	//{{{ updateRenderingHints() method
	private void updateRenderingHints()
	{
		HashMap hints = new HashMap();
		if(antiAlias)
		{
			//hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		}
		else
		{
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		}
		hints.put(RenderingHints.KEY_FRACTIONALMETRICS,
			fracFontMetrics ?
				RenderingHints.VALUE_FRACTIONALMETRICS_ON
				: RenderingHints.VALUE_FRACTIONALMETRICS_OFF);
		renderingHints = new RenderingHints(hints);
		fontRenderContext = new FontRenderContext(null,antiAlias,
			fracFontMetrics);
	} //}}}
	//{{{ getCharWidth() method
	private int getCharWidth(Font font)
	{
		Integer returnValue = (Integer)fonts.get(font);
		if(returnValue == null)
		{
			int minWidth = Integer.MAX_VALUE;
			int maxWidth = Integer.MIN_VALUE;
			FontMetrics fm = getFontMetrics(font);
			int[] widths = fm.getWidths();
			for(int i = 0; i < widths.length; i++)
			{
				int width = widths[i];
				if(width == 0 || !font.canDisplay((char)i))
					continue;
				minWidth = Math.min(width,minWidth);
				maxWidth = Math.max(width,maxWidth);
			}
			String str = ""iwiwiwiau1234"";
			double width1 = font.createGlyphVector(textArea.getPainter()
				.getFontRenderContext(),str).getLogicalBounds()
				.getWidth();
			double width2 = str.length() * maxWidth;
			if(minWidth == maxWidth
				&& (int)width1 == (int)width2)
			{
				Log.log(Log.DEBUG,this,""Using monospaced font optimization: "" + font);
				returnValue = new Integer(maxWidth);
			}
			else
			{
				Log.log(Log.DEBUG,this,""Not using monospaced font optimization: "" + font);
				Log.log(Log.DEBUG,this,""Minimum width = "" + minWidth
					+ "", maximum width = "" + maxWidth
					+ "", width 1 = "" + width1
					+ "", width 2 = "" + width2);
				returnValue = new Integer(0);
			}
			fonts.put(font,returnValue);
		}
		return returnValue.intValue();
	} //}}}
	//}}}
	//{{{ Inner classes
	//{{{ PaintLineBackground class
	class PaintLineBackground extends TextAreaExtension
	{
		//{{{ paintValidLine() method
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			// minimise access$ methods
			JEditTextArea textArea = TextAreaPainter.this.textArea;
			Buffer buffer = textArea.getBuffer();
			//{{{ Paint line highlight and collapsed fold highlight
			boolean collapsedFold =
				(physicalLine < buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine)
				&& !textArea.displayManager
				.isLineVisible(physicalLine + 1));
			SyntaxStyle foldLineStyle = null;
			if(collapsedFold)
			{
				int level = buffer.getFoldLevel(physicalLine + 1);
				if(buffer.getFoldHandler() instanceof IndentFoldHandler)
					level = Math.max(1,level / buffer.getIndentSize());
				if(level > 3)
					level = 0;
				foldLineStyle = TextAreaPainter.this.foldLineStyle[level];
			}
			int caret = textArea.getCaretPosition();
			boolean paintLineHighlight = isLineHighlightEnabled()
				&& caret >= start && caret < end
				&& textArea.selection.size() == 0;
			Color bgColor;
			if(paintLineHighlight)
				bgColor = lineHighlightColor;
			else if(collapsedFold)
			{
				bgColor = foldLineStyle.getBackgroundColor();
				if(bgColor == null)
					bgColor = getBackground();
			}
			else
				bgColor = getBackground();
			if(paintLineHighlight || collapsedFold)
			{
				gfx.setColor(bgColor);
				gfx.fillRect(0,y,getWidth(),fm.getHeight());
			} //}}}
			//{{{ Paint token backgrounds
			ChunkCache.LineInfo lineInfo = textArea.chunkCache
				.getLineInfo(screenLine);
			if(lineInfo.chunks != null)
			{
				float baseLine = y + fm.getHeight()
					- fm.getLeading() - fm.getDescent();
				Chunk.paintChunkBackgrounds(
					lineInfo.chunks,gfx,
					textArea.getHorizontalOffset(),
					baseLine);
			} //}}}
		} //}}}
	} //}}}
	//{{{ PaintSelection class
	class PaintSelection extends TextAreaExtension
	{
		//{{{ paintValidLine() method
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(textArea.selection.size() == 0)
				return;
			gfx.setColor(textArea.isMultipleSelectionEnabled()
				? getMultipleSelectionColor()
				: getSelectionColor());
			for(int i = textArea.selection.size() - 1; i >= 0; i--)
			{
				paintSelection(gfx,screenLine,physicalLine,y,
					(Selection)textArea.selection.get(i));
			}
		} //}}}
		//{{{ paintSelection() method
		private void paintSelection(Graphics2D gfx, int screenLine,
			int physicalLine, int y, Selection s)
		{
			int[] selectionStartAndEnd
				= textArea.getSelectionStartAndEnd(
				screenLine,physicalLine,s);
			if(selectionStartAndEnd == null)
				return;
			int x1 = selectionStartAndEnd[0];
			int x2 = selectionStartAndEnd[1];
			gfx.fillRect(x1,y,x2 - x1,fm.getHeight());
		} //}}}
	} //}}}
	//{{{ PaintWrapGuide class
	class PaintWrapGuide extends TextAreaExtension
	{
		public void paintScreenLineRange(Graphics2D gfx, int firstLine,
			int lastLine, int[] physicalLines, int[] start,
			int[] end, int y, int lineHeight)
		{
			if(textArea.getDisplayManager().wrapMargin != 0
				&& isWrapGuidePainted())
			{
				gfx.setColor(getWrapGuideColor());
				int x = textArea.getHorizontalOffset()
					+ textArea.getDisplayManager()
					.wrapMargin;
				gfx.drawLine(x,y,x,y + (lastLine - firstLine
					+ 1) * lineHeight);
			}
		}
		public String getToolTipText(int x, int y)
		{
			if(textArea.getDisplayManager().wrapMargin != 0 && isWrapGuidePainted())
			{
				int wrapGuidePos = textArea.getDisplayManager().wrapMargin
					+ textArea.getHorizontalOffset();
				if(Math.abs(x - wrapGuidePos) < 5)
				{
					return String.valueOf(textArea.getBuffer()
						.getProperty(""maxLineLen""));
				}
			}
			return null;
		}
	} //}}}
	//{{{ PaintText class
	class PaintText extends TextAreaExtension
	{
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			ChunkCache.LineInfo lineInfo = textArea.chunkCache
				.getLineInfo(screenLine);
			Font defaultFont = getFont();
			Color defaultColor = getForeground();
			gfx.setFont(defaultFont);
			gfx.setColor(defaultColor);
			int x = textArea.getHorizontalOffset();
			int originalX = x;
			float baseLine = y + fm.getHeight()
				- fm.getLeading() - fm.getDescent();
			if(lineInfo.chunks != null)
			{
				x += Chunk.paintChunkList(lineInfo.chunks,
					gfx,textArea.getHorizontalOffset(),
					baseLine,!Debug.DISABLE_GLYPH_VECTOR);
			}
			Buffer buffer = textArea.getBuffer();
			if(!lineInfo.lastSubregion)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString("":"",Math.max(x,
					textArea.getHorizontalOffset()
					+ textArea.getDisplayManager().wrapMargin + textArea.charWidth),
					baseLine);
				x += textArea.charWidth;
			}
			else if(physicalLine < buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine)
				&& !textArea.displayManager
				.isLineVisible(physicalLine + 1))
			{
				int level = buffer.getFoldLevel(physicalLine + 1);
				if(buffer.getFoldHandler() instanceof IndentFoldHandler)
					level = Math.max(1,level / buffer.getIndentSize());
				if(level > 3)
					level = 0;
				SyntaxStyle foldLineStyle = TextAreaPainter.this.foldLineStyle[level];
				Font font = foldLineStyle.getFont();
				gfx.setFont(font);
				gfx.setColor(foldLineStyle.getForegroundColor());
				int nextLine;
				int nextScreenLine = screenLine + 1;
				if(nextScreenLine < textArea.getVisibleLines())
				{
					nextLine = textArea.chunkCache.getLineInfo(nextScreenLine)
						.physicalLine;
				}
				else
				{
					nextLine = textArea.displayManager
						.getNextVisibleLine(physicalLine);
				}
				if(nextLine == -1)
					nextLine = textArea.getLineCount();
				int count = nextLine - physicalLine - 1;
				String str = "" ["" + count + "" lines]"";
				float width = getStringWidth(str);
				gfx.drawString(str,x,baseLine);
				x += width;
			}
			else if(eolMarkers)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString(""."",x,baseLine);
				x += textArea.charWidth;
			}
			lineInfo.width = (x - originalX);
		}
	} //}}}
	//{{{ PaintCaret class
	class PaintCaret extends TextAreaExtension
	{
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(!textArea.isCaretVisible())
				return;
			int caret = textArea.getCaretPosition();
			if(caret < start || caret >= end)
				return;
			int offset = caret - textArea.getLineStartOffset(physicalLine);
			textArea.offsetToXY(physicalLine,offset,textArea.returnValue);
			int caretX = textArea.returnValue.x;
			int height = fm.getHeight();
			gfx.setColor(caretColor);
			if(textArea.isOverwriteEnabled())
			{
				gfx.drawLine(caretX,y + height - 1,
					caretX + textArea.charWidth,y + height - 1);
			}
			else if(blockCaret)
				gfx.drawRect(caretX,y,textArea.charWidth - 1,height - 1);
			else
				gfx.drawLine(caretX,y,caretX,y + height - 1);
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.util.CharIndexedSegment,"/*
 * CharIndexedSegment.java
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1998 Wes Biggs
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Library General Public License as published
 * by the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package org.gjt.sp.util;
//{{{ Imports
import java.io.Serializable;
import javax.swing.text.Segment;
import gnu.regexp.*;
//}}}
/**
 * Lets <code>gnu.regexp</code> search within <code>Segment</code> objects.
 */
public class CharIndexedSegment implements CharIndexed, Serializable
{
	//{{{ CharIndexedSegment constructor
	/**
	 * Creates a new <code>CharIndexedSegment</code>.
	 * @since jEdit 4.1pre3
	 */
	public CharIndexedSegment(Segment seg, int index)
	{
		this.seg = seg;
		m_index = index;
	} //}}}
	//{{{ CharIndexedSegment constructor
	/**
	 * Creates a new <code>CharIndexedSegment</code>.
	 * @since jEdit 4.1pre1
	 */
	public CharIndexedSegment(Segment seg, boolean reverse)
	{
		this.seg = seg;
		m_index = (reverse ? seg.count - 1 : 0);
		this.reverse = reverse;
	} //}}}
	//{{{ charAt() method
	public char charAt(int index)
	{
		if(reverse)
			index = -index;
		return ((m_index + index) < seg.count && m_index + index >= 0)
			? seg.array[seg.offset + m_index + index]
			: CharIndexed.OUT_OF_BOUNDS;
	} //}}}
	//{{{ isValid() method
	public boolean isValid()
	{
		return (m_index >=0 && m_index < seg.count);
	} //}}}
	//{{{ reset() method
	public void reset()
	{
		m_index = (reverse ? seg.count - 1 : 0);
	} //}}}
	//{{{ move() method
	public boolean move(int index)
	{
		if(reverse)
			index = -index;
		return ((m_index += index) < seg.count);
	} //}}}
	//{{{ Private members
	private Segment seg;
	private int m_index;
	private boolean reverse;
	//}}}
}
"
org.gjt.sp.util.IntegerArray,"/*
 * IntegerArray.java - Automatically growing array of ints
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
/**
 * A simple collection that stores integers and grows automatically.
 */
public class IntegerArray
{
	//{{{ IntegerArray constructor
	public IntegerArray()
	{
		this(2000);
	} //}}}
	//{{{ IntegerArray constructor
	public IntegerArray(int initialSize)
	{
		array = new int[initialSize];
	} //}}}
	//{{{ add() method
	public void add(int num)
	{
		if(len >= array.length)
		{
			int[] arrayN = new int[len * 2];
			System.arraycopy(array,0,arrayN,0,len);
			array = arrayN;
		}
		array[len++] = num;
	} //}}}
	//{{{ get() method
	public final int get(int index)
	{
		return array[index];
	} //}}}
	//{{{ getSize() method
	public final int getSize()
	{
		return len;
	} //}}}
	//{{{ setSize() method
	public final void setSize(int len)
	{
		this.len = len;
	} //}}}
	//{{{ clear() method
	public final void clear()
	{
		len = 0;
	} //}}}
	//{{{ getArray() method
	public int[] getArray()
	{
		return array;
	} //}}}
	//{{{ Private members
	private int[] array;
	private int len;
	//}}}
}
"
org.gjt.sp.util.Log,"/*
 * Log.java - A class for logging events
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 1999, 2003 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import java.io.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
/**
 * This class provides methods for logging events. In terms of functionality,
 * it is somewhere in between <code>System.out.println()</code> and
 * full-blown logging packages such as log4j.<p>
 *
 * All events are logged to an in-memory buffer and optionally a stream,
 * and those with a high urgency (warnings and errors) are also printed
 * to standard output.<p>
 *
 * Logging of exception tracebacks is supported.<p>
 *
 * This class can also optionally redirect standard output and error to the log.
 *
 * @author Slava Pestov
 * @version $Id: Log.java,v 1.14 2004/03/28 00:07:27 spestov Exp $
 */
public class Log
{
	//{{{ Constants
	/**
	 * The maximum number of log messages that will be kept in memory.
	 * @since jEdit 2.6pre5
	 */
	public static final int MAXLINES = 500;
	/**
	 * Debugging message urgency. Should be used for messages only
	 * useful when debugging a problem.
	 * @since jEdit 2.2pre2
	 */
	public static final int DEBUG = 1;
	/**
	 * Message urgency. Should be used for messages which give more
	 * detail than notices.
	 * @since jEdit 2.2pre2
	 */
	public static final int MESSAGE = 3;
	/**
	 * Notice urgency. Should be used for messages that directly
	 * affect the user.
	 * @since jEdit 2.2pre2
	 */
	public static final int NOTICE = 5;
	/**
	 * Warning urgency. Should be used for messages that warrant
	 * attention.
	 * @since jEdit 2.2pre2
	 */
	public static final int WARNING = 7;
	/**
	 * Error urgency. Should be used for messages that signal a
	 * failure.
	 * @since jEdit 2.2pre2
	 */
	public static final int ERROR = 9;
	//}}}
	//{{{ init() method
	/**
	 * Initializes the log.
	 * @param stdio If true, standard output and error will be
	 * sent to the log
	 * @param level Messages with this log level or higher will
	 * be printed to the system console
	 * @since jEdit 3.2pre4
	 */
	public static void init(boolean stdio, int level)
	{
		if(stdio)
		{
			if(System.out == realOut && System.err == realErr)
			{
				System.setOut(createPrintStream(NOTICE,null));
				System.setErr(createPrintStream(ERROR,null));
			}
		}
		Log.level = level;
		// Log some stuff
		log(MESSAGE,Log.class,""When reporting bugs, please""
			+ "" include the following information:"");
		String[] props = {
			""java.version"", ""java.vm.version"", ""java.runtime.version"",
			""java.vendor"", ""java.compiler"", ""os.name"", ""os.version"",
			""os.arch"", ""user.home"", ""java.home"",
			""java.class.path"",
			};
		for(int i = 0; i < props.length; i++)
		{
			log(MESSAGE,Log.class,
				props[i] + ""="" + System.getProperty(props[i]));
		}
	} //}}}
	//{{{ setLogWriter() method
	/**
	 * Writes all currently logged messages to this stream if there was no
	 * stream set previously, and sets the stream to write future log
	 * messages to.
	 * @param stream The writer
	 * @since jEdit 3.2pre4
	 */
	public static void setLogWriter(Writer stream)
	{
		if(Log.stream == null && stream != null)
		{
			try
			{
				if(wrap)
				{
					for(int i = logLineCount; i < log.length; i++)
					{
						stream.write(log[i]);
						stream.write(lineSep);
					}
				}
				for(int i = 0; i < logLineCount; i++)
				{
					stream.write(log[i]);
					stream.write(lineSep);
				}
				stream.flush();
			}
			catch(Exception e)
			{
				// do nothing, who cares
			}
		}
		Log.stream = stream;
	} //}}}
	//{{{ flushStream() method
	/**
	 * Flushes the log stream.
	 * @since jEdit 2.6pre5
	 */
	public static void flushStream()
	{
		if(stream != null)
		{
			try
			{
				stream.flush();
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	} //}}}
	//{{{ closeStream() method
	/**
	 * Closes the log stream. Should be done before your program exits.
	 * @since jEdit 2.6pre5
	 */
	public static void closeStream()
	{
		if(stream != null)
		{
			try
			{
				stream.close();
				stream = null;
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	} //}}}
	//{{{ getLogListModel() method
	/**
	 * Returns the list model for viewing the log contents.
	 * @since jEdit 4.2pre1
	 */
	public static ListModel getLogListModel()
	{
		return listModel;
	} //}}}
	//{{{ log() method
	/**
	 * Logs a message. This method is thread-safe.<p>
	 *
	 * The following code sends a typical debugging message to the activity
	 * log:
	 * <pre>Log.log(Log.DEBUG,this,""counter = "" + counter);</pre>
	 * The corresponding activity log entry might read as follows:
	 * <pre>[debug] JavaParser: counter = 15</pre>
	 *
	 * @param urgency The urgency; can be one of
	 * <code>Log.DEBUG</code>, <code>Log.MESSAGE</code>,
	 * <code>Log.NOTICE</code>, <code>Log.WARNING</code>, or
	 * <code>Log.ERROR</code>.
	 * @param source The source of the message, either an object or a
	 * class instance. When writing log messages from macros, set
	 * this parameter to <code>BeanShell.class</code> to make macro
	 * errors easier to spot in the activity log.
	 * @param message The message. This can either be a string or
	 * an exception
	 *
	 * @since jEdit 2.2pre2
	 */
	public static void log(int urgency, Object source, Object message)
	{
		String _source;
		if(source == null)
		{
			_source = Thread.currentThread().getName();
			if(_source == null)
			{
				_source = Thread.currentThread().getClass().getName();
			}
		}
		else if(source instanceof Class)
			_source = ((Class)source).getName();
		else
			_source = source.getClass().getName();
		int index = _source.lastIndexOf('.');
		if(index != -1)
			_source = _source.substring(index+1);
		if(message instanceof Throwable)
		{
			_logException(urgency,source,(Throwable)message);
		}
		else
		{
			String _message = String.valueOf(message);
			// If multiple threads log stuff, we don't want
			// the output to get mixed up
			synchronized(LOCK)
			{
				StringTokenizer st = new StringTokenizer(
					_message,""\r\n"");
				int lineCount = 0;
				boolean oldWrap = wrap;
				while(st.hasMoreTokens())
				{
					lineCount++;
					_log(urgency,_source,st.nextToken()
						.replace('\t',' '));
				}
				listModel.update(lineCount,oldWrap);
			}
		}
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private static Object LOCK = new Object();
	private static String[] log;
	private static int logLineCount;
	private static boolean wrap;
	private static int level = WARNING;
	private static Writer stream;
	private static String lineSep;
	private static PrintStream realOut;
	private static PrintStream realErr;
	private static LogListModel listModel;
	//}}}
	//{{{ Class initializer
	static
	{
		level = WARNING;
		realOut = System.out;
		realErr = System.err;
		log = new String[MAXLINES];
		lineSep = System.getProperty(""line.separator"");
		listModel = new LogListModel();
	} //}}}
	//{{{ createPrintStream() method
	private static PrintStream createPrintStream(final int urgency,
		final Object source)
	{
		return new PrintStream(new OutputStream() {
			public void write(int b)
			{
				byte[] barray = { (byte)b };
				write(barray,0,1);
			}
			public void write(byte[] b, int off, int len)
			{
				String str = new String(b,off,len);
				log(urgency,source,str);
			}
		});
	} //}}}
	//{{{ _logException() method
	private static void _logException(final int urgency,
		final Object source,
		final Throwable message)
	{
		PrintStream out = createPrintStream(urgency,source);
		synchronized(LOCK)
		{
			message.printStackTrace(out);
		}
	} //}}}
	//{{{ _log() method
	private static void _log(int urgency, String source, String message)
	{
		String fullMessage = ""["" + urgencyToString(urgency) + ""] "" + source
			+ "": "" + message;
		try
		{
			log[logLineCount] = fullMessage;
			if(++logLineCount >= log.length)
			{
				wrap = true;
				logLineCount = 0;
			}
			if(stream != null)
			{
				stream.write(fullMessage);
				stream.write(lineSep);
			}
		}
		catch(Exception e)
		{
			e.printStackTrace(realErr);
		}
		if(urgency >= level)
		{
			if(urgency == ERROR)
				realErr.println(fullMessage);
			else
				realOut.println(fullMessage);
		}
	} //}}}
	//{{{ urgencyToString() method
	private static String urgencyToString(int urgency)
	{
		switch(urgency)
		{
		case DEBUG:
			return ""debug"";
		case MESSAGE:
			return ""message"";
		case NOTICE:
			return ""notice"";
		case WARNING:
			return ""warning"";
		case ERROR:
			return ""error"";
		}
		throw new IllegalArgumentException(""Invalid urgency: "" + urgency);
	} //}}}
	//}}}
	//{{{ LogListModel class
	static class LogListModel implements ListModel
	{
		Vector listeners = new Vector();
		private void fireIntervalAdded(int index1, int index2)
		{
			for(int i = 0; i < listeners.size(); i++)
			{
				ListDataListener listener = (ListDataListener)
					listeners.elementAt(i);
				listener.intervalAdded(new ListDataEvent(this,
					ListDataEvent.INTERVAL_ADDED,
					index1,index2));
			}
		}
		private void fireIntervalRemoved(int index1, int index2)
		{
			for(int i = 0; i < listeners.size(); i++)
			{
				ListDataListener listener = (ListDataListener)
					listeners.elementAt(i);
				listener.intervalRemoved(new ListDataEvent(this,
					ListDataEvent.INTERVAL_REMOVED,
					index1,index2));
			}
		}
		public void addListDataListener(ListDataListener listener)
		{
			listeners.addElement(listener);
		}
		public void removeListDataListener(ListDataListener listener)
		{
			listeners.removeElement(listener);
		}
		public Object getElementAt(int index)
		{
			if(wrap)
			{
				if(index < MAXLINES - logLineCount)
					return log[index + logLineCount];
				else
					return log[index - MAXLINES + logLineCount];
			}
			else
				return log[index];
		}
		public int getSize()
		{
			if(wrap)
				return MAXLINES;
			else
				return logLineCount;
		}
		void update(final int lineCount, final boolean oldWrap)
		{
			if(lineCount == 0 || listeners.size() == 0)
				return;
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(wrap)
					{
						if(oldWrap)
							fireIntervalRemoved(0,lineCount - 1);
						else
						{
							fireIntervalRemoved(0,
								logLineCount);
						}
						fireIntervalAdded(
							MAXLINES - lineCount + 1,
							MAXLINES);
					}
					else
					{
						fireIntervalAdded(
							logLineCount - lineCount + 1,
							logLineCount);
					}
				}
			});
		}
	} //}}}
}
"
org.gjt.sp.util.ReadWriteLock,"/*
 * ReadWriteLock.java
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Peter Graves
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import java.util.Vector;
/**
 * Implements consumer/producer locking scemantics.
 * @author Peter Graves
 * @version $Id: ReadWriteLock.java,v 1.7 2004/02/14 19:02:49 spestov Exp $
 * The lock tries to be re-entrant when called from the same thread in some
 * cases.
 * 
 * The following is ok:
 * read lock
 * read lock
 * read unlock
 * read unlock
 * 
 * write lock
 * read lock
 * read unlock
 * write unlock
 * 
 * The following is not ok:
 * 
 * read lock
 * write lock
 * write unlock
 * read unlock
 * 
 * write lock
 * write lock
 * write unlock
 * write unlock
 */
public class ReadWriteLock
{
	//{{{ readLock() method
	public synchronized void readLock()
	{
		// this seems to make nested readLock() calls work okay.
		// but I have no idea if it actually fixes things or not.
		if (activeReaders != 0 || allowRead())
		{
			++activeReaders;
			//readers.addElement(Thread.currentThread());
			return;
		}
		++waitingReaders;
		while (!allowRead())
		{
			try
			{
				wait();
			}
			catch (InterruptedException e)
			{
				--waitingReaders; // Roll back state.
				Log.log(Log.ERROR,this,e);
				return;
			}
		}
		--waitingReaders;
		++activeReaders;
		readers.addElement(Thread.currentThread());
	} //}}}
	//{{{ readUnlock() method
	public synchronized void readUnlock()
	{
		if(activeReaders == 0)
			throw new InternalError(""Unbalanced readLock()/readUnlock() calls"");
		--activeReaders;
		//readers.removeElement(Thread.currentThread());
		notifyAll();
	} //}}}
	//{{{ writeLock() method
	public synchronized void writeLock()
	{
		if (writerThread != null)
		{
			// Write in progress.
			if (Thread.currentThread() == writerThread)
			{
				// Same thread.
				++lockCount;
				return;
			}
		}
		if (allowWrite())
		{
			claimWriteLock();
			return;
		}
		++waitingWriters;
		while (!allowWrite())
		{
			try
			{
				wait();
			}
			catch (InterruptedException e)
			{
				--waitingWriters;
				Log.log(Log.ERROR,this,e);
				return;
			}
		}
		--waitingWriters;
		claimWriteLock();
	} //}}}
	//{{{ writeUnlock() method
	public synchronized void writeUnlock()
	{
		if(activeWriters != 1 || lockCount <= 0)
			throw new InternalError(""Unbalanced writeLock()/writeUnlock() calls"");
		if(Thread.currentThread() != writerThread)
			throw new InternalError(""writeUnlock() from wrong thread"");
		if (--lockCount == 0)
		{
			--activeWriters;
			writerThread = null;
			notifyAll();
		}
	} //}}}
	//{{{ isWriteLocked() method
	public synchronized boolean isWriteLocked()
	{
		//Debug.assert(activeWriters == 0 || activeWriters == 1);
		return activeWriters == 1;
	} //}}}
	//{{{ Private members
	//{{{ Instance variables
	private int activeReaders;
	private int activeWriters;
	private int waitingReaders;
	private int waitingWriters;
	private Vector readers = new Vector();
	private Thread writerThread;
	private int lockCount;
	//}}}
	//{{{ allowRead() method
	private final boolean allowRead()
	{
		return (Thread.currentThread() == writerThread)
			|| (waitingWriters == 0 && activeWriters == 0);
	} //}}}
	//{{{ allowWrite() method
	private final boolean allowWrite()
	{
		/*Thread current = Thread.currentThread();
		for(int i = 0; i < readers.size(); i++)
		{
			if(readers.elementAt(i) == current)
				throw new InternalError(""Cannot nest writeLock() inside readLock()"");
		}*/
		return activeReaders == 0 && activeWriters == 0;
	} //}}}
	//{{{ claimWriteLock() method
	private void claimWriteLock()
	{
		++activeWriters;
		//Debug.assert(writerThread == null);
		writerThread = Thread.currentThread();
		//Debug.assert(lockCount == 0);
		lockCount = 1;
	} //}}}
	//}}}
}
"
org.gjt.sp.util.SegmentBuffer,"/*
 * SegmentBuffer.java - A Segment you can append stuff to
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import javax.swing.text.Segment;
/**
 * An extended segment that you can append text to.
 */
public class SegmentBuffer extends Segment
{
	//{{{ SegmentBuffer constructor
	public SegmentBuffer(int capacity)
	{
		ensureCapacity(capacity);
	} //}}}
	//{{{ append() method
	public void append(char ch)
	{
		ensureCapacity(count + 1);
		array[offset + count] = ch;
		count++;
	} //}}}
	//{{{ append() method
	public void append(char[] text, int off, int len)
	{
		ensureCapacity(count + len);
		System.arraycopy(text,off,array,count,len);
		count += len;
	} //}}}
	//{{{ Private members
	//{{{ ensureCapacity() method
	private void ensureCapacity(int capacity)
	{
		if(array == null)
			array = new char[capacity];
		else if(capacity >= array.length)
		{
			char[] arrayN = new char[capacity * 2];
			System.arraycopy(array,0,arrayN,0,count);
			array = arrayN;
		}
	} //}}}
	//}}}
}
"
org.gjt.sp.util.WorkRequest,"/*
 * WorkRequest.java - Runnable subclass
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
/**
 * A subclass of the Runnable interface.
 * @since jEdit 2.6pre1
 */
public abstract class WorkRequest implements Runnable
{
	/**
	 * Sets if the request can be aborted.
	 */
	public void setAbortable(boolean abortable)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setAbortable(abortable);
	}
	/**
	 * Sets the status text.
	 * @param status The status text
	 */
	public void setStatus(String status)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setStatus(status);
	}
	/**
	 * Sets the progress value.
	 * @param value The progress value.
	 */
	public void setProgressValue(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressValue(value);
	}
	/**
	 * Sets the maximum progress value.
	 * @param value The progress value.
	 */
	public void setProgressMaximum(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressMaximum(value);
	}
}
"
org.gjt.sp.util.WorkThread,"/*
 * WorkThread.java - Background thread that does stuff
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
/**
 * Services work requests in the background.
 * @author Slava Pestov
 * @version $Id: WorkThread.java,v 1.7 2003/03/12 17:01:50 spestov Exp $
 */
public class WorkThread extends Thread
{
	public WorkThread(WorkThreadPool pool, ThreadGroup group, String name)
	{
		super(group, name);
		// so that jEdit doesn't exit with no views open automatically
		//setDaemon(true);
		setPriority(Thread.MIN_PRIORITY);
		this.pool = pool;
	}
	/**
	 * Sets if the current request can be aborted.
	 * @since jEdit 2.6pre1
	 */
	public void setAbortable(boolean abortable)
	{
		synchronized(abortLock)
		{
			this.abortable = abortable;
			if(aborted)
				stop(new Abort());
		}
	}
	/**
	 * Returns if the work thread is currently running a request.
	 */
	public boolean isRequestRunning()
	{
		return requestRunning;
	}
	/**
	 * Returns the status text.
	 */
	public String getStatus()
	{
		return status;
	}
	/**
	 * Sets the status text.
	 * @since jEdit 2.6pre1
	 */
	public void setStatus(String status)
	{
		this.status = status;
		pool.fireProgressChanged(this);
	}
	/**
	 * Returns the progress value.
	 */
	public int getProgressValue()
	{
		return progressValue;
	}
	/**
	 * Sets the progress value.
	 * @since jEdit 2.6pre1
	 */
	public void setProgressValue(int progressValue)
	{
		this.progressValue = progressValue;
		pool.fireProgressChanged(this);
	}
	/**
	 * Returns the progress maximum.
	 */
	public int getProgressMaximum()
	{
		return progressMaximum;
	}
	/**
	 * Sets the maximum progress value.
	 * @since jEdit 2.6pre1
	 */
	public void setProgressMaximum(int progressMaximum)
	{
		this.progressMaximum = progressMaximum;
		pool.fireProgressChanged(this);
	}
	/**
	 * Aborts the currently running request, if allowed.
	 * @since jEdit 2.6pre1
	 */
	public void abortCurrentRequest()
	{
		synchronized(abortLock)
		{
			if(abortable && !aborted)
				stop(new Abort());
			aborted = true;
		}
	}
	public void run()
	{
		Log.log(Log.DEBUG,this,""Work request thread starting ["" + getName() + ""]"");
		for(;;)
		{
			doRequests();
		}
	}
	// private members
	private WorkThreadPool pool;
	private Object abortLock = new Object();
	private boolean requestRunning;
	private boolean abortable;
	private boolean aborted;
	private String status;
	private int progressValue;
	private int progressMaximum;
	private void doRequests()
	{
		WorkThreadPool.Request request;
		for(;;)
		{
			request = pool.getNextRequest();
			if(request == null)
				break;
			else
			{
				requestRunning = true;
				pool.fireStatusChanged(this);
				doRequest(request);
				requestRunning = false;
			}
		}
		pool.fireStatusChanged(this);
		synchronized(pool.waitForAllLock)
		{
			// notify a running waitForRequests() method
			pool.waitForAllLock.notifyAll();
		}
		synchronized(pool.lock)
		{
			// wait for more requests
			try
			{
				pool.lock.wait();
			}
			catch(InterruptedException ie)
			{
				Log.log(Log.ERROR,this,ie);
			}
		}
	}
	private void doRequest(WorkThreadPool.Request request)
	{
		Log.log(Log.DEBUG,WorkThread.class,""Running in work thread: "" + request);
		try
		{
			request.run.run();
		}
		catch(Abort a)
		{
			Log.log(Log.ERROR,WorkThread.class,""Unhandled abort"");
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in work thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}
		finally
		{
			synchronized(abortLock)
			{
				aborted = abortable = false;
			}
			status = null;
			progressValue = progressMaximum = 0;
			pool.requestDone();
			pool.fireStatusChanged(this);
		}
	}
	public static class Abort extends Error
	{
		public Abort()
		{
			super(""Work request aborted"");
		}
	}
}
"
org.gjt.sp.util.WorkThreadPool,"/*
 * WorkThreadPool.java - Background thread pool that does stuff
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
//{{{ Imports
import javax.swing.event.EventListenerList;
import javax.swing.SwingUtilities;
//}}}
/**
 * A pool of work threads.
 * @author Slava Pestov
 * @version $Id: WorkThreadPool.java,v 1.8 2004/05/29 01:55:26 spestov Exp $
 * @see org.gjt.sp.util.WorkThread
 * @since jEdit 2.6pre1
 */
public class WorkThreadPool
{
	//{{{ WorkThreadPool constructor
	/**
	 * Creates a new work thread pool with the specified number of
	 * work threads.
	 * @param name The thread name prefix
	 * @param count The number of work threads
	 */
	public WorkThreadPool(String name, int count)
	{
		listenerList = new EventListenerList();
		if(count != 0)
		{
			threadGroup = new ThreadGroup(name);
			threads = new WorkThread[count];
			for(int i = 0; i < threads.length; i++)
			{
				threads[i] = new WorkThread(this,threadGroup,name + "" #"" + (i+1));
			}
		}
		else
			Log.log(Log.WARNING,this,""Async I/O disabled"");
	} //}}}
	//{{{ start() method
	/**
	 * Starts all the threads in this thread pool.
	 */
	public void start()
	{
		/* not really needed since threads don't start until after */
		synchronized(lock)
		{
			started = true;
			if(awtRequestCount != 0 && requestCount == 0)
				queueAWTRunner();
		}
		if(threads != null)
		{
			for(int i = 0; i < threads.length; i++)
			{
				threads[i].start();
			}
		}
	} //}}}
	//{{{ addWorkRequest() method
	/**
	 * Adds a work request to the queue.
	 * @param run The runnable
	 * @param inAWT If true, will be executed in AWT thread. Otherwise,
	 * will be executed in work thread
	 */
	public void addWorkRequest(Runnable run, boolean inAWT)
	{
		if(threads == null)
		{
			run.run();
			return;
		}
		synchronized(lock)
		{
			//{{{ if there are no requests, execute AWT requests immediately
			if(started && inAWT && requestCount == 0 && awtRequestCount == 0)
			{
//				Log.log(Log.DEBUG,this,""AWT immediate: "" + run);
				if(SwingUtilities.isEventDispatchThread())
					run.run();
				else
					SwingUtilities.invokeLater(run);
				return;
			} //}}}
			Request request = new Request(run);
			//{{{ Add to AWT queue...
			if(inAWT)
			{
				if(firstAWTRequest == null && lastAWTRequest == null)
					firstAWTRequest = lastAWTRequest = request;
				else
				{
					lastAWTRequest.next = request;
					lastAWTRequest = request;
				}
				awtRequestCount++;
				// if no requests are running, requestDone()
				// will not be called, so we must queue the
				// AWT runner ourselves.
				if(started && requestCount == 0)
					queueAWTRunner();
			} //}}}
			//{{{ Add to work thread queue...
			else
			{
				if(firstRequest == null && lastRequest == null)
					firstRequest = lastRequest = request;
				else
				{
					lastRequest.next = request;
					lastRequest = request;
				}
				requestCount++;
			} //}}}
			lock.notifyAll();
		}
	} //}}}
	//{{{ waitForRequests() method
	/**
	 * Waits until all requests are complete.
	 */
	public void waitForRequests()
	{
		if(threads == null)
			return;
		synchronized(waitForAllLock)
		{
			while(requestCount != 0)
			{
				try
				{
					waitForAllLock.wait();
				}
				catch(InterruptedException ie)
				{
					Log.log(Log.ERROR,this,ie);
				}
			}
		}
		if(SwingUtilities.isEventDispatchThread())
		{
			// do any queued AWT runnables
			doAWTRequests();
		}
		else
		{
			try
			{
				SwingUtilities.invokeAndWait(new RunRequestsInAWTThread());
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
	} //}}}
	//{{{ getRequestCount() method
	/**
	 * Returns the number of pending requests.
	 */
	public int getRequestCount()
	{
		return requestCount;
	} //}}}
	//{{{ getThreadCount() method
	/**
	 * Returns the number of threads in this pool.
	 */
	public int getThreadCount()
	{
		if(threads == null)
			return 0;
		else
			return threads.length;
	} //}}}
	//{{{ getThread() method
	/**
	 * Returns the specified thread.
	 * @param index The index of the thread
	 */
	public WorkThread getThread(int index)
	{
		return threads[index];
	} //}}}
	//{{{ addProgressListener() method
	/**
	 * Adds a progress listener to this thread pool.
	 * @param listener The listener
	 */
	public void addProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.add(WorkThreadProgressListener.class,listener);
	} //}}}
	//{{{ removeProgressListener() method
	/**
	 * Removes a progress listener from this thread pool.
	 * @param listener The listener
	 */
	public void removeProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.remove(WorkThreadProgressListener.class,listener);
	} //}}}
	//{{{ Package-private members
	Object lock = new Object();
	Object waitForAllLock = new Object();
	//{{{ fireStatusChanged() method
	void fireStatusChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}
			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.statusUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} //}}}
	//{{{ fireProgressChanged() method
	void fireProgressChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}
			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.progressUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} //}}}
	//{{{ requestDone() method
	void requestDone()
	{
		synchronized(lock)
		{
			requestCount--;
			if(requestCount == 0 && firstAWTRequest != null)
				queueAWTRunner();
		}
	} //}}}
	//{{{ getNextRequest() method
	Request getNextRequest()
	{
		synchronized(lock)
		{
			Request request = firstRequest;
			if(request == null)
				return null;
			firstRequest = firstRequest.next;
			if(firstRequest == null)
				lastRequest = null;
			if(request.alreadyRun)
				throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
			request.alreadyRun = true;
			/* StringBuffer buf = new StringBuffer(""request queue is now: "");
			Request _request = request.next;
			while(_request != null)
			{
				buf.append(_request.id);
				if(_request.next != null)
					buf.append("","");
				_request = _request.next;
			}
			Log.log(Log.DEBUG,this,buf.toString()); */
			return request;
		}
	} //}}}
	//}}}
	//{{{ Private members
	//{{{ Instance variables
	private boolean started;
	private ThreadGroup threadGroup;
	private WorkThread[] threads;
	// Request queue
	private Request firstRequest;
	private Request lastRequest;
	private int requestCount;
	// AWT thread magic
	private boolean awtRunnerQueued;
	private Request firstAWTRequest;
	private Request lastAWTRequest;
	private int awtRequestCount;
	private EventListenerList listenerList;
	//}}}
	//{{{ doAWTRequests() method
	/** Must always be called with the lock held. */
	private void doAWTRequests()
	{
		while(requestCount == 0 && firstAWTRequest != null)
		{
			doAWTRequest(getNextAWTRequest());
		}
	} //}}}
	//{{{ doAWTRequest() method
	/** Must always be called with the lock held. */
	private void doAWTRequest(Request request)
	{
//		Log.log(Log.DEBUG,this,""Running in AWT thread: "" + request);
		try
		{
			request.run.run();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in AWT thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}
		awtRequestCount--;
	} //}}}
	//{{{ queueAWTRunner() method
	/** Must always be called with the lock held. */
	private void queueAWTRunner()
	{
		if(!awtRunnerQueued)
		{
			awtRunnerQueued = true;
			SwingUtilities.invokeLater(new RunRequestsInAWTThread());
//			Log.log(Log.DEBUG,this,""AWT runner queued"");
		}
	} //}}}
	//{{{ getNextAWTRequest() method
	private Request getNextAWTRequest()
	{
		Request request = firstAWTRequest;
		firstAWTRequest = firstAWTRequest.next;
		if(firstAWTRequest == null)
			lastAWTRequest = null;
		if(request.alreadyRun)
			throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
		request.alreadyRun = true;
		/* StringBuffer buf = new StringBuffer(""AWT request queue is now: "");
		Request _request = request.next;
		while(_request != null)
		{
			buf.append(_request.id);
			if(_request.next != null)
				buf.append("","");
			_request = _request.next;
		}
		Log.log(Log.DEBUG,this,buf.toString()); */
		return request;
	} //}}}
	//}}}
	static int ID;
	//{{{ Request class
	static class Request
	{
		int id = ++ID;
		Runnable run;
		boolean alreadyRun;
		Request next;
		Request(Runnable run)
		{
			this.run = run;
		}
		public String toString()
		{
			return ""[id="" + id + "",run="" + run + ""]"";
		}
	} //}}}
	//{{{ RunRequestsInAWTThread class
	class RunRequestsInAWTThread implements Runnable
	{
		public void run()
		{
			synchronized(lock)
			{
				awtRunnerQueued = false;
				if(requestCount == 0)
					doAWTRequests();
			}
		}
	} //}}}
}
"
org.gjt.sp.util.WorkThreadProgressListener,"/*
 * WorkThreadProgressListener.java - Progress listener
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import java.util.EventListener;
/**
 * A work thread execution progress listener.
 * @since jEdit 2.6pre1
 */
public interface WorkThreadProgressListener extends EventListener
{
	// status message changed, operation started, operation ends, ...
	void statusUpdate(WorkThreadPool threadPool, int threadIndex);
	// progress bar value change
	void progressUpdate(WorkThreadPool threadPool, int threadIndex);
}
"
org.objectweb.asm.ByteVector,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A dynamically extensible vector of bytes. This class is roughly equivalent to
 * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.
 */
final class ByteVector {
  /**
   * The content of this vector.
   */
  byte[] data;
  /**
   * Actual number of bytes in this vector.
   */
  int length;
  /**
   * Constructs a new {@link ByteVector ByteVector} with a default initial size.
   */
  public ByteVector () {
    data = new byte[64];
  }
  /**
   * Constructs a new {@link ByteVector ByteVector} with the given initial size.
   *
   * @param initialSize the initial size of the byte vector to be constructed.
   */
  public ByteVector (final int initialSize) {
    data = new byte[initialSize];
  }
  /**
   * Puts a byte into this byte vector. The byte vector is automatically
   * enlarged if necessary.
   *
   * @param b a byte.
   * @return this byte vector.
   */
  public ByteVector put1 (final int b) {
    int length = this.length;
    if (length + 1 > data.length) {
      enlarge(1);
    }
    data[length++] = (byte)b;
    this.length = length;
    return this;
  }
  /**
   * Puts two bytes into this byte vector. The byte vector is automatically
   * enlarged if necessary.
   *
   * @param b1 a byte.
   * @param b2 another byte.
   * @return this byte vector.
   */
  public ByteVector put11 (final int b1, final int b2) {
    int length = this.length;
    if (length + 2 > data.length) {
      enlarge(2);
    }
    byte[] data = this.data;
    data[length++] = (byte)b1;
    data[length++] = (byte)b2;
    this.length = length;
    return this;
  }
  /**
   * Puts a short into this byte vector. The byte vector is automatically
   * enlarged if necessary.
   *
   * @param s a short.
   * @return this byte vector.
   */
  public ByteVector put2 (final int s) {
    int length = this.length;
    if (length + 2 > data.length) {
      enlarge(2);
    }
    byte[] data = this.data;
    data[length++] = (byte)(s >>> 8);
    data[length++] = (byte)s;
    this.length = length;
    return this;
  }
  /**
   * Puts a byte and a short into this byte vector. The byte vector is
   * automatically enlarged if necessary.
   *
   * @param b a byte.
   * @param s a short.
   * @return this byte vector.
   */
  public ByteVector put12 (final int b, final int s) {
    int length = this.length;
    if (length + 3 > data.length) {
      enlarge(3);
    }
    byte[] data = this.data;
    data[length++] = (byte)b;
    data[length++] = (byte)(s >>> 8);
    data[length++] = (byte)s;
    this.length = length;
    return this;
  }
  /**
   * Puts an int into this byte vector. The byte vector is automatically
   * enlarged if necessary.
   *
   * @param i an int.
   * @return this byte vector.
   */
  public ByteVector put4 (final int i) {
    int length = this.length;
    if (length + 4 > data.length) {
      enlarge(4);
    }
    byte[] data = this.data;
    data[length++] = (byte)(i >>> 24);
    data[length++] = (byte)(i >>> 16);
    data[length++] = (byte)(i >>> 8);
    data[length++] = (byte)i;
    this.length = length;
    return this;
  }
  /**
   * Puts a long into this byte vector. The byte vector is automatically
   * enlarged if necessary.
   *
   * @param l a long.
   * @return this byte vector.
   */
  public ByteVector put8 (final long l) {
    int length = this.length;
    if (length + 8 > data.length) {
      enlarge(8);
    }
    byte[] data = this.data;
    int i = (int)(l >>> 32);
    data[length++] = (byte)(i >>> 24);
    data[length++] = (byte)(i >>> 16);
    data[length++] = (byte)(i >>> 8);
    data[length++] = (byte)i;
    i = (int)l;
    data[length++] = (byte)(i >>> 24);
    data[length++] = (byte)(i >>> 16);
    data[length++] = (byte)(i >>> 8);
    data[length++] = (byte)i;
    this.length = length;
    return this;
  }
  /**
   * Puts a String in UTF format into this byte vector. The byte vector is
   * automatically enlarged if necessary.
   *
   * @param s a String.
   * @return this byte vector.
   */
  public ByteVector putUTF (final String s) {
    int charLength = s.length();
    int byteLength = 0;
    for (int i = 0; i < charLength; ++i) {
      char c = s.charAt(i);
      if (c >= '\001' && c <= '\177') {
        byteLength++;
      } else if (c > '\u07FF') {
        byteLength += 3;
      } else {
        byteLength += 2;
      }
    }
    if (byteLength > 65535) {
      throw new IllegalArgumentException();
    }
    int length = this.length;
    if (length + 2 + byteLength > data.length) {
      enlarge(2 + byteLength);
    }
    byte[] data = this.data;
    data[length++] = (byte)(byteLength >>> 8);
    data[length++] = (byte)(byteLength);
    for (int i = 0; i < charLength; ++i) {
      char c = s.charAt(i);
      if (c >= '\001' && c <= '\177') {
        data[length++] = (byte)c;
      } else if (c > '\u07FF') {
        data[length++] = (byte)(0xE0 | c >> 12 & 0xF);
        data[length++] = (byte)(0x80 | c >> 6 & 0x3F);
        data[length++] = (byte)(0x80 | c & 0x3F);
      } else {
        data[length++] = (byte)(0xC0 | c >> 6 & 0x1F);
        data[length++] = (byte)(0x80 | c & 0x3F);
      }
    }
    this.length = length;
    return this;
  }
  /**
   * Puts an array of bytes into this byte vector. The byte vector is
   * automatically enlarged if necessary.
   *
   * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt> null
   *      bytes into this byte vector.
   * @param off index of the fist byte of b that must be copied.
   * @param len number of bytes of b that must be copied.
   * @return this byte vector.
   */
  public ByteVector putByteArray (
    final byte[] b,
    final int off,
    final int len)
  {
    if (length + len > data.length) {
      enlarge(len);
    }
    if (b != null) {
      System.arraycopy(b, off, data, length, len);
    }
    length += len;
    return this;
  }
  /**
   * Enlarge this byte vector so that it can receive n more bytes.
   *
   * @param size number of additional bytes that this byte vector should be
   *      able to receive.
   */
  private void enlarge (final int size) {
    byte[] newData = new byte[Math.max(2*data.length, length + size)];
    System.arraycopy(data, 0, newData, 0, length);
    data = newData;
  }
}
"
org.objectweb.asm.ClassVisitor,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A visitor to visit a Java class. The methods of this interface must be called
 * in the following order: <tt>visit</tt> (<tt>visitField</tt> |
 * <tt>visitMethod</tt> | <tt>visitInnerClass</tt>)* <tt>visitEnd</tt>.
 */
public interface ClassVisitor {
  /**
   * Visits the header of the class.
   *
   * @param access the class's access flags (see {@link Constants}). This
   *      parameter also indicates if the class is deprecated.
   * @param name the internal name of the class (see {@link Type#getInternalName
   *      getInternalName}).
   * @param superName the internal of name of the super class (see {@link
   *      Type#getInternalName getInternalName}). For interfaces, the super
   *      class is {@link Object}. May be <tt>null</tt>, but only for the {@link
   *      Object java.lang.Object} class.
   * @param interfaces the internal names of the class's interfaces (see {@link
   *      Type#getInternalName getInternalName}). May be <tt>null</tt>.
   * @param sourceFile the name of the source file from which this class was
   *      compiled. May be <tt>null</tt>.
   */
  void visit (
    int access,
    String name,
    String superName,
    String[] interfaces,
    String sourceFile);
  /**
   * Visits information about an inner class. This inner class is not
   * necessarily a member of the class being visited.
   *
   * @param name the internal name of an inner class (see {@link
   *      Type#getInternalName getInternalName}).
   * @param outerName the internal name of the class to which the inner class
   *      belongs (see {@link Type#getInternalName getInternalName}). May be
   *      <tt>null</tt>.
   * @param innerName the (simple) name of the inner class inside its enclosing
   *      class. May be <tt>null</tt> for anonymous inner classes.
   * @param access the access flags of the inner class as originally declared
   *      in the enclosing class.
   */
  void visitInnerClass (
    String name,
    String outerName,
    String innerName,
    int access);
  /**
   * Visits a field of the class.
   *
   * @param access the field's access flags (see {@link Constants}). This
   *      parameter also indicates if the field is synthetic and/or deprecated.
   * @param name the field's name.
   * @param desc the field's descriptor (see {@link Type Type}).
   * @param value the field's initial value. This parameter, which may be
   *      <tt>null</tt> if the field does not have an initial value, must be an
   *      {@link java.lang.Integer Integer}, a {@link java.lang.Float Float}, a
   *      {@link java.lang.Long Long}, a {@link java.lang.Double Double} or a
   *      {@link String String}.
   */
  void visitField (int access, String name, String desc, Object value);
  /**
   * Visits a method of the class. This method <i>must</i> return a new
   * {@link CodeVisitor CodeVisitor} instance (or <tt>null</tt>) each time it
   * is called, i.e., it should not return a previously returned visitor.
   *
   * @param access the method's access flags (see {@link Constants}). This
   *      parameter also indicates if the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param desc the method's descriptor (see {@link Type Type}).
   * @param exceptions the internal names of the method's exception
   *      classes (see {@link Type#getInternalName getInternalName}). May be
   *      <tt>null</tt>.
   * @return an object to visit the byte code of the method, or <tt>null</tt> if
   *      this class visitor is not interested in visiting the code of this
   *      method.
   */
  CodeVisitor visitMethod (
    int access,
    String name,
    String desc,
    String[] exceptions);
  /**
   * Visits the end of the class. This method, which is the last one to be
   * called, is used to inform the visitor that all the fields and methods of
   * the class have been visited.
   */
  void visitEnd ();
}
"
org.objectweb.asm.ClassWriter,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A {@link ClassVisitor ClassVisitor} that generates Java class files. More
 * precisely this visitor generates a byte array conforming to the Java class
 * file format. It can be used alone, to generate a Java class ""from scratch"",
 * or with one or more {@link ClassReader ClassReader} and adapter class
 * visitor to generate a modified class from one or more existing Java classes.
 */
public class ClassWriter implements ClassVisitor {
  /**
   * The type of CONSTANT_Class constant pool items.
   */
  final static int CLASS = 7;
  /**
   * The type of CONSTANT_Fieldref constant pool items.
   */
  final static int FIELD = 9;
  /**
   * The type of CONSTANT_Methodref constant pool items.
   */
  final static int METH = 10;
  /**
   * The type of CONSTANT_InterfaceMethodref constant pool items.
   */
  final static int IMETH = 11;
  /**
   * The type of CONSTANT_String constant pool items.
   */
  final static int STR = 8;
  /**
   * The type of CONSTANT_Integer constant pool items.
   */
  final static int INT = 3;
  /**
   * The type of CONSTANT_Float constant pool items.
   */
  final static int FLOAT = 4;
  /**
   * The type of CONSTANT_Long constant pool items.
   */
  final static int LONG = 5;
  /**
   * The type of CONSTANT_Double constant pool items.
   */
  final static int DOUBLE = 6;
  /**
   * The type of CONSTANT_NameAndType constant pool items.
   */
  final static int NAME_TYPE = 12;
  /**
   * The type of CONSTANT_Utf8 constant pool items.
   */
  final static int UTF8 = 1;
  /**
   * Index of the next item to be added in the constant pool.
   */
  private short index;
  /**
   * The constant pool of this class.
   */
  private ByteVector pool;
  /**
   * The constant pool's hash table data.
   */
  private Item[] table;
  /**
   * The threshold of the constant pool's hash table.
   */
  private int threshold;
  /**
   * The access flags of this class.
   */
  private int access;
  /**
   * The constant pool item that contains the internal name of this class.
   */
  private int name;
  /**
   * The constant pool item that contains the internal name of the super class
   * of this class.
   */
  private int superName;
  /**
   * Number of interfaces implemented or extended by this class or interface.
   */
  private int interfaceCount;
  /**
   * The interfaces implemented or extended by this class or interface. More
   * precisely, this array contains the indexes of the constant pool items
   * that contain the internal names of these interfaces.
   */
  private int[] interfaces;
  /**
   * The constant pool item that contains the name of the source file from
   * which this class was compiled.
   */
  private Item sourceFile;
  /**
   * Number of fields of this class.
   */
  private int fieldCount;
  /**
   * The fields of this class.
   */
  private ByteVector fields;
  /**
   * <tt>true</tt> if the maximum stack size and number of local variables must
   * be automatically computed.
   */
  private boolean computeMaxs;
  /**
   * The methods of this class. These methods are stored in a linked list of
   * {@link CodeWriter CodeWriter} objects, linked to each other by their {@link
   * CodeWriter#next} field. This field stores the first element of this list.
   */
  CodeWriter firstMethod;
  /**
   * The methods of this class. These methods are stored in a linked list of
   * {@link CodeWriter CodeWriter} objects, linked to each other by their {@link
   * CodeWriter#next} field. This field stores the last element of this list.
   */
  CodeWriter lastMethod;
  /**
   * The number of entries in the InnerClasses attribute.
   */
  private int innerClassesCount;
  /**
   * The InnerClasses attribute.
   */
  private ByteVector innerClasses;
  /**
   * A reusable key used to look for items in the hash {@link #table table}.
   */
  Item key;
  /**
   * A reusable key used to look for items in the hash {@link #table table}.
   */
  Item key2;
  /**
   * A reusable key used to look for items in the hash {@link #table table}.
   */
  Item key3;
  /**
   * The type of instructions without any label.
   */
  final static int NOARG_INSN = 0;
  /**
   * The type of instructions with an signed byte label.
   */
  final static int SBYTE_INSN = 1;
  /**
   * The type of instructions with an signed short label.
   */
  final static int SHORT_INSN = 2;
  /**
   * The type of instructions with a local variable index label.
   */
  final static int VAR_INSN = 3;
  /**
   * The type of instructions with an implicit local variable index label.
   */
  final static int IMPLVAR_INSN = 4;
  /**
   * The type of instructions with a type descriptor argument.
   */
  final static int TYPE_INSN = 5;
  /**
   * The type of field and method invocations instructions.
   */
  final static int FIELDORMETH_INSN = 6;
  /**
   * The type of the INVOKEINTERFACE instruction.
   */
  final static int ITFMETH_INSN = 7;
  /**
   * The type of instructions with a 2 bytes bytecode offset label.
   */
  final static int LABEL_INSN = 8;
  /**
   * The type of instructions with a 4 bytes bytecode offset label.
   */
  final static int LABELW_INSN = 9;
  /**
   * The type of the LDC instruction.
   */
  final static int LDC_INSN = 10;
  /**
   * The type of the LDC_W and LDC2_W instructions.
   */
  final static int LDCW_INSN = 11;
  /**
   * The type of the IINC instruction.
   */
  final static int IINC_INSN = 12;
  /**
   * The type of the TABLESWITCH instruction.
   */
  final static int TABL_INSN = 13;
  /**
   * The type of the LOOKUPSWITCH instruction.
   */
  final static int LOOK_INSN = 14;
  /**
   * The type of the MULTIANEWARRAY instruction.
   */
  final static int MANA_INSN = 15;
  /**
   * The type of the WIDE instruction.
   */
  final static int WIDE_INSN = 16;
  /**
   * The instruction types of all JVM opcodes.
   */
  static byte[] TYPE;
  // --------------------------------------------------------------------------
  // Static initializer
  // --------------------------------------------------------------------------
  /**
   * Computes the instruction types of JVM opcodes.
   */
  static {
    int i;
    byte[] b = new byte[220];
    String s =
      ""AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADDDDDEEEEEEEEE"" +
      ""EEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA"" +
      ""AAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAAAAAAGGGGGGGHAFBFAAFFAAQPIIJJII"" +
      ""IIIIIIIIIIIIIIII"";
    for (i = 0; i < b.length; ++i) {
      b[i] = (byte)(s.charAt(i) - 'A');
    }
    TYPE = b;
    /* code to generate the above string
    // SBYTE_INSN instructions
    b[Constants.NEWARRAY] = SBYTE_INSN;
    b[Constants.BIPUSH] = SBYTE_INSN;
    // SHORT_INSN instructions
    b[Constants.SIPUSH] = SHORT_INSN;
    // (IMPL)VAR_INSN instructions
    b[Constants.RET] = VAR_INSN;
    for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {
      b[i] = VAR_INSN;
    }
    for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {
      b[i] = VAR_INSN;
    }
    for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3
      b[i] = IMPLVAR_INSN;
    }
    for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3
      b[i] = IMPLVAR_INSN;
    }
    // TYPE_INSN instructions
    b[Constants.NEW] = TYPE_INSN;
    b[Constants.ANEWARRAY] = TYPE_INSN;
    b[Constants.CHECKCAST] = TYPE_INSN;
    b[Constants.INSTANCEOF] = TYPE_INSN;
    // (Set)FIELDORMETH_INSN instructions
    for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {
      b[i] = FIELDORMETH_INSN;
    }
    b[Constants.INVOKEINTERFACE] = ITFMETH_INSN;
    // LABEL(W)_INSN instructions
    for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {
      b[i] = LABEL_INSN;
    }
    b[Constants.IFNULL] = LABEL_INSN;
    b[Constants.IFNONNULL] = LABEL_INSN;
    b[200] = LABELW_INSN; // GOTO_W
    b[201] = LABELW_INSN; // JSR_W
    // temporary opcodes used internally by ASM - see Label and CodeWriter
    for (i = 202; i < 220; ++i) {
      b[i] = LABEL_INSN;
    }
    // LDC(_W) instructions
    b[Constants.LDC] = LDC_INSN;
    b[19] = LDCW_INSN; // LDC_W
    b[20] = LDCW_INSN; // LDC2_W
    // special instructions
    b[Constants.IINC] = IINC_INSN;
    b[Constants.TABLESWITCH] = TABL_INSN;
    b[Constants.LOOKUPSWITCH] = LOOK_INSN;
    b[Constants.MULTIANEWARRAY] = MANA_INSN;
    b[196] = WIDE_INSN; // WIDE
    for (i = 0; i < b.length; ++i) {
      System.err.print((char)('A' + b[i]));
    }
    System.err.println();
    */
  }
  // --------------------------------------------------------------------------
  // Constructor
  // --------------------------------------------------------------------------
  /**
   * Constructs a new {@link ClassWriter ClassWriter} object.
   *
   * @param computeMaxs <tt>true</tt> if the maximum stack size and the maximum
   *      number of local variables must be automatically computed. If this flag
   *      is <tt>true</tt>, then the arguments of the {@link
   *      CodeVisitor#visitMaxs visitMaxs} method of the {@link CodeVisitor
   *      CodeVisitor} returned by the {@link #visitMethod visitMethod} method
   *      will be ignored, and computed automatically from the signature and
   *      the bytecode of each method.
   */
  public ClassWriter (final boolean computeMaxs) {
    index = 1;
    pool = new ByteVector();
    table = new Item[64];
    threshold = (int)(0.75d*table.length);
    key = new Item();
    key2 = new Item();
    key3 = new Item();
    this.computeMaxs = computeMaxs;
  }
  // --------------------------------------------------------------------------
  // Implementation of the ClassVisitor interface
  // --------------------------------------------------------------------------
  public void visit (
    final int access,
    final String name,
    final String superName,
    final String[] interfaces,
    final String sourceFile)
  {
    this.access = access;
    this.name = newClass(name).index;
    this.superName = superName == null ? 0 : newClass(superName).index;
    if (interfaces != null && interfaces.length > 0) {
      interfaceCount = interfaces.length;
      this.interfaces = new int[interfaceCount];
      for (int i = 0; i < interfaceCount; ++i) {
        this.interfaces[i] = newClass(interfaces[i]).index;
      }
    }
    if (sourceFile != null) {
      newUTF8(""SourceFile"");
      this.sourceFile = newUTF8(sourceFile);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      newUTF8(""Deprecated"");
    }
  }
  public void visitInnerClass (
    final String name,
    final String outerName,
    final String innerName,
    final int access)
  {
    if (innerClasses == null) {
      newUTF8(""InnerClasses"");
      innerClasses = new ByteVector();
    }
    ++innerClassesCount;
    innerClasses.put2(name == null ? 0 : newClass(name).index);
    innerClasses.put2(outerName == null ? 0 : newClass(outerName).index);
    innerClasses.put2(innerName == null ? 0 : newUTF8(innerName).index);
    innerClasses.put2(access);
  }
  public void visitField (
    final int access,
    final String name,
    final String desc,
    final Object value)
  {
    ++fieldCount;
    if (fields == null) {
      fields = new ByteVector();
    }
    fields.put2(access).put2(newUTF8(name).index).put2(newUTF8(desc).index);
    int attributeCount = 0;
    if (value != null) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      ++attributeCount;
    }
    fields.put2(attributeCount);
    if (value != null) {
      fields.put2(newUTF8(""ConstantValue"").index);
      fields.put4(2).put2(newCst(value).index);
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      fields.put2(newUTF8(""Synthetic"").index).put4(0);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      fields.put2(newUTF8(""Deprecated"").index).put4(0);
    }
  }
  public CodeVisitor visitMethod (
    final int access,
    final String name,
    final String desc,
    final String[] exceptions)
  {
    CodeWriter cw = new CodeWriter(this, computeMaxs);
    cw.init(access, name, desc, exceptions);
    return cw;
  }
  public void visitEnd () {
  }
  // --------------------------------------------------------------------------
  // Other public methods
  // --------------------------------------------------------------------------
  /**
   * Returns the bytecode of the class that was build with this class writer.
   *
   * @return the bytecode of the class that was build with this class writer.
   */
  public byte[] toByteArray () {
    // computes the real size of the bytecode of this class
    int size = 24 + 2*interfaceCount;
    if (fields != null) {
      size += fields.length;
    }
    int nbMethods = 0;
    CodeWriter cb = firstMethod;
    while (cb != null) {
      ++nbMethods;
      size += cb.getSize();
      cb = cb.next;
    }
    size += pool.length;
    int attributeCount = 0;
    if (sourceFile != null) {
      ++attributeCount;
      size += 8;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      ++attributeCount;
      size += 6;
    }
    if (innerClasses != null) {
      ++attributeCount;
      size += 8 + innerClasses.length;
    }
    // allocates a byte vector of this size, in order to avoid unnecessary
    // arraycopy operations in the ByteVector.enlarge() method
    ByteVector out = new ByteVector(size);
    out.put4(0xCAFEBABE).put2(3).put2(45);
    out.put2(index).putByteArray(pool.data, 0, pool.length);
    out.put2(access).put2(name).put2(superName);
    out.put2(interfaceCount);
    for (int i = 0; i < interfaceCount; ++i) {
      out.put2(interfaces[i]);
    }
    out.put2(fieldCount);
    if (fields != null) {
      out.putByteArray(fields.data, 0, fields.length);
    }
    out.put2(nbMethods);
    cb = firstMethod;
    while (cb != null) {
      cb.put(out);
      cb = cb.next;
    }
    out.put2(attributeCount);
    if (sourceFile != null) {
      out.put2(newUTF8(""SourceFile"").index).put4(2).put2(sourceFile.index);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      out.put2(newUTF8(""Deprecated"").index).put4(0);
    }
    if (innerClasses != null) {
      out.put2(newUTF8(""InnerClasses"").index);
      out.put4(innerClasses.length + 2).put2(innerClassesCount);
      out.putByteArray(innerClasses.data, 0, innerClasses.length);
    }
    return out.data;
  }
  // --------------------------------------------------------------------------
  // Utility methods: constant pool management
  // --------------------------------------------------------------------------
  /**
   * Adds a number or string constant to the constant pool of the class being
   * build. Does nothing if the constant pool already contains a similar item.
   *
   * @param cst the value of the constant to be added to the constant pool. This
   *      parameter must be an {@link java.lang.Integer Integer}, a {@link
   *      java.lang.Float Float}, a {@link java.lang.Long Long}, a {@link
          java.lang.Double Double} or a {@link String String}.
   * @return a new or already existing constant item with the given value.
   */
  Item newCst (final Object cst) {
    if (cst instanceof Integer) {
      int val = ((Integer)cst).intValue();
      return newInteger(val);
    } else if (cst instanceof Float) {
      float val = ((Float)cst).floatValue();
      return newFloat(val);
    } else if (cst instanceof Long) {
      long val = ((Long)cst).longValue();
      return newLong(val);
    } else if (cst instanceof Double) {
      double val = ((Double)cst).doubleValue();
      return newDouble(val);
    } else if (cst instanceof String) {
      return newString((String)cst);
    } else {
      throw new IllegalArgumentException(""value "" + cst);
    }
  }
  /**
   * Adds an UTF string to the constant pool of the class being build. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param value the String value.
   * @return a new or already existing UTF8 item.
   */
  Item newUTF8 (final String value) {
    key.set(UTF8, value, null, null);
    Item result = get(key);
    if (result == null) {
      pool.put1(UTF8).putUTF(value);
      result = new Item(index++, key);
      put(result);
    }
    return result;
  }
  /**
   * Adds a class reference to the constant pool of the class being build. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param value the internal name of the class.
   * @return a new or already existing class reference item.
   */
  Item newClass (final String value) {
    key2.set(CLASS, value, null, null);
    Item result = get(key2);
    if (result == null) {
      pool.put12(CLASS, newUTF8(value).index);
      result = new Item(index++, key2);
      put(result);
    }
    return result;
  }
  /**
   * Adds a field reference to the constant pool of the class being build. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param owner the internal name of the field's owner class.
   * @param name the field's name.
   * @param desc the field's descriptor.
   * @return a new or already existing field reference item.
   */
  Item newField (
    final String owner,
    final String name,
    final String desc)
  {
    key3.set(FIELD, owner, name, desc);
    Item result = get(key3);
    if (result == null) {
      put122(FIELD, newClass(owner).index, newNameType(name, desc).index);
      result = new Item(index++, key3);
      put(result);
    }
    return result;
  }
  /**
   * Adds a method reference to the constant pool of the class being build. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param owner the internal name of the method's owner class.
   * @param name the method's name.
   * @param desc the method's descriptor.
   * @return a new or already existing method reference item.
   */
  Item newMethod (
    final String owner,
    final String name,
    final String desc)
  {
    key3.set(METH, owner, name, desc);
    Item result = get(key3);
    if (result == null) {
      put122(METH, newClass(owner).index, newNameType(name, desc).index);
      result = new Item(index++, key3);
      put(result);
    }
    return result;
  }
  /**
   * Adds an interface method reference to the constant pool of the class being
   * build. Does nothing if the constant pool already contains a similar item.
   *
   * @param ownerItf the internal name of the method's owner interface.
   * @param name the method's name.
   * @param desc the method's descriptor.
   * @return a new or already existing interface method reference item.
   */
  Item newItfMethod (
    final String ownerItf,
    final String name,
    final String desc)
  {
    key3.set(IMETH, ownerItf, name, desc);
    Item result = get(key3);
    if (result == null) {
      put122(IMETH, newClass(ownerItf).index, newNameType(name, desc).index);
      result = new Item(index++, key3);
      put(result);
    }
    return result;
  }
  /**
   * Adds an integer to the constant pool of the class being build. Does nothing
   * if the constant pool already contains a similar item.
   *
   * @param value the int value.
   * @return a new or already existing int item.
   */
  private Item newInteger (final int value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(INT).put4(value);
      result = new Item(index++, key);
      put(result);
    }
    return result;
  }
  /**
   * Adds a float to the constant pool of the class being build. Does nothing if
   * the constant pool already contains a similar item.
   *
   * @param value the float value.
   * @return a new or already existing float item.
   */
  private Item newFloat (final float value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(FLOAT).put4(Float.floatToIntBits(value));
      result = new Item(index++, key);
      put(result);
    }
    return result;
  }
  /**
   * Adds a long to the constant pool of the class being build. Does nothing if
   * the constant pool already contains a similar item.
   *
   * @param value the long value.
   * @return a new or already existing long item.
   */
  private Item newLong (final long value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(LONG).put8(value);
      result = new Item(index, key);
      put(result);
      index += 2;
    }
    return result;
  }
  /**
   * Adds a double to the constant pool of the class being build. Does nothing
   * if the constant pool already contains a similar item.
   *
   * @param value the double value.
   * @return a new or already existing double item.
   */
  private Item newDouble (final double value) {
    key.set(value);
    Item result = get(key);
    if (result == null) {
      pool.put1(DOUBLE).put8(Double.doubleToLongBits(value));
      result = new Item(index, key);
      put(result);
      index += 2;
    }
    return result;
  }
  /**
   * Adds a string to the constant pool of the class being build. Does nothing
   * if the constant pool already contains a similar item.
   *
   * @param value the String value.
   * @return a new or already existing string item.
   */
  private Item newString (final String value) {
    key2.set(STR, value, null, null);
    Item result = get(key2);
    if (result == null) {
      pool.put12(STR, newUTF8(value).index);
      result = new Item(index++, key2);
      put(result);
    }
    return result;
  }
  /**
   * Adds a name and type to the constant pool of the class being build. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param name a name.
   * @param desc a type descriptor.
   * @return a new or already existing name and type item.
   */
  private Item newNameType (final String name, final String desc) {
    key2.set(NAME_TYPE, name, desc, null);
    Item result = get(key2);
    if (result == null) {
      put122(NAME_TYPE, newUTF8(name).index, newUTF8(desc).index);
      result = new Item(index++, key2);
      put(result);
    }
    return result;
  }
  /**
   * Returns the constant pool's hash table item which is equal to the given
   * item.
   *
   * @param key a constant pool item.
   * @return the constant pool's hash table item which is equal to the given
   *      item, or <tt>null</tt> if there is no such item.
   */
  private Item get (final Item key) {
    Item tab[] = table;
    int hashCode = key.hashCode;
    int index = (hashCode & 0x7FFFFFFF) % tab.length;
    for (Item i = tab[index]; i != null; i = i.next) {
      if (i.hashCode == hashCode && key.isEqualTo(i)) {
        return i;
      }
    }
    return null;
  }
  /**
   * Puts the given item in the constant pool's hash table. The hash table
   * <i>must</i> not already contains this item.
   *
   * @param i the item to be added to the constant pool's hash table.
   */
  private void put (final Item i) {
    if (index > threshold) {
      int oldCapacity = table.length;
      Item oldMap[] = table;
      int newCapacity = oldCapacity * 2 + 1;
      Item newMap[] = new Item[newCapacity];
      threshold = (int)(newCapacity * 0.75);
      table = newMap;
      for (int j = oldCapacity; j-- > 0; ) {
        for (Item old = oldMap[j]; old != null; ) {
          Item e = old;
          old = old.next;
          int index = (e.hashCode & 0x7FFFFFFF) % newCapacity;
          e.next = newMap[index];
          newMap[index] = e;
        }
      }
    }
    int index = (i.hashCode & 0x7FFFFFFF) % table.length;
    i.next = table[index];
    table[index] = i;
  }
  /**
   * Puts one byte and two shorts into the constant pool.
   *
   * @param b a byte.
   * @param s1 a short.
   * @param s2 another short.
   */
  private void put122 (final int b, final int s1, final int s2) {
    pool.put12(b, s1).put2(s2);
  }
}
"
org.objectweb.asm.CodeVisitor,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A visitor to visit the bytecode instructions of a Java method. The methods
 * of this visitor must be called in the sequential order of the bytecode
 * instructions of the visited code. The {@link #visitMaxs visitMaxs} method
 * must be called after all the instructions have been visited. The {@link
 * #visitTryCatchBlock visitTryCatchBlock}, {@link #visitLocalVariable
 * visitLocalVariable} and {@link #visitLineNumber visitLineNumber} methods may
 * be called in any order, at any time (provided the labels passed as arguments
 * have already been visited with {@link #visitLabel visitLabel}).
 */
public interface CodeVisitor {
  /**
   * Visits a zero operand instruction.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is
   *      either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2,
   *      ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0, FCONST_1,
   *      FCONST_2, DCONST_0, DCONST_1,
   *
   *      IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD,
   *      IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE,
   *      SASTORE,
   *
   *      POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP,
   *
   *      IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL,
   *      DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG,
   *      FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR,
   *      LOR, IXOR, LXOR,
   *
   *      I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C,
   *      I2S,
   *
   *      LCMP, FCMPL, FCMPG, DCMPL, DCMPG,
   *
   *      IRETURN, LRETURN, FRETURN, DRETURN, ARETURN, RETURN,
   *
   *      ARRAYLENGTH,
   *
   *      ATHROW,
   *
   *      MONITORENTER, or MONITOREXIT.
   */
  void visitInsn (int opcode);
  /**
   * Visits an instruction with a single int operand.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is
   *      either BIPUSH, SIPUSH or NEWARRAY.
   * @param operand the operand of the instruction to be visited.
   */
  void visitIntInsn (int opcode, int operand);
  /**
   * Visits a local variable instruction. A local variable instruction is an
   * instruction that loads or stores the value of a local variable.
   *
   * @param opcode the opcode of the local variable instruction to be visited.
   *      This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE,
   *      LSTORE, FSTORE, DSTORE, ASTORE or RET.
   * @param var the operand of the instruction to be visited. This operand is
   *      the index of a local variable.
   */
  void visitVarInsn (int opcode, int var);
  /**
   * Visits a type instruction. A type instruction is an instruction that
   * takes a type descriptor as parameter.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode
   *      is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
   * @param desc the operand of the instruction to be visited. This operand is
   *      must be a fully qualified class name in internal form, or the type
   *      descriptor of an array type (see {@link Type Type}).
   */
  void visitTypeInsn (int opcode, String desc);
  /**
   * Visits a field instruction. A field instruction is an instruction that
   * loads or stores the value of a field of an object.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode
   *      is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
   * @param owner the internal name of the field's owner class (see {@link
   *      Type#getInternalName getInternalName}).
   * @param name the field's name.
   * @param desc the field's descriptor (see {@link Type Type}).
   */
  void visitFieldInsn (int opcode, String owner, String name, String desc);
  /**
   * Visits a method instruction. A method instruction is an instruction that
   * invokes a method.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode
   *      is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
   *      INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *      Type#getInternalName getInternalName}).
   * @param name the method's name.
   * @param desc the method's descriptor (see {@link Type Type}).
   */
  void visitMethodInsn (int opcode, String owner, String name, String desc);
  /**
   * Visits a jump instruction. A jump instruction is an instruction that may
   * jump to another instruction.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode
   *      is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE,
   *      IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE,
   *      GOTO, JSR, IFNULL or IFNONNULL.
   * @param label the operand of the instruction to be visited. This operand is
   *      a label that designates the instruction to which the jump instruction
   *      may jump.
   */
  void visitJumpInsn (int opcode, Label label);
  /**
   * Visits a label. A label designates the instruction that will be visited
   * just after it.
   *
   * @param label a {@link Label Label} object.
   */
  void visitLabel (Label label);
  // -------------------------------------------------------------------------
  // Special instructions
  // -------------------------------------------------------------------------
  /**
   * Visits a LDC instruction.
   *
   * @param cst the constant to be loaded on the stack. This parameter must be
   *      a non null {@link java.lang.Integer Integer}, a {@link java.lang.Float
   *      Float}, a {@link java.lang.Long Long}, a {@link java.lang.Double
   *      Double} or a {@link String String}.
   */
  void visitLdcInsn (Object cst);
  /**
   * Visits an IINC instruction.
   *
   * @param var index of the local variable to be incremented.
   * @param increment amount to increment the local variable by.
   */
  void visitIincInsn (int var, int increment);
  /**
   * Visits a TABLESWITCH instruction.
   *
   * @param min the minimum key value.
   * @param max the maximum key value.
   * @param dflt beginning of the default handler block.
   * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is the
   *      beginning of the handler block for the <tt>min + i</tt> key.
   */
  void visitTableSwitchInsn (int min, int max, Label dflt, Label labels[]);
  /**
   * Visits a LOOKUPSWITCH instruction.
   *
   * @param dflt beginning of the default handler block.
   * @param keys the values of the keys.
   * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is the
   *      beginning of the handler block for the <tt>keys[i]</tt> key.
   */
  void visitLookupSwitchInsn (Label dflt, int keys[], Label labels[]);
  /**
   * Visits a MULTIANEWARRAY instruction.
   *
   * @param desc an array type descriptor (see {@link Type Type}).
   * @param dims number of dimensions of the array to allocate.
   */
  void visitMultiANewArrayInsn (String desc, int dims);
  // -------------------------------------------------------------------------
  // Exceptions table entries, max stack size and max locals
  // -------------------------------------------------------------------------
  /**
   * Visits a try catch block.
   *
   * @param start beginning of the exception handler's scope (inclusive).
   * @param end end of the exception handler's scope (exclusive).
   * @param handler beginning of the exception handler's code.
   * @param type internal name of the type of exceptions handled by the handler,
   *      or <tt>null</tt> to catch any exceptions (for ""finally"" blocks).
   * @throws IllegalArgumentException if one of the labels has not already been
   *      visited by this visitor (by the {@link #visitLabel visitLabel}
   *      method).
   */
  void visitTryCatchBlock (Label start, Label end, Label handler, String type);
  /**
   * Visits the maximum stack size and the maximum number of local variables of
   * the method.
   *
   * @param maxStack maximum stack size of the method.
   * @param maxLocals maximum number of local variables for the method.
   */
  void visitMaxs (int maxStack, int maxLocals);
  // -------------------------------------------------------------------------
  // Debug information
  // -------------------------------------------------------------------------
  /**
   * Visits a local variable declaration.
   *
   * @param name the name of a local variable.
   * @param desc the type descriptor of this local variable.
   * @param start the first instruction corresponding to the scope of this
   *      local variable (inclusive).
   * @param end the last instruction corresponding to the scope of this
   *      local variable (exclusive).
   * @param index the local variable's index.
   * @throws IllegalArgumentException if one of the labels has not already been
   *      visited by this visitor (by the {@link #visitLabel visitLabel}
   *      method).
   */
  void visitLocalVariable (
    String name,
    String desc,
    Label start,
    Label end,
    int index);
  /**
   * Visits a line number declaration.
   *
   * @param line a line number. This number refers to the source file
   *      from which the class was compiled.
   * @param start the first instruction corresponding to this line number.
   * @throws IllegalArgumentException if <tt>start</tt> has not already been
   *      visited by this visitor (by the {@link #visitLabel visitLabel}
   *      method).
   */
  void visitLineNumber (int line, Label start);
}
"
org.objectweb.asm.CodeWriter,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A {@link CodeVisitor CodeVisitor} that generates Java bytecode instructions.
 * Each visit method of this class appends the bytecode corresponding to the
 * visited instruction to a byte vector, in the order these methods are called.
 */
public class CodeWriter implements CodeVisitor {
  /**
   * <tt>true</tt> if preconditions must be checked at runtime or not.
   */
  final static boolean CHECK = false;
  /**
   * Next code writer (see {@link ClassWriter#firstMethod firstMethod}).
   */
  CodeWriter next;
  /**
   * The class writer to which this method must be added.
   */
  private ClassWriter cw;
  /**
   * The constant pool item that contains the name of this method.
   */
  private Item name;
  /**
   * The constant pool item that contains the descriptor of this method.
   */
  private Item desc;
  /**
   * Access flags of this method.
   */
  private int access;
  /**
   * Maximum stack size of this method.
   */
  private int maxStack;
  /**
   * Maximum number of local variables for this method.
   */
  private int maxLocals;
  /**
   * The bytecode of this method.
   */
  private ByteVector code = new ByteVector();
  /**
   * Number of entries in the catch table of this method.
   */
  private int catchCount;
  /**
   * The catch table of this method.
   */
  private ByteVector catchTable;
  /**
   * Number of exceptions that can be thrown by this method.
   */
  private int exceptionCount;
  /**
   * The exceptions that can be thrown by this method. More
   * precisely, this array contains the indexes of the constant pool items
   * that contain the internal names of these exception classes.
   */
  private int[] exceptions;
  /**
   * Number of entries in the LocalVariableTable attribute.
   */
  private int localVarCount;
  /**
   * The LocalVariableTable attribute.
   */
  private ByteVector localVar;
  /**
   * Number of entries in the LineNumberTable attribute.
   */
  private int lineNumberCount;
  /**
   * The LineNumberTable attribute.
   */
  private ByteVector lineNumber;
  /**
   * Indicates if some jump instructions are too small and need to be resized.
   */
  private boolean resize;
  // --------------------------------------------------------------------------
  // Fields for the control flow graph analysis algorithm (used to compute the
  // maximum stack size). A control flow graph contains one node per ""basic
  // block"", and one edge per ""jump"" from one basic block to another. Each node
  // (i.e., each basic block) is represented by the Label object that
  // corresponds to the first instruction of this basic block. Each node also
  // stores the list of its successors in the graph, as a linked list of Edge
  // objects.
  // --------------------------------------------------------------------------
  /**
   * <tt>true</tt> if the maximum stack size and number of local variables must
   * be automatically computed.
   */
  private final boolean computeMaxs;
  /**
   * The (relative) stack size after the last visited instruction. This size is
   * relative to the beginning of the current basic block, i.e., the true stack
   * size after the last visited instruction is equal to the {@link
   * Label#beginStackSize beginStackSize} of the current basic block plus
   * <tt>stackSize</tt>.
   */
  private int stackSize;
  /**
   * The (relative) maximum stack size after the last visited instruction. This
   * size is relative to the beginning of the current basic block, i.e., the
   * true maximum stack size after the last visited instruction is equal to the
   * {@link Label#beginStackSize beginStackSize} of the current basic block plus
   * <tt>stackSize</tt>.
   */
  private int maxStackSize;
  /**
   * The current basic block. This block is the basic block to which the next
   * instruction to be visited must be added.
   */
  private Label currentBlock;
  /**
   * The basic block stack used by the control flow analysis algorithm. This
   * stack is represented by a linked list of {@link Label Label} objects,
   * linked to each other by their {@link Label#next} field. This stack must
   * not be confused with the JVM stack used to execute the JVM instructions!
   */
  private Label blockStack;
  /**
   * The stack size variation corresponding to each JVM instruction. This stack
   * variation is equal to the size of the values produced by an instruction,
   * minus the size of the values consumed by this instruction.
   */
  private final static int[] SIZE;
  // --------------------------------------------------------------------------
  // Fields to optimize the creation of {@link Edge Edge} objects by using a
  // pool of reusable objects. The (shared) pool is a linked list of Edge
  // objects, linked to each other by their {@link Edge#poolNext} field. Each
  // time a CodeWriter needs to allocate an Edge, it removes the first Edge
  // of the pool and adds it to a private list of Edge objects. After the end
  // of the control flow analysis algorithm, the Edge objects in the private
  // list of the CodeWriter are added back to the pool (by appending this
  // private list to the pool list; in order to do this in constant time, both
  // head and tail of the private list are stored in this CodeWriter).
  // --------------------------------------------------------------------------
  /**
   * The head of the list of {@link Edge Edge} objects used by this {@link
   * CodeWriter CodeWriter}. These objects, linked to each other by their
   * {@link Edge#poolNext} field, are added back to the shared pool at the
   * end of the control flow analysis algorithm.
   */
  private Edge head;
  /**
   * The tail of the list of {@link Edge Edge} objects used by this {@link
   * CodeWriter CodeWriter}. These objects, linked to each other by their
   * {@link Edge#poolNext} field, are added back to the shared pool at the
   * end of the control flow analysis algorithm.
   */
  private Edge tail;
  /**
   * The shared pool of {@link Edge Edge} objects. This pool is a linked list
   * of Edge objects, linked to each other by their {@link Edge#poolNext} field.
   */
  private static Edge pool;
  // --------------------------------------------------------------------------
  // Static initializer
  // --------------------------------------------------------------------------
  /**
   * Computes the stack size variation corresponding to each JVM instruction.
   */
  static {
    int i;
    int[] b = new int[202];
    String s =
      ""EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDDCDCDEEEEEEEEE"" +
      ""EEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCDCDCEEEEDDDDDDDCDCDCEFEF"" +
      ""DDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFEDDDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE"";
    for (i = 0; i < b.length; ++i) {
      b[i] = s.charAt(i) - 'E';
    }
    SIZE = b;
    /* code to generate the above string
    int NA = 0; // not applicable (unused opcode or variable size opcode)
    b = new int[] {
      0,  //NOP,             // visitInsn
      1,  //ACONST_NULL,     // -
      1,  //ICONST_M1,       // -
      1,  //ICONST_0,        // -
      1,  //ICONST_1,        // -
      1,  //ICONST_2,        // -
      1,  //ICONST_3,        // -
      1,  //ICONST_4,        // -
      1,  //ICONST_5,        // -
      2,  //LCONST_0,        // -
      2,  //LCONST_1,        // -
      1,  //FCONST_0,        // -
      1,  //FCONST_1,        // -
      1,  //FCONST_2,        // -
      2,  //DCONST_0,        // -
      2,  //DCONST_1,        // -
      1,  //BIPUSH,          // visitIntInsn
      1,  //SIPUSH,          // -
      1,  //LDC,             // visitLdcInsn
      NA, //LDC_W,           // -
      NA, //LDC2_W,          // -
      1,  //ILOAD,           // visitVarInsn
      2,  //LLOAD,           // -
      1,  //FLOAD,           // -
      2,  //DLOAD,           // -
      1,  //ALOAD,           // -
      NA, //ILOAD_0,         // -
      NA, //ILOAD_1,         // -
      NA, //ILOAD_2,         // -
      NA, //ILOAD_3,         // -
      NA, //LLOAD_0,         // -
      NA, //LLOAD_1,         // -
      NA, //LLOAD_2,         // -
      NA, //LLOAD_3,         // -
      NA, //FLOAD_0,         // -
      NA, //FLOAD_1,         // -
      NA, //FLOAD_2,         // -
      NA, //FLOAD_3,         // -
      NA, //DLOAD_0,         // -
      NA, //DLOAD_1,         // -
      NA, //DLOAD_2,         // -
      NA, //DLOAD_3,         // -
      NA, //ALOAD_0,         // -
      NA, //ALOAD_1,         // -
      NA, //ALOAD_2,         // -
      NA, //ALOAD_3,         // -
      -1, //IALOAD,          // visitInsn
      0,  //LALOAD,          // -
      -1, //FALOAD,          // -
      0,  //DALOAD,          // -
      -1, //AALOAD,          // -
      -1, //BALOAD,          // -
      -1, //CALOAD,          // -
      -1, //SALOAD,          // -
      -1, //ISTORE,          // visitVarInsn
      -2, //LSTORE,          // -
      -1, //FSTORE,          // -
      -2, //DSTORE,          // -
      -1, //ASTORE,          // -
      NA, //ISTORE_0,        // -
      NA, //ISTORE_1,        // -
      NA, //ISTORE_2,        // -
      NA, //ISTORE_3,        // -
      NA, //LSTORE_0,        // -
      NA, //LSTORE_1,        // -
      NA, //LSTORE_2,        // -
      NA, //LSTORE_3,        // -
      NA, //FSTORE_0,        // -
      NA, //FSTORE_1,        // -
      NA, //FSTORE_2,        // -
      NA, //FSTORE_3,        // -
      NA, //DSTORE_0,        // -
      NA, //DSTORE_1,        // -
      NA, //DSTORE_2,        // -
      NA, //DSTORE_3,        // -
      NA, //ASTORE_0,        // -
      NA, //ASTORE_1,        // -
      NA, //ASTORE_2,        // -
      NA, //ASTORE_3,        // -
      -3, //IASTORE,         // visitInsn
      -4, //LASTORE,         // -
      -3, //FASTORE,         // -
      -4, //DASTORE,         // -
      -3, //AASTORE,         // -
      -3, //BASTORE,         // -
      -3, //CASTORE,         // -
      -3, //SASTORE,         // -
      -1, //POP,             // -
      -2, //POP2,            // -
      1,  //DUP,             // -
      1,  //DUP_X1,          // -
      1,  //DUP_X2,          // -
      2,  //DUP2,            // -
      2,  //DUP2_X1,         // -
      2,  //DUP2_X2,         // -
      0,  //SWAP,            // -
      -1, //IADD,            // -
      -2, //LADD,            // -
      -1, //FADD,            // -
      -2, //DADD,            // -
      -1, //ISUB,            // -
      -2, //LSUB,            // -
      -1, //FSUB,            // -
      -2, //DSUB,            // -
      -1, //IMUL,            // -
      -2, //LMUL,            // -
      -1, //FMUL,            // -
      -2, //DMUL,            // -
      -1, //IDIV,            // -
      -2, //LDIV,            // -
      -1, //FDIV,            // -
      -2, //DDIV,            // -
      -1, //IREM,            // -
      -2, //LREM,            // -
      -1, //FREM,            // -
      -2, //DREM,            // -
      0,  //INEG,            // -
      0,  //LNEG,            // -
      0,  //FNEG,            // -
      0,  //DNEG,            // -
      -1, //ISHL,            // -
      -1, //LSHL,            // -
      -1, //ISHR,            // -
      -1, //LSHR,            // -
      -1, //IUSHR,           // -
      -1, //LUSHR,           // -
      -1, //IAND,            // -
      -2, //LAND,            // -
      -1, //IOR,             // -
      -2, //LOR,             // -
      -1, //IXOR,            // -
      -2, //LXOR,            // -
      0,  //IINC,            // visitIincInsn
      1,  //I2L,             // visitInsn
      0,  //I2F,             // -
      1,  //I2D,             // -
      -1, //L2I,             // -
      -1, //L2F,             // -
      0,  //L2D,             // -
      0,  //F2I,             // -
      1,  //F2L,             // -
      1,  //F2D,             // -
      -1, //D2I,             // -
      0,  //D2L,             // -
      -1, //D2F,             // -
      0,  //I2B,             // -
      0,  //I2C,             // -
      0,  //I2S,             // -
      -3, //LCMP,            // -
      -1, //FCMPL,           // -
      -1, //FCMPG,           // -
      -3, //DCMPL,           // -
      -3, //DCMPG,           // -
      -1, //IFEQ,            // visitJumpInsn
      -1, //IFNE,            // -
      -1, //IFLT,            // -
      -1, //IFGE,            // -
      -1, //IFGT,            // -
      -1, //IFLE,            // -
      -2, //IF_ICMPEQ,       // -
      -2, //IF_ICMPNE,       // -
      -2, //IF_ICMPLT,       // -
      -2, //IF_ICMPGE,       // -
      -2, //IF_ICMPGT,       // -
      -2, //IF_ICMPLE,       // -
      -2, //IF_ACMPEQ,       // -
      -2, //IF_ACMPNE,       // -
      0,  //GOTO,            // -
      1,  //JSR,             // -
      0,  //RET,             // visitVarInsn
      -1, //TABLESWITCH,     // visiTableSwitchInsn
      -1, //LOOKUPSWITCH,    // visitLookupSwitch
      -1, //IRETURN,         // visitInsn
      -2, //LRETURN,         // -
      -1, //FRETURN,         // -
      -2, //DRETURN,         // -
      -1, //ARETURN,         // -
      0,  //RETURN,          // -
      NA, //GETSTATIC,       // visitFieldInsn
      NA, //PUTSTATIC,       // -
      NA, //GETFIELD,        // -
      NA, //PUTFIELD,        // -
      NA, //INVOKEVIRTUAL,   // visitMethodInsn
      NA, //INVOKESPECIAL,   // -
      NA, //INVOKESTATIC,    // -
      NA, //INVOKEINTERFACE, // -
      NA, //UNUSED,          // NOT VISITED
      1,  //NEW,             // visitTypeInsn
      0,  //NEWARRAY,        // visitIntInsn
      0,  //ANEWARRAY,       // visitTypeInsn
      0,  //ARRAYLENGTH,     // visitInsn
      NA, //ATHROW,          // -
      0,  //CHECKCAST,       // visitTypeInsn
      0,  //INSTANCEOF,      // -
      -1, //MONITORENTER,    // visitInsn
      -1, //MONITOREXIT,     // -
      NA, //WIDE,            // NOT VISITED
      NA, //MULTIANEWARRAY,  // visitMultiANewArrayInsn
      -1, //IFNULL,          // visitJumpInsn
      -1, //IFNONNULL,       // -
      NA, //GOTO_W,          // -
      NA, //JSR_W,           // -
    };
    for (i = 0; i < b.length; ++i) {
      System.err.print((char)('E' + b[i]));
    }
    System.err.println();
    */
  }
  // --------------------------------------------------------------------------
  // Constructor
  // --------------------------------------------------------------------------
  /**
   * Constructs a CodeWriter.
   *
   * @param cw the class writer in which the method must be added.
   * @param computeMaxs <tt>true</tt> if the maximum stack size and number of
   *      local variables must be automatically computed.
   */
  protected CodeWriter (final ClassWriter cw, final boolean computeMaxs) {
    if (cw.firstMethod == null) {
      cw.firstMethod = this;
      cw.lastMethod = this;
    } else {
      cw.lastMethod.next = this;
      cw.lastMethod = this;
    }
    this.cw = cw;
    this.computeMaxs = computeMaxs;
    if (computeMaxs) {
      // pushes the first block onto the stack of blocks to be visited
      currentBlock = new Label();
      currentBlock.pushed = true;
      blockStack = currentBlock;
    }
  }
  /**
   * Initializes this CodeWriter to define the bytecode of the specified method.
   *
   * @param access the method's access flags (see {@link Constants}).
   * @param name the method's name.
   * @param desc the method's descriptor (see {@link Type Type}).
   * @param exceptions the internal names of the method's exceptions. May be
   *      <tt>null</tt>.
   */
  protected void init (
    final int access,
    final String name,
    final String desc,
    final String[] exceptions)
  {
    this.access = access;
    this.name = cw.newUTF8(name);
    this.desc = cw.newUTF8(desc);
    if (exceptions != null && exceptions.length > 0) {
      exceptionCount = exceptions.length;
      this.exceptions = new int[exceptionCount];
      for (int i = 0; i < exceptionCount; ++i) {
        this.exceptions[i] = cw.newClass(exceptions[i]).index;
      }
    }
    if (computeMaxs) {
      // updates maxLocals
      int size = getArgumentsAndReturnSizes(desc) >> 2;
      if ((access & Constants.ACC_STATIC) != 0) {
        --size;
      }
      if (size > maxLocals) {
        maxLocals = size;
      }
    }
  }
  // --------------------------------------------------------------------------
  // Implementation of the CodeVisitor interface
  // --------------------------------------------------------------------------
  public void visitInsn (final int opcode) {
    if (computeMaxs) {
      // updates current and max stack sizes
      int size = stackSize + SIZE[opcode];
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
      // if opcode == ATHROW or xRETURN, ends current block (no successor)
      if ((opcode >= Constants.IRETURN && opcode <= Constants.RETURN) ||
          opcode == Constants.ATHROW)
      {
        if (currentBlock != null) {
          currentBlock.maxStackSize = maxStackSize;
          currentBlock = null;
        }
      }
    }
    // adds the instruction to the bytecode of the method
    code.put1(opcode);
  }
  public void visitIntInsn (final int opcode, final int operand) {
    if (computeMaxs && opcode != Constants.NEWARRAY) {
      // updates current and max stack sizes only if opcode == NEWARRAY
      // (stack size variation = 0 for BIPUSH or SIPUSH)
      int size = stackSize + 1;
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    // adds the instruction to the bytecode of the method
    if (opcode == Constants.SIPUSH) {
      code.put12(opcode, operand);
    } else { // BIPUSH or NEWARRAY
      code.put11(opcode, operand);
    }
  }
  public void visitVarInsn (final int opcode, final int var) {
    if (computeMaxs) {
      // updates current and max stack sizes
      if (opcode == Constants.RET) {
        // no stack change, but end of current block (no successor)
        if (currentBlock != null) {
          currentBlock.maxStackSize = maxStackSize;
          currentBlock = null;
        }
      } else { // xLOAD or xSTORE
        int size = stackSize + SIZE[opcode];
        if (size > maxStackSize) {
          maxStackSize = size;
        }
        stackSize = size;
      }
      // updates max locals
      int n;
      if (opcode == Constants.LLOAD || opcode == Constants.DLOAD ||
          opcode == Constants.LSTORE || opcode == Constants.DSTORE)
      {
        n = var + 2;
      } else {
        n = var + 1;
      }
      if (n > maxLocals) {
        maxLocals = n;
      }
    }
    // adds the instruction to the bytecode of the method
    if (var < 4 && opcode != Constants.RET) {
      int opt;
      if (opcode < Constants.ISTORE) {
        opt = 26 /*ILOAD_0*/ + ((opcode - Constants.ILOAD) << 2) + var;
      } else {
        opt = 59 /*ISTORE_0*/ + ((opcode - Constants.ISTORE) << 2) + var;
      }
      code.put1(opt);
    } else if (var >= 256) {
      code.put1(196 /*WIDE*/).put12(opcode, var);
    } else {
      code.put11(opcode, var);
    }
  }
  public void visitTypeInsn (final int opcode, final String desc) {
    if (computeMaxs && opcode == Constants.NEW) {
      // updates current and max stack sizes only if opcode == NEW
      // (stack size variation = 0 for ANEWARRAY, CHECKCAST, INSTANCEOF)
      int size = stackSize + 1;
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    // adds the instruction to the bytecode of the method
    code.put12(opcode, cw.newClass(desc).index);
  }
  public void visitFieldInsn (
    final int opcode,
    final String owner,
    final String name,
    final String desc)
  {
    if (computeMaxs) {
      int size;
      // computes the stack size variation
      char c = desc.charAt(0);
      switch (opcode) {
        case Constants.GETSTATIC:
          size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);
          break;
        case Constants.PUTSTATIC:
          size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);
          break;
        case Constants.GETFIELD:
          size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);
          break;
        //case Constants.PUTFIELD:
        default:
          size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);
          break;
      }
      // updates current and max stack sizes
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    // adds the instruction to the bytecode of the method
    code.put12(opcode, cw.newField(owner, name, desc).index);
  }
  public void visitMethodInsn (
    final int opcode,
    final String owner,
    final String name,
    final String desc)
  {
    Item i;
    if (opcode == Constants.INVOKEINTERFACE) {
      i = cw.newItfMethod(owner, name, desc);
    } else {
      i = cw.newMethod(owner, name, desc);
    }
    int argSize = i.intVal;
    if (computeMaxs) {
      // computes the stack size variation. In order not to recompute several
      // times this variation for the same Item, we use the intVal field of
      // this item to store this variation, once it has been computed. More
      // precisely this intVal field stores the sizes of the arguments and of
      // the return value corresponding to desc.
      if (argSize == 0) {
        // the above sizes have not been computed yet, so we compute them...
        argSize = getArgumentsAndReturnSizes(desc);
        // ... and we save them in order not to recompute them in the future
        i.intVal = argSize;
      }
      int size;
      if (opcode == Constants.INVOKESTATIC) {
        size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;
      } else {
        size = stackSize - (argSize >> 2) + (argSize & 0x03);
      }
      // updates current and max stack sizes
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    // adds the instruction to the bytecode of the method
    if (opcode == Constants.INVOKEINTERFACE) {
      if (!computeMaxs) {
        if (argSize == 0) {
          argSize = getArgumentsAndReturnSizes(desc);
          i.intVal = argSize;
        }
      }
      code.put12(Constants.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);
    } else {
      code.put12(opcode, i.index);
    }
  }
  public void visitJumpInsn (final int opcode, final Label label) {
    if (CHECK) {
      if (label.owner == null) {
        label.owner = this;
      } else if (label.owner != this) {
        throw new IllegalArgumentException();
      }
    }
    if (computeMaxs) {
      if (opcode == Constants.GOTO) {
        // no stack change, but end of current block (with one new successor)
        if (currentBlock != null) {
          currentBlock.maxStackSize = maxStackSize;
          addSuccessor(stackSize, label);
          currentBlock = null;
        }
      } else if (opcode == Constants.JSR) {
        if (currentBlock != null) {
          addSuccessor(stackSize + 1, label);
        }
      } else {
        // updates current stack size (max stack size unchanged because stack
        // size variation always negative in this case)
        stackSize += SIZE[opcode];
        if (currentBlock != null) {
          addSuccessor(stackSize, label);
        }
      }
    }
    // adds the instruction to the bytecode of the method
    if (label.resolved && label.position - code.length < Short.MIN_VALUE) {
      // case of a backward jump with an offset < -32768. In this case we
      // automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx <l>
      // with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the ""opposite"" opcode
      // of IFxxx (i.e., IFNE for IFEQ) and where <l'> designates the
      // instruction just after the GOTO_W.
      if (opcode == Constants.GOTO) {
        code.put1(200); // GOTO_W
      } else if (opcode == Constants.JSR) {
        code.put1(201); // JSR_W
      } else {
        code.put1(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);
        code.put2(8);   // jump offset
        code.put1(200); // GOTO_W
      }
      label.put(this, code, code.length - 1, true);
    } else {
      // case of a backward jump with an offset >= -32768, or of a forward jump
      // with, of course, an unknown offset. In these cases we store the offset
      // in 2 bytes (which will be increased in resizeInstructions, if needed).
      code.put1(opcode);
      label.put(this, code, code.length - 1, false);
    }
  }
  public void visitLabel (final Label label) {
    if (CHECK) {
      if (label.owner == null) {
        label.owner = this;
      } else if (label.owner != this) {
        throw new IllegalArgumentException();
      }
    }
    if (computeMaxs) {
      if (currentBlock != null) {
        // ends current block (with one new successor)
        currentBlock.maxStackSize = maxStackSize;
        addSuccessor(stackSize, label);
      }
      // begins a new current block,
      // resets the relative current and max stack sizes
      currentBlock = label;
      stackSize = 0;
      maxStackSize = 0;
    }
    // resolves previous forward references to label, if any
    resize |= label.resolve(this, code.length, code.data);
  }
  public void visitLdcInsn (final Object cst) {
    Item i = cw.newCst(cst);
    if (computeMaxs) {
      int size;
      // computes the stack size variation
      if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {
        size = stackSize + 2;
      } else {
        size = stackSize + 1;
      }
      // updates current and max stack sizes
      if (size > maxStackSize) {
        maxStackSize = size;
      }
      stackSize = size;
    }
    // adds the instruction to the bytecode of the method
    int index = i.index;
    if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {
      code.put12(20 /*LDC2_W*/, index);
    } else if (index >= 256) {
      code.put12(19 /*LDC_W*/, index);
    } else {
      code.put11(Constants.LDC, index);
    }
  }
  public void visitIincInsn (final int var, final int increment) {
    if (computeMaxs) {
      // updates max locals only (no stack change)
      int n = var + 1;
      if (n > maxLocals) {
        maxLocals = n;
      }
    }
    // adds the instruction to the bytecode of the method
    if ((var > 255) || (increment > 127) || (increment < -128)) {
      code.put1(196 /*WIDE*/).put12(Constants.IINC, var).put2(increment);
    } else {
      code.put1(Constants.IINC).put11(var, increment);
    }
  }
  public void visitTableSwitchInsn (
    final int min,
    final int max,
    final Label dflt,
    final Label labels[])
  {
    if (computeMaxs) {
      // updates current stack size (max stack size unchanged)
      --stackSize;
      // ends current block (with many new successors)
      if (currentBlock != null) {
        currentBlock.maxStackSize = maxStackSize;
        addSuccessor(stackSize, dflt);
        for (int i = 0; i < labels.length; ++i) {
          addSuccessor(stackSize, labels[i]);
        }
        currentBlock = null;
      }
    }
    // adds the instruction to the bytecode of the method
    int source = code.length;
    code.put1(Constants.TABLESWITCH);
    while (code.length % 4 != 0) {
      code.put1(0);
    }
    dflt.put(this, code, source, true);
    code.put4(min).put4(max);
    for (int i = 0; i < labels.length; ++i) {
      labels[i].put(this, code, source, true);
    }
  }
  public void visitLookupSwitchInsn (
    final Label dflt,
    final int keys[],
    final Label labels[])
  {
    if (computeMaxs) {
      // updates current stack size (max stack size unchanged)
      --stackSize;
      // ends current block (with many new successors)
      if (currentBlock != null) {
        currentBlock.maxStackSize = maxStackSize;
        addSuccessor(stackSize, dflt);
        for (int i = 0; i < labels.length; ++i) {
          addSuccessor(stackSize, labels[i]);
        }
        currentBlock = null;
      }
    }
    // adds the instruction to the bytecode of the method
    int source = code.length;
    code.put1(Constants.LOOKUPSWITCH);
    while (code.length % 4 != 0) {
      code.put1(0);
    }
    dflt.put(this, code, source, true);
    code.put4(labels.length);
    for (int i = 0; i < labels.length; ++i) {
      code.put4(keys[i]);
      labels[i].put(this, code, source, true);
    }
  }
  public void visitMultiANewArrayInsn (final String desc, final int dims) {
    if (computeMaxs) {
      // updates current stack size (max stack size unchanged because stack
      // size variation always negative or null)
      stackSize += 1 - dims;
    }
    // adds the instruction to the bytecode of the method
    Item classItem = cw.newClass(desc);
    code.put12(Constants.MULTIANEWARRAY, classItem.index).put1(dims);
  }
  public void visitTryCatchBlock (
    final Label start,
    final Label end,
    final Label handler,
    final String type)
  {
    if (CHECK) {
      if (start.owner != this || end.owner != this || handler.owner != this) {
        throw new IllegalArgumentException();
      }
      if (!start.resolved || !end.resolved || !handler.resolved) {
        throw new IllegalArgumentException();
      }
    }
    if (computeMaxs) {
      // pushes handler block onto the stack of blocks to be visited
      if (!handler.pushed) {
        handler.beginStackSize = 1;
        handler.pushed = true;
        handler.next = blockStack;
        blockStack = handler;
      }
    }
    ++catchCount;
    if (catchTable == null) {
      catchTable = new ByteVector();
    }
    catchTable.put2(start.position);
    catchTable.put2(end.position);
    catchTable.put2(handler.position);
    catchTable.put2(type != null ? cw.newClass(type).index : 0);
  }
  public void visitMaxs (final int maxStack, final int maxLocals) {
    if (computeMaxs) {
      // true (non relative) max stack size
      int max = 0;
      // control flow analysis algorithm: while the block stack is not empty,
      // pop a block from this stack, update the max stack size, compute
      // the true (non relative) begin stack size of the successors of this
      // block, and push these successors onto the stack (unless they have
      // already been pushed onto the stack). Note: by hypothesis, the {@link
      // Label#beginStackSize} of the blocks in the block stack are the true
      // (non relative) beginning stack sizes of these blocks.
      Label stack = blockStack;
      while (stack != null) {
        // pops a block from the stack
        Label l = stack;
        stack = stack.next;
        // computes the true (non relative) max stack size of this block
        int start = l.beginStackSize;
        int blockMax = start + l.maxStackSize;
        // updates the global max stack size
        if (blockMax > max) {
          max = blockMax;
        }
        // analyses the successors of the block
        Edge b = l.successors;
        while (b != null) {
          l = b.successor;
          // if this successor has not already been pushed onto the stack...
          if (!l.pushed) {
            // computes the true beginning stack size of this successor block
            l.beginStackSize = start + b.stackSize;
            // pushes this successor onto the stack
            l.pushed = true;
            l.next = stack;
            stack = l;
          }
          b = b.next;
        }
      }
      this.maxStack = max;
      // releases all the Edge objects used by this CodeWriter
      synchronized (SIZE) {
        // appends the [head ... tail] list at the beginning of the pool list
        if (tail != null) {
          tail.poolNext = pool;
          pool = head;
        }
      }
    } else {
      this.maxStack = maxStack;
      this.maxLocals = maxLocals;
    }
  }
  public void visitLocalVariable (
    final String name,
    final String desc,
    final Label start,
    final Label end,
    final int index)
  {
    if (CHECK) {
      if (start.owner != this || !start.resolved) {
        throw new IllegalArgumentException();
      }
      if (end.owner != this || !end.resolved) {
        throw new IllegalArgumentException();
      }
    }
    if (localVar == null) {
      cw.newUTF8(""LocalVariableTable"");
      localVar = new ByteVector();
    }
    ++localVarCount;
    localVar.put2(start.position);
    localVar.put2(end.position - start.position);
    localVar.put2(cw.newUTF8(name).index);
    localVar.put2(cw.newUTF8(desc).index);
    localVar.put2(index);
  }
  public void visitLineNumber (final int line, final Label start) {
    if (CHECK) {
      if (start.owner != this || !start.resolved) {
        throw new IllegalArgumentException();
      }
    }
    if (lineNumber == null) {
      cw.newUTF8(""LineNumberTable"");
      lineNumber = new ByteVector();
    }
    ++lineNumberCount;
    lineNumber.put2(start.position);
    lineNumber.put2(line);
  }
  // --------------------------------------------------------------------------
  // Utility methods: control flow analysis algorithm
  // --------------------------------------------------------------------------
  /**
   * Computes the size of the arguments and of the return value of a method.
   *
   * @param desc the descriptor of a method.
   * @return the size of the arguments of the method (plus one for the implicit
   *      this argument), argSize, and the size of its return value, retSize,
   *      packed into a single int i = <tt>(argSize << 2) | retSize</tt>
   *      (argSize is therefore equal to <tt>i >> 2</tt>, and retSize to
   *      <tt>i & 0x03</tt>).
   */
  private static int getArgumentsAndReturnSizes (final String desc) {
    int n = 1;
    int c = 1;
    while (true) {
      char car = desc.charAt(c++);
      if (car == ')') {
        car = desc.charAt(c);
        return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
      } else if (car == 'L') {
        while (desc.charAt(c++) != ';') {
        }
        n += 1;
      } else if (car == '[') {
        while ((car = desc.charAt(c)) == '[') {
          ++c;
        }
        if (car == 'D' || car == 'J') {
          n -= 1;
        }
      } else if (car == 'D' || car == 'J') {
        n += 2;
      } else {
        n += 1;
      }
    }
  }
  /**
   * Adds a successor to the {@link #currentBlock currentBlock} block.
   *
   * @param stackSize the current (relative) stack size in the current block.
   * @param successor the successor block to be added to the current block.
   */
  private void addSuccessor (final int stackSize, final Label successor) {
    Edge b;
    // creates a new Edge object or reuses one from the shared pool
    synchronized (SIZE) {
      if (pool == null) {
        b = new Edge();
      } else {
        b = pool;
        // removes b from the pool
        pool = pool.poolNext;
      }
    }
    // adds the previous Edge to the list of Edges used by this CodeWriter
    if (tail == null) {
      tail = b;
    }
    b.poolNext = head;
    head = b;
    // initializes the previous Edge object...
    b.stackSize = stackSize;
    b.successor = successor;
    // ...and adds it to the successor list of the currentBlock block
    b.next = currentBlock.successors;
    currentBlock.successors = b;
  }
  // --------------------------------------------------------------------------
  // Utility methods: dump bytecode array
  // --------------------------------------------------------------------------
  /**
   * Returns the size of the bytecode of this method.
   *
   * @return the size of the bytecode of this method.
   */
  final int getSize () {
    if (resize) {
      // replaces the temporary jump opcodes introduced by Label.resolve.
      resizeInstructions(new int[0], new int[0], 0);
    }
    int size = 8;
    if (code.length > 0) {
      cw.newUTF8(""Code"");
      size += 18 + code.length + 8 * catchCount;
      if (localVar != null) {
        size += 8 + localVar.length;
      }
      if (lineNumber != null) {
        size += 8 + lineNumber.length;
      }
    }
    if (exceptionCount > 0) {
      cw.newUTF8(""Exceptions"");
      size += 8 + 2 * exceptionCount;
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      cw.newUTF8(""Synthetic"");
      size += 6;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      cw.newUTF8(""Deprecated"");
      size += 6;
    }
    return size;
  }
  /**
   * Puts the bytecode of this method in the given byte vector.
   *
   * @param out the byte vector into which the bytecode of this method must be
   *      copied.
   */
  final void put (final ByteVector out) {
    out.put2(access).put2(name.index).put2(desc.index);
    int attributeCount = 0;
    if (code.length > 0) {
      ++attributeCount;
    }
    if (exceptionCount > 0) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      ++attributeCount;
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      ++attributeCount;
    }
    out.put2(attributeCount);
    if (code.length > 0) {
      int size = 12 + code.length + 8 * catchCount;
      if (localVar != null) {
        size += 8 + localVar.length;
      }
      if (lineNumber != null) {
        size += 8 + lineNumber.length;
      }
      out.put2(cw.newUTF8(""Code"").index).put4(size);
      out.put2(maxStack).put2(maxLocals);
      out.put4(code.length).putByteArray(code.data, 0, code.length);
      out.put2(catchCount);
      if (catchCount > 0) {
        out.putByteArray(catchTable.data, 0, catchTable.length);
      }
      attributeCount = 0;
      if (localVar != null) {
        ++attributeCount;
      }
      if (lineNumber != null) {
        ++attributeCount;
      }
      out.put2(attributeCount);
      if (localVar != null) {
        out.put2(cw.newUTF8(""LocalVariableTable"").index);
        out.put4(localVar.length + 2).put2(localVarCount);
        out.putByteArray(localVar.data, 0, localVar.length);
      }
      if (lineNumber != null) {
        out.put2(cw.newUTF8(""LineNumberTable"").index);
        out.put4(lineNumber.length + 2).put2(lineNumberCount);
        out.putByteArray(lineNumber.data, 0, lineNumber.length);
      }
    }
    if (exceptionCount > 0) {
      out.put2(cw.newUTF8(""Exceptions"").index).put4(2 * exceptionCount + 2);
      out.put2(exceptionCount);
      for (int i = 0; i < exceptionCount; ++i) {
        out.put2(exceptions[i]);
      }
    }
    if ((access & Constants.ACC_SYNTHETIC) != 0) {
      out.put2(cw.newUTF8(""Synthetic"").index).put4(0);
    }
    if ((access & Constants.ACC_DEPRECATED) != 0) {
      out.put2(cw.newUTF8(""Deprecated"").index).put4(0);
    }
  }
  // --------------------------------------------------------------------------
  // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
  // --------------------------------------------------------------------------
  /**
   * Resizes the designated instructions, while keeping jump offsets and
   * instruction addresses consistent. This may require to resize other existing
   * instructions, or even to introduce new instructions: for example,
   * increasing the size of an instruction by 2 at the middle of a method can
   * increases the offset of an IFEQ instruction from 32766 to 32768, in which
   * case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W 32765. This, in turn,
   * may require to increase the size of another jump instruction, and so on...
   * All these operations are handled automatically by this method.
   * <p>
   * <i>This method must be called after all the method that is being built has
   * been visited</i>. In particular, the {@link Label Label} objects used to
   * construct the method are no longer valid after this method has been called.
   *
   * @param indexes current positions of the instructions to be resized. Each
   *      instruction must be designated by the index of its <i>last</i> byte,
   *      plus one (or, in other words, by the index of the <i>first</i> byte of
   *      the <i>next</i> instruction).
   * @param sizes the number of bytes to be <i>added</i> to the above
   *      instructions. More precisely, for each i &lt; <tt>len</tt>,
   *      <tt>sizes</tt>[i] bytes will be added at the end of the instruction
   *      designated by <tt>indexes</tt>[i] or, if <tt>sizes</tt>[i] is
   *      negative, the <i>last</i> |<tt>sizes[i]</tt>| bytes of the instruction
   *      will be removed (the instruction size <i>must not</i> become negative
   *      or null). The gaps introduced by this method must be filled in
   *      ""manually"" in the array returned by the {@link #getCode getCode}
   *      method.
   * @param len the number of instruction to be resized. Must be smaller than or
   *      equal to <tt>indexes</tt>.length and <tt>sizes</tt>.length.
   * @return the <tt>indexes</tt> array, which now contains the new positions of
   *      the resized instructions (designated as above).
   */
  protected int[] resizeInstructions (
    final int[] indexes,
    final int[] sizes,
    final int len)
  {
    byte[] b = code.data; // bytecode of the method
    int u, v, label;      // indexes in b
    int i, j;             // loop indexes
    // 1st step:
    // As explained above, resizing an instruction may require to resize another
    // one, which may require to resize yet another one, and so on. The first
    // step of the algorithm consists in finding all the instructions that
    // need to be resized, without modifying the code. This is done by the
    // following ""fix point"" algorithm:
    // - parse the code to find the jump instructions whose offset will need
    //   more than 2 bytes to be stored (the future offset is computed from the
    //   current offset and from the number of bytes that will be inserted or
    //   removed between the source and target instructions). For each such
    //   instruction, adds an entry in (a copy of) the indexes and sizes arrays
    //   (if this has not already been done in a previous iteration!)
    // - if at least one entry has been added during the previous step, go back
    //   to the beginning, otherwise stop.
    // In fact the real algorithm is complicated by the fact that the size of
    // TABLESWITCH and LOOKUPSWITCH instructions depends on their position in
    // the bytecode (because of padding). In order to ensure the convergence of
    // the algorithm, the number of bytes to be added or removed from these
    // instructions is over estimated during the previous loop, and computed
    // exactly only after the loop is finished (this requires another pass to
    // parse the bytecode of the method).
    int[] allIndexes = new int[len]; // copy of indexes
    int[] allSizes = new int[len];   // copy of sizes
    boolean[] resize;                // instructions to be resized
    int newOffset;                   // future offset of a jump instruction
    System.arraycopy(indexes, 0, allIndexes, 0, len);
    System.arraycopy(sizes, 0, allSizes, 0, len);
    resize = new boolean[code.length];
    int state = 3; // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
    do {
      if (state == 3) {
        state = 2;
      }
      u = 0;
      while (u < b.length) {
        int opcode = b[u] & 0xFF;  // opcode of current instruction
        int insert = 0;            // bytes to be added after this instruction
        switch (ClassWriter.TYPE[opcode]) {
          case ClassWriter.NOARG_INSN:
          case ClassWriter.IMPLVAR_INSN:
            u += 1;
            break;
          case ClassWriter.LABEL_INSN:
            if (opcode > 201) {
              // converts temporary opcodes 202 to 217 (inclusive), 218 and 219
              // to IFEQ ... JSR (inclusive), IFNULL and IFNONNULL
              opcode = opcode < 218 ? opcode - 49 : opcode - 20;
              label = u + readUnsignedShort(b, u + 1);
            } else {
              label = u + readShort(b, u + 1);
            }
            newOffset = getNewOffset(allIndexes, allSizes, u, label);
            if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {
              if (!resize[u]) {
                if (opcode == Constants.GOTO || opcode == Constants.JSR) {
                  // two additional bytes will be required to replace this
                  // GOTO or JSR instruction with a GOTO_W or a JSR_W
                  insert = 2;
                } else {
                  // five additional bytes will be required to replace this
                  // IFxxx <l> instruction with IFNOTxxx <l'> GOTO_W <l>, where
                  // IFNOTxxx is the ""opposite"" opcode of IFxxx (i.e., IFNE for
                  // IFEQ) and where <l'> designates the instruction just after
                  // the GOTO_W.
                  insert = 5;
                }
                resize[u] = true;
              }
            }
            u += 3;
            break;
          case ClassWriter.LABELW_INSN:
            u += 5;
            break;
          case ClassWriter.TABL_INSN:
            if (state == 1) {
              // true number of bytes to be added (or removed) from this
              // instruction = (future number of padding bytes - current number
              // of padding byte) - previously over estimated variation =
              // = ((3 - newOffset%4) - (3 - u%4)) - u%4
              // = (-newOffset%4 + u%4) - u%4
              // = -(newOffset & 3)
              newOffset = getNewOffset(allIndexes, allSizes, 0, u);
              insert = -(newOffset & 3);
            } else if (!resize[u]) {
              // over estimation of the number of bytes to be added to this
              // instruction = 3 - current number of padding bytes = 3 - (3 -
              // u%4) = u%4 = u & 3
              insert = u & 3;
              resize[u] = true;
            }
            // skips instruction
            u = u + 4 - (u & 3);
            u += 4*(readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;
            break;
          case ClassWriter.LOOK_INSN:
            if (state == 1) {
              // like TABL_INSN
              newOffset = getNewOffset(allIndexes, allSizes, 0, u);
              insert = -(newOffset & 3);
            } else if (!resize[u]) {
              // like TABL_INSN
              insert = u & 3;
              resize[u] = true;
            }
            // skips instruction
            u = u + 4 - (u & 3);
            u += 8*readInt(b, u + 4) + 8;
            break;
          case ClassWriter.WIDE_INSN:
            opcode = b[u + 1] & 0xFF;
            if (opcode == Constants.IINC) {
              u += 6;
            } else {
              u += 4;
            }
            break;
          case ClassWriter.VAR_INSN:
          case ClassWriter.SBYTE_INSN:
          case ClassWriter.LDC_INSN:
            u += 2;
            break;
          case ClassWriter.SHORT_INSN:
          case ClassWriter.LDCW_INSN:
          case ClassWriter.FIELDORMETH_INSN:
          case ClassWriter.TYPE_INSN:
          case ClassWriter.IINC_INSN:
            u += 3;
            break;
          case ClassWriter.ITFMETH_INSN:
            u += 5;
            break;
          // case ClassWriter.MANA_INSN:
          default:
            u += 4;
            break;
        }
        if (insert != 0) {
          // adds a new (u, insert) entry in the allIndexes and allSizes arrays
          int[] newIndexes = new int[allIndexes.length + 1];
          int[] newSizes = new int[allSizes.length + 1];
          System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);
          System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);
          newIndexes[allIndexes.length] = u;
          newSizes[allSizes.length] = insert;
          allIndexes = newIndexes;
          allSizes = newSizes;
          if (insert > 0) {
            state = 3;
          }
        }
      }
      if (state < 3) {
        --state;
      }
    } while (state != 0);
    // 2nd step:
    // copies the bytecode of the method into a new bytevector, updates the
    // offsets, and inserts (or removes) bytes as requested.
    ByteVector newCode = new ByteVector(code.length);
    u = 0;
    while (u < code.length) {
      for (i = allIndexes.length - 1; i >= 0; --i) {
        if (allIndexes[i] == u) {
          if (i < len) {
            if (sizes[i] > 0) {
              newCode.putByteArray(null, 0, sizes[i]);
            } else {
              newCode.length += sizes[i];
            }
            indexes[i] = newCode.length;
          }
        }
      }
      int opcode = b[u] & 0xFF;
      switch (ClassWriter.TYPE[opcode]) {
        case ClassWriter.NOARG_INSN:
        case ClassWriter.IMPLVAR_INSN:
          newCode.put1(opcode);
          u += 1;
          break;
        case ClassWriter.LABEL_INSN:
          if (opcode > 201) {
            // changes temporary opcodes 202 to 217 (inclusive), 218 and 219
            // to IFEQ ... JSR (inclusive), IFNULL and IFNONNULL
            opcode = opcode < 218 ? opcode - 49 : opcode - 20;
            label = u + readUnsignedShort(b, u + 1);
          } else {
            label = u + readShort(b, u + 1);
          }
          newOffset = getNewOffset(allIndexes, allSizes, u, label);
          if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {
            // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx <l> with
            // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the ""opposite"" opcode
            // of IFxxx (i.e., IFNE for IFEQ) and where <l'> designates the
            // instruction just after the GOTO_W.
            if (opcode == Constants.GOTO) {
              newCode.put1(200); // GOTO_W
            } else if (opcode == Constants.JSR) {
              newCode.put1(201); // JSR_W
            } else {
              newCode.put1(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);
              newCode.put2(8);   // jump offset
              newCode.put1(200); // GOTO_W
              newOffset -= 3;    // newOffset now computed from start of GOTO_W
            }
            newCode.put4(newOffset);
          } else {
            newCode.put1(opcode);
            newCode.put2(newOffset);
          }
          u += 3;
          break;
        case ClassWriter.LABELW_INSN:
          label = u + readInt(b, u + 1);
          newOffset = getNewOffset(allIndexes, allSizes, u, label);
          newCode.put1(opcode);
          newCode.put4(newOffset);
          u += 5;
          break;
        case ClassWriter.TABL_INSN:
          // skips 0 to 3 padding bytes
          v = u;
          u = u + 4 - (v & 3);
          // reads and copies instruction
          int source = newCode.length;
          newCode.put1(Constants.TABLESWITCH);
          while (newCode.length % 4 != 0) {
            newCode.put1(0);
          }
          label = v + readInt(b, u); u += 4;
          newOffset = getNewOffset(allIndexes, allSizes, v, label);
          newCode.put4(newOffset);
          j = readInt(b, u); u += 4;
          newCode.put4(j);
          j = readInt(b, u) - j + 1; u += 4;
          newCode.put4(readInt(b, u - 4));
          for ( ; j > 0; --j) {
            label = v + readInt(b, u); u += 4;
            newOffset = getNewOffset(allIndexes, allSizes, v, label);
            newCode.put4(newOffset);
          }
          break;
        case ClassWriter.LOOK_INSN:
          // skips 0 to 3 padding bytes
          v = u;
          u = u + 4 - (v & 3);
          // reads and copies instruction
          source = newCode.length;
          newCode.put1(Constants.LOOKUPSWITCH);
          while (newCode.length % 4 != 0) {
            newCode.put1(0);
          }
          label = v + readInt(b, u); u += 4;
          newOffset = getNewOffset(allIndexes, allSizes, v, label);
          newCode.put4(newOffset);
          j = readInt(b, u); u += 4;
          newCode.put4(j);
          for ( ; j > 0; --j) {
            newCode.put4(readInt(b, u)); u += 4;
            label = v + readInt(b, u); u += 4;
            newOffset = getNewOffset(allIndexes, allSizes, v, label);
            newCode.put4(newOffset);
          }
          break;
        case ClassWriter.WIDE_INSN:
          opcode = b[u + 1] & 0xFF;
          if (opcode == Constants.IINC) {
            newCode.putByteArray(b, u, 6);
            u += 6;
          } else {
            newCode.putByteArray(b, u, 4);
            u += 4;
          }
          break;
        case ClassWriter.VAR_INSN:
        case ClassWriter.SBYTE_INSN:
        case ClassWriter.LDC_INSN:
          newCode.putByteArray(b, u, 2);
          u += 2;
          break;
        case ClassWriter.SHORT_INSN:
        case ClassWriter.LDCW_INSN:
        case ClassWriter.FIELDORMETH_INSN:
        case ClassWriter.TYPE_INSN:
        case ClassWriter.IINC_INSN:
          newCode.putByteArray(b, u, 3);
          u += 3;
          break;
        case ClassWriter.ITFMETH_INSN:
          newCode.putByteArray(b, u, 5);
          u += 5;
          break;
        // case MANA_INSN:
        default:
          newCode.putByteArray(b, u, 4);
          u += 4;
          break;
      }
    }
    // updates the instructions addresses in the
    // catch, local var and line number tables
    if (catchTable != null) {
      b = catchTable.data;
      u = 0;
      while (u < catchTable.length) {
        writeShort(b, u, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u)));
        writeShort(b, u + 2, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u + 2)));
        writeShort(b, u + 4, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u + 4)));
        u += 8;
      }
    }
    if (localVar != null) {
      b = localVar.data;
      u = 0;
      while (u < localVar.length) {
        label = readUnsignedShort(b, u);
        newOffset = getNewOffset(allIndexes, allSizes, 0, label);
        writeShort(b, u, newOffset);
        label += readUnsignedShort(b, u + 2);
        newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;
        writeShort(b, u, newOffset);
        u += 10;
      }
    }
    if (lineNumber != null) {
      b = lineNumber.data;
      u = 0;
      while (u < lineNumber.length) {
        writeShort(b, u, getNewOffset(
          allIndexes, allSizes, 0, readUnsignedShort(b, u)));
        u += 4;
      }
    }
    // replaces old bytecodes with new ones
    code = newCode;
    // returns the positions of the resized instructions
    return indexes;
  }
  /**
   * Reads an unsigned short value in the given byte array.
   *
   * @param b a byte array.
   * @param index the start index of the value to be read.
   * @return the read value.
   */
  static int readUnsignedShort (final byte[] b, final int index) {
    return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
  }
  /**
   * Reads a signed short value in the given byte array.
   *
   * @param b a byte array.
   * @param index the start index of the value to be read.
   * @return the read value.
   */
  static short readShort (final byte[] b, final int index) {
    return (short)(((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));
  }
  /**
   * Reads a signed int value in the given byte array.
   *
   * @param b a byte array.
   * @param index the start index of the value to be read.
   * @return the read value.
   */
  static int readInt (final byte[] b, final int index) {
    return ((b[index] & 0xFF) << 24) |
           ((b[index + 1] & 0xFF) << 16) |
           ((b[index + 2] & 0xFF) << 8) |
           (b[index + 3] & 0xFF);
  }
  /**
   * Writes a short value in the given byte array.
   *
   * @param b a byte array.
   * @param index where the first byte of the short value must be written.
   * @param s the value to be written in the given byte array.
   */
  static void writeShort (final byte[] b, final int index, final int s) {
    b[index] = (byte)(s >>> 8);
    b[index + 1] = (byte)s;
  }
  /**
   * Computes the future value of a bytecode offset.
   * <p>
   * Note: it is possible to have several entries for the same instruction
   * in the <tt>indexes</tt> and <tt>sizes</tt>: two entries (index=a,size=b)
   * and (index=a,size=b') are equivalent to a single entry (index=a,size=b+b').
   *
   * @param indexes current positions of the instructions to be resized. Each
   *      instruction must be designated by the index of its <i>last</i> byte,
   *      plus one (or, in other words, by the index of the <i>first</i> byte of
   *      the <i>next</i> instruction).
   * @param sizes the number of bytes to be <i>added</i> to the above
   *      instructions. More precisely, for each i < <tt>len</tt>,
   *      <tt>sizes</tt>[i] bytes will be added at the end of the instruction
   *      designated by <tt>indexes</tt>[i] or, if <tt>sizes</tt>[i] is
   *      negative, the <i>last</i> |<tt>sizes[i]</tt>| bytes of the instruction
   *      will be removed (the instruction size <i>must not</i> become negative
   *      or null).
   * @param begin index of the first byte of the source instruction.
   * @param end index of the first byte of the target instruction.
   * @return the future value of the given bytecode offset.
   */
  static int getNewOffset (
    final int[] indexes,
    final int[] sizes,
    final int begin,
    final int end)
  {
    int offset = end - begin;
    for (int i = 0; i < indexes.length; ++i) {
      if (begin < indexes[i] && indexes[i] <= end) { // forward jump
        offset += sizes[i];
      } else if (end < indexes[i] && indexes[i] <= begin) { // backward jump
        offset -= sizes[i];
      }
    }
    return offset;
  }
  /**
   * Returns the current size of the bytecode of this method. This size just
   * includes the size of the bytecode instructions: it does not include the
   * size of the Exceptions, LocalVariableTable, LineNumberTable, Synthetic
   * and Deprecated attributes, if present.
   *
   * @return the current size of the bytecode of this method.
   */
  protected int getCodeSize () {
    return code.length;
  }
  /**
   * Returns the current bytecode of this method. This bytecode only contains
   * the instructions: it does not include the Exceptions, LocalVariableTable,
   * LineNumberTable, Synthetic and Deprecated attributes, if present.
   *
   * @return the current bytecode of this method. The bytecode is contained
   *      between the index 0 (inclusive) and the index {@link #getCodeSize
   *      getCodeSize} (exclusive).
   */
  protected byte[] getCode () {
    return code.data;
  }
}
"
org.objectweb.asm.Constants,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * Defines the JVM opcodes, access flags and array type codes. This interface
 * does not define all the JVM opcodes because some opcodes are automatically
 * handled. For example, the xLOAD and xSTORE opcodes are automatically replaced
 * by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n
 * opcodes are therefore not defined in this interface. Likewise for LDC,
 * automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and
 * JSR_W.
 */
public interface Constants {
  // access flags
  int ACC_PUBLIC = 1;
  int ACC_PRIVATE = 2;
  int ACC_PROTECTED = 4;
  int ACC_STATIC = 8;
  int ACC_FINAL = 16;
  int ACC_SYNCHRONIZED = 32;
  int ACC_VOLATILE = 64;
  int ACC_TRANSIENT = 128;
  int ACC_NATIVE = 256;
  int ACC_INTERFACE = 512;
  int ACC_ABSTRACT = 1024;
  int ACC_STRICT = 2048;
  int ACC_SUPER = 32;
  int ACC_SYNTHETIC = 65536;
  int ACC_DEPRECATED = 131072;
  // types for NEWARRAY
  int T_BOOLEAN = 4;
  int T_CHAR = 5;
  int T_FLOAT = 6;
  int T_DOUBLE = 7;
  int T_BYTE = 8;
  int T_SHORT = 9;
  int T_INT = 10;
  int T_LONG = 11;
  // opcodes                  // visit method (- = idem)
  int NOP = 0;                // visitInsn
  int ACONST_NULL = 1;        // -
  int ICONST_M1 = 2;          // -
  int ICONST_0 = 3;           // -
  int ICONST_1 = 4;           // -
  int ICONST_2 = 5;           // -
  int ICONST_3 = 6;           // -
  int ICONST_4 = 7;           // -
  int ICONST_5 = 8;           // -
  int LCONST_0 = 9;           // -
  int LCONST_1 = 10;          // -
  int FCONST_0 = 11;          // -
  int FCONST_1 = 12;          // -
  int FCONST_2 = 13;          // -
  int DCONST_0 = 14;          // -
  int DCONST_1 = 15;          // -
  int BIPUSH = 16;            // visitIntInsn
  int SIPUSH = 17;            // -
  int LDC = 18;               // visitLdcInsn
  //int LDC_W = 19;           // -
  //int LDC2_W = 20;          // -
  int ILOAD = 21;             // visitVarInsn
  int LLOAD = 22;             // -
  int FLOAD = 23;             // -
  int DLOAD = 24;             // -
  int ALOAD = 25;             // -
  //int ILOAD_0 = 26;         // -
  //int ILOAD_1 = 27;         // -
  //int ILOAD_2 = 28;         // -
  //int ILOAD_3 = 29;         // -
  //int LLOAD_0 = 30;         // -
  //int LLOAD_1 = 31;         // -
  //int LLOAD_2 = 32;         // -
  //int LLOAD_3 = 33;         // -
  //int FLOAD_0 = 34;         // -
  //int FLOAD_1 = 35;         // -
  //int FLOAD_2 = 36;         // -
  //int FLOAD_3 = 37;         // -
  //int DLOAD_0 = 38;         // -
  //int DLOAD_1 = 39;         // -
  //int DLOAD_2 = 40;         // -
  //int DLOAD_3 = 41;         // -
  //int ALOAD_0 = 42;         // -
  //int ALOAD_1 = 43;         // -
  //int ALOAD_2 = 44;         // -
  //int ALOAD_3 = 45;         // -
  int IALOAD = 46;            // visitInsn
  int LALOAD = 47;            // -
  int FALOAD = 48;            // -
  int DALOAD = 49;            // -
  int AALOAD = 50;            // -
  int BALOAD = 51;            // -
  int CALOAD = 52;            // -
  int SALOAD = 53;            // -
  int ISTORE = 54;            // visitVarInsn
  int LSTORE = 55;            // -
  int FSTORE = 56;            // -
  int DSTORE = 57;            // -
  int ASTORE = 58;            // -
  //int ISTORE_0 = 59;        // -
  //int ISTORE_1 = 60;        // -
  //int ISTORE_2 = 61;        // -
  //int ISTORE_3 = 62;        // -
  //int LSTORE_0 = 63;        // -
  //int LSTORE_1 = 64;        // -
  //int LSTORE_2 = 65;        // -
  //int LSTORE_3 = 66;        // -
  //int FSTORE_0 = 67;        // -
  //int FSTORE_1 = 68;        // -
  //int FSTORE_2 = 69;        // -
  //int FSTORE_3 = 70;        // -
  //int DSTORE_0 = 71;        // -
  //int DSTORE_1 = 72;        // -
  //int DSTORE_2 = 73;        // -
  //int DSTORE_3 = 74;        // -
  //int ASTORE_0 = 75;        // -
  //int ASTORE_1 = 76;        // -
  //int ASTORE_2 = 77;        // -
  //int ASTORE_3 = 78;        // -
  int IASTORE = 79;           // visitInsn
  int LASTORE = 80;           // -
  int FASTORE = 81;           // -
  int DASTORE = 82;           // -
  int AASTORE = 83;           // -
  int BASTORE = 84;           // -
  int CASTORE = 85;           // -
  int SASTORE = 86;           // -
  int POP = 87;               // -
  int POP2 = 88;              // -
  int DUP = 89;               // -
  int DUP_X1 = 90;            // -
  int DUP_X2 = 91;            // -
  int DUP2 = 92;              // -
  int DUP2_X1 = 93;           // -
  int DUP2_X2 = 94;           // -
  int SWAP = 95;              // -
  int IADD = 96;              // -
  int LADD = 97;              // -
  int FADD = 98;              // -
  int DADD = 99;              // -
  int ISUB = 100;             // -
  int LSUB = 101;             // -
  int FSUB = 102;             // -
  int DSUB = 103;             // -
  int IMUL = 104;             // -
  int LMUL = 105;             // -
  int FMUL = 106;             // -
  int DMUL = 107;             // -
  int IDIV = 108;             // -
  int LDIV = 109;             // -
  int FDIV = 110;             // -
  int DDIV = 111;             // -
  int IREM = 112;             // -
  int LREM = 113;             // -
  int FREM = 114;             // -
  int DREM = 115;             // -
  int INEG = 116;             // -
  int LNEG = 117;             // -
  int FNEG = 118;             // -
  int DNEG = 119;             // -
  int ISHL = 120;             // -
  int LSHL = 121;             // -
  int ISHR = 122;             // -
  int LSHR = 123;             // -
  int IUSHR = 124;            // -
  int LUSHR = 125;            // -
  int IAND = 126;             // -
  int LAND = 127;             // -
  int IOR = 128;              // -
  int LOR = 129;              // -
  int IXOR = 130;             // -
  int LXOR = 131;             // -
  int IINC = 132;             // visitIincInsn
  int I2L = 133;              // visitInsn
  int I2F = 134;              // -
  int I2D = 135;              // -
  int L2I = 136;              // -
  int L2F = 137;              // -
  int L2D = 138;              // -
  int F2I = 139;              // -
  int F2L = 140;              // -
  int F2D = 141;              // -
  int D2I = 142;              // -
  int D2L = 143;              // -
  int D2F = 144;              // -
  int I2B = 145;              // -
  int I2C = 146;              // -
  int I2S = 147;              // -
  int LCMP = 148;             // -
  int FCMPL = 149;            // -
  int FCMPG = 150;            // -
  int DCMPL = 151;            // -
  int DCMPG = 152;            // -
  int IFEQ = 153;             // visitJumpInsn
  int IFNE = 154;             // -
  int IFLT = 155;             // -
  int IFGE = 156;             // -
  int IFGT = 157;             // -
  int IFLE = 158;             // -
  int IF_ICMPEQ = 159;        // -
  int IF_ICMPNE = 160;        // -
  int IF_ICMPLT = 161;        // -
  int IF_ICMPGE = 162;        // -
  int IF_ICMPGT = 163;        // -
  int IF_ICMPLE = 164;        // -
  int IF_ACMPEQ = 165;        // -
  int IF_ACMPNE = 166;        // -
  int GOTO = 167;             // -
  int JSR = 168;              // -
  int RET = 169;              // visitVarInsn
  int TABLESWITCH = 170;      // visiTableSwitchInsn
  int LOOKUPSWITCH = 171;     // visitLookupSwitch
  int IRETURN = 172;          // visitInsn
  int LRETURN = 173;          // -
  int FRETURN = 174;          // -
  int DRETURN = 175;          // -
  int ARETURN = 176;          // -
  int RETURN = 177;           // -
  int GETSTATIC = 178;        // visitFieldInsn
  int PUTSTATIC = 179;        // -
  int GETFIELD = 180;         // -
  int PUTFIELD = 181;         // -
  int INVOKEVIRTUAL = 182;    // visitMethodInsn
  int INVOKESPECIAL = 183;    // -
  int INVOKESTATIC = 184;     // -
  int INVOKEINTERFACE = 185;  // -
  //int UNUSED = 186;         // NOT VISITED
  int NEW = 187;              // visitTypeInsn
  int NEWARRAY = 188;         // visitIntInsn
  int ANEWARRAY = 189;        // visitTypeInsn
  int ARRAYLENGTH = 190;      // visitInsn
  int ATHROW = 191;           // -
  int CHECKCAST = 192;        // visitTypeInsn
  int INSTANCEOF = 193;       // -
  int MONITORENTER = 194;     // visitInsn
  int MONITOREXIT = 195;      // -
  //int WIDE = 196;           // NOT VISITED
  int MULTIANEWARRAY = 197;   // visitMultiANewArrayInsn
  int IFNULL = 198;           // visitJumpInsn
  int IFNONNULL = 199;        // -
  //int GOTO_W = 200;         // -
  //int JSR_W = 201;          // -
}
"
org.objectweb.asm.Edge,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * An edge in the control flow graph of a method body. See {@link Label Label}.
 */
class Edge {
  /**
   * The (relative) stack size in the basic block from which this edge
   * originates. This size is equal to the stack size at the ""jump"" instruction
   * to which this edge corresponds, relatively to the stack size at the
   * beginning of the originating basic block.
   */
  int stackSize;
  /**
   * The successor block of the basic block from which this edge originates.
   */
  Label successor;
  /**
   * The next edge in the list of successors of the originating basic block.
   * See {@link Label#successors successors}.
   */
  Edge next;
  /**
   * The next available edge in the pool. See {@link CodeWriter#pool pool}.
   */
  Edge poolNext;
}
"
org.objectweb.asm.Item,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A constant pool item. Constant pool items can be created with the 'newXXX'
 * methods in the {@link ClassWriter} class.
 */
final class Item {
  /**
   * Index of this item in the constant pool.
   */
  short index;
  /**
   * Type of this constant pool item. A single class is used to represent all
   * constant pool item types, in order to minimize the bytecode size of this
   * package. The value of this field is one of the constants defined in the
   * {@link ClassWriter ClassWriter} class.
   */
  int type;
  /**
   * Value of this item, for a {@link ClassWriter#INT INT} item.
   */
  int intVal;
  /**
   * Value of this item, for a {@link ClassWriter#LONG LONG} item.
   */
  long longVal;
  /**
   * Value of this item, for a {@link ClassWriter#FLOAT FLOAT} item.
   */
  float floatVal;
  /**
   * Value of this item, for a {@link ClassWriter#DOUBLE DOUBLE} item.
   */
  double doubleVal;
  /**
   * First part of the value of this item, for items that do not hold a
   * primitive value.
   */
  String strVal1;
  /**
   * Second part of the value of this item, for items that do not hold a
   * primitive value.
   */
  String strVal2;
  /**
   * Third part of the value of this item, for items that do not hold a
   * primitive value.
   */
  String strVal3;
  /**
   * The hash code value of this constant pool item.
   */
  int hashCode;
  /**
   * Link to another constant pool item, used for collision lists in the
   * constant pool's hash table.
   */
  Item next;
  /**
   * Constructs an uninitialized {@link Item Item} object.
   */
  Item () {
  }
  /**
   * Constructs a copy of the given item.
   *
   * @param index index of the item to be constructed.
   * @param i the item that must be copied into the item to be constructed.
   */
  Item (final short index, final Item i) {
    this.index = index;
    type = i.type;
    intVal = i.intVal;
    longVal = i.longVal;
    floatVal = i.floatVal;
    doubleVal = i.doubleVal;
    strVal1 = i.strVal1;
    strVal2 = i.strVal2;
    strVal3 = i.strVal3;
    hashCode = i.hashCode;
  }
  /**
   * Sets this item to an {@link ClassWriter#INT INT} item.
   *
   * @param intVal the value of this item.
   */
  void set (final int intVal) {
    this.type = ClassWriter.INT;
    this.intVal = intVal;
    this.hashCode = type + intVal;
  }
  /**
   * Sets this item to a {@link ClassWriter#LONG LONG} item.
   *
   * @param longVal the value of this item.
   */
  void set (final long longVal) {
    this.type = ClassWriter.LONG;
    this.longVal = longVal;
    this.hashCode = type + (int)longVal;
  }
  /**
   * Sets this item to a {@link ClassWriter#FLOAT FLOAT} item.
   *
   * @param floatVal the value of this item.
   */
  void set (final float floatVal) {
    this.type = ClassWriter.FLOAT;
    this.floatVal = floatVal;
    this.hashCode = type + (int)floatVal;
  }
  /**
   * Sets this item to a {@link ClassWriter#DOUBLE DOUBLE} item.
   *
   * @param doubleVal the value of this item.
   */
  void set (final double doubleVal) {
    this.type = ClassWriter.DOUBLE;
    this.doubleVal = doubleVal;
    this.hashCode = type + (int)doubleVal;
  }
  /**
   * Sets this item to an item that do not hold a primitive value.
   *
   * @param type the type of this item.
   * @param strVal1 first part of the value of this item.
   * @param strVal2 second part of the value of this item.
   * @param strVal3 third part of the value of this item.
   */
  void set (
    final int type,
    final String strVal1,
    final String strVal2,
    final String strVal3)
  {
    this.type = type;
    this.strVal1 = strVal1;
    this.strVal2 = strVal2;
    this.strVal3 = strVal3;
    switch (type) {
      case ClassWriter.UTF8:
      case ClassWriter.STR:
      case ClassWriter.CLASS:
        hashCode = type + strVal1.hashCode();
        return;
      case ClassWriter.NAME_TYPE:
        hashCode = type + strVal1.hashCode()*strVal2.hashCode();
        return;
      //case ClassWriter.FIELD:
      //case ClassWriter.METH:
      //case ClassWriter.IMETH:
      default:
        hashCode = type + strVal1.hashCode()*strVal2.hashCode()*strVal3.hashCode();
        return;
    }
  }
  /**
   * Indicates if the given item is equal to this one.
   *
   * @param i the item to be compared to this one.
   * @return <tt>true</tt> if the given item if equal to this one,
   *      <tt>false</tt> otherwise.
   */
  boolean isEqualTo (final Item i) {
    if (i.type == type) {
      switch (type) {
        case ClassWriter.INT:
          return i.intVal == intVal;
        case ClassWriter.LONG:
          return i.longVal == longVal;
        case ClassWriter.FLOAT:
          return i.floatVal == floatVal;
        case ClassWriter.DOUBLE:
          return i.doubleVal == doubleVal;
        case ClassWriter.UTF8:
        case ClassWriter.STR:
        case ClassWriter.CLASS:
          return i.strVal1.equals(strVal1);
        case ClassWriter.NAME_TYPE:
          return i.strVal1.equals(strVal1) &&
                 i.strVal2.equals(strVal2);
        //case ClassWriter.FIELD:
        //case ClassWriter.METH:
        //case ClassWriter.IMETH:
        default:
          return i.strVal1.equals(strVal1) &&
                 i.strVal2.equals(strVal2) &&
                 i.strVal3.equals(strVal3);
      }
    }
    return false;
  }
}
"
org.objectweb.asm.Label,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
/**
 * A label represents a position in the bytecode of a method. Labels are used
 * for jump, goto, and switch instructions, and for try catch blocks.
 */
public class Label {
  /**
   * The code writer to which this label belongs, or <tt>null</tt> if unknown.
   */
  CodeWriter owner;
  /**
   * Indicates if the position of this label is known.
   */
  boolean resolved;
  /**
   * The position of this label in the code, if known.
   */
  int position;
  /**
   * Number of forward references to this label, times two.
   */
  private int referenceCount;
  /**
   * Informations about forward references. Each forward reference is described
   * by two consecutive integers in this array: the first one is the position
   * of the first byte of the bytecode instruction that contains the forward
   * reference, while the second is the position of the first byte of the
   * forward reference itself. In fact the sign of the first integer indicates
   * if this reference uses 2 or 4 bytes, and its absolute value gives the
   * position of the bytecode instruction.
   */
  private int[] srcAndRefPositions;
  // --------------------------------------------------------------------------
  // Fields for the control flow graph analysis algorithm (used to compute the
  // maximum stack size). A control flow graph contains one node per ""basic
  // block"", and one edge per ""jump"" from one basic block to another. Each node
  // (i.e., each basic block) is represented by the Label object that
  // corresponds to the first instruction of this basic block. Each node also
  // stores the list of it successors in the graph, as a linked list of Edge
  // objects.
  // --------------------------------------------------------------------------
  /**
   * The stack size at the beginning of this basic block.
   * This size is initially unknown. It is computed by the control flow
   * analysis algorithm (see {@link CodeWriter#visitMaxs visitMaxs}).
   */
  int beginStackSize;
  /**
   * The (relative) maximum stack size corresponding to this basic block. This
   * size is relative to the stack size at the beginning of the basic block,
   * i.e., the true maximum stack size is equal to {@link #beginStackSize
   * beginStackSize} + {@link #maxStackSize maxStackSize}.
   */
  int maxStackSize;
  /**
   * The successors of this node in the control flow graph. These successors
   * are stored in a linked list of {@link Edge Edge} objects, linked to each
   * other by their {@link Edge#next} field.
   */
  Edge successors;
  /**
   * The next basic block in the basic block stack.
   * See {@link CodeWriter#visitMaxs visitMaxs}.
   */
  Label next;
  /**
   * <tt>true</tt> if this basic block has been pushed in the basic block stack.
   * See {@link CodeWriter#visitMaxs visitMaxs}.
   */
  boolean pushed;
  // --------------------------------------------------------------------------
  // Constructor
  // --------------------------------------------------------------------------
  /**
   * Constructs a new label.
   */
  public Label () {
  }
  // --------------------------------------------------------------------------
  // Methods to compute offsets and to manage forward references
  // --------------------------------------------------------------------------
  /**
   * Puts a reference to this label in the bytecode of a method. If the position
   * of the label is known, the offset is computed and written directly.
   * Otherwise, a null offset is written and a new forward reference is declared
   * for this label.
   *
   * @param owner the code writer that calls this method.
   * @param out the bytecode of the method.
   * @param source the position of first byte of the bytecode instruction that
   *      contains this label.
   * @param wideOffset <tt>true</tt> if the reference must be stored in 4 bytes,
   *      or <tt>false</tt> if it must be stored with 2 bytes.
   * @throws IllegalArgumentException if this label has not been created by the
   *      given code writer.
   */
  void put (
    final CodeWriter owner,
    final ByteVector out,
    final int source,
    final boolean wideOffset)
  {
    if (CodeWriter.CHECK) {
      if (this.owner == null) {
        this.owner = owner;
      } else if (this.owner != owner) {
        throw new IllegalArgumentException();
      }
    }
    if (resolved) {
      if (wideOffset) {
        out.put4(position - source);
      } else {
        out.put2(position - source);
      }
    } else {
      if (wideOffset) {
        addReference(-1 - source, out.length);
        out.put4(-1);
      } else {
        addReference(source, out.length);
        out.put2(-1);
      }
    }
  }
  /**
   * Adds a forward reference to this label. This method must be called only for
   * a true forward reference, i.e. only if this label is not resolved yet. For
   * backward references, the offset of the reference can be, and must be,
   * computed and stored directly.
   *
   * @param sourcePosition the position of the referencing instruction. This
   *      position will be used to compute the offset of this forward reference.
   * @param referencePosition the position where the offset for this forward
   *      reference must be stored.
   */
  private void addReference (
    final int sourcePosition,
    final int referencePosition)
  {
    if (srcAndRefPositions == null) {
      srcAndRefPositions = new int[6];
    }
    if (referenceCount >= srcAndRefPositions.length) {
      int[] a = new int[srcAndRefPositions.length + 6];
      System.arraycopy(srcAndRefPositions, 0, a, 0, srcAndRefPositions.length);
      srcAndRefPositions = a;
    }
    srcAndRefPositions[referenceCount++] = sourcePosition;
    srcAndRefPositions[referenceCount++] = referencePosition;
  }
  /**
   * Resolves all forward references to this label. This method must be called
   * when this label is added to the bytecode of the method, i.e. when its
   * position becomes known. This method fills in the blanks that where left in
   * the bytecode by each forward reference previously added to this label.
   *
   * @param owner the code writer that calls this method.
   * @param position the position of this label in the bytecode.
   * @param data the bytecode of the method.
   * @return <tt>true</tt> if a blank that was left for this label was to small
   *      to store the offset. In such a case the corresponding jump instruction
   *      is replaced with a pseudo instruction (using unused opcodes) using an
   *      unsigned two bytes offset. These pseudo instructions will need to be
   *      replaced with true instructions with wider offsets (4 bytes instead of
   *      2). This is done in {@link CodeWriter#resizeInstructions}.
   * @throws IllegalArgumentException if this label has already been resolved,
   *      or if it has not been created by the given code writer.
   */
  boolean resolve (
    final CodeWriter owner,
    final int position,
    final byte[] data)
  {
    if (CodeWriter.CHECK) {
      if (this.owner == null) {
        this.owner = owner;
      }
      if (resolved || this.owner != owner) {
        throw new IllegalArgumentException();
      }
    }
    boolean needUpdate = false;
    this.resolved = true;
    this.position = position;
    int i = 0;
    while (i < referenceCount) {
      int source = srcAndRefPositions[i++];
      int reference = srcAndRefPositions[i++];
      int offset;
      if (source >= 0) {
        offset = position - source;
        if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
          // changes the opcode of the jump instruction, in order to be able to
          // find it later (see resizeInstructions in CodeWriter). These
          // temporary opcodes are similar to jump instruction opcodes, except
          // that the 2 bytes offset is unsigned (and can therefore represent
          // values from 0 to 65535, which is sufficient since the size of a
          // method is limited to 65535 bytes).
          int opcode = data[reference - 1] & 0xFF;
          if (opcode <= Constants.JSR) {
            // changes IFEQ ... JSR to opcodes 202 to 217 (inclusive)
            data[reference - 1] = (byte)(opcode + 49);
          } else {
            // changes IFNULL and IFNONNULL to opcodes 218 and 219 (inclusive)
            data[reference - 1] = (byte)(opcode + 20);
          }
          needUpdate = true;
        }
        data[reference++] = (byte)(offset >>> 8);
        data[reference] = (byte)offset;
      } else {
        offset = position + source + 1;
        data[reference++] = (byte)(offset >>> 24);
        data[reference++] = (byte)(offset >>> 16);
        data[reference++] = (byte)(offset >>> 8);
        data[reference] = (byte)offset;
      }
    }
    return needUpdate;
  }
}
"
org.objectweb.asm.Type,"/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (C) 2000 INRIA, France Telecom
 * Copyright (C) 2002 France Telecom
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Contact: Eric.Bruneton@rd.francetelecom.com
 *
 * Author: Eric Bruneton
 */
package org.objectweb.asm;
import java.lang.reflect.Method;
/**
 * A Java type. This class can be used to make it easier to manipulate type
 * and method descriptors.
 */
public class Type {
  /**
   * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.
   */
  public final static int VOID = 0;
  /**
   * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.
   */
  public final static int BOOLEAN = 1;
  /**
   * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.
   */
  public final static int CHAR = 2;
  /**
   * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.
   */
  public final static int BYTE = 3;
  /**
   * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.
   */
  public final static int SHORT = 4;
  /**
   * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.
   */
  public final static int INT = 5;
  /**
   * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.
   */
  public final static int FLOAT = 6;
  /**
   * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.
   */
  public final static int LONG = 7;
  /**
   * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.
   */
  public final static int DOUBLE = 8;
  /**
   * The sort of array reference types. See {@link #getSort getSort}.
   */
  public final static int ARRAY = 9;
  /**
   * The sort of object reference type. See {@link #getSort getSort}.
   */
  public final static int OBJECT = 10;
  /**
   * The <tt>void</tt> type.
   */
  public final static Type VOID_TYPE = new Type(VOID);
  /**
   * The <tt>boolean</tt> type.
   */
  public final static Type BOOLEAN_TYPE = new Type(BOOLEAN);
  /**
   * The <tt>char</tt> type.
   */
  public final static Type CHAR_TYPE = new Type(CHAR);
  /**
   * The <tt>byte</tt> type.
   */
  public final static Type BYTE_TYPE = new Type(BYTE);
  /**
   * The <tt>short</tt> type.
   */
  public final static Type SHORT_TYPE = new Type(SHORT);
  /**
   * The <tt>int</tt> type.
   */
  public final static Type INT_TYPE = new Type(INT);
  /**
   * The <tt>float</tt> type.
   */
  public final static Type FLOAT_TYPE = new Type(FLOAT);
  /**
   * The <tt>long</tt> type.
   */
  public final static Type LONG_TYPE = new Type(LONG);
  /**
   * The <tt>double</tt> type.
   */
  public final static Type DOUBLE_TYPE = new Type(DOUBLE);
  // --------------------------------------------------------------------------
  // Fields
  // --------------------------------------------------------------------------
  /**
   * The sort of this Java type.
   */
  private final int sort;
  /**
   * A buffer containing the descriptor of this Java type.
   * This field is only used for reference types.
   */
  private char[] buf;
  /**
   * The offset of the descriptor of this Java type in {@link #buf buf}.
   * This field is only used for reference types.
   */
  private int off;
  /**
   * The length of the descriptor of this Java type.
   */
  private int len;
  // --------------------------------------------------------------------------
  // Constructors
  // --------------------------------------------------------------------------
  /**
   * Constructs a primitive type.
   *
   * @param sort the sort of the primitive type to be constructed.
   */
  private Type (final int sort) {
    this.sort = sort;
    this.len = 1;
  }
  /**
   * Constructs a reference type.
   *
   * @param sort the sort of the reference type to be constructed.
   * @param buf a buffer containing the descriptor of the previous type.
   * @param off the offset of this descriptor in the previous buffer.
   * @param len the length of this descriptor.
   */
  private Type (
    final int sort,
    final char[] buf,
    final int off,
    final int len)
  {
    this.sort = sort;
    this.buf = buf;
    this.off = off;
    this.len = len;
  }
  /**
   * Returns the Java type corresponding to the given type descriptor.
   *
   * @param typeDescriptor a type descriptor.
   * @return the Java type corresponding to the given type descriptor.
   */
  public static Type getType (final String typeDescriptor) {
    return getType(typeDescriptor.toCharArray(), 0);
  }
  /**
   * Returns the Java type corresponding to the given class.
   *
   * @param c a class.
   * @return the Java type corresponding to the given class.
   */
  public static Type getType (final Class c) {
    if (c.isPrimitive()) {
      if (c == Integer.TYPE) {
        return INT_TYPE;
      } else if (c == Void.TYPE) {
        return VOID_TYPE;
      } else if (c == Boolean.TYPE) {
        return BOOLEAN_TYPE;
      } else if (c == Byte.TYPE) {
        return BYTE_TYPE;
      } else if (c == Character.TYPE) {
        return CHAR_TYPE;
      } else if (c == Short.TYPE) {
        return SHORT_TYPE;
      } else if (c == Double.TYPE) {
        return DOUBLE_TYPE;
      } else if (c == Float.TYPE) {
        return FLOAT_TYPE;
      } else /*if (c == Long.TYPE)*/ {
        return LONG_TYPE;
      }
    } else {
      return getType(getDescriptor(c));
    }
  }
  /**
   * Returns the Java types corresponding to the argument types of the given
   * method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the Java types corresponding to the argument types of the given
   *      method descriptor.
   */
  public static Type[] getArgumentTypes (final String methodDescriptor) {
    char[] buf = methodDescriptor.toCharArray();
    int off = 1;
    int size = 0;
    while (true) {
      char car = buf[off++];
      if (car == ')') {
        break;
      } else if (car == 'L') {
        while (buf[off++] != ';') {
        }
        ++size;
      } else if (car != '[') {
        ++size;
      }
    }
    Type[] args = new Type[size];
    off = 1;
    size = 0;
    while (buf[off] != ')') {
      args[size] = getType(buf, off);
      off += args[size].len;
      size += 1;
    }
    return args;
  }
  /**
   * Returns the Java types corresponding to the argument types of the given
   * method.
   *
   * @param method a method.
   * @return the Java types corresponding to the argument types of the given
   *      method.
   */
  public static Type[] getArgumentTypes (final Method method) {
    Class[] classes = method.getParameterTypes();
    Type[] types = new Type[classes.length];
    for (int i = classes.length - 1; i >= 0; --i) {
      types[i] = getType(classes[i]);
    }
    return types;
  }
  /**
   * Returns the Java type corresponding to the return type of the given
   * method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the Java type corresponding to the return type of the given
   *      method descriptor.
   */
  public static Type getReturnType (final String methodDescriptor) {
    char[] buf = methodDescriptor.toCharArray();
    return getType(buf, methodDescriptor.indexOf(')') + 1);
  }
  /**
   * Returns the Java type corresponding to the return type of the given
   * method.
   *
   * @param method a method.
   * @return the Java type corresponding to the return type of the given
   *      method.
   */
  public static Type getReturnType (final Method method) {
    return getType(method.getReturnType());
  }
  /**
   * Returns the Java type corresponding to the given type descriptor.
   *
   * @param buf a buffer containing a type descriptor.
   * @param off the offset of this descriptor in the previous buffer.
   * @return the Java type corresponding to the given type descriptor.
   */
  private static Type getType (final char[] buf, final int off) {
    int len;
    switch (buf[off]) {
      case 'V': return VOID_TYPE;
      case 'Z': return BOOLEAN_TYPE;
      case 'C': return CHAR_TYPE;
      case 'B': return BYTE_TYPE;
      case 'S': return SHORT_TYPE;
      case 'I': return INT_TYPE;
      case 'F': return FLOAT_TYPE;
      case 'J': return LONG_TYPE;
      case 'D': return DOUBLE_TYPE;
      case '[':
        len = 1;
        while (buf[off + len] == '[') {
          ++len;
        }
        if (buf[off + len] == 'L') {
          ++len;
          while (buf[off + len] != ';') {
            ++len;
          }
        }
        return new Type(ARRAY, buf, off, len + 1);
      //case 'L':
      default:
        len = 1;
        while (buf[off + len] != ';') {
          ++len;
        }
        return new Type(OBJECT, buf, off, len + 1);
    }
  }
  // --------------------------------------------------------------------------
  // Accessors
  // --------------------------------------------------------------------------
  /**
   * Returns the sort of this Java type.
   *
   * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN}, {@link #CHAR CHAR},
   *      {@link #BYTE BYTE}, {@link #SHORT SHORT}, {@link #INT INT}, {@link
   *      #FLOAT FLOAT}, {@link #LONG LONG}, {@link #DOUBLE DOUBLE}, {@link
   *      #ARRAY ARRAY} or {@link #OBJECT OBJECT}.
   */
  public int getSort () {
    return sort;
  }
  /**
   * Returns the number of dimensions of this array type.
   * This method should only be used for an array type.
   *
   * @return the number of dimensions of this array type.
   */
  public int getDimensions () {
    int i = 1;
    while (buf[off + i] == '[') {
      ++i;
    }
    return i;
  }
  /**
   * Returns the type of the elements of this array type.
   * This method should only be used for an array type.
   *
   * @return Returns the type of the elements of this array type.
   */
  public Type getElementType () {
    return getType(buf, off + getDimensions());
  }
  /**
   * Returns the name of the class corresponding to this object type.
   * This method should only be used for an object type.
   *
   * @return the fully qualified name of the class corresponding to this object
   *      type.
   */
  public String getClassName () {
    return new String(buf, off + 1, len - 2).replace('/', '.');
  }
  /**
   * Returns the internal name of the class corresponding to this object type.
   * The internal name of a class is its fully qualified name, where '.' are
   * replaced by '/'.   * This method should only be used for an object type.
   *
   * @return the internal name of the class corresponding to this object type.
   */
  public String getInternalName () {
    return new String(buf, off + 1, len - 2);
  }
  // --------------------------------------------------------------------------
  // Conversion to type descriptors
  // --------------------------------------------------------------------------
  /**
   * Returns the descriptor corresponding to this Java type.
   *
   * @return the descriptor corresponding to this Java type.
   */
  public String getDescriptor () {
    StringBuffer buf = new StringBuffer();
    getDescriptor(buf);
    return buf.toString();
  }
  /**
   * Returns the descriptor corresponding to the given argument and return
   * types.
   *
   * @param returnType the return type of the method.
   * @param argumentTypes the argument types of the method.
   * @return the descriptor corresponding to the given argument and return
   *      types.
   */
  public static String getMethodDescriptor (
    final Type returnType,
    final Type[] argumentTypes)
  {
    StringBuffer buf = new StringBuffer();
    buf.append('(');
    for (int i = 0; i < argumentTypes.length; ++i) {
      argumentTypes[i].getDescriptor(buf);
    }
    buf.append(')');
    returnType.getDescriptor(buf);
    return buf.toString();
  }
  /**
   * Appends the descriptor corresponding to this Java type to the given string
   * buffer.
   *
   * @param buf the string buffer to which the descriptor must be appended.
   */
  private void getDescriptor (final StringBuffer buf) {
    switch (sort) {
      case VOID:    buf.append('V'); return;
      case BOOLEAN: buf.append('Z'); return;
      case CHAR:    buf.append('C'); return;
      case BYTE:    buf.append('B'); return;
      case SHORT:   buf.append('S'); return;
      case INT:     buf.append('I'); return;
      case FLOAT:   buf.append('F'); return;
      case LONG:    buf.append('J'); return;
      case DOUBLE:  buf.append('D'); return;
      //case ARRAY:
      //case OBJECT:
      default:      buf.append(this.buf, off, len);
    }
  }
  // --------------------------------------------------------------------------
  // Direct conversion from classes to type descriptors,
  // without intermediate Type objects
  // --------------------------------------------------------------------------
  /**
   * Returns the internal name of the given class. The internal name of a class
   * is its fully qualified name, where '.' are replaced by '/'.
   *
   * @param c an object class.
   * @return the internal name of the given class.
   */
  public static String getInternalName (final Class c) {
    return c.getName().replace('.', '/');
  }
  /**
   * Returns the descriptor corresponding to the given Java type.
   *
   * @param c an object class, a primitive class or an array class.
   * @return the descriptor corresponding to the given class.
   */
  public static String getDescriptor (final Class c) {
    StringBuffer buf = new StringBuffer();
    getDescriptor(buf, c);
    return buf.toString();
  }
  /**
   * Returns the descriptor corresponding to the given method.
   *
   * @param m a {@link Method Method} object.
   * @return the descriptor of the given method.
   */
  public static String getMethodDescriptor (final Method m) {
    Class[] parameters = m.getParameterTypes();
    StringBuffer buf = new StringBuffer();
    buf.append('(');
    for (int i = 0; i < parameters.length; ++i) {
      getDescriptor(buf, parameters[i]);
    }
    buf.append(')');
    getDescriptor(buf, m.getReturnType());
    return buf.toString();
  }
  /**
   * Appends the descriptor of the given class to the given string buffer.
   *
   * @param buf the string buffer to which the descriptor must be appended.
   * @param c the class whose descriptor must be computed.
   */
  private static void getDescriptor (final StringBuffer buf, final Class c) {
    Class d = c;
    while (true) {
      if (d.isPrimitive()) {
        char car;
        if (d == Integer.TYPE) {
          car = 'I';
        } else if (d == Void.TYPE) {
          car = 'V';
        } else if (d == Boolean.TYPE) {
          car = 'Z';
        } else if (d == Byte.TYPE) {
          car = 'B';
        } else if (d == Character.TYPE) {
          car = 'C';
        } else if (d == Short.TYPE) {
          car = 'S';
        } else if (d == Double.TYPE) {
          car = 'D';
        } else if (d == Float.TYPE) {
          car = 'F';
        } else /*if (d == Long.TYPE)*/ {
          car = 'J';
        }
        buf.append(car);
        return;
      } else if (d.isArray()) {
        buf.append('[');
        d = d.getComponentType();
      } else {
        buf.append('L');
        String name = d.getName();
        int len = name.length();
        for (int i = 0; i < len; ++i) {
          char car = name.charAt(i);
          buf.append(car == '.' ? '/' : car);
        }
        buf.append(';');
        return;
      }
    }
  }
  // --------------------------------------------------------------------------
  // Corresponding size and opcodes
  // --------------------------------------------------------------------------
  /**
   * Returns the size of values of this type.
   *
   * @return the size of values of this type, i.e., 2 for <tt>long</tt> and
   *      <tt>double</tt>, and 1 otherwise.
   */
  public int getSize () {
    return (sort == LONG || sort == DOUBLE ? 2 : 1);
  }
  /**
   * Returns a JVM instruction opcode adapted to this Java type.
   *
   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,
   *      ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,
   *      ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.
   * @return an opcode that is similar to the given opcode, but adapted to this
   *      Java type. For example, if this type is <tt>float</tt> and
   *      <tt>opcode</tt> is IRETURN, this method returns FRETURN.
   */
  public int getOpcode (final int opcode) {
    if (opcode == Constants.IALOAD || opcode == Constants.IASTORE) {
      switch (sort) {
        case VOID:
          return opcode + 5;
        case BOOLEAN:
        case BYTE:
          return opcode + 6;
        case CHAR:
          return opcode + 7;
        case SHORT:
          return opcode + 8;
        case INT:
          return opcode;
        case FLOAT:
          return opcode + 2;
        case LONG:
          return opcode + 1;
        case DOUBLE:
          return opcode + 3;
        //case ARRAY:
        //case OBJECT:
        default:
          return opcode + 4;
      }
    } else {
      switch (sort) {
        case VOID:
          return opcode + 5;
        case BOOLEAN:
        case CHAR:
        case BYTE:
        case SHORT:
        case INT:
          return opcode;
        case FLOAT:
          return opcode + 2;
        case LONG:
          return opcode + 1;
        case DOUBLE:
          return opcode + 3;
        //case ARRAY:
        //case OBJECT:
        default:
          return opcode + 4;
      }
    }
  }
}
"
