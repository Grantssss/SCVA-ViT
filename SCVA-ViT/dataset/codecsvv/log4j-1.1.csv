metric_name,file
org.apache.log4j.Appender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;
/**
   Implement this interface for your own strategies for printing log
   statements. 
   @author Ceki G&uuml;lc&uuml;
*/
public interface Appender {
  /**
     Add a filter to the end of the filter list.
     @since 0.9.0
   */
  void addFilter(Filter newFilter);
  /**
     Returns the head Filter. The Filters are organized in a linked list
     and so all Filters on this Appender are available through the result.
     @return the head Filter or null, if no Filters are present
     @since 1.1
  */
  public
  Filter getFilter();
  /**
     Clear the list of filters by removing all the filters in it.
     @since 0.9.0
   */
  public
  void clearFilters();
  /**
     Release any resources allocated within the appender such as file
     handles, network connections, etc.
     <p>It is a programming error to append to a closed appender.
     @since 0.8.4
  */
  public
  void close();
  /**
     Log in Appender specific way.  */
  public
  void doAppend(LoggingEvent event);
  /**
     Get the name of this appender. The name uniquely identifies the
     appender.  */
  public
  String getName();
  /**
     Set the {@link ErrorHandler} for this appender.
     @ since 0.9.0
   */
  public
  void setErrorHandler(ErrorHandler errorHandler);
  /**
     Returns the {@link ErrorHandler} for this appender.
     @since 1.1
   */
  public
  ErrorHandler getErrorHandler();
  /**
     Set the {@link Layout} for this appender.
     @since 0.8.1
  */
  public
  void setLayout(Layout layout);
  /**
     Returns this appenders layout.
     @since 1.1
  */
  public
  Layout getLayout();
  /**
     Set the name of this appender. The name is used by other
     components to identify this appender.
     @since 0.8.1
  */
  public
  void setName(String name);
  /**
     Configurators call this method to determine if the appender
    requires a layout. If this method returns <code>true</code>,
    meaning that layout is required, then the configurator will
    configure an layout using the configuration information at its
    disposal.  If this method returns <code>false</code>, meaning that
    a layout is not required, then layout configuration will be
    skipped even if there is available layout configuration
    information at the disposal of the configurator..
     <p>In the rather exceptional case, where the appender
     implementation admits a layout but can also work without it, then
     the appender should return <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout();
}
"
org.apache.log4j.AppenderSkeleton,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.helpers.LogLog;
/** 
   Abstract super-class of the other appenders in the package.
   This class provides the code for common functionality, such as
   support for threshold filtering and support for general filters.
   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public abstract class AppenderSkeleton implements Appender, OptionHandler {
  /**
     A string constant used in naming the option for setting the
     threshold for the appender. See also {@link #setThreshold
     setThreshold} method. Current value of this string constant is
     <b>Threshold</b>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String THRESHOLD_OPTION = ""Threshold"";
  /** The layout variable does not need to be set if the appender
      implementation has its own layout. */
  protected Layout layout;
  /** Appenders are named. */
  protected String name;
  /**
     There is no priority threshold filtering by default.  */
  protected Priority threshold;
  /** 
      It is assumed and enforced that errorHandler is never null.
  */
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();
  /** The first filter in the filter chain. Set to <code>null</code>
      initially. */
  protected Filter headFilter;
  /** The last filter in the filter chain. */
  protected Filter tailFilter;
  /**
     Is this appender closed? 
   */
  protected boolean closed = false;
  /**
     Derived appenders should override this method if option structure
     requires it.  */
  public
  void activateOptions() {
  }
  /**
     Add a filter to end of the filter list.
     @since 0.9.0
   */
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.next = newFilter;
      tailFilter = newFilter;    
    }
  }
  /**
     Subclasses of <code>AppenderSkeleton</code> should imlement this
     method to perform actual logging. See also {@link #doAppend
     AppenderSkeleton.doAppend} method.
     @since 0.9.0
  */
  abstract
  protected
  void append(LoggingEvent event);
  /**
     Clear the filters chain.
     @since 0.9.0 */
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }
  /**
     Finalize this appender by calling the imlenentation's
     <code>close</code> method.
     @since 0.8.4
  */
  public
  void finalize() {
    // An appender might be closed then garbage collected. There is no
    // point in closing twice.
    if(this.closed) 
      return;
    LogLog.debug(""Finalizing appender named [""+name+""]."");
    close();
  }
  /** 
      Return the currently set {@link ErrorHandler} for this
      Appender.  
      @since 0.9.0 */
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }
  /**
     Returns the head Filter.
     @since 1.1
  */
  public
  Filter getFilter() {
    return headFilter;
  }
  /** 
      Return the first filter in the filter chain for this
      Appender. The return value may be <code>null</code> if no is
      filter is set.
  */
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }
  /**
     Returns the layout of this appender. The value may be null.
  */
  public
  Layout getLayout() {
    return layout;
  }
  /**
     Returns the name of this FileAppender.
   */
  public
  final
  String getName() {
    return this.name;
  }
  /**
     Returns the string array {{@link #THRESHOLD_OPTION}}.
     <p>Configurable appenders must override this method to return the
     additional options they accept.  
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
   */
  public
  String[] getOptionStrings() {
    return new String[] {THRESHOLD_OPTION};
  }
  /**
     Returns this appenders threshold priority. See the {@link
     #setThreshold} method for the meaning of this option.
     @since 1.1 */
  public
  Priority getThreshold() {
    return threshold;
  }
  /**
     Check whether the message priority is below the appender's
     threshold. Ig there is no threshold set, then the return value is
     always <code>true</code>.
  */
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }
  /**
     This method performs threshold checks and invokes filters before
     delegating actual logging to the sub-classes specific {@link
     AppenderSkeleton#append} method.
   */
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error(""Attempted to append to closed appender named [""+name+""]."");
    }
    if(!isAsSevereAsThreshold(event.priority)) {
      return;
    }
    Filter f = this.headFilter;
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.next;
      }
    }
    this.append(event);    
  }
  /** 
      Set the {@link ErrorHandler} for this Appender.
      @since 0.9.0
  */
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // We do not throw exception here since the cause is probably a
      // bad config file.
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
    }
  }
  /**
     Set the layout for this appender. Note that some appenders have
     their own (fixed) layouts or do not use one. For example, the
     {@link org.apache.log4j.net.SocketAppender} ignores the layout set
     here. 
  */
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }
  /**
     Set the name of this Appender.
   */
  public
  void setName(String name) {
    this.name = name;
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    if(key.equalsIgnoreCase(THRESHOLD_OPTION)) {
      threshold = Priority.toPriority(value);
    }
  }
  /**
     Set the threshold priority. All log events with lower priority
     than the threshold priority are ignored by the appender.
     <p>In configuration files this option is specified by setting the
     value of the <b>Threshold</b> option to a priority
     string, such as ""DEBUG"", ""INFO"" and so on.
     @since 0.8.3 */
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }  
}
"
org.apache.log4j.AsyncAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors:  Aaron Greenhouse <aarong@cs.cmu.edu>
package org.apache.log4j;
import org.apache.log4j.Category;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.BoundedFIFO;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.LogLog;
import java.util.Enumeration;
/**
   The AsyncAppender lets users log events asynchronously. It uses a
   bounded buffer to store logging events.
   <p>The AsyncAppender will collect the events sent to it and then
   dispatch them to all the appenders that are attached to it. You can
   attach multiple appenders to an AsyncAppender.
   <p>The AsyncAppender uses a separate thread to serve the events in
   its bounded buffer. 
   <p>Refer to the results in {@link org.apache.log4j.performance.Logging}
   for the impact of using this appender.
   <p><b>Important note:</b> The <code>AsyncAppender</code> can only
   be script configured using the {@link
   org.apache.log4j.xml.DOMConfigurator}. Refer to example  configuration
   files <a href=""xml/examples/doc-files/sample4.xml"">sample4.xml</a>
   and <a href=""xml/examples/doc-files/sample5.xml"">sample5.xml</a>.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AsyncAppender extends AppenderSkeleton 
                                            implements AppenderAttachable {
  /**
     A string constant used in naming the option for setting the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  /**
     A string constant used in naming the option for setting the size of the
     internal buffer where logging events are stored until they are written.
     Current value of this string constant is <b>BufferSize</b>.  
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";
  /** The default buffer size is set to 128 events. */
  public static final int DEFAULT_BUFFER_SIZE = 128;
  //static Category cat = Category.getInstance(AsyncAppender.class.getName());
  BoundedFIFO bf = new BoundedFIFO(DEFAULT_BUFFER_SIZE);
  AppenderAttachableImpl aai;
  Dispatcher dispatcher;
  boolean locationInfo = false;
  boolean interruptedWarningMessage = false;
  public
  AsyncAppender() {
    // Note: The dispatcher code assumes that the aai is set once and
    // for all!!!
    aai = new AppenderAttachableImpl();
    dispatcher = new Dispatcher(bf, this);
    dispatcher.start();
  }
  public 
  void addAppender(Appender newAppender) {
    synchronized(aai) {
      aai.addAppender(newAppender);
    }
  } 
  public
  void append(LoggingEvent event) {
    // Set the NDC and thread name for the calling thread as these
    // LoggingEvent fields were not set at event creation time.
    event.getNDC();
    event.getThreadName();
    if(locationInfo) {
      event.getLocationInformation();	
    }
    synchronized(bf) {
      while(bf.isFull()) {
	try {
	  //LogLog.debug(""Waiting for free space in buffer, ""+bf.length());
	  bf.wait();
	} catch(InterruptedException e) {
	  if(!interruptedWarningMessage) {
	    interruptedWarningMessage = true;
	    LogLog.warn(""AsyncAppender interrupted."", e);
	  } else {
	    LogLog.warn(""AsyncAppender interrupted again."");
	  }
	}
      }
      //cat.debug(""About to put new event in buffer."");      
      bf.put(event);
      if(bf.wasEmpty()) {
	//cat.debug(""Notifying dispatcher to process events."");
	bf.notify();
      }
    }
  }
  /**
     Close this <code>AsyncAppender</code> by interrupting the
     dispatcher thread which will process all pending events before
     exiting. 
  */
  public 
  void close() {
    synchronized(this) {
      if(closed) // avoid multiple close, otherwise one gets NullPointerException
	return; 
      closed = true;
    }
    // The following cannot be synchronized on ""this"" because the
    // dispatcher synchronizes with ""this"" in its while loop. If we
    // did synhcronize we would systematically get deadlocks when
    // close was called.
    dispatcher.close();
    try {
      dispatcher.join();
    } catch(InterruptedException e) {
      LogLog.error(""Got an InterruptedException while waiting for the ""+
		   ""dispatcher to finish."", e);
    }
    dispatcher = null;
    bf = null;
  }
  public
  Enumeration getAllAppenders() {
    synchronized(aai) {
      return aai.getAllAppenders();
    }
  }
  public
  Appender getAppender(String name) {
    synchronized(aai) {
      return aai.getAppender(name);
    }
  }
  /**
     Returns the current value of the <b>LocationInfo</b> option.
  */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
     The <code>AsyncAppender</code> does not require a layout. Hence,
     this method always returns <code>false</code>. */
  public 
  boolean requiresLayout() {
    return false;
  }
  public
  void removeAllAppenders() {
    synchronized(aai) {
      aai.removeAllAppenders();
    }
  }
  public
  void removeAppender(Appender appender) {
    synchronized(aai) {
      aai.removeAppender(appender);
    }
  }
  public
  void removeAppender(String name) {
    synchronized(aai) {
      aai.removeAppender(name);
    }
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the event that will be ultimately logged will likely to
     contain the wrong location information (if present in the log
     format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  /**
     The <b>BufferSize</b> option takes a non-negative integer
     value.  This integer value determines the maximum size of the
     bounded buffer. Increasing the size of the buffer is always
     safe. However, if an existing buffer holds unwritten elements,
     then <em>decreasing the buffer size will result in event
     loss.</em> Nevertheless, while script configuring the
     AsyncAppender, it is safe to set a buffer size smaller than the
     {@link #DEFAULT_BUFFER_SIZE default buffer size} because
     configurators guarantee that an appender cannot be used before
     being completely configured. 
   */
  public
  void setBufferSize(int size) {
    bf.resize(size);
  }
  /**
     Returns the current value of the <b>BufferSize</b> option.
   */
  public
  int getBufferSize() {
    return bf.getMaxSize();
  }
 /**
     Returns the option names for this component in addition in
     addition to the options of its super class {@link
     AppenderSkeleton}.  
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
   */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {LOCATION_INFO_OPTION, BUFFER_SIZE_OPTION});
  }
 /**
     Set AsyncAppender specific options:
     <p>On top of the options of the super class {@link
     AppenderSkeleton}, the only recognized options are
     <b>BufferSize</b> and <b>LocationInfo</b>.
     <p> The <b>BufferSize</b> option takes a non-negative integer
     value.  This integer value determines the maximum size of the
     bounded buffer. Increasing the size of the buffer is always
     safe. However, if an existing buffer holds unwritten elements,
     then <em>decreasing the buffer size will result in event
     loss.</em> Nevertheless, while script configuring the
     AsyncAppender, it is safe to set a buffer size smaller than the
     {@link #DEFAULT_BUFFER_SIZE default buffer size} because
     configurators guarantee that an appender cannot be used before
     being completely configured. 
     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the event that will be ultimately logged will likely to
     contain the wrong location information (if present in the log
     format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
 */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);
    if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    else if (option.equals(BUFFER_SIZE_OPTION)) {
      int newSize = OptionConverter.toInt(value, DEFAULT_BUFFER_SIZE);
      bf.resize(newSize);
    }
  }
  /*
  public
  String getOption(String option) {
    if (option.equals(LOCATION_INFO_OPTION)) {
      return locationInfo ? ""true"" : ""false"";
    } else if (option.equals(BUFFER_SIZE_OPTION)) {
      return Integer.toString(bf.getMaxSize());
    } else {
      return super.getOption(option);
    }
  }
  */
}
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// ----------------------------------------------------------------------------
class Dispatcher extends Thread {
  BoundedFIFO bf;
  AppenderAttachableImpl aai;
  boolean interrupted = false;
  AsyncAppender container;
  Dispatcher(BoundedFIFO bf, AsyncAppender container) {
    this.bf = bf;
    this.container = container;
    this.aai = container.aai;
    // set the dispatcher priority to lowest possible value
    this.setPriority(Thread.MIN_PRIORITY);
    this.setName(""Dispatcher-""+getName());
    // set the dispatcher priority to MIN_PRIORITY plus or minus 2
    // depending on the direction of MIN to MAX_PRIORITY.
    //+ (Thread.MAX_PRIORITY > Thread.MIN_PRIORITY ? 1 : -1)*2);
  }
  void close() {
    synchronized(bf) {
      interrupted = true;   
      // We have a waiting dispacther if and only if bf.length is
      // zero.  In that case, we need to give it a death kiss.
      if(bf.length() == 0) {
	bf.notify();
      }
    }
  }
  /**
     The dispatching strategy is to wait until there are events in the
     buffer to process. After having processed an event, we release
     the monitor (variable bf) so that new events can be placed in the
     buffer, instead of keeping the monitor and processing the remaining
     events in the buffer. 
    <p>Other approaches might yield better results.
  */
  public
  void run() {
    //Category cat = Category.getInstance(Dispatcher.class.getName());
    LoggingEvent event;
    while(true) {
      synchronized(bf) {
	if(bf.length() == 0) {
	  // Exit loop if interrupted but only if the the buffer is empty.
	  if(interrupted) { 
	    //cat.info(""Exiting."");
	    return;
	  }
	  try {
	    //LogLog.debug(""Waiting for new event to dispatch."");
	    bf.wait();
	  } catch(InterruptedException e) {
	    LogLog.error(""The dispathcer should not be interrupted."");
	    break;
	  }
	}
	event = bf.get();
	if(bf.wasFull()) {
	  //LogLog.debug(""Notifying AsyncAppender about freed space."");
	  bf.notify();
	}
      } // synchronized
      // The synchronization on parent is necessary to protect against
      // operations on the aai object of the parent
      synchronized(container.aai) {
	if(aai != null && event != null) {
	  aai.appendLoopOnAppenders(event);
	}
      }
    } // while
  }
}
"
org.apache.log4j.BasicConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//              ""Muly Oved"" <mulyoved@hotmail.com>
package org.apache.log4j;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.util.Enumeration;
/**
   Use this class to quickly configure the package.
   <p>For file based configuration see {@link
   PropertyConfigurator}. For XML based configuration see {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}.
   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public class BasicConfigurator {
  /**
     <p><code>DISABLE_OVERRIDE_KEY</code> is the name of the constant
     holding the string value <b>log4j.disableOverride</b>.
     <p>Setting the system property <b>log4j.disableOverride</b> to
     ""true"" or any other value than ""false"" overrides the effects of
     all methods {@link Hierarchy#disable}, {@link
     Hierarchy#disableAll}, {@link Hierarchy#disableDebug} and {@link
     Hierarchy#disableInfo}. Thus, enabling normal evaluation of logging
     requests, i.e. according to the <a
     href=""../../manual.html#selectionRule"">Basic Selection Rule</a>.
     <p>If both <code>log4j.disableOverride</code> and a
     <code>log4j.disable</code> options are present, then
     <code>log4j.disableOverride</code> as the name indicates
     overrides any <code>log4j.disable</code> options.
     @since 0.8.5 */ 
     public static final String DISABLE_OVERRIDE_KEY = ""log4j.disableOverride"";
  /**
     <p><code>DISABLE_KEY</code> is the name of the constant
     holding the string value <b>log4j.disable</b>.
     <p>Setting the system property <b>log4j.disable</b> to DEBUG,
     INFO, WARN, ERROR or FATAL is equivalent to calling the {@link
     Hierarchy#disable} method with the corresponding priority.
     <p>If both <code>log4j.disableOverride</code> and a
     <code>log4j.disable</code> options are present, then
     <code>log4j.disableOverride</code> as the name indicates
     overrides any <code>log4j.disable</code> options.
     @since 1.1 */
     public static final String DISABLE_KEY = ""log4j.disable"";
  /**
     Special priority value signifying inherited behaviour. The
     current value of this string constant is <b>inherited</b>.
  */
  public static final String INHERITED = ""inherited"";
  // Check if value of(DISABLE_OVERRIDE_KEY) system property is set.
  // If it is set to ""true"" or any value other than ""false"", then set
  // static variable Category.disable to Category.DISABLE_OVERRIDE.
  static {    
    String override = OptionConverter.getSystemProperty(DISABLE_OVERRIDE_KEY, null);
    if(override != null) {
      Category.defaultHierarchy.setDisableOverride(override);
    } else { // check for log4j.disable only in absence of log4j.disableOverride
      String disableStr = OptionConverter.getSystemProperty(DISABLE_KEY, null);
      if(disableStr != null) {
	Category.defaultHierarchy.disable(disableStr);
      }
    }
  }
  protected BasicConfigurator() {
  }
  /**
     Used by subclasses to add a renderer to the hierarchy passed as parameter.
   */
  protected
  void addRenderer(Hierarchy hierarchy, String renderedClassName, 
		   String renderingClassName) {
    LogLog.debug(""Rendering class: [""+renderingClassName+""], Rendered class: [""+
		 renderedClassName+""]."");
    ObjectRenderer renderer = (ObjectRenderer) 
             OptionConverter.instantiateByClassName(renderingClassName, 
						    ObjectRenderer.class,
						    null);
    if(renderer == null) {
      LogLog.error(""Could not instantiate renderer [""+renderingClassName+""]."");
      return;
    } else {
      try {
	Class renderedClass = Class.forName(renderedClassName);
	hierarchy.rendererMap.put(renderedClass, renderer);
      } catch(ClassNotFoundException e) {
	LogLog.error(""Could not find class [""+renderedClassName+""]."", e);
      }
    }
  }
  /**
     See {@link Hierarchy#disable(String)}.
     @deprecated Use <code>Category.getDefaultHierarchy().disable()</code> instead.  */
  public
  static
  void disable(String priorityStr) {
    Category.getDefaultHierarchy().disable(priorityStr);
  }
  /**
     See {@link Hierarchy#disable(Priority)}.
     @deprecated Use <code>Category.getDefaultHierarchy().disable(p)</code> instead.  */
  public
  static
  void disable(Priority p) {
  }
  /**
     See {@link Hierarchy#disableAll()}.
     @deprecated Use <code>Category.getDefaultHierarchy().disableAll()</code> instead.  */  
  public
  static
  void disableAll() {
      Category.getDefaultHierarchy().disable(Priority.FATAL);
  }
 /**
     See {@link Hierarchy#disableDebug()}.
     @deprecated Use <code>Category.getDefaultHierarchy().disableDebug()</code> instead.  */ 
  public
  static
  void disableDebug() {
    Category.getDefaultHierarchy().disable(Priority.DEBUG);
  }  
 /**
     See {@link Hierarchy#disableInfo()}.
     @deprecated Use <code>Category.getDefaultHierarchy().disableInfo()</code> instead.  */ 
  public
  static
  void disableInfo() {
    Category.getDefaultHierarchy().disable(Priority.INFO);
  } 
 /**
     See {@link Hierarchy#enableAll()}.
     @deprecated Use <code>Category.getDefaultHierarchy().enableAll()</code> instead.  */ 
  public
  static
  void enableAll() {
    Category.getDefaultHierarchy().disable(Priority.INFO);
  }
  /**
     Add a {@link FileAppender} that uses {@link PatternLayout} using
     the {@link PatternLayout#TTCC_CONVERSION_PATTERN} and prints to
     <code>System.out</code> to the root category.  */
  static
  public
  void configure() {
    Category root = Category.getRoot();
    root.addAppender(new ConsoleAppender(
           new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
  }
  /**
     Add <code>appender</code> to the root category.
     @param appender The appender to add to the root category.
  */
  static
  public
  void configure(Appender appender) {
    Category root = Category.getRoot();
    root.addAppender(appender);
  }
  /**
     Reset the default hierarchy to its defaut. It is equivalent to
     calling
     <code>Category.getDefaultHierarchy().resetConfiguration()</code>.
     See {@link Hierarchy#resetConfiguration()} for more details.  */
  public
  static
  void resetConfiguration() {
    Category.defaultHierarchy.resetConfiguration();
  }
  /**
     @deprecated Use <code>hierarchy.resetConfiguration()</code> instead.
  */
  public
  static
  void resetConfiguration(Hierarchy hierarchy) {
    hierarchy.resetConfiguration();
  }
}
"
org.apache.log4j.Category,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors: Alex Blewitt <Alex.Blewitt@ioshq.com>
//              Markus Oestreicher <oes@zurich.ibm.com>
//              Frank Hoering <fhr@zurich.ibm.com>
//              Nelson Minar <nelson@media.mit.edu>
//              Jim Cakalic <jim_cakalic@na.biomerieux.com>
//              Avy Sharell <asharell@club-internet.fr>
//              Ciaran Treanor <ciaran@xelector.com>
//              Jeff Turner <jeff@socialchange.net.au>
//              Michael Horwitz <MHorwitz@siemens.co.za>
//              Calvin Chan <calvin.chan@hic.gov.au>
//              Aaron Greenhouse <aarong@cs.cmu.edu>
package org.apache.log4j;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.NullEnumeration;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import java.util.Enumeration;
import java.util.Vector;
import java.util.MissingResourceException;
import java.text.MessageFormat;
import java.util.ResourceBundle;
import java.net.URL;
import java.net.MalformedURLException;
/**
  This is the central class in the log4j package. One of the
  distintive features of log4j are hierarchical categories and their
  evaluation.
  <p>See the <a href=""../../../../manual.html"">user manual</a> for an
  introduction on this class. 
  @author Ceki G&uuml;lc&uuml;
  @author Anders Kristensen */
public class Category implements AppenderAttachable {
  /**
     The hierarchy where categories are attached to by default.
  */
  static 
  public 
  final Hierarchy defaultHierarchy = new Hierarchy(new 
						   RootCategory(Priority.DEBUG));
  /**
     This string constant is set to <b>log4j.properties</b> the name
     of the file that will be searched by default in classpath. If the
     file can be found, then it is fed to the {@link
     PropertyConfigurator}.
     See also {@link #DEFAULT_CONFIGURATION_KEY} for a more general
     alternative.
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     @since 0.8.5 */
     static public final String DEFAULT_CONFIGURATION_FILE = ""log4j.properties"";
  /**
     This string constant is set to <b>log4j.configuration</b>. 
     <p>It corresponds to name of a system property that, if set,
     specifies the name of the resource containing the properties file
     or {@link URL} with which log4j should configure itself. See
     {@link OptionConverter#selectAndConfigure} for more detailed
     information on the processing of this option.
     <p>Setting the <b>log4j.configuration</b> system property
     overrides the default search for the file <b>log4j.properties</b>.
     <p>Note that all property keys are case sensitive.  
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     @since 1.0 */
     static final public String DEFAULT_CONFIGURATION_KEY=""log4j.configuration"";
  /**
      Setting the system property <b>log4j.defaultInitOverride</b> to
      ""true"" or any other value than ""false"" will skip default
      configuration process.
     <p>The current value of the DEFAULT_INIT_OVERRIDE_KEY string
     constant is <b>log4j.defaultInitOverride</b>.
     <p>See also the full description of <a
     href=""../../../../manual.html#defaultInit"">default
     intialization</a> procedure.
     <p>Note that all property keys are case sensitive.  
     @since 0.8.5 */
  public static final String DEFAULT_INIT_OVERRIDE_KEY = 
                                                 ""log4j.defaultInitOverride"";
  /** Search for the properties file log4j.properties in the CLASSPATH.  */
  static {
    String override =OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,
						       null);
    // if there is no default init override, them get the resource
    // specified by the user or the default config file.
    if(override == null || ""false"".equalsIgnoreCase(override)) {
      String resource = OptionConverter.getSystemProperty(
                                                   DEFAULT_CONFIGURATION_KEY, 
						   DEFAULT_CONFIGURATION_FILE);
      URL url = null;
      try {
	// so, resource is not a URL:
	// attempt to get the resource from the class path
	url = new URL(resource);
      } catch (MalformedURLException ex) {
	  url = Loader.getResource(resource, Object.class); 
      }	
      // If we have a non-null url, then delegate the rest of the
      // configuration to the OptionConverter.selectAndConfigure
      // method.
      if(url != null) {
	LogLog.debug(""Using URL [""+url+""] for automatic log4j configuration."");
	OptionConverter.selectAndConfigure(url, defaultHierarchy);
      } else {
	LogLog.debug(""Could not find resource: [""+resource+""]."");
      }
    }  
  } 
  /**
     The name of this category.
  */
  protected String   name;  
  /**
     The assigned priority of this category.  The
     <code>priority</code> variable need not be assined a value in
     which case it is inherited form the hierarchy.  */
  volatile protected Priority priority;
  /**
     The parent of this category. All categories have at least one
     ancestor which is the root category. */
  volatile protected Category parent;
  /**
     The fully qualified name of the class that this Category
     object. Subclasses should override this variable.  */
  private static final String FQCN = Category.class.getName();
  protected ResourceBundle resourceBundle;
  // Categories need to know what Hierarchy they are in
  protected Hierarchy hierarchy;
  AppenderAttachableImpl aai;
  /** Additivity is set to true by default, that is children inherit
      the appenders of their ancestors by default. If this variable is
      set to <code>false</code> then the appenders found in the
      ancestors of this category are not used. However, the children
      of this category will inherit its appenders, unless the children
      have their additivity flag set to <code>false</code> too. See
      the user manual for more details. */
  protected boolean additive = true;
  /**
     This constructor created a new <code>Category</code> instance and
     sets its name.
     <p>It is intended to be used by sub-classes only. You should not
     create categories directly.
     @param name The name of the category.  
  */
  protected 
  Category(String name) {
    this.name = name;
  }
  /**
     Add <code>newAppender</code> to the list of appenders of this
     Category instance.
     <p>If <code>newAppender</code> is already in the list of
     appenders, then it won't be added again.
  */
  synchronized  
  public 
  void addAppender(Appender newAppender) {
    if(aai == null) {
      aai = new AppenderAttachableImpl();
    }
    aai.addAppender(newAppender);
  }
  /**
     If <code>assertion</code> parameter is <code>false</code>, then
     logs <code>msg</code> as an {@link #error(Object) error} statement.
     @param assertion 
     @param msg The message to print if <code>assertion</code> is
     false.
     @since 0.8.1 */
  public
  void assert(boolean assertion, String msg) {
    if(!assertion)
      this.error(msg);
  }
  /**
     Call the appenders in the hierrachy starting at
     <code>this</code>.  If no appenders could be found, emit a
     warning.
     <p>This method calls all the appenders inherited from the
     hierarchy circumventing any evaluation of whether to log or not
     to log the particular log request.
     @param LoggingEvent the event to log.  */
  public
  void callAppenders(LoggingEvent event) {
    int writes = 0;
    for(Category c = this; c != null; c=c.parent) {
      // Protected against simultaneous call to addAppender, removeAppender,...
      synchronized(c) {
	if(c.aai != null) {
	  writes += c.aai.appendLoopOnAppenders(event);
	}
	if(!c.additive) {
	  break;
	}
      }
    }
    // No appenders in hierarchy, warn user only once.
    if(!hierarchy.emittedNoAppenderWarning && writes == 0) {
      LogLog.error(""No appenders could be found for category ("" +
		    this.getName() + "")."");
      LogLog.error(""Please initialize the log4j system properly."");
      hierarchy.emittedNoAppenderWarning = true;
    }
  }
  /**
     Close all attached appenders implementing the AppenderAttachable
     interface.  
     @since 1.0
  */
  synchronized
  void closeNestedAppenders() {
    Enumeration enum = this.getAllAppenders();
    if(enum != null) {
      while(enum.hasMoreElements()) {
	Appender a = (Appender) enum.nextElement();
	if(a instanceof AppenderAttachable) {
	  a.close();
	}
      }
    }
  }
  /** 
    Log a message object with the {@link Priority#DEBUG DEBUG} priority.
    <p>This method first checks if this category is <code>DEBUG</code>
    enabled by comparing the priority of this category with the {@link
    Priority#DEBUG DEBUG} priority. If this category is
    <code>DEBUG</code> enabled, then it converts the message object
    (passed as parameter) to a string by invoking the appropriate
    {@link ObjectRenderer}. It then proceeds to call all the
    registered appenders in this category and also higher in the
    hierarchy depending on the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #debug(Object,
    Throwable)} form instead.
    @param message the message object to log. */
  public
  void debug(Object message) {
    if(hierarchy.disable >=  Priority.DEBUG_INT) 
      return;    
    if(Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority())) {
      forcedLog(FQCN, Priority.DEBUG, message, null);
    }
  }
  /** 
   Log a message object with the <code>DEBUG</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #debug(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */  
  public
  void debug(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.DEBUG_INT) return;
    if(this.isEnabledFor(Priority.DEBUG))
      forcedLog(FQCN, Priority.DEBUG, message, t);    
  }
  //public
  //void dump() {
  //  System.out.println(""Category "" + name + "" dump -----"");
  //  for(Category c = this; c != null; c=c.parent)
  //	System.out.println(""(""+c.name+"", ""+c.priority+"") ->"");
  //  System.out.println(""---------------------------"");
  //
  //}
  /** 
    Log a message object with the {@link Priority#ERROR ERROR} priority.
    <p>This method first checks if this category is <code>ERROR</code>
    enabled by comparing the priority of this category with {@link
    Priority#ERROR ERROR} priority. If this category is
    <code>ERROR</code> enabled, then it converts the message object
    passed as parameter to a string by invoking the appropriate {@link
    ObjectRenderer}. It proceeds to call all the registered appenders
    in this category and also higher in the hierarchy depending on
    the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #error(Object,
    Throwable)} form instead.
    @param message the message object to log */
  public
  void error(Object message) {
    if(hierarchy.disable >=  Priority.ERROR_INT) return;
    if(this.isEnabledFor(Priority.ERROR))
      forcedLog(FQCN, Priority.ERROR, message, null);
  }
  /** 
   Log a message object with the <code>ERROR</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #error(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */  
  public
  void error(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.ERROR_INT) return;
    if(this.isEnabledFor(Priority.ERROR))
      forcedLog(FQCN, Priority.ERROR, message, t);
  }
  /**
     If the named category exists (in the default hierarchy) then it
     returns a reference to the category, otherwise it returns
     <code>null</code>.
     <p>Contributed by Ciaran Treanor -  ciaran@xelector.com
     @version 0.8.5 */
  public
  static
  Category exists(String name) {    
    return defaultHierarchy.exists(name);
  }
  /** 
    Log a message object with the {@link Priority#FATAL FATAL} priority.
    <p>This method first checks if this category is <code>FATAL</code>
    enabled by comparing the priority of this category with {@link
    Priority#FATAL FATAL} priority. If the category is <code>FATAL</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hierarchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #fatal(Object, Throwable)} form
    instead. 
    @param message the message object to log */
  public
  void fatal(Object message) {
    if(hierarchy.disable >=  Priority.FATAL_INT) return;    
    if(Priority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.FATAL, message, null);
  }
  /** 
   Log a message object with the <code>FATAL</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #fatal(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void fatal(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.FATAL_INT) return;   
    if(Priority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.FATAL, message, t);
  }
  /**
     This method creates a new logging event and logs the event
     without further checks.  */
  protected
  void forcedLog(String fqcn, Priority priority, Object message, Throwable t) {
    callAppenders(new LoggingEvent(fqcn, this, priority, message, t));
  }
  /**
     Get the additivity flag for this Category instance.  
  */
  public
  boolean getAdditivity() {
    return additive;
  }
  /**
     Get the appenders contained in this category as an {@link
     Enumeration}. If no appenders can be found, then a {@link NullEnumeration}
     is returned.
     @return Enumeration An enumeration of the appenders in this category.  */
  synchronized
  public
  Enumeration getAllAppenders() {
    if(aai == null)
      return NullEnumeration.getInstance();
    else 
      return aai.getAllAppenders();
  }
  /**
     Look for the appender named as <code>name</code>.
     <p>Return the appender with that name if in the list. Return
     <code>null</code> otherwise.  */
  synchronized
  public
  Appender getAppender(String name) {
     if(aai == null || name == null)
      return null;
     return aai.getAppender(name);
  }
  /**
     Starting from this category, search the category hierarchy for a
     non-null priority and return it. Otherwise, return the priority of the
     root category.
     <p>The Category class is designed so that this method executes as
     quickly as possible.
   */
  public 
  Priority getChainedPriority() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.priority != null) 
	return c.priority;
    }
    return null; // If reached will cause an NullPointerException.
  }
  /**
     Returns all the currently defined categories in the default
     hierarchy as an {@link java.util.Enumeration Enumeration}.
     <p>The root category is <em>not</em> included in the returned
     {@link Enumeration}.     
  */
  public
  static
  Enumeration getCurrentCategories() {
    return defaultHierarchy.getCurrentCategories();
  }
  /**
     Return the default Hierarchy instance.
     @since 1.0
   */
  public 
  static 
  Hierarchy getDefaultHierarchy() {
    return defaultHierarchy;
  }
  /**
     Return the the {@link Hierarchy} where this <code>Category</code> instance is
     attached.
     @since 1.1 */
  public  
  Hierarchy getHierarchy() {
    return hierarchy;
  }
 /**
     Retrieve a category with named as the <code>name</code>
     parameter. If the named category already exists, then the
     existing instance will be reutrned. Otherwise, a new instance is
     created. 
     By default, categories do not have a set priority but inherit
     it from the hierarchy. This is one of the central features of
     log4j.
     @param name The name of the category to retrieve.  */
  public
  static
  Category getInstance(String name) {
    return defaultHierarchy.getInstance(name);
  }	
 /**
    Shorthand for <code>getInstance(clazz.getName())</code>.
    @param clazz The name of <code>clazz</code> will be used as the
    name of the category to retrieve.  See {@link
    #getInstance(String)} for more detailed information.
    @since 1.0 */
  public
  static
  Category getInstance(Class clazz) {
    return getInstance(clazz.getName());
  }	
  /**
     Like {@link #getInstance(String)} except that the type of category
     instantiated depends on the type returned by the {@link
     CategoryFactory#makeNewCategoryInstance} method of the
     <code>factory</code> parameter.
     <p>This method is intended to be used by sub-classes.
     @param name The name of the category to retrieve.
     @param factory A {@link CategoryFactory} implementation that will
     actually create a new Instance.
     @since 0.8.5 */
  public
  static
  Category getInstance(String name, CategoryFactory factory) {
    return defaultHierarchy.getInstance(name, factory);
  }	
  /**
     Return the category name.  */
  public
  final
  String getName() {
    return name;
  }
  /**
     Returns the assigned {@link Priority}, if any, for this Category.  
     @return Priority - the assigned Priority, can be <code>null</code>.
  */
  final
  public
  Priority getPriority() {
    return this.priority;
  }
  /**
     Return the root of the default category hierrachy.
     <p>The root category is always instantiated and available. It's
     name is ""root"".
     <p>Nevertheless, calling {@link #getInstance
     Category.getInstance(""root"")} does not retrieve the root category 
     but a category just under root named ""root"".
   */
  final
  public
  static
  Category getRoot() {
    return defaultHierarchy.getRoot();
  }
  /**
     Return the {@link ResourceBundle} for this category.
     <p>This method walks the hierarchy to find the appropriate
     resource bundle.
     <p>In case there is no bundle in the hierarchy then
     <code>null</code> is returned.
     @since 0.9.0 */
  public
  ResourceBundle getResourceBundle() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.resourceBundle != null) 
	return c.resourceBundle;
    }
    // It might be the case that there is no resource bundle 
    return null;
  }
  protected
  String getResourceBundleString(String key) {
    ResourceBundle rb = getResourceBundle();
    // This is one of the rare cases where we can use logging in order
    // to report errors from within log4j.
    if(rb == null) {
      if(!hierarchy.emittedNoResourceBundleWarning) {
	error(""No resource bundle has been set for category ""+name);
	hierarchy.emittedNoResourceBundleWarning = true;
      }
      return null;
    }
    else {
      try {
	return rb.getString(key);
      }
      catch(MissingResourceException mre) {
	error(""No resource is associated with key \""""+key+""\""."");
	return null;
      }
    }
  }
  /** 
    Log a message object with the {@link Priority#INFO INFO} priority.
    <p>This method first checks if this category is <code>INFO</code>
    enabled by comparing the priority of this category with {@link
    Priority#INFO INFO} priority. If the category is <code>INFO</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hierarchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #info(Object, Throwable)} form
    instead. 
    @param message the message object to log */
  public
  void info(Object message) {
    if(hierarchy.disable >=  Priority.INFO_INT) return;    
    if(Priority.INFO.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.INFO, message, null);
  }
  /** 
   Log a message object with the <code>INFO</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #info(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void info(Object message, Throwable t) {
    if(hierarchy.disable >=  Priority.INFO_INT) return;   
    if(Priority.INFO.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, Priority.INFO, message, t);
  }
  /**
     Check whether this category is enabled for the <code>DEBUG</code>
     priority.
     <p> This function is intended to lessen the computational cost of
     disabled log debug statements.
     <p> For some <code>cat</code> Category object, when you write,
     <pre>
       cat.debug(""This is entry number: "" + i );
     </pre>
     <p>You incur the cost constructing the message, concatenatiion in
     this case, regardless of whether the message is logged or not.
     <p>If you are worried about speed, then you should write
     <pre>
       if(cat.isDebugEnabled()) {
         cat.debug(""This is entry number: "" + i );
       }
     </pre>
     <p>This way you will not incur the cost of parameter construction
     if debugging is disabled for <code>cat</code>. On the other hand,
     if the <code>cat</code> is debug enabled, you will incur the cost
     of evaluating whether the category is debug enabled twice. Once
     in <code>isDebugEnabled</code> and once in the
     <code>debug</code>.  This is an insignificant overhead since
     evaluating a category takes about 1% of the time it takes to
     actually log.
     @return boolean - <code>true</code> if this category is debug
     enabled, <code>false</code> otherwise.
   */
  public
  boolean isDebugEnabled() {
    if(hierarchy.disable >=  Priority.DEBUG_INT)
      return false;   
    return Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority());
  }
  /**
     Check whether this category is enabled for a given {@link
     Priority} passed as parameter.
     See also {@link #isDebugEnabled}.
     @return boolean True if this category is enabled for <code>priority</code>.
  */
  public
  boolean isEnabledFor(Priority priority) {
    if(hierarchy.disable >= priority.level) {
      return false;
    }
    return priority.isGreaterOrEqual(this.getChainedPriority());
  }
  /**
    Check whether this category is enabled for the info priority.
    See also {@link #isDebugEnabled}.
    @return boolean - <code>true</code> if this category is enabled
    for priority info, <code>false</code> otherwise.
  */
  public
  boolean isInfoEnabled() {
    if(hierarchy.disable >= Priority.INFO_INT)
      return false;   
    return Priority.INFO.isGreaterOrEqual(this.getChainedPriority());
  }
  /**
     Log a localized message. The user supplied parameter
     <code>key</code> is replaced by its localized version from the
     resource bundle.
     @see #setResourceBundle
     @since 0.8.4 */
  public
  void l7dlog(Priority priority, String key, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      String msg = getResourceBundleString(key);
      // if message corresponding to 'key' could not be found in the
      // resource bundle, then default to 'key'.
      if(msg == null) {
	msg = key;
      }
      forcedLog(FQCN, priority, msg, t);
    }
  }
  /**
     Log a localized and parameterized message. First, the user
     supplied <code>key</code> is searched in the resource
     bundle. Next, the resulting pattern is formatted using 
     {@link MessageFormat#format(String,Object[])} method with the user
     supplied object array <code>params</code>.
     @since 0.8.4
  */
  public
  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }    
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      String pattern = getResourceBundleString(key);
      String msg;
      if(pattern == null) 
	msg = key;
      else 
	msg = java.text.MessageFormat.format(pattern, params);
      forcedLog(FQCN, priority, msg, t);
    }
  }
  /**
     This generic form is intended to be used by wrappers.
   */
  public
  void log(Priority priority, Object message, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) 
      forcedLog(FQCN, priority, message, t);
  }
 /**
    This generic form is intended to be used by wrappers. 
 */
  public
  void log(Priority priority, Object message) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, priority, message, null);
  }
  /**
     This is the most generic printing method. It is intended to be
     invoked by <b>wrapper</b> classes.
     @param callerFQCN The wrapper class' fully qualified class name.
     @param priority The priority of the logging request.
     @param message The message of the logging request.
     @param t The throwable of the logging request, may be null.  */
  public
  void log(String callerFQCN, Priority priority, Object message, Throwable t) {
    if(hierarchy.disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      forcedLog(callerFQCN, priority, message, t);
    }
  }
  /**
     Remove all previously added appenders from this Category
     instance.
     <p>This is useful when re-reading configuration information.
  */
  synchronized
  public
  void removeAllAppenders() {
    if(aai != null) {
      aai.removeAllAppenders();
      aai = null;
    }
  }
  /**
     Remove the appender passed as parameter form the list of appenders.
     @since 0.8.2
  */
  synchronized
  public
  void removeAppender(Appender appender) {
    if(appender == null || aai == null) 
      return;
    aai.removeAppender(appender);
  }
  /**
     Remove the appender with the name passed as parameter form the
     list of appenders.
     @since 0.8.2 */
  synchronized
  public
  void removeAppender(String name) {
    if(name == null || aai == null) return;
    aai.removeAppender(name);
  }
  /**
     Set the additivity flag for this Category instance.
     @since 0.8.1
   */
  public
  void setAdditivity(boolean additive) {
    this.additive = additive;
  }
  /**
     Only the Hiearchy class can set the hiearchy of a
     category. Default package access is MANDATORY here.  */
  final
  void setHierarchy(Hierarchy hierarchy) {
    this.hierarchy = hierarchy;
  }
  /**
     Set the priority of this Category.
     <p>Null values are admitted.
  */
  public
  void setPriority(Priority priority) {
    this.priority = priority;
  }
  /**
     Set the resource bundle to be used with localized logging
     methods {@link #l7dlog(Priority,String,Throwable)} and {@link
     #l7dlog(Priority,String,Object[],Throwable)}.
     @since 0.8.4
   */
  public
  void setResourceBundle(ResourceBundle bundle) {
    resourceBundle = bundle;
  }
  /**
     Calling this method will <em>safely</em> close and remove all
     appenders in all the categories including root contained in the
     default hierachy.
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.
     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a category
     and again to a nested appender.  
     @since 1.0
  */
  public
  static
  void shutdown() {
    defaultHierarchy.shutdown();
  }
  /** 
    Log a message object with the {@link Priority#WARN WARN} priority.
    <p>This method first checks if this category is <code>WARN</code>
    enabled by comparing the priority of this category with {@link
    Priority#WARN WARN} priority. If the category is <code>WARN</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hieararchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #warn(Object, Throwable)} form
    instead.  <p>
    @param message the message object to log.  */
  public
  void warn(Object message) {
    if(this.isEnabledFor(Priority.WARN))
      forcedLog(FQCN, Priority.WARN, message, null);
  }
  /** 
   Log a message with the <code>WARN</code> priority including the
   stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #warn(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void warn(Object message, Throwable t) {
    if(this.isEnabledFor(Priority.WARN))
      forcedLog(FQCN, Priority.WARN, message, t);
  }
}
"
org.apache.log4j.CategoryKey,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
/**
   CategoryKey is heavily used internally to accelerate hash table searches.
   @author Ceki G&uuml;lc&uuml; 
*/
class CategoryKey {
  String   name;  
  int hashCache;
  CategoryKey(String name) {
    this.name = name.intern();
    hashCache = name.hashCode();
  }
  final
  public  
  int hashCode() {
    return hashCache;
  }
  final
  public
  boolean equals(Object rArg) {
    if(this == rArg)
      return true;
    if(rArg != null && CategoryKey.class == rArg.getClass()) 
      return  name == ((CategoryKey)rArg ).name;
    else 
      return false;
  }
}
"
org.apache.log4j.ConsoleAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
/**
   ConsoleAppender appends log events to <code>System.out</code> or
   <code>System.err</code> using a layout specified by the
   user. The default target is <code>System.out</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 1.1 */
public class ConsoleAppender extends WriterAppender {
  public static final String SYSTEM_OUT = ""System.out"";
  public static final String SYSTEM_ERR = ""System.err"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String TARGET_OPTION = ""Target"";
  protected String target = SYSTEM_OUT;
  /**
     The default constructor does nothing.
   */
  public ConsoleAppender() {    
  }
  public ConsoleAppender(Layout layout) {
    this(layout, SYSTEM_OUT);
  }
  public ConsoleAppender(Layout layout, String target) {
    this.layout = layout;
    if (SYSTEM_OUT.equals(target)) {
      setWriter(new OutputStreamWriter(System.out));	
    } else if (SYSTEM_ERR.equalsIgnoreCase(target)) {
      setWriter(new OutputStreamWriter(System.err));
    } else {
      targetWarn(target);
    }
  }
  /**
     Sets the value of the <b>Target</b> option.
     @param value String identifying a console; recognized values are
                  ""System.out"" (default) and ""System.err""
   */
  public
  void setTarget(String value) {
    String v = value.trim();
    if (SYSTEM_OUT.equalsIgnoreCase(v)) {
      target = SYSTEM_OUT;
    } else if (SYSTEM_ERR.equalsIgnoreCase(v)) {
      target = SYSTEM_ERR;
    } else {
      targetWarn(value);
    }  
  }
  /** Returns the current value of the <b>Target</b> option. */
  public
  String getTarget() {
    return target;
  }
  void targetWarn(String val) {
    LogLog.warn(""[""+val+""] should be System.out or System.err."");
    LogLog.warn(""Using System.out (default)."");
  }
  public
  void activateOptions() {
    if(target.equals(SYSTEM_OUT)) {
      setWriter(new OutputStreamWriter(System.out));
    } else {
      setWriter(new OutputStreamWriter(System.err));
    }
  }
  /**
     Override the parent method to do nothing.
   */
  protected
  final 
  void closeWriter() {
  }
  /**
    Returns the option names for this component, namely the string
    array {{@link #TARGET_OPTION} and the options of its super class
    {@link WriterAppender}.
    <b>See</b> Options of the super classes {@link WriterAppender} and
    {@link AppenderSkeleton}. In particular the <b>Threshold</b>
    option.
    @deprecated We now use JavaBeans introspection to configure
    components. Options strings are no longer needed.  
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TARGET_OPTION});
  }
  /**
     Set ConsoleAppender specific options.
     The <b>Target</b> option is recognized on top of options
     for the super class {@link WriterAppender}.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    if (key.equalsIgnoreCase(TARGET_OPTION)) {
      String v = value.trim();
      if(SYSTEM_OUT.equalsIgnoreCase(v)) {
	target = SYSTEM_OUT;
      } else {
	if(!SYSTEM_ERR.equalsIgnoreCase(v)) {
	  targetWarn(value);
	}  
      }
    }
  }
}
"
org.apache.log4j.DailyRollingFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.File;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Calendar;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
/**
   DailyRollingFileAppender extends {@link FileAppender} so that the
   underlying file is rolled over at a user chosen frequency.
   <p>The rolling schedule is specified by the <b>DatePattern</b>
   option. This pattern should follow the {@link SimpleDateFormat}
   conventions. In particular, you <em>must</em> escape literal text
   within a pair of single quotes. A formatted version of the date
   pattern is used as the suffix for the rolled file name.
   <p>For example, if the <b>File</b> option is set to
   <code>/foo/bar.log</code> and the <b>DatePattern</b> set to
   <code>'.'yyyy-MM-dd</code>, on 2001-02-16 at midnight, the logging
   file <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-02-16</code> and logging for 2001-02-17
   will continue in <code>/foo/bar.log</code> until it is rolled over
   itself the next day.
   <p>Is is possible to specify monthly, weekly, half-daily, daily,
   hourly, or minutely rollover schedules.
   <p><table border=""1"">
   <tr>
   <th>DatePattern</th> 
   <th>Rollover schedule</th>
   <th>Example</th>
   <tr>
   <td><code>'.'yyyy-MM</code>
   <td>Rollover at the beginning of each month</td>   
   <td>Assuming the first day of the week is Sunday, at Sunday 00:00,
   March 25th, 2001, <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-03</code>. Logging for the month of April
   will be output to <code>/foo/bar.log</code> until it is rolled over
   itself at the beginning of May.
   <tr>
   <td><code>'.'yyyy-ww</code>
   <td>Rollover at the first day of each week. The first day of the
   week depends on the locale.</td>
   <td>At midnight, on March 31st, 2001, <code>/foo/bar.log</code>
   will be copied to <code>/foo/bar.log.2001-08</code>. Logging for
   the 9th week of 2001 will be output to <code>/foo/bar.log</code>
   until it is rolled over the next week.
   <tr>
   <td><code>'.'yyyy-MM-dd</code>   
   <td>Rollover at midnight each day.</td>
   <td>At midnight, on March 9th, 2001, <code>/foo/bar.log</code> will
   be copied to <code>/foo/bar.log.2001-03-08</code>. Logging for the
   9th day of March will be output to <code>/foo/bar.log</code> until
   it is rolled over the next day.
   <tr>
   <td><code>'.'yyyy-MM-dd-a</code>   
   <td>Rollover at midnight and midday of each day.</td>
   <td>At noon, on March 9th, 2001, <code>/foo/bar.log</code> will be
   copied to <code>/foo/bar.log.2001-03-09-AM</code>. Logging for the
   afternoon of the 9th will be output to <code>/foo/bar.log</code>
   until it is rolled over the next morning, i.e at midnight 00:00.
   <tr>
   <td><code>'.'yyyy-MM-dd-HH</code>   
   <td>Rollover at the top of every hour.</td>
   <td>At approximately 11:00,000, on March 9th, 2001,
   <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-03-09-10</code>. Logging for the 11th hour
   of of the 9th of March will be output to <code>/foo/bar.log</code>
   until it is rolled over at the beginning of the next hour.
   <tr>
   <td><code>'.'yyyy-MM-dd-HH-mm</code>   
   <td>Rollover at the beginning of every minutue.</td>
   <td>At approximately 11:23,000, on March 9th, 2001,
   <code>/foo/bar.log</code> will be copied to
   <code>/foo/bar.log.2001-03-09-10-22</code>. Logging for the minutue
   of 11:23 (9th of March) will be output to
   <code>/foo/bar.log</code> untill it is rolled over the next minute.
   </table>
   <p>Do not use the colon "":"" character in anywhere in the
   <b>DatePattern</b> option. The text before the colon is interpeted
   as the protocol specificaion of a URL which is probably not what
   you want.
   @author Eirik Lygre
   @author Ceki G&uuml;lc&uuml; */
public class DailyRollingFileAppender extends FileAppender {
  // The code assumes that the following constants are in a increasing
  // sequence.
  static final int TOP_OF_TROUBLE=-1;
  static final int TOP_OF_MINUTE = 0;
  static final int TOP_OF_HOUR   = 1;
  static final int HALF_DAY      = 2;
  static final int TOP_OF_DAY    = 3;
  static final int TOP_OF_WEEK   = 4;
  static final int TOP_OF_MONTH  = 5;
  /**
     A string constant used in naming the option for setting the
     filename pattern. Current value of this string constant is
     <strong>DatePattern</strong>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  static final public String DATE_PATTERN_OPTION = ""DatePattern"";
  /**
     The date pattern. By default, the pattern is set to
     ""'.'yyyy-MM-dd"" meaning daily rollover. 
   */
  private String datePattern = ""'.'yyyy-MM-dd"";
  /**
     The actual formatted filename that is currently being written to.
  */
  private String scheduledFilename;
  /**
     The timestamp when we shall next recompute the filename.
  */
  private long nextCheck = System.currentTimeMillis () - 1;
  Date now = new Date();
  SimpleDateFormat sdf;
  RollingCalendar rc = new RollingCalendar();
  int checkPeriod = TOP_OF_TROUBLE;
  /**
     The default constructor does nothing. */
  public
  DailyRollingFileAppender() {
  }
  /**
    Instantiate a <code>DailyRollingFileAppender</code> and open the
    file designated by <code>filename</code>. The opened filename will
    become the ouput destination for this appender.
    */
  public DailyRollingFileAppender (Layout layout, String filename, 
				   String datePattern) throws IOException {
    super(layout, filename, true);
    this.datePattern = datePattern;
    activateOptions();
  }
  /**
     The <b>DatePattern</b> takes a string in the same format as
     expected by {@link SimpleDateFormat}. This options determines the
     rollover schedule.
   */
  public
  void setDatePattern(String pattern) {
    datePattern = pattern;
  }
  /** Returns the value of the <b>DatePattern</b> option. */
  public
  String getDatePattern() {
    return datePattern;
  }
  /**
     Retuns the option names for this component, namely {@link
     #DATE_PATTERN_OPTION} in
     addition to the options of {@link FileAppender#getOptionStrings
     FileAppender}.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {DATE_PATTERN_OPTION});
  }
  /**
     Set the options for the {@link DailyRollingFileAppender}
     instance.
     <p>The <b>DatePattern</b> takes a string in the same format as
     expected by {@link SimpleDateFormat}. This options determines the
     rollover schedule.
     <p>Be sure to refer to the options in the super classes {@link
     FileAppender}, {@link WriterAppender} and in particular the
     <b>Threshold</b> option in {@link AppenderSkeleton}.
     </ul>
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
 */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(DATE_PATTERN_OPTION)) {
      datePattern = value;
    }
  }
  public
  void activateOptions() {
    super.activateOptions();
    if(datePattern != null && fileName != null) {
      now.setTime(System.currentTimeMillis());
      sdf = new SimpleDateFormat(datePattern);
      int type = computeCheckPeriod();
      printPeriodicity(type);
      rc.setType(type);
      scheduledFilename = fileName+sdf.format(now);
    } else {
      LogLog.error(""Either Filename or DatePattern options are not set for [""+
		   name+""]."");
    }
  }
  void printPeriodicity(int type) {
    switch(type) {
    case TOP_OF_MINUTE:
      LogLog.debug(""Appender [""+name+""] to be rolled every minute."");
      break;
    case TOP_OF_HOUR:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled on top of every hour."");
      break;
    case HALF_DAY:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at midday and midnight."");
      break;
    case TOP_OF_DAY:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at midnight."");
      break;
    case TOP_OF_WEEK:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at start of week."");
      break;
    case TOP_OF_MONTH:
      LogLog.debug(""Appender [""+name
		   +""] to be rolled at start of every month."");
      break;	    
    default:
      LogLog.warn(""Unknown periodicity for appender [""+name+""]."");
    }
  }
  int computeCheckPeriod() {
    RollingCalendar c = new RollingCalendar();
    // set sate to 1970-01-01 00:00:00 GMT
    Date epoch = new Date(0);    
    if(datePattern != null) {
      for(int i = TOP_OF_MINUTE; i <= TOP_OF_MONTH; i++) {	
	String r0 = sdf.format(epoch);
	c.setType(i);
	Date next = new Date(c.getNextCheckMillis(epoch));
	String r1 = sdf.format(next);
	//LogLog.debug(""Type = ""+i+"", r0 = ""+r0+"", r1 = ""+r1);
	if(r0 != null && r1 != null && !r0.equals(r1)) {
	  return i;
	}
      }
    }
    return TOP_OF_TROUBLE; // Deliberately head for trouble...
  }
  /**
     Rollover the current file to a new file.
  */  
  void rollOver() throws IOException {
    /* Compute filename, but only if datePattern is specified */
    if (datePattern == null) {
      errorHandler.error(""Missing DatePattern option in rollOver()."");
      return;
    }
    String datedFilename = fileName+sdf.format(now);
    if (scheduledFilename.equals(datedFilename)) 
      return;
    // close current file, and rename it to datedFilename
    this.closeFile(); 
    File target  = new File(scheduledFilename);    
    if (target.exists()) {
      target.delete();
    }
    File file = new File(fileName);
    file.renameTo(target);    
    LogLog.debug(fileName +"" -> ""+ scheduledFilename);    
    try {
      // This will also close the file. This is OK since multiple
      // close operations are safe.
      this.setFile(fileName, false);
    }
    catch(IOException e) {
      errorHandler.error(""setFile(""+fileName+"", false) call failed."");
    }
    scheduledFilename = datedFilename;    
  }
  /**
     This method differentiates DailyRollingFileAppender from its
     super class.
  */
  protected 
  void subAppend(LoggingEvent event) {
    long n = System.currentTimeMillis();
    if (n >= nextCheck) {
      now.setTime(n);
      nextCheck = rc.getNextCheckMillis(now);
      try {  
	rollOver();  
      }
      catch(IOException ioe) {
	LogLog.error(""rollOver() failed."", ioe);
      }
    }
    super.subAppend(event);
   }
}  
/**
   RollingCalendar is a helper class to
   DailyRollingFileAppender. Using this class, it is easy to compute
   and access the next Millis().
   It subclasses the standard {@link GregorianCalendar}-object, to
   allow access to the protected function getTimeInMillis(), which it
   then exports.
   @author <a HREF=""mailto:eirik.lygre@evita.no"">Eirik Lygre</a> */
class RollingCalendar extends GregorianCalendar {
  int type = DailyRollingFileAppender.TOP_OF_TROUBLE;
  void setType(int type) {
    this.type = type;
  }
  public
  long getNextCheckMillis(Date now) {
    return getNextCheckDate(now).getTime();
  }
  public 
  Date getNextCheckDate(Date now) {
    this.setTime(now);
    switch(type) {
    case DailyRollingFileAppender.TOP_OF_MINUTE:
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.MINUTE, 1); 
	break;
    case DailyRollingFileAppender.TOP_OF_HOUR:
	this.set(Calendar.MINUTE, 0); 
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.HOUR_OF_DAY, 1); 
	break;
    case DailyRollingFileAppender.HALF_DAY:
	this.set(Calendar.MINUTE, 0); 
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	int hour = get(Calendar.HOUR_OF_DAY);
	if(hour < 12) {
	  this.set(Calendar.HOUR_OF_DAY, 12);
	} else {
	  this.set(Calendar.HOUR_OF_DAY, 0);
	  this.add(Calendar.DAY_OF_MONTH, 1);       
	}
	break;
    case DailyRollingFileAppender.TOP_OF_DAY:
	this.set(Calendar.HOUR_OF_DAY, 0); 
	this.set(Calendar.MINUTE, 0); 
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.DATE, 1);       
	break;
    case DailyRollingFileAppender.TOP_OF_WEEK:
	this.set(Calendar.DAY_OF_WEEK, getFirstDayOfWeek());
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.WEEK_OF_YEAR, 1);
	break;
    case DailyRollingFileAppender.TOP_OF_MONTH:
	this.set(Calendar.DATE, 1);
	this.set(Calendar.HOUR_OF_DAY, 0);
	this.set(Calendar.SECOND, 0);
	this.set(Calendar.MILLISECOND, 0);
	this.add(Calendar.MONTH, 1); 
	break;
    default:
	throw new IllegalStateException(""Unknown periodicity type."");
    }      
    return getTime();
  }
}"
org.apache.log4j.DefaultCategoryFactory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.CategoryFactory;
class DefaultCategoryFactory implements CategoryFactory {
  DefaultCategoryFactory() {
  }    
  public
  Category makeNewCategoryInstance(String name) {
    return new Category(name);
  }    
}
"
org.apache.log4j.FileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
//import org.apache.log4j.helpers.TracerPrintWriter;
// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>
/**
   FileAppender appends log events to a file. 
   <b>Support for java.io.Writer and console appending has been
   deprecated and will be removed in the near future.</b> You are
   stongly encouraged to use the replacement solutions: {@link
   WriterAppender} and {@link ConsoleAppender}.
   @author Ceki G&uuml;lc&uuml; */
public class FileAppender extends WriterAppender {
 /**
     A string constant used in naming the option for setting the
     output file. Current value of this string constant is
     <b>File</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public static final String FILE_OPTION = ""File"";
  /**
     A string constant used in naming the option that determines whether 
     the output file will be truncated or appended to. Current value
     of this string constant is <b>Append</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.     
  */
  public static final String APPEND_OPTION = ""Append"";
  /** Append to or truncate the file? The default value for this
      variable is <code>true</code>, meaning that by default a
      <code>FileAppender</code> will append to an existing file and
      not truncate it.
      <p>This option is meaningful only if the FileAppender opens the
      file.      
  */
  protected boolean fileAppend = true;
  /**
     The name of the log file. */
  protected String fileName = null;
  /**
     Is the QuietWriter ours or was it created and passed by the user?     
     @deprecated FileAppender will not support streams passed by the
     user in the future. */
  protected boolean qwIsOurs = false;
  /**
     The default constructor does not do anything. 
  */
  public
  FileAppender() {
  }
  /**
     Instantiate a FileAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  
     @deprecated <b>The functionality of this constructor form has
     been replaced by the {@link WriterAppender}. This constructor
     will be removed in the <em>near</em> term.</b>
  */
  public
  FileAppender(Layout layout, OutputStream os) {
    super(layout, os);
  }
  /**
     Instantiate a FileAppender and set the output destination to
     <code>writer</code>.
     <p>The <code>writer</code> must have been opened by the user.  
     @deprecated <b>The functionality of constructor form has been
     replaced by the {@link WriterAppender}. This constructor will be
     removed in the <em>near</em> term.</b>
  */
  public
  FileAppender(Layout layout, Writer writer) {
    super(layout, writer);
  }                    
  /**
    Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file designated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  FileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    this.layout = layout;
    this.setFile(filename, append);
  }
  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>The file will be appended to.  */
  public
  FileAppender(Layout layout, String filename) throws IOException {
    this(layout, filename, true);
  }
  /**
     The <b>File</b> option takes a string value which should be
     the name of the file to append to. Special values ""System.out"" or
     ""System.err"" are interpreted as the standard out and standard
     error streams.
     <p><font color=""#DD0044""><b>Note that the ""System.out"" or ""System.err""
     options are deprecated. Use {@link ConsoleAppender}
     instead.</b></font>
     <p>If the option is set to ""System.out"" or ""System.err"" the
     output will go to the corresponding stream. Otherwise, if the
     option is set to the name of a file, then the file will be opened
     and output will go there.
     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.
   */
  public void setFile(String file) {
    // Trim spaces from both ends. The users probably does not want 
    // trailing spaces in file names.
    String val = file.trim();
    if(val.equalsIgnoreCase(""System.out"")) {
      setWriter(new OutputStreamWriter(System.out));
    } else if(val.equalsIgnoreCase(""System.err"")) {
      setWriter(new OutputStreamWriter(System.err));
    } else {
      fileName = val;
    }
  }
  /** 
      Returns the value of the <b>Append</b> option. 
   */
  public
  boolean getAppend() {
    return fileAppend;
  }
  /** Returns the value of the <b>File</b> option. */
  public
  String getFile() {
    return fileName;
  }
  /**
     Returns the option names for this component, namely the string
     array {@link #FILE_OPTION}, {@link #APPEND_OPTION}} in addition
     to the options of its super class {@link WriterAppender}.  
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {FILE_OPTION, APPEND_OPTION});
  }
  /**
     <The <b>Append</b> option takes a boolean value. It is set to
     <code>true</code> by default. If true, then <code>File</code>
     will be opened in append mode by {@link #setFile setFile} (see
     above). Otherwise, {@link #setFile setFile} will open
     <code>File</code> in truncate mode.
     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.
   */
  public
  void setAppend(boolean flag) {
    fileAppend = flag;
  }
  /**
     If the value of {@link #FILE_OPTION} is not <code>null</code>, then {@link
     #setFile} is called with the values of {@link #FILE_OPTION} and
     {@link #APPEND_OPTION}.
     @since 0.8.1 */
  public
  void activateOptions() {    
    if(fileName != null) {
      try {
	setFile(fileName, fileAppend);
      }
      catch(java.io.IOException e) {
	errorHandler.error(""setFile(""+fileName+"",""+fileAppend+"") call failed."",
			   e, ErrorCode.FILE_OPEN_FAILURE);
      }
    } else {
      //LogLog.error(""File option not set for appender [""+name+""]."");
      LogLog.warn(""File option not set for appender [""+name+""]."");
      LogLog.warn(""Are you using FileAppender instead of ConsoleAppender?"");
    }
  }
 /**
     Closes the previously opened file.
  */
  protected
  void closeFile() {
    // FIXME (remove qwIsOurs)
    if(this.qw != null && this.qwIsOurs) {
      try {
	this.qw.close();
      }
      catch(java.io.IOException e) {
	// Exceptionally, it does not make sense to delegate to an
	// ErrorHandler. Since a closed appender is basically dead.
	LogLog.error(""Could not close "" + qw, e);
      }
    }
  }
  /**
    <p>Sets and <i>opens</i> the file where the log output will
    go. The specified file must be writable. 
    <p>If there was already an opened file, then the previous file
    is closed first. 
    @param fileName The path to the log file.
    @param append   If true will append to fileName. Otherwise will
        truncate fileName.  */
  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    reset();
    this.setQWForFiles(new FileWriter(fileName, append));
    //this.tp = new TracerPrintWriter(qw);
    this.fileName = fileName;
    this.fileAppend = append;
    this.qwIsOurs = true;
    writeHeader();
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method.  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    if(key.equalsIgnoreCase(FILE_OPTION)) {
      // Trim spaces from both ends. The users probably does not want 
      // trailing spaces in file names.
      String val = value.trim();
      if(val.equalsIgnoreCase(""System.out"")) {
	setWriter(new OutputStreamWriter(System.out));
      } else if(val.equalsIgnoreCase(""System.err"")) {
	setWriter(new OutputStreamWriter(System.err));
      } else {
	fileName = val;
      }
    }
    else if (key.equalsIgnoreCase(APPEND_OPTION)) {
      fileAppend = OptionConverter.toBoolean(value, fileAppend);
    }
  }
  /**
     Sets the quiet writer being used.
     This method is overriden by {@link RollingFileAppender}.
   */
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new QuietWriter(writer, errorHandler);
  }
  /**
     Close any previously opened file and call the parent's
     <code>reset</code>.  */
  protected
  void reset() {
    closeFile();
    this.fileName = null;
    if(qwIsOurs) {
      super.reset();    
    } else {
      this.qw = null;
      //this.tp = null;    
    }
  }  
}
"
org.apache.log4j.Hierarchy,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// WARNING This class MUST not have references to the Category or
// WARNING RootCategory classes in its static initiliazation neither 
// WARNING directly nor indirectly.
// Contributors:
//                Luke Blanshard <luke@quiq.com>
//                Mario Schomburg - IBM Global Services/Germany
//                Anders Kristensen
//                Igor Poteryaev
package org.apache.log4j;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
/**
   This class is specialized in retreiving categories by name and
   also maintaining the category hierarchy.
   <p><em>The casual user should not have to deal with this class
   firectly.</em> In fact, up until version 0.9.0, this class had
   default package access. However, if you are in an environment where
   multiple applications run in the same VM, then read on.
   <p>The structure of the category hierachy is maintained by the
   {@link #getInstance} method. The hierrachy is such that children
   link to their parent but parents do not have any pointers to their
   children. Moreover, categories can be instantiated in any order, in
   particular decendant before ancestor.
   <p>In case a decendant is created before a particular ancestor,
   then it creates a provision node for the ancestor and adds itself
   to the provision node. Other decendants of the same ancestor add
   themselves to the previously created provision node.
   <p>See the code below for further details.
   @author Ceki G&uuml;lc&uuml; 
*/
public class Hierarchy {
  // DISABLE_OFF should be set to a value lower than all possible
  // priorities.
  static final int DISABLE_OFF = -1;
  static final int DISABLE_OVERRIDE = -2;  
  static 
  private
  CategoryFactory defaultFactory = new DefaultCategoryFactory();
  Hashtable ht;
  Category root;
  RendererMap rendererMap;
  int disable;
  boolean emittedNoAppenderWarning = false;
  boolean emittedNoResourceBundleWarning = false;  
  /**
     Create a new Category hierarchy.
     @param root The root of the new hierarchy.
   */
  public
  Hierarchy(Category root) {
    ht = new Hashtable();
    this.root = root;
    // Don't disable any priority level by default.
    disable = DISABLE_OFF;
    this.root.setHierarchy(this);
    rendererMap = new RendererMap();
  }
  /**
     Add an object renderer for a specific class.       
   */
  public
  void addRenderer(Class classToRender, ObjectRenderer or) {
    rendererMap.put(classToRender, or);
  }
  /**
     This call will clear all category definitions from the internal
     hashtable. Invoking this method will irrevocably mess up the
     category hiearchy.
     <p>You should <em>really</em> know what you are doing before
     invoking this method.
     @since 0.9.0 */
  public
  void clear() {
    //System.out.println(""\n\nAbout to clear internal hash table."");
    ht.clear();
  }
  /**
     Check if the named category exists in the hirarchy. If so return
     its reference, otherwise returns <code>null</code>.
     @param name The name of the category to search for.
  */
  public
  Category exists(String name) {    
    Object o = ht.get(new CategoryKey(name));
    if(o instanceof Category) {
      return (Category) o;
    } else {
      return null;
    }
  }
  /**
     Similar to {@link #disable(Priority)} except that the priority
     argument is given as a String.  */
  public
  void disable(String priorityStr) {
    if(disable != DISABLE_OVERRIDE) {  
      Priority p = Priority.toPriority(priorityStr, null);
      if(p != null) {
	disable = p.level;
      } else {
	LogLog.warn(""Could not convert [""+priorityStr+""] to Priority."");
      }
    }
  }
  /**
     Disable all logging requests of priority <em>equal to or
     below</em> the priority parameter <code>p</code>, for
     <em>all</em> categories in this hierarchy. Logging requests of
     higher priority then <code>p</code> remain unaffected.
     <p>Nevertheless, if the {@link
     BasicConfigurator#DISABLE_OVERRIDE_KEY} system property is set to
     ""true"" or any value other than ""false"", then logging requests are
     evaluated as usual, i.e. according to the <a
     href=""../../../../manual.html#selectionRule"">Basic Selection Rule</a>.
     <p>The ""disable"" family of methods are there for speed. They
     allow printing methods such as debug, info, etc. to return
     immediately after an interger comparison without walking the
     category hierarchy. In most modern computers an integer
     comparison is measured in nanoseconds where as a category walk is
     measured in units of microseconds.
     <p>Other configurators define alternate ways of overriding the
     disable override flag. See {@link PropertyConfigurator} and
     {@link org.apache.log4j.xml.DOMConfigurator}.
     @since 0.8.5 */
  public
  void disable(Priority p) {
    if((disable != DISABLE_OVERRIDE) && (p != null)) {
      disable = p.level;
    }
  }
  /**
     Disable all logging requests regardless of category and priority.
     This method is equivalent to calling {@link #disable} with the
     argument {@link Priority#FATAL}, the highest possible priority.
     @since 0.8.5 */
  public
  void disableAll() {
    disable(Priority.FATAL);
  }
  /**
     Disable all logging requests of priority DEBUG regardless of
     category.  Invoking this method is equivalent to calling {@link
     #disable} with the argument {@link Priority#DEBUG}.
     @since 0.8.5 */
  public
  void disableDebug() {
    disable(Priority.DEBUG);
  }
  /**
     Disable all logging requests of priority INFO and below
     regardless of category. Note that DEBUG messages are also
     disabled.  
     <p>Invoking this method is equivalent to calling {@link #disable}
     with the argument {@link Priority#INFO}.
     @since 0.8.5 */
  public
  void disableInfo() {
    disable(Priority.INFO);
  }  
  /**
     Undoes the effect of calling any of {@link #disable}, {@link
     #disableAll}, {@link #disableDebug} and {@link #disableInfo}
     methods. More precisely, invoking this method sets the Category
     class internal variable called <code>disable</code> to its
     default ""off"" value.
     @since 0.8.5 */
  public
  void enableAll() {
    disable = DISABLE_OFF;
  }
  /**
     Override the shipped code flag if the <code>override</code>
     parameter is not null.
     <p>If <code>override</code> is null then there is nothing to do.
     Otherwise, set Category.shippedCode to false if override has a
     value other than ""false"".     
  */
  public
  void overrideAsNeeded(String override) {
    // If override is defined, any value other than false will be
    // interpreted as true.    
    if(override != null) {
      LogLog.debug(""Handling non-null disable override directive: \""""+
		   override +""\""."");
      if(OptionConverter.toBoolean(override, true)) {
	LogLog.debug(""Overriding all disable methods."");
	disable = DISABLE_OVERRIDE;
      }
    }
  }
  /**
     Return a new category instance named as the first parameter using
     the default factory. 
     <p>If a category of that name already exists, then it will be
     returned.  Otherwise, a new category will be instantiated and
     lthen inked with its existing ancestors as well as children.
     @param name The name of the category to retreive.
 */
  public
  Category getInstance(String name) {
    return getInstance(name, defaultFactory);
  }
 /**
     Return a new category instance named as the first parameter using
     <code>factory</code>.
     <p>If a category of that name already exists, then it will be
     returned.  Otherwise, a new category will be instantiated by the
     <code>factory</code> parameter and linked with its existing
     ancestors as well as children.
     @param name The name of the category to retreive.
     @param factory The factory that will make the new category instance.
 */
  public
  Category getInstance(String name, CategoryFactory factory) {
    //System.out.println(""getInstance(""+name+"") called."");
    CategoryKey key = new CategoryKey(name);    
    // Synchronize to prevent write conflicts. Read conflicts (in
    // getChainedPriority method) are possible only if variable
    // assignments are non-atomic.
    Category category;
    synchronized(ht) {
      Object o = ht.get(key);
      if(o == null) {
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this);
	ht.put(key, category);      
	updateParents(category);
	return category;
      } else if(o instanceof Category) {
	return (Category) o;
      } else if (o instanceof ProvisionNode) {
	//System.out.println(""(""+name+"") ht.get(this) returned ProvisionNode"");
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this); 
	ht.put(key, category);
	updateChildren((ProvisionNode) o, category);
	updateParents(category);	
	return category;
      }
      else {
	// It should be impossible to arrive here
	return null;  // but let's keep the compiler happy.
      }
    }
  }
  /**
     Returns all the currently defined categories in this hierarchy as
     an {@link java.util.Enumeration Enumeration}.
     <p>The root category is <em>not</em> included in the returned
     {@link Enumeration}.  */
  public
  Enumeration getCurrentCategories() {
    // The accumlation in v is necessary because not all elements in
    // ht are Category objects as there might be some ProvisionNodes
    // as well.
    Vector v = new Vector(ht.size());
    Enumeration elems = ht.elements();
    while(elems.hasMoreElements()) {
      Object o = elems.nextElement();
      if(o instanceof Category) {
	v.addElement(o);
      }
    }
    return v.elements();
  }
  public
  boolean isDisabled(int level) {
    return disable >=  level;
  }
  /**
     Get the renderer map for this hierarchy.
  */
  public
  RendererMap getRendererMap() {
    return rendererMap;
  }
  /**
     Get the root of this hierarchy.
     @since 0.9.0
   */
  public
  Category getRoot() {
    return root;
  }
  /**
     Reset all values contained in this hierarchy instance to their
     default.  This removes all appenders from all categories, sets
     the priority of all non-root categories to <code>null</code>,
     sets their additivity flag to <code>true</code> and sets the priority
     of the root category to {@link Priority#DEBUG DEBUG}.  Moreover,
     message disabling is set its default ""off"" value.
     <p>Existing categories are not removed. They are just reset.
     <p>This method should be used sparingly and with care as it will
     block all logging until it is completed.</p>
     @since version 0.8.5 */
  public
  void resetConfiguration() {
    getRoot().setPriority(Priority.DEBUG);
    root.setResourceBundle(null);
    disable = Hierarchy.DISABLE_OFF;
    // the synchronization is needed to prevent JDK 1.2.x hashtable
    // surprises
    synchronized(ht) {    
      shutdown(); // nested locks are OK    
      Enumeration cats = getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.setPriority(null);
	c.setAdditivity(true);
	c.setResourceBundle(null);
      }
    }
    rendererMap.clear();
  }
  /**
     Set the disable override value given a string.
     @since 1.1
   */
  public
  void setDisableOverride(String override) {
    if(OptionConverter.toBoolean(override, true)) {
      LogLog.debug(""Overriding disable."");
      disable =  DISABLE_OVERRIDE;
    }
  }
  /**
     Shutting down a hierarchy will <em>safely</em> close and remove
     all appenders in all categories including the root category.
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.
     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a category
     and again to a nested appender.
     @since 1.0 */
  public 
  void shutdown() {
    Category root = getRoot();    
    // begin by closing nested appenders
    root.closeNestedAppenders();
    synchronized(ht) {
      Enumeration cats = this.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.closeNestedAppenders();
      }
      // then, remove all appenders
      root.removeAllAppenders();
      cats = this.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.removeAllAppenders();
      }      
    }
  }
  /**
     This method loops through all the *potential* parents of
     'cat'. There 3 possible cases:
     1) No entry for the potential parent of 'cat' exists
        We create a ProvisionNode for this potential parent and insert
        'cat' in that provision node.
     2) There entry is of type Category for the potential parent.
        The entry is 'cat's nearest existing parent. We update cat's
        parent field with this entry. We also break from the loop
        because updating our parent's parent is our parent's
        responsibility.
     3) There entry is of type ProvisionNode for this potential parent.
        We add 'cat' to the list of children for this potential parent.
   */
  final
  private
  void updateParents(Category cat) {
    String name = cat.name;
    int length = name.length();
    boolean parentFound = false;
    //System.out.println(""UpdateParents called for "" + name);
    // if name = ""w.x.y.z"", loop thourgh ""w.x.y"", ""w.x"" and ""w"", but not ""w.x.y.z"" 
    for(int i = name.lastIndexOf('.', length-1); i >= 0; 
	                                 i = name.lastIndexOf('.', i-1))  {
      String substr = name.substring(0, i);
      //System.out.println(""Updating parent : "" + substr);
      CategoryKey key = new CategoryKey(substr); // simple constructor
      Object o = ht.get(key);
      // Create a provision node for a future parent.
      if(o == null) {
	//System.out.println(""No parent ""+substr+"" found. Creating ProvisionNode."");
	ProvisionNode pn = new ProvisionNode(cat);
	ht.put(key, pn);
      } else if(o instanceof Category) {
	parentFound = true;
	cat.parent = (Category) o;
	//System.out.println(""Linking "" + cat.name + "" -> "" + ((Category) o).name);
	break; // no need to update the ancestors of the closest ancestor
      } else if(o instanceof ProvisionNode) {
	((ProvisionNode) o).addElement(cat);
      } else {
	Exception e = new IllegalStateException(""unexpected object type "" + 
					o.getClass() + "" in ht."");
	e.printStackTrace();			   
      }
    }
    // If we could not find any existing parents, then link with root.
    if(!parentFound) 
      cat.parent = root;
  }
  /** 
      We update the links for all the children that placed themselves
      in the provision node 'pn'. The second argument 'cat' is a
      reference for the newly created Category, parent of all the
      children in 'pn'
      We loop on all the children 'c' in 'pn':
         If the child 'c' has been already linked to a child of
         'cat' then there is no need to update 'c'.
	 Otherwise, we set cat's parent field to c's parent and set
	 c's parent field to cat.
  */
  final
  private
  void updateChildren(ProvisionNode pn, Category cat) {
    //System.out.println(""updateChildren called for "" + cat.name);
    final int last = pn.size();
    for(int i = 0; i < last; i++) {
      Category c = (Category) pn.elementAt(i);
      //System.out.println(""Updating child "" +p.name);
      // Unless this child already points to a correct (lower) parent,
      // make cat.parent point to c.parent and c.parent to cat.
      if(!c.parent.name.startsWith(cat.name)) {
	cat.parent = c.parent;
	c.parent = cat;      
      }
    }
  }    
}
"
org.apache.log4j.HTMLLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.OptionConverter;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.Writer;
/**
   This layout outputs events in a HTML table.
   @author Ceki G&uuml;lc&uuml;   
 */
public class HTMLLayout extends Layout {
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  static String TRACE_PREFIX = ""<br>&nbsp;&nbsp;&nbsp;&nbsp;"";
  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  /**
     A string constant used in naming the option for setting the the
     HTML document title.  Current value of this string
     constant is <b>Title</b>.  
  */
  public static final String TITLE_OPTION = ""Title"";
  // Print no location info by default
  boolean locationInfo = false;
  String title = ""Log4J Log Messages"";
  /**
     Returns a String consisting of one element {@link
     #LOCATION_INFO_OPTION}. 
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
 */
  public
  String[] getOptionStrings() {
    return new String[] {LOCATION_INFO_OPTION, TITLE_OPTION};
  }
  /**
     Set HTMLLayout specific options.
     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 
     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    if (key.equalsIgnoreCase(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    }
    else if (key.equalsIgnoreCase(TITLE_OPTION)) {
      title = value;
    }
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 
     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  /**
     Returns the current value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
    The <b>Title</b> option takes a String value. This option sets the
    document title of the generated HTML document.
    <p>Defaults to 'Log4J Log Messages'.
  */
  public
  void setTitle(String title) {
    this.title = title;
  }
  /**
     Returns the current value of the <b>Title</b> option.
  */
  public
  String getTitle() {
    return title;
  }
 /**
     Returns the content type output by this layout, i.e ""text/html"".
  */
  public
  String getContentType() {
    return ""text/html"";
  }
  /**
     No options to activate.
  */
  public
  void activateOptions() {
  }
  public 
  String format(LoggingEvent event) {
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    sbuf.append(Layout.LINE_SEP + ""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<td>"");
    sbuf.append(event.timeStamp - event.getStartTime());
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""<td title=\"""" + event.getThreadName() + "" thread\"">"");
    sbuf.append(escapeHTMLTags(event.getThreadName()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""<td title=\""Priority\"">"");
    if (event.priority.equals(Priority.DEBUG)) {
      sbuf.append(""<font color=\""#339933\"">"");
      sbuf.append(event.priority);      
      sbuf.append(""</font>"");
    }
    else if(event.priority.isGreaterOrEqual(Priority.WARN)) {
      sbuf.append(""<font color=\""#993300\""><strong>"");
      sbuf.append(event.priority);      
      sbuf.append(""</strong></font>"");
    } else {
      sbuf.append(event.priority);      
    }
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""<td title=\"""" + event.categoryName + "" category\"">"");
    sbuf.append(escapeHTMLTags(event.categoryName));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    if(locationInfo) {
      LocationInfo locInfo = event.getLocationInformation();
      sbuf.append(""<td>"");
      sbuf.append(escapeHTMLTags(locInfo.getFileName()));
      sbuf.append(':');
      sbuf.append(locInfo.getLineNumber());
      sbuf.append(""</td>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<td title=\""Message\"">"");
    sbuf.append(escapeHTMLTags(event.getRenderedMessage()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    if (event.getNDC() != null) {
      sbuf.append(""<tr><td bgcolor=\""#EEEEEE\"" style=\""font-size : xx-small;\"" colspan=\""6\"" title=\""Nested Diagnostic Context\"">"");
      sbuf.append(""NDC: "" + escapeHTMLTags(event.getNDC()));
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }
    String[] s = event.getThrowableStrRep(); 
    if(s != null) {
      sbuf.append(""<tr><td bgcolor=\""#993300\"" style=\""color:White; font-size : xx-small;\"" colspan=\""6\"">"");
      appendThrowableAsHTML(s, sbuf);
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }
    return sbuf.toString();
  }
  void appendThrowableAsHTML(String[] s, StringBuffer sbuf) {
    if(s != null) {
      int len = s.length;
      if(len == 0) 
	return;
      sbuf.append(escapeHTMLTags(s[0]));
      sbuf.append(Layout.LINE_SEP);
      for(int i = 1; i < len; i++) {
	sbuf.append(TRACE_PREFIX);
	sbuf.append(escapeHTMLTags(s[i]));
	sbuf.append(Layout.LINE_SEP);
      }
    }
  }
  /**
     Returns appropriate HTML headers.
  */
  public
  String getHeader() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" \""http://www.w3.org/TR/html4/loose.dtd\"">""  + Layout.LINE_SEP);
    sbuf.append(""<html>"" + Layout.LINE_SEP);
    sbuf.append(""<head>"" + Layout.LINE_SEP);
    sbuf.append(""<title>"" + title + ""</title>"" + Layout.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">""  + Layout.LINE_SEP);
    sbuf.append(""<!--""  + Layout.LINE_SEP);
    sbuf.append(""body, table {font-family: arial,sans-serif; font-size: x-small;}"" + Layout.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"" + Layout.LINE_SEP);
    sbuf.append(""-->"" + Layout.LINE_SEP);
    sbuf.append(""</style>"" + Layout.LINE_SEP);
    sbuf.append(""</head>"" + Layout.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"" + Layout.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"" + Layout.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"" + Layout.LINE_SEP);
    sbuf.append(""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Time</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Thread</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Priority</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Category</th>"" + Layout.LINE_SEP);
    if(locationInfo) {
      sbuf.append(""<th>File:Line</th>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    return sbuf.toString();
  }
  /**
     Returns the appropriate HTML footers.
  */
  public
  String getFooter() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""</table>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""</body></html>"");
    return sbuf.toString();
  }
  /**
     The HTML layout handles the throwable contained in logging
     events. Hence, this method return <code>false</code>.  */
  public
  boolean ignoresThrowable() {
    return false;
  }
  /**
   * This method takes a string which may contain HTML tags (ie, <b>, <table>,
   * etc) and converts the '<' and '>' characters to their HTML escape
   * sequences.
   *
   * @param input The text to be converted.
   * @return The input string with the characters '<' and '>' replaced with
   *  &lt; and &gt; respectively.
   */
  private String escapeHTMLTags(String input) {
    //Check if the string is null or zero length -- if so, return
    //what was sent in.
    if( input == null || input.length() == 0 ) {
        return input;
    }
    //Use a StringBuffer in lieu of String concatenation -- it is
    //much more efficient this way.
    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';
    for(int i=0; i < input.length(); i++) {
        ch = input.charAt(i);
        if(ch == '<') {
            buf.append(""&lt;"");
        }
        else if(ch == '>') {
            buf.append(""&gt;"");
        }
        else {
            buf.append(ch);
        }
    }
    return buf.toString();
  }
}
"
org.apache.log4j.Layout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
/**
   Extend this abstract class to create your own log layout format.
   @author Ceki G&uuml;lc&uuml;
*/
public abstract class Layout implements OptionHandler {
  // Note that the line.separator property can be looked up even by
  // applets.
  public final static String LINE_SEP = System.getProperty(""line.separator"");
  public final static int LINE_SEP_LEN  = LINE_SEP.length();
  /**
     Implement this method to create your own layout format.
  */
  abstract
  public
  String format(LoggingEvent event);
  /**
     Returns the content type output by this layout. The base class
     returns ""text/plain"". 
  */
  public
  String getContentType() {
    return ""text/plain"";
  }
  /**
     Returns the header for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getHeader() {
    return null;
  }
  /**
     Returns the footer for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getFooter() {
    return null;
  }
  /**
     If the layout handles the throwable object contained within
     {@link LoggingEvent}, then the layout should return
     <code>false</code>. Otherwise, if the layout ignores throwable
     object, then the layout should return <code>true</code>.
     <p>The {@link SimpleLayout}, {@link TTCCLayout}, {@link
     PatternLayout} all return <code>true</code>. The {@link
     org.apache.log4j.xml.XMLLayout} returns <code>false</code>.
     @since 0.8.4 */
  abstract
  public
  boolean ignoresThrowable();
}
"
org.apache.log4j.NDC,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
//
//      See the LICENCE file for the terms of usage and distribution.
package org.apache.log4j;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.log4j.helpers.LogLog;
/**
   The NDC class implements <i>nested diagnostic contexts</i> as
   defined by Neil Harrison in the article ""Patterns for Logging
   Diagnostic Messages"" part of the book ""<i>Pattern Languages of
   Program Design 3</i>"" edited by Martin et al.
   <p>A Nested Diagnostic Context, or NDC in short, is an instrument
   to distinguish interleaved log output from different sources. Log
   output is typically interleaved when a server handles multiple
   clients near-simulatanously.
   <p>Interleaved log output can still be meaningful if each log entry
   from different contexts had a distinctive stamp. This is where NDCs
   come into play.
   <p><em><b>Note that NDCs are managed on a per thread
   basis</b></em>. NDC operations such as {@link #push push}, {@link
   #pop}, {@link #clear}, {@link #getDepth} and {@link #setMaxDepth}
   affect the NDC of the <em>current</em> thread only. NDCs of other
   threads remain unaffected.
   <p>For example, a servlet can build a per client request NDC
   consisting the clients host name and other information contained in
   the the request. <em>Cookies</em> are another source of distinctive
   information. To build an NDC one uses the {@link #push push}
   operation. Simply put,
   <p><ul>
     <li>Contexts can be nested.
     <p><li>When entering a context, call <code>NDC.push</code>. As a
     side effect, if there is no nested diagnostic context for the
     current thread, this method will create it.
     <p><li>When leaving a context, call <code>NDC.pop</code>.
   </ul>
   <p>There is no penalty for forgetting to match each
   <code>push</code> operation with a corresponding <code>pop</code>,
   except the obvious mismatch between the real application context
   and the context set in the NDC.
   <p>If configured to do so, {@link PatternLayout} and {@link
   TTCCLayout} instances automatically retrieve the nested diagnostic
   context for the current thread without any user intervention.
   Hence, even if a servlet is serving multiple clients
   simultaneously, the logs emanating from the same code (belonging to
   the same category) can still be distinguished because each client
   request will have a different NDC tag.
   <p>Heavy duty systems should call the {@link #remove} method when
   leaving the run method of a thread. This ensures that the memory
   used by the thread can be freed by the Java garbage collector. In
   version 0.8.5, we have added a meachanism to lazily remove
   references to dead threads. In practice, this means that you can be
   a little sloppy and sometimes forget to call {@link #remove} before
   exiting a thread.
   <p>A thread may inherit the nested diagnostic context of another
   (possibly parent) thread using the {@link #inherit inherit}
   method. A thread may obtain a copy of its NDC with the {@link
   #cloneStack cloneStack} method and pass the reference to any other
   thread, in particular to a child.
   @author Ceki G&uuml;lc&uuml;
   @since log4j v0.7.0
*/
public class NDC {
  // The synchronized keyword is not used in this class. This may seem
  // dangerous, especially since the class will be used by
  // multiple-threads. In particular, all threads share the same
  // hashtable (the ""ht"" variable). This is OK since java hashtables
  // are thread safe. Same goes for Stacks.
  // More importantly, when inheriting diagnostic contexts the child
  // thread is handed a clone of the parent's NDC.  It follows that
  // each thread has its own NDC (i.e. stack).
  static Hashtable ht = new Hashtable();
  static int pushCounter = 0; // the number of times push has been called
                              // after the latest call to lazyRemove
  // The number of times we allow push to be called before we call lazyRemove
  // 5 is a relatively small number. As such, lazyRemove is not called too
  // frequently. We thus avoid the cost of creating an Enumeration too often.
  // The higher this number, the longer is the avarage period for which all
  // logging calls in all threads are blocked.
  static final int REAP_THRESHOLD = 5;
  // No instances allowed.
  private NDC() {}
  /**
     Clear any nested diagnostic information if any. This method is
     useful in cases where the same thread can be potentially used
     over and over in different unrelated contexts.
     <p>This method is equivalent to calling the {@link #setMaxDepth}
     method with a zero <code>maxDepth</code> argument.
     @since 0.8.4c */
  public
  static
  void clear() {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null) 
      stack.setSize(0);    
  }
  /**
     Clone the diagnostic context for the current thread.
     <p>Internally a diagnostic context is represented as a stack.  A
     given thread can supply the stack (i.e. diagnostic context) to a
     child thread so that the child can inherit the parent thread's
     diagnostic context.
     <p>The child thread uses the {@link #inherit inherit} method to
     inherit the parent's diagnostic context.
     @return Stack A clone of the current thread's  diagnostic context.
  */
  public
  static
  Stack cloneStack() {
    Object o = ht.get(Thread.currentThread());
    if(o == null)
      return null;
    else {
      Stack stack = (Stack) o;
      return (Stack) stack.clone();
    }
  }
  /**
     Inherit the diagnostic context of another thread.
     <p>The parent thread can obtain a reference to its diagnostic
     context using the {@link #cloneStack} method.  It should
     communicate this information to its child so that it may inherit
     the parent's diagnostic context.
     <p>The parent's diagnostic context is cloned before being
     inherited. In other words, once inherited, the two diagnostic
     contexts can be managed independently.
     <p>In java, a child thread cannot obtain a reference to its
     parent, unless it is directly handed the reference. Consequently,
     there is no client-transparent way of inheriting diagnostic
     contexts. Do you know any solution to this problem?
     @param stack The diagnostic context of the parent thread.
  */
  public
  static
  void inherit(Stack stack) {
    if(stack != null)
      ht.put(Thread.currentThread(), stack);
  }
  /**
     Used when printing the diagnostic context.
  */
  static
  public
  String get() {
    Stack s = (Stack) ht.get(Thread.currentThread());
    if(s != null && !s.isEmpty()) 
      return ((DiagnosticContext) s.peek()).fullMessage;
    else
      return null;
  }
  /**
     Get the current nesting depth of this diagnostic context.
     @see #setMaxDepth
     @since 0.7.5
   */
  public
  static
  int getDepth() {
    Stack stack = (Stack) ht.get(Thread.currentThread());          
    if(stack == null)
      return 0;
    else
      return stack.size();      
  }
  private
  static
  void lazyRemove() {
    // The synchronization on ht is necessary to prevent JDK 1.2.x from
    // throwing ConcurrentModificationExceptions at us. This sucks BIG-TIME.
    // One solution is to write our own hashtable implementation.
    Vector v;
    synchronized(ht) {
      // Avoid calling clean-up too often.
      if(++pushCounter >= REAP_THRESHOLD) {
	return; // We release the lock ASAP.
      } else {
	pushCounter = 0; // OK let's do some work.
      }
      int misses = 0;
      v = new Vector(); 
      Enumeration enum = ht.keys();
      // We give up after 4 straigt missses. That is 4 consecutive
      // inspected threads in 'ht' that turn out to be alive.
      // The higher the proportion on dead threads in ht, the higher the
      // chances of removal.
      while(enum.hasMoreElements() && (misses <= 4)) {
	Thread t = (Thread) enum.nextElement();
	if(t.isAlive()) {
	  misses++;
	} else {
	  misses = 0;
	  v.addElement(t);
	}
      }
    } // synchronized
    int size = v.size();
    for(int i = 0; i < size; i++) {
      Thread t = (Thread) v.elementAt(i);
      LogLog.debug(""Lazy NDC removal for thread ["" + t.getName() + ""] (""+ 
		   ht.size() + "")."");
      ht.remove(t);
    }
  }
  /**
     Clients should call this method before leaving a diagnostic
     context.
     <p>The returned value is the value that was pushed last. If no
     context is available, then the empty string """" is returned.
     @return String The innermost diagnostic context.
     */
  public
  static
  String pop() {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack != null && !stack.isEmpty()) 
      return ((DiagnosticContext) stack.pop()).message;
    else
      return """";
  }
  /**
     Push new diagnostic context information for the current thread.
     <p>The contents of the <code>message</code> parameter is
     determined solely by the client.  
     @param message The new diagnostic context information.  */
  public
  static
  void push(String message) {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack == null) {
      DiagnosticContext dc = new DiagnosticContext(message, null);      
      stack = new Stack();
      ht.put(key, stack);
      stack.push(dc);
    } else if (stack.isEmpty()) {
      DiagnosticContext dc = new DiagnosticContext(message, null);            
      stack.push(dc);
    } else {
      DiagnosticContext parent = (DiagnosticContext) stack.peek();
      stack.push(new DiagnosticContext(message, parent));
    }    
  }
  /**
     Remove the diagnostic context for this thread.
     <p>Each thread that created a diagnostic context by calling
     {@link #pop} should call this method before exiting. Otherwise,
     the memory used by the diagnostic context for the <b>thread</b>
     cannot be reclaimed by the VM.
     <p>As this is such an important problem in heavy duty systems and
     because it is difficult to always guarantee that the remove
     method is called before exiting a thread, this method has been
     augmented to lazily remove references to dead threads. In
     practice, this means that you can be a little sloppy and
     occasionally forget to call {@link #remove} before exiting a
     thread.
  */
  static
  public
  void remove() {
    ht.remove(Thread.currentThread());
    // Lazily remove dead-thread references in ht.
    lazyRemove();    
  }
  /**
     Set maximum depth of this diagnostic context. If the current
     depth is smaller or equal to <code>maxDepth</code>, then no
     action is taken.
     <p>This method is a convenient alternative to multiple {@link
     #pop} calls. Moreover, it is often the case that at the end of
     complex call sequences, the depth of the NDC is
     unpredictable. The <code>setMaxDepth</code> method circumvents
     this problem.
     <p>For example, the combination
     <pre>
       void foo() {
       &nbsp;  int depth = NDC.getDepth();
       &nbsp;  ... complex sequence of calls
       &nbsp;  NDC.setMaxDepth(depth);
       }
     </pre>
     ensures that between the entry and exit of foo the depth of the
     diagnostic stack is conserved.
     @see #getDepth
     @since 0.7.5 */
  static
  public
  void setMaxDepth(int maxDepth) {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null && maxDepth < stack.size()) 
      stack.setSize(maxDepth);
  }
  // =====================================================================
   private static class DiagnosticContext {
    String fullMessage;
    String message;
    DiagnosticContext(String message, DiagnosticContext parent) {
      this.message = message;
      if(parent != null) {
	fullMessage = parent.fullMessage + ' ' + message;
      } else {
	fullMessage = message;
      }
    }
  }
}
"
org.apache.log4j.PatternLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */
package org.apache.log4j;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.NDC;
import org.apache.log4j.helpers.PatternParser;
import org.apache.log4j.helpers.PatternConverter;
import org.apache.log4j.helpers.OptionConverter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.Vector;
import java.text.FieldPosition;
// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Anders Kristensen <akristensen@dynamicsoft.com>
/**
   A flexible layout configurable with pattern string.
   <p>The goal of this class is to {@link #format format} a {@link
   LoggingEvent} and return the results as a String. The results
   depend on the <em>conversion pattern</em>.
   <p>The conversion pattern is closely related to the conversion
   pattern of the printf function in C. A conversion pattern is
   composed of literal text and format control expressions called
   <em>conversion specifiers</em>.
   <p><i>You are free to insert any literal text within the conversion
   pattern.</i>
   <p>Each conversion specifier starts with a percent sign (%) and is
   followed by optional <em>format modifiers</em> and a <em>conversion
   character</em>. The conversion character specifies the type of
   data, e.g. category, priority, date, thread name. The format
   modifiers control such things as field width, padding, left and
   right justification. The following is a simple example.
   <p>Let the conversion pattern be <b>""%-5p [%t]: %m%n""</b> and assume
   that the log4j environment was set to use a PatternLayout. Then the
   statements
   <pre>
   Category root = Category.getRoot();
   root.debug(""Message 1"");
   root.warn(""Message 2"");   
   </pre>
   would yield the output
   <pre>
   DEBUG [main]: Message 1
   WARN  [main]: Message 2  
   </pre>
   <p>Note that there is no explicit separator between text and
   conversion specifiers. The pattern parser knows when it has reached
   the end of a conversion specifier when it reads a conversion
   character. In the example above the conversion specifier
   <b>%-5p</b> means the priority of the logging event should be left
   justfied to a with of five characters. 
   The recognized conversion characters are
   <p>
   <table border=1 CELLPADDING=8>
   <th>Conversion Character</th>
   <th>Effect</th>
   <tr>
     <td align=center><b>c</b></td>
     <td>Used to output the category of the logging event. The
     category conversion specifier can be optionally followed by
     <em>precision specifier</em>, that is a decimal constant in
     brackets.
     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the category name will be
     printed. By default the category name is printed in full.
     <p>For example, for the category name ""a.b.c"" the pattern
     <b>%c{2}</b> will output ""b.c"".
     </td>
   </tr>
   <tr>
     <td align=center><b>C</b></td>
     <td>Used to output the fully qualified class name of the caller
     issuing the logging request. This conversion specifier
     can be optionally followed by <em>precision specifier</em>, that
     is a decimal constant in brackets.
     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the class name will be
     printed. By default the class name is output in fullly qualified form.
     <p>For example, for the class name ""org.apache.xyz.SomeClass"", the
     pattern <b>%C{1}</b> will output ""SomeClass"".
     <p><b>WARNING</b> Generating the caller class information is
     slow. Thus, it's use should be avoided unless execution speed is
     not an issue.
     </td>
     </tr>
   <tr> <td align=center><b>d</b></td> <td>Used to output the date of
	 the logging event. The date conversion specifier may be
	 followed by a <em>date format specifier</em> enclosed between
	 braces. For example, <b>%d{HH:mm:ss,SSS}</b> or
	 <b>%d{dd&nbsp;MMM&nbsp;yyyy&nbsp;HH:mm:ss,SSS}</b>.  If no
	 date format specifier is given then ISO8601 format is
	 assumed.
	 <p>The date format specifier admits the same syntax as the
	 time pattern string of the {@link
	 java.text.SimpleDateFormat}. Altough part of the standard
	 JDK, the performance of <code>SimpleDateFormat</code> is
	 quite poor.
	 <p>For better results it is recommended to use the log4j date
	 formatters. These can be specified using one of the strings
	 ""ABSOLUTE"", ""DATE"" and ""ISO8601"" for specifying {@link
	 org.apache.log4j.helpers.AbsoluteTimeDateFormat
	 AbsoluteTimeDateFormat}, {@link
	 org.apache.log4j.helpers.DateTimeDateFormat DateTimeDateFormat}
	 and respectively {@link
	 org.apache.log4j.helpers.ISO8601DateFormat
	 ISO8601DateFormat}. For example, <b>%d{ISO8601}</b> or
	 <b>%d{ABSOLUTE}</b>.
	 <p>These dedicated date formatters perform significantly
	 better than {@link java.text.SimpleDateFormat}.
     </td>
   </tr>
   <tr>
   <td align=center><b>F</b></td>
   <td>Used to output the file name where the logging request was
   issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
   <td align=center><b>l</b></td>
     <td>Used to output location information of the caller which generated
     the logging event. 
     <p>The location information depends on the JVM implementation but
     usually consists of the fully qualified name of the calling
     method followed by the callers source the file name and line
     number between parentheses.
     <p>The location information can be very useful. However, it's
     generation is <em>extremely</em> slow. It's use should be avoided
     unless execution speed is not an issue.
     </td>
   </tr>
   <tr>
   <td align=center><b>L</b></td>
   <td>Used to output the line number from where the logging request
   was issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
     <td align=center><b>m</b></td>
     <td>Used to output the application supplied message associated with 
     the logging event.</td>   
   </tr>
   <tr>
   <td align=center><b>M</b></td>
   <td>Used to output the method name where the logging request was
   issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
     <td align=center><b>n</b></td>
     <td>Outputs the platform dependent line separator character or
     characters. 
     <p>This conversion character offers practically the same
     performance as using non-portable line separator strings such as
     ""\n"", or ""\r\n"". Thus, it is the preferred way of specifying a
     line separator.
   </tr>
   <tr>
     <td align=center><b>p</b></td>
     <td>Used to output the priority of the logging event.</td>
   </tr>
   <tr>
     <td align=center><b>r</b></td>
     <td>Used to output the number of milliseconds elapsed since the start
     of the application until the creation of the logging event.</td>
   </tr>  
   <tr>
     <td align=center><b>t</b></td>
     <td>Used to output the name of the thread that generated the
     logging event.</td>
   </tr>
   <tr>
     <td align=center><b>x</b></td>
     <td>Used to output the NDC (nested diagnostic context) associated
     with the thread that generated the logging event.
     </td>     
   </tr>
   <tr>
     <td align=center><b>%</b></td>
     <td>The sequence %% outputs a single percent sign.
     </td>     
   </tr>
   </table>
   <p>By default the relevant infromation is output as is. However,
   with the aid of format modifiers it is possible to change the
   minimum field width, the maximum field width and justification.
   <p>The optional format modifier is placed between the percent sign
   and the conversion character.
   <p>The first optional format modifier is the <em>left justification
   flag</em> which is just the minus (-) character. Then comes the
   optional <em>minimum field width</em> modifier. This is a decimal
   constant that represents the minimum number of characters to
   output. If the data item requires fewer characters, it is padded on
   either the left or the right until the minimum width is
   reached. The default is to pad on the left (right justify) but you
   can specify right padding with the left justification flag. The
   padding character is space. If the data item is larger than the
   minimum field width, the field is expanded to accomodate the
   data. The value is never truncated.
   <p>This behavior can be changed using the <em>maximum field
   width</em> modifier which is designated by a period followed by a
   decimal constant. If the data item is longer than the maximum
   field, then the extra characters are removed from the
   <em>beginning</em> of the data item and not from the end. For
   example, it the maximum field width is eight and the data item is
   ten characters long, then the first two characters of the data item
   are dropped. This behaviour deviates from the printf function in C
   where truncation is done from the end.
   <p>Below are various format modifier examples for the category
   conversion specifier.
   <p>
   <TABLE BORDER=1 CELLPADDING=8>
   <th>Format modifier
   <th>left justify
   <th>minimim width
   <th>maximum width
   <th>comment
   <tr>
   <td align=center>%20c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>none</td>
   <td>Left pad with spaces if the category name is less than 20
   characters long.
   <tr> <td align=center>%-20c</td> <td align=center>true</td> <td
   align=center>20</td> <td align=center>none</td> <td>Right pad with
   spaces if the category name is less than 20 characters long.
   <tr>
   <td align=center>%.30c</td>
   <td align=center>NA</td>
   <td align=center>none</td>
   <td align=center>30</td>
   <td>Truncate from the beginning if the category name is longer than 30
   characters.
   <tr>
   <td align=center>%20.30c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>30</td>
   <td>Left pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.   
   <tr>
   <td align=center>%-20.30c</td>
   <td align=center>true</td>
   <td align=center>20</td>
   <td align=center>30</td>
   <td>Right pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.   
   </table>
   <p>Below are some examples of conversion patterns.
   <dl>
   <p><dt><b>%r [%t] %-5p %c %x - %m\n</b> 
   <p><dd>This is essentially the TTCC layout.
   <p><dt><b>%-6r [%15.15t] %-5p %30.30c %x - %m\n</b>
   <p><dd>Similar to the TTCC layout except that the rlative time is
   right padded if less than 6 digits, thread name is right padded if
   less than 15 characters and truncated if longer and the category
   name is left padded if shorter than 30 characters and truncated if
   longer.
  </dl>
   <p>The above text is largely inspired from Peter A. Darnell and
   Philip E. Margolis' higly recommended book ""C -- a Software
   Engineering Approach"", ISBN 0-387-97389-3.
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2 */
public class PatternLayout extends Layout {
   /**
     A string constant used in naming the option for setting the
     layout pattern. Current value of this string constant is
     <b>ConversionPattern</b>.
     <p>Note that the search for all option keys is case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String CONVERSION_PATTERN_OPTION = ""ConversionPattern"";
  /** Default pattern string for log output. Currently set to the
      string <b>""%m%n""</b> which just prints the application supplied
      message. */
  public final static String DEFAULT_CONVERSION_PATTERN =""%m%n"";
  /** A conversion pattern equivalent to the TTCCCLayout.
      Current value is <b>%r [%t] %p %c %x - %m%n</b>. */  
  public final static String TTCC_CONVERSION_PATTERN
                                             = ""%r [%t] %p %c %x - %m%n"";
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  private String pattern;
  private PatternConverter head;
  private String timezone;
  /**
     Constructs a PatternLayout using the DEFAULT_LAYOUT_PATTERN.
     The default pattern just produces the application supplied message.
  */
  public PatternLayout() {
    this(DEFAULT_CONVERSION_PATTERN);
  }
  /**
     Constructs a PatternLayout using the supplied conversion pattern.
  */
  public PatternLayout(String pattern) {
    this.pattern = pattern;
    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN : 
			     pattern).parse();
  }
  /**
     Returns the the array of option strings that {@link
     PatternLayout} recognizes. The only recognized option string is
     the value of {@link #CONVERSION_PATTERN_OPTION}.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return new String[] {CONVERSION_PATTERN_OPTION};
  }	
  /**
     The PatternLayout specific options are:
     <p>
     <dl>
     <dt><b>ConversionPattern</b>
     <p><dd>The value determines the conversion pattern used.
     </dl>
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
  public
  void setOption(String option, String value) {
    if(value == null)
      return;
    if(option.equalsIgnoreCase(CONVERSION_PATTERN_OPTION)) {
      pattern = value;
      head = createPatternParser(value).parse();
    }
    //else if(option.equals(TIMEZONE_OPTION)) {
    //try {
    //timezone = OptionConverter.substituteVars(value);
    //}
    //catch(IllegalArgumentException e) {
    //LogLog.error(""Could not substitute variables."" , e);
    //}
    //}
  }
  /**
     Set the <b>ConversionPattern</b> option. This is the string which
     controls formatting and consists of a mix of literal content and
     conversion specifiers.
   */
  public
  void setConversionPattern(String conversionPattern) {
    pattern = conversionPattern;
    head = createPatternParser(conversionPattern).parse();
  }
  /**
     Returns the value of the <b>ConversionPattern</b> option.
   */
  public
  String getConversionPattern() {
    return pattern;
  }
  /**
     Does not do anything as options become effective immediately. See
     {@link #setOption} method. */
  public
  void activateOptions() {
    // nothing to do.
  }
 /**
     The PatternLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
  /**
    Returns PatternParser used to parse the conversion string. Subclasses
    may override this to return a subclass of PatternParser which recognize
    custom conversion characters.
    @since 0.9.0
  */
  protected PatternParser createPatternParser(String pattern) {
    return new PatternParser(pattern);
  }
  /**
     Produces a formatted string as specified by the conversion pattern.
  */
  public String format(LoggingEvent event) {
    // Reset working stringbuffer
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    PatternConverter c = head;
    while(c != null) {
      c.format(sbuf, event);
      c = c.next;
    }
    return sbuf.toString();
  }
}
"
org.apache.log4j.Priority,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
// Contributors:  Kitching Simon <Simon.Kitching@orange.ch>
package org.apache.log4j;
/**
   Defines the minimum set of priorities recognized by the system,
   that is {@link #FATAL}, {@link #ERROR}, {@link #WARN}, {@link
   #INFO} and {@link #DEBUG}.
   <p>The <code>Priority</code> class may be subclassed to define a larger
   priority set.
   @author Ceki G&uuml;lc&uuml;
 */
public class Priority {
  int level;
  String levelStr;
  int syslogEquivalent;
  public final static int FATAL_INT = 50000;
  public final static int ERROR_INT = 40000;
  public final static int WARN_INT  = 30000;
  public final static int INFO_INT  = 20000;
  public final static int DEBUG_INT = 10000;
  /**
     The <code>FATAL</code> priority designates very severe error
     events that will presumably lead the application to abort.
   */
  final static public Priority FATAL = new Priority(FATAL_INT, ""FATAL"", 0);
  /**
     The <code>ERROR</code> priority designates error events that
     might still allow the application to continue running.  */
  final static public Priority ERROR = new Priority(ERROR_INT, ""ERROR"", 3);
  /**
     The <code>WARN</code> priority designates potentially harmful situations.
  */
  final static public Priority WARN  = new Priority(WARN_INT, ""WARN"",  4);
  /**
     The <code>INFO</code> priority designates informational messages
     that highlight the progress of the application at coarse-grained
     level.  */
  final static public Priority INFO  = new Priority(INFO_INT, ""INFO"",  6);
  /**
     The <code>DEBUG</code> priority designates fine-grained
     informational events that are most useful to debug an
     application.  */
  final static public Priority DEBUG = new Priority(DEBUG_INT, ""DEBUG"", 7);
  /**
     Instantiate a priority object.
   */
  protected
  Priority(int level, String levelStr, int syslogEquivalent) {
    this.level = level;
    this.levelStr = levelStr;
    this.syslogEquivalent = syslogEquivalent;
  }
  /**
     Return the syslog equivalent of this priority as an integer.
   */
  public
  final
  int getSyslogEquivalent() {
    return syslogEquivalent;
  }
  /**
     Returns the string representation of this priority.
   */
  final
  public
  String toString() {
    return levelStr;
  }
  /**
     Returns the integer representation of this priority.
   */
  public
  final
  int toInt() {
    return level;
  }
  /**
     Returns <code>true</code> if this priority has a higher or equal
     priority than the priority passed as argument, <code>false</code>
     otherwise.  
     <p>You should think twice before overriding the default
     implementation of <code>isGreaterOrEqual</code> method.
  */
  public
  boolean isGreaterOrEqual(Priority r) {
    return level >= r.level;
  }
  /**
     Return all possible priorities as an array of Priority objects in
     descending order.  */
  public
  static
  Priority[] getAllPossiblePriorities() {
    return new Priority[] {Priority.FATAL, Priority.ERROR, Priority.WARN, 
			     Priority.INFO, Priority.DEBUG};
  }
  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns {@link #DEBUG}. 
  */
  public
  static
  Priority toPriority(String sArg) {
    return toPriority(sArg, Priority.DEBUG);
  }
  /**
    Convert an integer passed as argument to a priority. If the
    conversion fails, then this method returns {@link #DEBUG}.
  */
  public
  static
  Priority toPriority(int val) {
    return toPriority(val, Priority.DEBUG);
  }
  /**
    Convert an integer passed as argument to a priority. If the
    conversion fails, then this method returns the specified default.
  */
  public
  static
  Priority toPriority(int val, Priority defaultPriority) {
    switch(val) {
    case DEBUG_INT: return DEBUG;
    case INFO_INT: return INFO;
    case WARN_INT: return WARN;
    case ERROR_INT: return ERROR;
    case FATAL_INT: return FATAL;
    default: return defaultPriority;
    }
  }
  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns the value of
     <code>defaultPriority</code>.  
  */
  public
  static
  Priority toPriority(String sArg, Priority defaultPriority) {                  
    if(sArg == null)
       return defaultPriority;
    String s = sArg.toUpperCase();
    if(s.equals(""DEBUG"")) return Priority.DEBUG; 
    if(s.equals(""INFO""))  return Priority.INFO;
    if(s.equals(""WARN""))  return Priority.WARN;  
    if(s.equals(""ERROR"")) return Priority.ERROR;
    if(s.equals(""FATAL"")) return Priority.FATAL;
    return defaultPriority;
  }
}
"
org.apache.log4j.PropertyConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//               Anders Kristensen <akristensen@dynamicsoft.com>
package org.apache.log4j;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.DefaultCategoryFactory;
import org.apache.log4j.config.PropertySetter;
//import org.apache.log4j.config.PropertySetterException;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.FileWatchdog;
import java.util.NoSuchElementException;
import java.util.Enumeration;
import java.util.Properties;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Hashtable;
/**
   Extends {@link BasicConfigurator} to provide configuration from an
   external file.  See <b>{@link #doConfigure(String, Hierarchy)}</b> for the
   expected format.
   <p>It is sometimes useful to see how log4j is reading configuration
   files. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable. 
   <P>As of log4j version 0.8.5, at the initialization of the Category
   class, the file <b>log4j.properties</b> will be searched from the
   search path used to load classes. If the file can be found, then it
   will be fed to the {@link
   PropertyConfigurator#configure(java.net.URL)} method.
   <p>The <code>PropertyConfigurator</code> does not handle the
   advanced configuration features supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator} such as support for
   sub-classing of the Priority class, {@link org.apache.log4j.spi.Filter
   Filters}, custom {@link org.apache.log4j.spi.ErrorHandler ErrorHandlers},
   nested appenders such as the {@link org.apache.log4j.AsyncAppender
   AsyncAppender}, etc.
   <p><em>All option values admit variable substitution.</em> For
   example, if <code>java.home</code> system property is set to
   <code>/home/xyz</code> and the File option is set to the string
   <code>${java.home}/test.log</code>, then File option will be
   interpreted as the string <code>/home/xyz/test.log</code>.
   <p>The value of the substituted variable can be defined as a system
   property or in the configuration file file itself.
   <p>The syntax of variable substituion is similar to that of UNIX
   shells. The string between an opening <b>&quot;${&quot;</b> and
   closing <b>&quot;}&quot;</b> is interpreted as a key. Its value is
   searched in the system properties, and if not founf then in the
   configuration file being parsed.  The corresponding value replaces
   the ${variableName} sequence.
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.1 */
public class PropertyConfigurator extends BasicConfigurator
           implements Configurator {
  /**
     Used internally to keep track of configured appenders.
   */
  protected Hashtable registry = new Hashtable(11);
  protected CategoryFactory categoryFactory = new DefaultCategoryFactory();
  static final String CATEGORY_PREFIX = ""log4j.category."";
  static final String ADDITIVITY_PREFIX = ""log4j.additivity."";
  static final String ROOT_CATEGORY_PREFIX = ""log4j.rootCategory"";
  static final String APPENDER_PREFIX = ""log4j.appender."";  
  static final String RENDERER_PREFIX = ""log4j.renderer."";
  static final String CATEGORY_FACTORY_KEY = ""log4j.categoryFactory"";
  static final private String INTERNAL_ROOT_NAME = ""root"";
  /**
    Read configuration from a file. The existing configuration is not
    cleared nor reset. If you require a different call, behaviour,
    then call {@link BasicConfigurator#resetConfiguration
    resetConfiguration} method before calling
    <code>doConfigure</code>.
    <p>The configuration file consists of staments in the format
    <code>key=value</code>.
    <h3>Appender configuration</h3>
    <p>Appender configuration syntax is:
    <pre>
    # For appender named <i>appenderName</i>, set its class.
    # Note: The appender name can contain dots.
    log4j.appender.appenderName=fully.qualified.name.of.appender.class
    # Set appender specific options.
    log4j.appender.appenderName.option1=value1  
    ...
    log4j.appender.appenderName.optionN=valueN
    </pre>
    For each named appender you can configure its {@link Layout}. The
    syntax for configuring an appender's layout is:
    <pre>
    log4j.appender.appenderName.layout=fully.qualified.name.of.layout.class
    log4j.appender.appenderName.layout.option1=value1
    ....
    log4j.appender.appenderName.layout.optionN=valueN
    </pre>
    <h3>Configuring categories</h3>
    <p>The syntax for configuring the root category is:
    <pre>
      log4j.rootCategory=[FATAL|ERROR|WARN|INFO|DEBUG], appenderName, appenderName, ...
    </pre>
    <p>This syntax means that one of the strings values ERROR, WARN,
    INFO or DEBUG can be supplied followed by appender names separated
    by commas.
    <p>If one of the optional priority values ERROR, WARN, INFO or
    DEBUG is given, the root priority is set to the corresponding
    priority.  If no priority value is specified, then the root
    priority remains untouched.
    <p>The root category can be assigned multiple appenders.
    <p>Each <i>appenderName</i> (seperated by commas) will be added to
    the root category. The named appender is defined using the
    appender syntax defined above.
    <p>For non-root categories the syntax is almost the same:
    <pre>
    log4j.category.category_name=[INHERITED|FATAL|ERROR|WARN|INFO|DEBUG], appenderName, appenderName, ...
    </pre>
    <p>Thus, one of the usual priority values FATAL, ERROR, WARN,
    INFO, or DEBUG can be optionally specified. For any any of these
    values the named category is assigned the corresponding
    priority. In addition however, the value INHERITED can be
    optionally specified which means that named category should
    inherit its priority from the category hierarchy.
    <p>If no priority value is supplied, then the priority of the
    named category remains untouched.
    <p>By default categories inherit their priority from the
    hierarchy. However, if you set the priority of a category and
    later decide that that category should inherit its priority, then
    you should specify INHERITED as the value for the priority value.
    <p>Similar to the root category syntax, each <i>appenderName</i>
    (seperated by commas) will be attached to the named category.
    <p>See the <a href=""../../../../manual.html#additivity"">appender
    additivity rule</a> in the user manual for the meaning of the
    <code>additivity</code> flag.
    <p>The user can override any of the {@link
    Hierarchy#disable} family of methods by setting the a key
    ""log4j.disableOverride"" to <code>true</code> or any value other
    than false. As in <pre> log4j.disableOverride=true </pre>
    <h3>ObjectRenderers</h3>
    You can customize the way message objects of a given type are
    converted to String before being logged. This is done by
    specifying an {@link org.apache.log4j.or.ObjectRenderer ObjectRenderer}
    for the object type would like to customize.
    <p>The syntax is:
    <pre>
    log4j.renderer.fully.qualified.name.of.rendered.class=fully.qualified.name.of.rendering.class
    </pre>
    As in,
    <pre>
    log4j.renderer.my.Fruit=my.FruitRenderer
    </pre>
    <h3>Class Factories</h3>
    In case you are using your own sub-types of the
    <code>Category</code> class and wish to use configuration files,
    then you <em>must</em> set the <code>categoryFactory</code> for
    the sub-type that you are using.
    <p>The syntax is:
    <pre>
    log4j.categoryFactory=fully.qualified.name.of.categoryFactory.class
    </pre>
    See {@link org.apache.log4j.examples.MyCategory} for an example.
    <h3>Example</h3>
    <p>An example configuration is given below. Other configuration
    file examples are given in {@link org.apache.log4j.examples.Sort}
    class documentation.
    <pre>
    # Set options for appender named ""A1"". 
    # Appender ""A1"" will be a SyslogAppender
    log4j.appender.A1=org.apache.log4j.net.SyslogAppender
    # The syslog daemon resides on www.abc.net
    log4j.appender.A1.SyslogHost=www.abc.net
    # A1's layout is a PatternLayout, using the conversion pattern 
    # <b>%r %-5p %c{2} %M.%L %x - %m\n</b>. Thus, the log output will
    # include # the relative time since the start of the application in
    # milliseconds, followed by the priority of the log request,
    # followed by the two rightmost components of the category name,
    # followed by the callers method name, followed by the line number,
    # the nested disgnostic context and finally the message itself.
    # Refer to the documentation of {@link PatternLayout} for further information
    # on the syntax of the ConversionPattern key.    
    log4j.appender.A1.layout=org.apache.log4j.PatternLayout
    log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %c{2} %M.%L %x - %m\n
    # Set options for appender named ""A2""
    # A2 should be a RollingFileAppender, with maximum file size of 10 MB
    # using at most one backup file. A2's layout is TTCC, using the
    # ISO8061 date format with context printing enabled.    
    log4j.appender.A2=org.apache.log4j.RollingFileAppender
    log4j.appender.A2.MaxFileSize=10MB
    log4j.appender.A2.MaxBackupIndex=1
    log4j.appender.A2.layout=org.apache.log4j.TTCCLayout
    log4j.appender.A2.layout.ContextPrinting=enabled
    log4j.appender.A2.layout.DateFormat=ISO8601
    # Root category set to DEBUG using the A2 appender defined above.
    log4j.rootCategory=DEBUG, A2
    # Category definions:
    # The SECURITY category inherits is priority from root. However, it's output
    # will go to A1 appender defined above. It's additivity is non-cumulative.
    log4j.category.SECURITY=INHERIT, A1
    log4j.additivity.SECURITY=false
    # Only warnings or above will be logged for the category ""SECURITY.access"".
    # Output will go to A1.
    log4j.category.SECURITY.access=WARN
    # The category ""class.of.the.day"" inherits its priority from the
    # category hierrarchy.  Output will go to the appender's of the root
    # category, A2 in this case.
    log4j.category.class.of.the.day=INHERIT
    </pre>
    <p>Refer to the <b>setOption</b> method in each Appender and
    Layout for class specific options.
    <p>Use the <code>#</code> or <code>!</code> characters at the
    beginning of a line for comments.
   <p> 
   @param configFileName The name of the configuration file where the
   configuration information is stored.
  */
  public
  void doConfigure(String configFileName, Hierarchy hierarchy) {
    Properties props = new Properties();
    try {
      FileInputStream istream = new FileInputStream(configFileName);
      props.load(istream);
      istream.close();
    }
    catch (IOException e) {
      LogLog.error(""Could not read configuration file [""+configFileName+""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configFileName+""]."");
      return;
    }
    // If we reach here, then the config file is alright.
    doConfigure(props, hierarchy);
  }
  /**
   */
  static
  public 
  void configure(String configFilename) {
    new PropertyConfigurator().doConfigure(configFilename, 
					   Category.defaultHierarchy);
  }
  /**
     Read configuration options from url <code>configURL</code>.
     @since 0.8.2
   */
  public
  static
  void configure(java.net.URL configURL) {
    new PropertyConfigurator().doConfigure(configURL, Category.defaultHierarchy);
  }
  /**
     Read configuration options from <code>properties</code>.
     See {@link #doConfigure(String, Hierarchy)} for the expected format.
  */
  static
  public
  void configure(Properties properties) {
    new PropertyConfigurator().doConfigure(properties, Category.defaultHierarchy);
  }
  /**
     Like {@link #configureAndWatch(String, long)} except that the
     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
     used. 
     @param configFilename A file in key=value format.
  */
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }
  /**
     Read the configuration file <code>configFilename</code> if it
     exists. Moreover, a thread will be created that will periodically
     check if <code>configFilename</code> has been created or
     modified. The period is determined by the <code>delay</code>
     argument. If a change or file creation is detected, then
     <code>configFilename</code> is read to configure log4j.  
      @param configFilename A file in key=value format.
      @param delay The delay in milliseconds to wait between each check.
  */
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    PropertyWatchdog pdog = new PropertyWatchdog(configFilename);
    pdog.setDelay(delay);
    pdog.start();
  }
  /**
     Read configuration options from <code>properties</code>.
     See {@link #doConfigure(String, Hierarchy)} for the expected format.
  */
  public
  void doConfigure(Properties properties, Hierarchy hierarchy) {
    String value = properties.getProperty(LogLog.DEBUG_KEY);
    if(value == null) {
      value = properties.getProperty(LogLog.CONFIG_DEBUG_KEY);
      if(value != null)
	LogLog.warn(""[log4j.configDebug] is deprecated. Use [log4j.debug] instead."");
    }
    if(value != null) {
      LogLog.setInternalDebugging(OptionConverter.toBoolean(value, true));
    }
    // Check if the config file overides the shipped code flag.
    String override = properties.getProperty(
                                    BasicConfigurator.DISABLE_OVERRIDE_KEY);
    hierarchy.overrideAsNeeded(override);
    if(override == null) {
      String disableStr = properties.getProperty(BasicConfigurator.DISABLE_KEY);
      if(disableStr != null)
	hierarchy.disable(disableStr);      
    }
    configureRootCategory(properties, hierarchy);
    configureCategoryFactory(properties);
    parseCatsAndRenderers(properties, hierarchy);
    LogLog.debug(""Finished configuring."");    
    // We don't want to hold references to appenders preventing their
    // garbage collection.
    registry.clear();
  }
  /**
     Read configuration options from url <code>configURL</code>.
   */
  public
  void doConfigure(java.net.URL configURL, Hierarchy hierarchy) {
    Properties props = new Properties();
    LogLog.debug(""Reading configuration from URL "" + configURL);
    try {
      props.load(configURL.openStream());
    }
    catch (java.io.IOException e) {
      LogLog.error(""Could not read configuration file from URL ["" + configURL 
		   + ""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configURL +""]."");
      return;
    }
    doConfigure(props, hierarchy);
  }
  // -------------------------------------------------------------------------------
  // Internal stuff
  // -------------------------------------------------------------------------------
  void configureCategoryFactory(Properties props) {
    String factoryClassName = OptionConverter.findAndSubst(CATEGORY_FACTORY_KEY,
							   props);    
    if(factoryClassName != null) {
      LogLog.debug(""Setting category factory to [""+factoryClassName+""]."");
      categoryFactory = (CategoryFactory) 
                  OptionConverter.instantiateByClassName(factoryClassName,
							 CategoryFactory.class, 
							 categoryFactory);
    }
  }
  /*
  void configureOptionHandler(OptionHandler oh, String prefix,
			      Properties props) {
    String[] options = oh.getOptionStrings();
    if(options == null) 
      return;
    String value;
    for(int i = 0; i < options.length; i++) {
      value =  OptionConverter.findAndSubst(prefix + options[i], props);
      LogLog.debug(
         ""Option "" + options[i] + ""=["" + (value == null? ""N/A"" : value)+""]."");
      // Some option handlers assume that null value are not passed to them.
      // So don't remove this check
      if(value != null) {
	oh.setOption(options[i], value);
      }
    }
    oh.activateOptions();
  }
  */
  void configureRootCategory(Properties props, Hierarchy hierarchy) {
    String value = OptionConverter.findAndSubst(ROOT_CATEGORY_PREFIX, props);
    if(value == null) 
      LogLog.debug(""Could not find root category information. Is this OK?"");
    else {
      Category root = hierarchy.getRoot();
      synchronized(root) {
	parseCategory(props, root, ROOT_CATEGORY_PREFIX, INTERNAL_ROOT_NAME, 
		      value);
      }
    }        
  }
  /**
     Parse non-root elements, such non-root categories and renderers.
  */
  protected
  void parseCatsAndRenderers(Properties props, Hierarchy hierarchy) {
    Enumeration enum = props.propertyNames();
    while(enum.hasMoreElements()) {      
      String key = (String) enum.nextElement();
      if(key.startsWith(CATEGORY_PREFIX)) {
	String categoryName = key.substring(CATEGORY_PREFIX.length());	
	String value =  OptionConverter.findAndSubst(key, props);
	Category cat = hierarchy.getInstance(categoryName, categoryFactory);
	synchronized(cat) {
	  parseCategory(props, cat, key, categoryName, value);
	  parseAdditivityForCategory(props, cat, categoryName);
	}
      } else if(key.startsWith(RENDERER_PREFIX)) {
	String renderedClass = key.substring(RENDERER_PREFIX.length());	
	String renderingClass = OptionConverter.findAndSubst(key, props);
	addRenderer(hierarchy, renderedClass, renderingClass);
      }      
    }
  }  
  /**
     Parse the additivity option for a non-root category.
   */
  void parseAdditivityForCategory(Properties props, Category cat,
				  String categoryName) {
    String value = OptionConverter.findAndSubst(ADDITIVITY_PREFIX + categoryName, 
					     props);
    LogLog.debug(""Handling ""+ADDITIVITY_PREFIX + categoryName+""=[""+value+""]"");
    // touch additivity only if necessary	
    if((value != null) && (!value.equals(""""))) {
      boolean additivity = OptionConverter.toBoolean(value, true);
      LogLog.debug(""Setting additivity for \""""+categoryName+""\"" to ""+
		   additivity); 
      cat.setAdditivity(additivity);
    }
  }
  /**
     This method must work for the root category as well.
   */
  void parseCategory(Properties props, Category cat, String optionKey,
		     String catName, String value) {
    LogLog.debug(""Parsing for ["" +catName +""] with value=["" + value+""]."");
    // We must skip over ',' but not white space
    StringTokenizer st = new StringTokenizer(value, "","");
    // If value is not in the form "", appender.."" or """", then we should set
    // the priority of the category.
    if(!(value.startsWith("","") || value.equals(""""))) {
      // just to be on the safe side...
      if(!st.hasMoreTokens())
	return;
      String priorityStr = st.nextToken();
      LogLog.debug(""Priority token is ["" + priorityStr + ""]."");
      // If the priority value is inherited, set category priority value to
      // null. We also check that the user has not specified inherited for the
      // root category.
      if(priorityStr.equalsIgnoreCase(BasicConfigurator.INHERITED) &&
	                              !catName.equals(INTERNAL_ROOT_NAME)) 
	cat.setPriority(null);
      else 
	cat.setPriority(Priority.toPriority(priorityStr));
      LogLog.debug(""Category "" + catName + "" set to "" + cat.getPriority());
    }
    // Remove all existing appenders. They will be reconstructed below.
    cat.removeAllAppenders();
    Appender appender;    
    String appenderName;
    while(st.hasMoreTokens()) {
      appenderName = st.nextToken().trim();
      if(appenderName == null || appenderName.equals("",""))
	continue;
      LogLog.debug(""Parsing appender named \"""" + appenderName +""\""."");
      appender = parseAppender(props, appenderName);
      if(appender != null) {
	cat.addAppender(appender);
      }      
    }          
  }
  Appender parseAppender(Properties props, String appenderName) {
    Appender appender = registryGet(appenderName);
    if((appender != null)) {
      LogLog.debug(""Appender \"""" + appenderName + ""\"" was already parsed."");
      return appender;
    }
    // Appender was not previously initialized.
    String prefix = APPENDER_PREFIX + appenderName;
    String layoutPrefix = prefix + "".layout"";    
    appender = (Appender) OptionConverter.instantiateByKey(props, prefix,
					      org.apache.log4j.Appender.class,
					      null);
    if(appender == null) {
      LogLog.error(
              ""Could not instantiate appender named \"""" + appenderName+""\""."");
      return null;
    }
    appender.setName(appenderName);
    if(appender instanceof OptionHandler) {
      if(appender.requiresLayout()) {
	Layout layout = (Layout) OptionConverter.instantiateByKey(props, 
								  layoutPrefix,
								  Layout.class, 
								  null);
	if(layout != null) {
	  appender.setLayout(layout);
	  LogLog.debug(""Parsing layout options for \"""" + appenderName +""\""."");
	  //configureOptionHandler(layout, layoutPrefix + ""."", props);
          PropertySetter.setProperties(layout, props, layoutPrefix + ""."");
	  LogLog.debug(""End of parsing for \"""" + appenderName +""\""."");      
	}
      }
      //configureOptionHandler((OptionHandler) appender, prefix + ""."", props);
      PropertySetter.setProperties(appender, props, prefix + ""."");
      LogLog.debug(""Parsed \"""" + appenderName +""\"" options."");
    }
    registryPut(appender);
    return appender;
  }
  void  registryPut(Appender appender) {
    registry.put(appender.getName(), appender);
  }
  Appender registryGet(String name) {
    return (Appender) registry.get(name);
  }
}
class PropertyWatchdog extends FileWatchdog {
  PropertyWatchdog(String filename) {
    super(filename);
  }
  /**
     Call {@link PropertyConfigurator#configure(String)} with the
     <code>filename</code> to reconfigure log4j. */
  public
  void doOnChange() {
    new PropertyConfigurator().doConfigure(filename, Category.defaultHierarchy);
  }
}
"
org.apache.log4j.ProvisionNode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.util.Vector;
class ProvisionNode extends Vector {
  ProvisionNode(Category cat) {
    super();
    this.addElement(cat);
  }
}
"
org.apache.log4j.RollingFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.beans.*;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.File;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.spi.LoggingEvent;
/**
   RollingFileAppender extends FileAppender to backup the log files when 
   they reach a certain size. 
   @author Heinz Richter
   @author Ceki G&uuml;lc&uuml;
*/
public class RollingFileAppender extends FileAppender {
  /**
     A string constant used in naming the option for setting the
     maximum size of the log file. Current value of this string constant is
     <b>MaxFileSize</b>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  static final public String MAX_FILE_SIZE_OPTION = ""MaxFileSize"";
   /**
     A string constant used in naming the option for setting the the
     number of backup files to retain. Current value of this string
     constant is <b>MaxBackupIndex</b>. 
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
 */
  static final public String MAX_BACKUP_INDEX_OPTION = ""MaxBackupIndex"";  
  /**
     The default maximum file size is 10MB. 
  */
  protected long maxFileSize = 10*1024*1024; 
  /**
     There is one backup file by default.
   */
  protected int  maxBackupIndex  = 1;    
  /**
     The default constructor simply calls its {@link
     FileAppender#FileAppender parents constructor}.  */
  public
  RollingFileAppender() {
    super();
  }
  /**
    Instantiate a RollingFileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file desginated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  RollingFileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    super(layout, filename, append);
  }
  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>The file will be appended to.  */
  public
  RollingFileAppender(Layout layout, String filename) throws IOException {
    super(layout, filename);
  }
  /**
     Returns the value of the <b>MaxBackupIndex</b> option.
   */
  public
  int getMaxBackupIndex() {
    return maxBackupIndex;
  }
 /**
    Get the maximum size that the output file is allowed to reach
    before being rolled over to backup files.
    @since 1.1
 */
  public
  long getMaximumFileSize() {
    return maxFileSize;
  }
  /**
     Retuns the option names for this component, namely {@link
     #MAX_FILE_SIZE_OPTION} and {@link #MAX_BACKUP_INDEX_OPTION} in
     addition to the options of {@link FileAppender#getOptionStrings}
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {MAX_FILE_SIZE_OPTION, MAX_BACKUP_INDEX_OPTION});
  }
  /**
     Implements the usual roll over behaviour.
     <p>If <code>MaxBackupIndex</code> is positive, then files
     {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
     are renamed to {<code>File.2</code>, ..., 
     <code>File.MaxBackupIndex</code>}. Moreover, <code>File</code> is
     renamed <code>File.1</code> and closed. A new <code>File</code> is
     created to receive further log output.
     <p>If <code>MaxBackupIndex</code> is equal to zero, then the
     <code>File</code> is truncated with no backup files created.
   */
  public // synchronization not necessary since doAppend is alreasy synched
  void rollOver() {
    File target;    
    File file;
    LogLog.debug(""rolling over count="" + ((CountingQuietWriter) qw).getCount());
    LogLog.debug(""maxBackupIndex=""+maxBackupIndex);
    // If maxBackups <= 0, then there is no file renaming to be done.
    if(maxBackupIndex > 0) {
      // Delete the oldest file, to keep Windows happy.
      file = new File(fileName + '.' + maxBackupIndex);    
      if (file.exists())
       file.delete();
      // Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
      for (int i = maxBackupIndex - 1; i >= 1; i--) {
	file = new File(fileName + ""."" + i);
	if (file.exists()) {
	  target = new File(fileName + '.' + (i + 1));
	  LogLog.debug(""Renaming file "" + file + "" to "" + target);
	  file.renameTo(target);
	}
      }
      // Rename fileName to fileName.1
      target = new File(fileName + ""."" + 1);
      this.closeFile(); // keep windows happy. 
      file = new File(fileName);
      LogLog.debug(""Renaming file "" + file + "" to "" + target);
      file.renameTo(target);
    }
    try {
      // This will also close the file. This is OK since multiple
      // close operations are safe.
      this.setFile(fileName, false);
    }
    catch(IOException e) {
      LogLog.error(""setFile(""+fileName+"", false) call failed."", e);
    }
  }
  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    super.setFile(fileName, append);
    if(append) {
      File f = new File(fileName);
      ((CountingQuietWriter) qw).setCount(f.length());
    }
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(MAX_FILE_SIZE_OPTION)) {
      maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
    }
    else if(key.equalsIgnoreCase(MAX_BACKUP_INDEX_OPTION)) {
      maxBackupIndex = OptionConverter.toInt(value, maxBackupIndex);
    }
  }
  /**
     Set the maximum number of backup files to keep around.
     <p>The <b>MaxBackupIndex</b> option determines how many backup
     files are kept before the oldest is erased. This option takes
     a positive integer value. If set to zero, then there will be no
     backup files and the log file will be truncated when it reaches
     <code>MaxFileSize</code>.
   */
  public
  void setMaxBackupIndex(int maxBackups) {
    this.maxBackupIndex = maxBackups;    
  }
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.
     @deprecated Use {@link #setMaximumFileSize} instead.
   */
  public
  void setMaxFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.
     <p>This method is equivalent to {@link #setMaxFileSize} except
     that it is required for differentiating the setter taking a
     <code>long</code> argument from the setter taking a
     <code>String</code> argument by the JavaBeans {@link
     java.beans.Introspector Introspector}.
     @see #setMaxFileSize(String)
 */
  public
  void setMaximumFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.
     <p>In configuration files, the <b>MaxFileSize</b> option takes an
     long integer in the range 0 - 2^63. You can specify the value
     with the suffixes ""KB"", ""MB"" or ""GB"" so that the integer is
     interpreted being expressed respectively in kilobytes, megabytes
     or gigabytes. For example, the value ""10KB"" will be interpreted
     as 10240.
   */
  public
  void setMaxFileSize(String value) {
    maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
  }
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new CountingQuietWriter(writer, errorHandler);
  }
  /**
     This method differentiates RollingFileAppender from its super
     class.  
     @since 0.9.0
  */
  protected
  void subAppend(LoggingEvent event) {
    super.subAppend(event);
    if((fileName != null) &&
                     ((CountingQuietWriter) qw).getCount() >= maxFileSize) 
      this.rollOver();
   }
}
"
org.apache.log4j.RollingFileAppenderBeanInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.beans.*;
import org.apache.log4j.helpers.LogLog;
import java.lang.reflect.Method;
public class RollingFileAppenderBeanInfo extends SimpleBeanInfo {
  private PropertyDescriptor[] props;
  public
  RollingFileAppenderBeanInfo() {
    Class clazz = RollingFileAppender.class;
    try {
      // the magic is here
      BeanInfo bi = Introspector.getBeanInfo(clazz,
					     Introspector.IGNORE_ALL_BEANINFO);
      props = bi.getPropertyDescriptors();
      if(props != null) {
	for(int i = 0; i < props.length; i++) {
	  if(props[i].getName().equals(""maxFileSize"")) {
	    Method m = clazz.getMethod(""setMaxFileSize"", 
				       new Class[] {String.class});
	    props[i] = new PropertyDescriptor(""maxFileSize"", null, m);
	  }
	}
      }
      // flush the bean info because getPropertyDescriptors() will now return
      // different properties
      Introspector.flushFromCaches(RollingFileAppender.class);
    } catch(IntrospectionException e) {
      LogLog.error(""Could not inspect RollingFileAppender."", e);
    } catch(NoSuchMethodException e) {
      LogLog.error(""Could not find setter method for RollingFileAppender."", e);
    }
  }
  public
  PropertyDescriptor[] getPropertyDescriptors() {
    return props;
  }
}
"
org.apache.log4j.SimpleLayout,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
/**
   SimpleLayout consists of the priority of the log statement,
   followed by "" - "" and then the log message itself. For example,
   <pre>
           DEBUG - Hello world
   </pre>
   <p>
   @author Ceki G&uuml;lc&uuml;
   @since version 0.7.0
   <p>{@link PatternLayout} offers a much more powerful alternative.
*/
public class SimpleLayout extends Layout {
  StringBuffer sbuf = new StringBuffer(128);
  public SimpleLayout() {
  }
  public
  String[] getOptionStrings() {
    return new String[0];
  }
  public
  void setOption(String option, String value) {
  }
  public
  void activateOptions() {
  }
  /**
     Returns the log statement in a format consisting of the
     <code>priority</code>, followed by "" - "" and then the
     <code>message</code>. For example, <pre> INFO - ""A message""
     </pre>
     <p>The <code>category</code> parameter is ignored.
     <p>
     @return A byte array in SimpleLayout format.
    */
  public
  String format(LoggingEvent event) {
    sbuf.setLength(0);
    sbuf.append(event.priority.toString());
    sbuf.append("" - "");
    sbuf.append(event.getRenderedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }
/**
     The SimpleLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
org.apache.log4j.StressCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.Priority;
import org.apache.log4j.Category;
import java.util.Random;
/*
  Stress test the Category class.
*/
class StressCategory {
  static Priority[] priority = new Priority[] {Priority.DEBUG, 
					       Priority.INFO, 
					       Priority.WARN,
					       Priority.ERROR,
					       Priority.FATAL};
  static Priority defaultPriority = Category.getRoot().getPriority();
  static int LENGTH;
  static String[] names;
  static Category[] cat;
  static CT[] ct;
  static Random random = new Random(10);
  public static void main(String[] args) {
    LENGTH = args.length;
    if(LENGTH == 0) {
      System.err.println( ""Usage: java "" + StressCategory.class.getName() +
			  "" name1 ... nameN\n."");      
      System.exit(1);
    }
    if(LENGTH >= 7) {
      System.err.println(
        ""This stress test suffers from combinatorial explosion.\n""+
        ""Invoking with seven arguments takes about 90 minutes even on fast machines"");
    }
    names = new String[LENGTH];
    for(int i=0; i < LENGTH; i++) {
      names[i] = args[i];
    }    
    cat = new Category[LENGTH];
    ct = new CT[LENGTH]; 
    permute(0); 
    // If did not exit, then passed all tests.
  }
  // Loop through all permutations of names[].
  // On each possible permutation call createLoop
  static
  void permute(int n) {
    if(n == LENGTH)
      createLoop(0);
    else
      for(int i = n; i < LENGTH; i++) {
	swap(names, n, i);
	permute(n+1);
	swap(names, n, i);	
      }
  }
  static
  void swap(String[] names, int i, int j) {
    String t = names[i];
    names[i] = names[j];
    names[j] = t;
  }
  public
  static
  void permutationDump() {
    System.out.print(""Current permutation is - "");
    for(int i = 0; i < LENGTH; i++) {
      System.out.print(names[i] + "" "");
    }
    System.out.println();
  }
  // Loop through all possible 3^n combinations of not instantiating, 
  // instantiating and setting/not setting a priority.
  static
  void createLoop(int n) {
    if(n == LENGTH) {  
      //System.out.println(""..............Creating cat[]..........."");
      for(int i = 0; i < LENGTH; i++) {
	if(ct[i] == null)
	  cat[i] = null;
	else {
	  cat[i] = Category.getInstance(ct[i].catstr);
	  cat[i].setPriority(ct[i].priority);
	}
      }
      test();
      // Clear hash table for next round
      Category.defaultHierarchy.clear();
    }
    else {      
      ct[n]  = null;
      createLoop(n+1);  
      ct[n]  = new CT(names[n], null);
      createLoop(n+1);  
      int r = random.nextInt(); if(r < 0) r = -r;
      ct[n]  = new CT(names[n], priority[r%5]);
      createLoop(n+1);
    }
  }
  static
  void test() {    
    //System.out.println(""++++++++++++TEST called+++++++++++++"");
    //permutationDump();
    //catDump();
    for(int i = 0; i < LENGTH; i++) {
      if(!checkCorrectness(i)) {
	System.out.println(""Failed stress test."");
	permutationDump();
	//Hierarchy._default.fullDump();
	ctDump();
	catDump();
	System.exit(1);
      }
    }
  }
  static
  void ctDump() {
    for(int j = 0; j < LENGTH; j++) {
       if(ct[j] != null) 
	    System.out.println(""ct ["" + j + ""] = (""+ct[j].catstr+"","" + 
			       ct[j].priority + "")"");
       else 
	 System.out.println(""ct ["" + j + ""] = undefined"");
    }
  }
  static
  void catDump() {
    for(int j = 0; j < LENGTH; j++) {
      if(cat[j] != null)
	System.out.println(""cat["" + j + ""] = ("" + cat[j].name + "","" +
			   cat[j].getPriority() + "")"");
      else
	System.out.println(""cat["" + j + ""] = undefined""); 
    }
  }
  //  static
  //void provisionNodesDump() {
  //for (Enumeration e = CategoryFactory.ht.keys(); e.hasMoreElements() ;) {
  //  CategoryKey key = (CategoryKey) e.nextElement();
  //  Object c = CategoryFactory.ht.get(key);
  //  if(c instanceof  ProvisionNode) 
  //((ProvisionNode) c).dump(key.name);
  //}
  //}
  static
  boolean checkCorrectness(int i) {
    CT localCT = ct[i];
    // Can't perform test if category is not instantiated
    if(localCT == null) 
      return true;
    // find expected priority
    Priority expected = getExpectedPrioriy(localCT);
    Priority purported = cat[i].getChainedPriority();
    if(expected != purported) {
      System.out.println(""Expected priority for "" + localCT.catstr + "" is "" +
		       expected);
      System.out.println(""Purported priority for ""+ cat[i].name + "" is ""+purported);
      return false;
    }
    return true;
  }
  static
  Priority getExpectedPrioriy(CT ctParam) {
    Priority priority = ctParam.priority;
    if(priority != null) 
      return priority;
    String catstr = ctParam.catstr;    
    for(int i = catstr.lastIndexOf('.', catstr.length()-1); i >= 0; 
	                              i = catstr.lastIndexOf('.', i-1))  {
      String substr = catstr.substring(0, i);
      // find the priority of ct corresponding to substr
      for(int j = 0; j < LENGTH; j++) {	
	if(ct[j] != null && substr.equals(ct[j].catstr)) {
	  Priority p = ct[j].priority;
	  if(p != null) 
	    return p;	  
	}
      }
    }
    return defaultPriority;
  }
  static class CT {
    public String   catstr;
    public Priority priority;
    CT(String catstr,  Priority priority) {
      this.catstr = catstr;
      this.priority = priority;
    }
  }
}
"
org.apache.log4j.TTCCLayout,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of distribution.
// Contributors: Christopher Williams 
//               Mathias Bogaert
package org.apache.log4j;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.DateLayout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
/**
 TTCC layout format consists of time, thread, category and nested
 diagnostic context information, hence the name.
 <p>Each of the four fields can be individually enabled or
 disabled. The time format depends on the <code>DateFormat</code>
 used.
 <p>Here is an example TTCCLayout output with the {@link RelativeTimeDateFormat}.
 <pre>
176 [main] INFO  org.apache.log4j.examples.Sort - Populating an array of 2 elements in reverse order.
225 [main] INFO  org.apache.log4j.examples.SortAlgo - Entered the sort method.
262 [main] DEBUG org.apache.log4j.examples.SortAlgo.OUTER i=1 - Outer loop.
276 [main] DEBUG org.apache.log4j.examples.SortAlgo.SWAP i=1 j=0 - Swapping intArray[0] = 1 and intArray[1] = 0
290 [main] DEBUG org.apache.log4j.examples.SortAlgo.OUTER i=0 - Outer loop.
304 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Dump of interger array:
317 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Element [0] = 0
331 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Element [1] = 1
343 [main] INFO  org.apache.log4j.examples.Sort - The next log statement should be an error message.
346 [main] ERROR org.apache.log4j.examples.SortAlgo.DUMP - Tried to dump an uninitialized array.
        at org.apache.log4j.examples.SortAlgo.dump(SortAlgo.java:58)
        at org.apache.log4j.examples.Sort.main(Sort.java:64)
467 [main] INFO  org.apache.log4j.examples.Sort - Exiting main method.
</pre>
  <p>The first field is the number of milliseconds elapsed since the
  start of the program. The second field is the thread outputting the
  log statement. The third field is the priority, the fourth field is
  the category to which the statement belongs.
  <p>The fifth field (just before the '-') is the nested diagnostic
  context.  Note the nested diagnostic context may be empty as in the
  first two statements. The text after the '-' is the message of the
  statement.
  <p><b>WARNING</b> Do not use the same TTCCLayout instance from
  within different appenders. The TTCCLayout is not thread safe when
  used in his way. However, it is perfectly safe to use a TTCCLayout
  instance from just one appender.
  <p>{@link PatternLayout} offers a much more flexible alternative.
  @author Ceki G&uuml;lc&uuml;
  @author <A HREF=""mailto:heinz.richter@ecmwf.int"">Heinz Richter</a>
*/
public class TTCCLayout extends DateLayout {
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String THREAD_PRINTING_OPTION = ""ThreadPrinting"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String CATEGORY_PREFIXING_OPTION = ""CategoryPrefixing"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String CONTEXT_PRINTING_OPTION  = ""ContextPrinting"";  
  // Internal representation of options
  private boolean threadPrinting    = true;    
  private boolean categoryPrefixing = true;
  private boolean contextPrinting   = true;
  protected final StringBuffer buf = new StringBuffer(256);   
  /**
     Instantiate a TTCCLayout object with {@link
     RelativeTimeDateFormat} as the date formatter in the local time
     zone.
     @since 0.7.5
  */
  public TTCCLayout() {
    this.setDateFormat(RELATIVE_TIME_DATE_FORMAT, null);
  } 
  /**
     Instantiate a TTCCLayout object using the local time zone. The
     DateFormat used will depend on the <code>dateFormatType</code>.
     <p>This constructor just calls the {@link
     DateLayout#setDateFormat} method.
     */
  public TTCCLayout(String dateFormatType) {
    this.setDateFormat(dateFormatType);
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
              new String[] {THREAD_PRINTING_OPTION, CATEGORY_PREFIXING_OPTION,
  			    CONTEXT_PRINTING_OPTION});
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
  public
  void setOption(String key, String value) {
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(THREAD_PRINTING_OPTION)) 
      threadPrinting = OptionConverter.toBoolean(value, threadPrinting);
    else if(key.equalsIgnoreCase(CATEGORY_PREFIXING_OPTION))
      categoryPrefixing = OptionConverter.toBoolean(value, categoryPrefixing);
    else if(key.equalsIgnoreCase(CONTEXT_PRINTING_OPTION))
      contextPrinting = OptionConverter.toBoolean(value, contextPrinting);
  }
  /**
     The <b>ThreadPrinting</b> option specifies whether the name of the
     current thread is part of log output or not. This is true by default.
   */
  public
  void setThreadPrinting(boolean threadPrinting) {
    this.threadPrinting = threadPrinting;
  }
  /**
     Returns value of the <b>ThreadPrinting</b> option.
   */
  public
  boolean getThreadPrinting() {
    return threadPrinting;
  }
  /**
     The <b>CategoryPrefixing</b> option specifies whether {@link Category}
     name is part of log output or not. This is true by default.
   */
  public
  void setCategoryPrefixing(boolean categoryPrefixing) {
    this.categoryPrefixing = categoryPrefixing;
  }
  /**
     Returns value of the <b>CategoryPrefixing</b> option.
   */
  public
  boolean getCategoryPrefixing() {
    return categoryPrefixing;
  }
  /**
     The <b>ContextPrinting</b> option specifies log output will include
     the nested context information belonging to the current thread.
     This is true by default.
   */
  public
  void setContextPrinting(boolean contextPrinting) {
    this.contextPrinting = contextPrinting;
  }
  /**
     Returns value of the <b>ContextPrinting</b> option.
   */
  public
  boolean getContextPrinting() {
    return contextPrinting;
  }
  /**
   In addition to the priority of the statement and message, the
   returned byte array includes time, thread, category and {@link NDC}
   information.
   <p>Time, thread, category and diagnostic context are printed
   depending on options.
    @param category
    @param priority
    @param message
  */
  public
  String format(LoggingEvent event) {
    // Reset buf
    buf.setLength(0);
    dateFormat(buf, event);
    if(this.threadPrinting) {
      buf.append('[');
      buf.append(event.getThreadName());
      buf.append(""] "");
    }
    buf.append(event.priority.toString());
    buf.append(' ');
    if(this.categoryPrefixing) {
      buf.append(event.categoryName);
      buf.append(' ');
    }
    if(this.contextPrinting) {
       String ndc = event.getNDC();
      if(ndc != null) {
	buf.append(ndc);
	buf.append(' ');
      }
    }    
    buf.append(""- "");
    buf.append(event.getRenderedMessage());
    buf.append(LINE_SEP);    
    return buf.toString();
  }
 /** 
     The TTCCLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
} 
"
org.apache.log4j.WriterAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>
/**
   WriterAppender appends log events to a {@link java.io.Writer} or an
   {@link java.io.OutputStream} depending on the user's choice.
   @author Ceki G&uuml;lc&uuml;
   @since 1.1 */
public class WriterAppender extends AppenderSkeleton {
  /**
     A string constant used in naming the option for immediate
     flushing of the output stream at the end of each append
     operation. Current value of this string constant is
     <b>ImmediateFlush</b>.
     <p>Note that all option keys are case sensitive.     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed. 
  */
  public static final String IMMEDIATE_FLUSH_OPTION = ""ImmediateFlush"";
  /**
     Immediate flush means that the undelying writer or output stream
     will be flushed at the end of each append operation. Immediate
     flush is slower but ensures that each append request is actually
     written. If <code>immediateFlush</code> is set to
     <code>false</code>, then there is a good chance that the last few
     logs events are not actually written to persistent media if and
     when the application crashes.
     <p>The <code>immediateFlush</code> variable is set to
     <code>true</code> by default.
  */
  protected boolean immediateFlush = true;
  /**
     This is the {@link QuietWriter quietWriter} where we will write
     to. 
  */
  protected QuietWriter qw;
  /**
     This default constructor does nothing.  */
  public
  WriterAppender() {
  }
  /**
     Instantiate a WriterAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  */
  public
  WriterAppender(Layout layout, OutputStream os) {
    this(layout, new OutputStreamWriter(os));
  }
  /**
     Instantiate a WriterAppender and set the output destination to
     <code>writer</code>.
     <p>The <code>writer</code> must have been previously opened by
     the user.  */
  public
  WriterAppender(Layout layout, Writer writer) {
    this.layout = layout;
    this.setWriter(writer);
  }
  /**
     If the <b>ImmediateFlush</b> option is set to
     <code>true</code>, the appender will flush at the end of each
     write. This is the default behaviour. If the option is set to
     <code>false</code>, then the underlying stream can defer writing
     to physical medium to a later time. 
     <p>Avoiding the flush operation at the end of each append results in
     a performance gain of 10 to 20 percent. However, there is safety
     tradeoff involved in skipping flushing. Indeed, when flushing is
     skipped, then it is likely that the last few log events will not
     be recorded on disk when the application exits. This is a high
     price to pay even for a 20% performance gain.
   */
  public
  void setImmediateFlush(boolean value) {
    immediateFlush = value;
  }
  /**
     Returns value of the <b>ImmediateFlush</b> option.
   */
  public
  boolean getImmediateFlush() {
    return immediateFlush;
  }
  /**
     Does nothing.
  */
  public
  void activateOptions() {    
  }
  /**
     This method is called by the {@link AppenderSkeleton#doAppend}
     method. 
     <p>If the output stream exists and is writable then write a log
     statement to the output stream. Otherwise, write a single warning
     message to <code>System.err</code>.
     <p>The format of the output will depend on this appender's
     layout.
  */
  public
  void append(LoggingEvent event) {
    // Reminder: the nesting of calls is:
    //
    //    doAppend()
    //      - check threshold
    //      - filter
    //      - append();
    //        - checkEntryConditions();
    //        - subAppend();
    if(!checkEntryConditions()) {
      return;
    }
    subAppend(event);
   } 
  /**
     This method determines if there is a sense in attempting to append.
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.closed) {
      LogLog.warn(""Not allowed to write to a closed appender."");
      return false;
    }
    if(this.qw == null) {
      errorHandler.error(""No output stream or file set for appender named [""+ 
			name+""]."");
      return false;
    }
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+ name+""]."");
      return false;
    }
    return true;
  }
  /**
     Close this appender instance. The underlying stream or writer is
     also closed.
     <p>Closed appenders cannot be reused.
     @see #setWriter
     @since 0.8.4 */
  public
  synchronized
  void close() {
    if(this.closed)
      return;
    this.closed = true;
    writeFooter();
    reset();
  }
  /**
     Close the underlying {@link java.io.Writer}.
  */
  protected 
  void closeWriter() {
    if(qw != null) {
      try {
	qw.close();
      } catch(IOException e) {
	LogLog.error(""Could not close "" + qw, e); // do need to invoke an error handler
	                                          // at  this late stage
      }
    }
  }
  /**
     Retuns the option names for this component.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
           new String[] {IMMEDIATE_FLUSH_OPTION});
  }
  /**
     Set the {@link ErrorHandler} for this FileAppender and also the
     underlying {@link QuietWriter} if any. */
  public
  synchronized 
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
      if(this.qw != null) {
	this.qw.setErrorHandler(eh);
      }
    }    
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
 public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    if (key.equalsIgnoreCase(IMMEDIATE_FLUSH_OPTION)) {
      immediateFlush = OptionConverter.toBoolean(value, immediateFlush);
    }
  }  
  /**
    <p>Sets the Writer where the log output will go. The
    specified Writer must be opened by the user and be
    writable.
    <p>The <code>java.io.Writer</code> will be closed when the
    appender instance is closed.
    <p><b>WARNING:</b> Logging to an unopened Writer will fail.
    <p>  
    @param Writer An already opened Writer.  */
  public
  synchronized
  void setWriter(Writer writer) {
    reset();
    this.qw = new QuietWriter(writer, errorHandler);
    //this.tp = new TracerPrintWriter(qw);
    writeHeader();
  }
  /**
     Actual writing occurs here.
     <p>Most sub-classes of <code>FileAppender</code> will need to
     override this method.
     @since 0.9.0 */
  protected
  void subAppend(LoggingEvent event) {
    this.qw.write(this.layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  this.qw.write(s[i]);
	  this.qw.write(Layout.LINE_SEP);
	}
      }
    }
    if(this.immediateFlush) {
      this.qw.flush();
    } 
  }
  /**
     The WriterAppender requires a layout. Hence, this method returns
     <code>true</code>.
  */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
     Clear internal references to the writer and other variables.
     Sub-classes can override this method for an alternate closing
     behaviour.  */
  protected
  void reset() {
    closeWriter();
    this.qw = null;
    //this.tp = null;    
  }
  /**
     Write a footer as produced by the embedded layout's {@link
     Layout#getFooter} method.  */
  protected
  void writeFooter() {
    if(layout != null) {
      String f = layout.getFooter();
      if(f != null && this.qw != null)
	this.qw.write(f);
    }
  }
/**
     Write a header as produced by the embedded layout's {@link
     Layout#getHeader} method.  */
  protected 
  void writeHeader() {
    if(layout != null) {
      String h = layout.getHeader();
      if(h != null && this.qw != null)
	this.qw.write(h);
    }
  }
}
"
org.apache.log4j.config.PropertyGetter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */
package org.apache.log4j.config;
import java.beans.*;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.Appender;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
/**
   Used for inferring configuration information for a log4j's component.
   @author  Anders Kristensen
 */
public class PropertyGetter {
  protected static final Object[] NULL_ARG = new Object[] {};
  protected Object obj;
  protected PropertyDescriptor[] props;
  public interface PropertyCallback {
    void foundProperty(Object obj, String prefix, String name, Object value);
  }
  /**
    Create a new PropertySetter for the specified Object. This is done
    in prepartion for invoking {@link
    #getProperties(PropertyGetter.PropertyCallback, String)} one or
    more times.
    @param obj the object for which to set properties */
  public
  PropertyGetter(Object obj) throws IntrospectionException {
    BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
    props = bi.getPropertyDescriptors();
    this.obj = obj;
  }
  public
  static
  void getProperties(Object obj, PropertyCallback callback, String prefix) {
    try {
      new PropertyGetter(obj).getProperties(callback, prefix);
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect object "" + obj, ex);
    }
  }
  public
  void getProperties(PropertyCallback callback, String prefix) {
    for (int i = 0; i < props.length; i++) {
        Method getter = props[i].getReadMethod();
        if (getter == null) continue;
        if (!isHandledType(getter.getReturnType())) {
          //System.err.println(""Ignoring "" + props[i].getName() +"" "" + getter.getReturnType());
          continue;
        }
        String name = props[i].getName();
        try {
          Object result = getter.invoke(obj, NULL_ARG);
          //System.err.println(""PROP "" + name +"": "" + result);
          if (result != null) {
            callback.foundProperty(obj, prefix, name, result);
          }
        } catch (Exception ex) {
          LogLog.warn(""Failed to get value of property "" + name);
        }
    }
  }
  protected
  boolean isHandledType(Class type) {
    return String.class.isAssignableFrom(type) ||
           Integer.TYPE.isAssignableFrom(type) ||
           Long.TYPE.isAssignableFrom(type)    ||
           Boolean.TYPE.isAssignableFrom(type) ||
           Priority.class.isAssignableFrom(type);
  }
}
"
org.apache.log4j.config.PropertyPrinter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */
package org.apache.log4j.config;
import java.io.*;
import java.util.*;
import org.apache.log4j.*;
/**
   Prints the configuration of the log4j default hierarchy
   (which needs to be auto-initialized) as a propoperties file
   on a {@link PrintWriter}.
   @author  Anders Kristensen
 */
public class PropertyPrinter implements PropertyGetter.PropertyCallback {
  protected int numAppenders = 0;
  protected Hashtable appenderNames = new Hashtable();
  protected Hashtable layoutNames   = new Hashtable();
  protected PrintWriter out;
  protected boolean doCapitalize;
  public
  PropertyPrinter(PrintWriter out) {
    this(out, false);
  }
  public
  PropertyPrinter(PrintWriter out, boolean doCapitalize) {
    this.out = out;
    this.doCapitalize = doCapitalize;
    print(out);
    out.flush();
  }
  protected
  String genAppName() {
    return ""A"" + numAppenders++;
  }
  /**
     Returns true if the specified appender name is considered to have
     been generated, i.e. if it is of the form A[0-9]+.
  */
  protected
  boolean isGenAppName(String name) {
    if (name.length() < 2 || name.charAt(0) != 'A') return false;
    for (int i = 0; i < name.length(); i++) {
      if (name.charAt(i) < '0' || name.charAt(i) > '9') return false;
    }
    return true;
  }
  /**
   * Prints the configuration of the default log4j hierarchy as a Java
   * properties file on the specified Writer.
   * 
   * <p>N.B. print() can be invoked only once!
   */
  public
  void print(PrintWriter out) {
    printOptions(out, Category.getRoot());
    Enumeration cats = Category.getCurrentCategories();
    while (cats.hasMoreElements()) {
      printOptions(out, (Category) cats.nextElement());
    }
  }
  protected
  void printOptions(PrintWriter out, Category cat) {
    Enumeration appenders = cat.getAllAppenders();
    Priority prio = cat.getPriority();
    String appenderString = (prio == null ? """" : prio.toString());
    while (appenders.hasMoreElements()) {
      Appender app = (Appender) appenders.nextElement();
      String name;
      if ((name = (String) appenderNames.get(app)) == null) {
        // first assign name to the appender
        if ((name = app.getName()) == null || isGenAppName(name)) {
            name = genAppName();
        }
        appenderNames.put(app, name);
        printOptions(out, app, ""log4j.appender.""+name);
        if (app.getLayout() != null) {
          printOptions(out, app.getLayout(), ""log4j.appender.""+name+"".layout"");
        }
      }
      appenderString += "", "" + name;
    }
    String catKey = (cat == Category.getRoot())
        ? ""log4j.rootCategory""
        : ""log4j.category."" + cat.getName();
    if (appenderString != """") {
      out.println(catKey + ""="" + appenderString);
    }
  }
  protected
  void printOptions(PrintWriter out, Object obj, String fullname) {
    out.println(fullname + ""="" + obj.getClass().getName());
    PropertyGetter.getProperties(obj, this, fullname + ""."");
  }
  public void foundProperty(Object obj, String prefix, String name, Object value) {
    // XXX: Properties encode value.toString()
    if (obj instanceof Appender && ""name"".equals(name)) {
      return;
    }
    if (doCapitalize) {
      name = capitalize(name);
    }
    out.println(prefix + name + ""="" + value.toString());
  }
  public static String capitalize(String name) {
    if (Character.isLowerCase(name.charAt(0))) {
      if (name.length() == 1 || Character.isLowerCase(name.charAt(1))) {
        StringBuffer newname = new StringBuffer(name);
        newname.setCharAt(0, Character.toUpperCase(name.charAt(0)));
        return newname.toString();
      }
    }
    return name;
  }
  // for testing
  public static void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out));
  }
}"
org.apache.log4j.config.PropertySetter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.config;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.*;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;
/**
   General purpose Object property setter. Clients repeatedly invokes
   {@link #setProperty setProperty(name,value)} in order to invoke setters
   on the Object specified in the constructor. This class relies on the
   JavaBeans {@link Introspector} to analyze the given Object Class using
   reflection.
   <p>Usage:
   <pre>
     PropertySetter ps = new PropertySetter(anObject);
     ps.set(""name"", ""Joe"");
     ps.set(""age"", ""32"");
     ps.set(""isMale"", ""true"");
   </pre>
   will cause the invocations anObject.setName(""Joe""), anObject.setAge(32),
   and setMale(true) if such methods exist with those signatures.
   Otherwise an {@link IntrospectionException} are thrown.
   @author Anders Kristensen
   @since 1.1
 */
public class PropertySetter {
  protected Object obj;
  protected PropertyDescriptor[] props;
  /**
    Create a new PropertySetter for the specified Object. This is done
    in prepartion for invoking {@link #setProperty} one or more times.
    @param obj  the object for which to set properties
   */
  public
  PropertySetter(Object obj) {
    this.obj = obj;
  }
  /**
     Uses JavaBeans {@link Introspector} to computer setters of object to be
     configured.
   */
  protected
  void introspect() {
    try {
      BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
      props = bi.getPropertyDescriptors();
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect ""+obj+"": "" + ex.getMessage());
      props = new PropertyDescriptor[0];
    }
  }
  /**
     Set the properties of an object passed as a parameter in one
     go. The <code>properties</code> are parsed relative to a
     <code>prefix</code>.
     @param obj The object to configure.
     @param properties A java.util.Properties containing keys and values.
     @param prefix Only keys having the specified prefix will be set.
  */
  public
  static
  void setProperties(Object obj, Properties properties, String prefix) {
    new PropertySetter(obj).setProperties(properties, prefix);
  }
  /**
     Set the properites for the object that match the
     <code>prefix</code> passed as parameter.
   */
  public
  void setProperties(Properties properties, String prefix) {
    int len = prefix.length();
    for (Enumeration e = properties.keys(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      // handle only properties that start with the desired frefix.
      if (key.startsWith(prefix)) {
	// ignore key if it contains dots after the prefix
        if (key.indexOf('.', len + 1) > 0) {
	  //System.err.println(""----------Ignoring---[""+key
	  //	     +""], prefix=[""+prefix+""]."");
	  continue;
	}
	String value = OptionConverter.findAndSubst(key, properties);
        key = key.substring(len);
        if (""layout"".equals(key) && obj instanceof Appender) {
          continue;
        }        
        setProperty(key, value);
      }
    }
    activate();
  }
  /**
     Set a property on this PropertySetter's Object. If successful, this
     method will invoke a setter method on the underlying Object. The
     setter is the one for the specified property name and the value is
     determined partly from the setter argument type and partly from the
     value specified in the call to this method.
     <p>If the setter expects a String no conversion is necessary.
     If it expects an int, then an attempt is made to convert 'value'
     to an int using new Integer(value). If the setter expects a boolean,
     the conversion is by new Boolean(value).
     @param name    name of the property
     @param value   String value of the property
   */
  public
  void setProperty(String name, String value) {
    if (value == null) return;
    name = Introspector.decapitalize(name);
    PropertyDescriptor prop = getPropertyDescriptor(name);
    //LogLog.debug(""---------Key: ""+name+"", type=""+prop.getPropertyType());
    if (prop == null) {
      LogLog.warn(""No such property ["" + name + ""] in ""+
		  obj.getClass().getName()+""."" );
    } else {
      try {
        setProperty(prop, name, value);
      } catch (PropertySetterException ex) {
        LogLog.warn(""Failed to set property "" + name +
                    "" to value \"""" + value + ""\"". "" + ex.getMessage());
      }
    }
  }
  /** 
      Set the named property given a {@link PropertyDescriptor}.
      @param prop A PropertyDescriptor describing the characteristics
      of the property to set.
      @param name The named of the property to set.
      @param value The value of the property.      
   */
  public
  void setProperty(PropertyDescriptor prop, String name, String value)
    throws PropertySetterException {
    Method setter = prop.getWriteMethod();
    if (setter == null) {
      throw new PropertySetterException(""No setter for property"");
    }
    Class[] paramTypes = setter.getParameterTypes();
    if (paramTypes.length != 1) {
      throw new PropertySetterException(""#params for setter != 1"");
    }
    Object arg;
    try {
      arg = convertArg(value, paramTypes[0]);
    } catch (Throwable t) {
      throw new PropertySetterException(""Conversion to type [""+paramTypes[0]+
					""] failed. Reason: ""+t);
    }
    if (arg == null) {
      throw new PropertySetterException(
          ""Conversion to type [""+paramTypes[0]+""] failed."");
    }
    LogLog.debug(""Setting property ["" + name + ""] to ["" +arg+""]."");
    try {
      setter.invoke(obj, new Object[]  { arg });
    } catch (Exception ex) {
      throw new PropertySetterException(ex);
    }
  }
  /**
     Convert <code>val</code> a String parameter to an object of a
     given type.
  */
  protected
  Object convertArg(String val, Class type) {
    if(val == null)
      return null;
    String v = val.trim();
    if (String.class.isAssignableFrom(type)) {
      return val;
    } else if (Integer.TYPE.isAssignableFrom(type)) {
      return new Integer(v);
    } else if (Long.TYPE.isAssignableFrom(type)) {
      return new Long(v);
    } else if (Boolean.TYPE.isAssignableFrom(type)) {
      if (""true"".equalsIgnoreCase(v)) {
        return Boolean.TRUE;
      } else if (""false"".equalsIgnoreCase(v)) {
        return Boolean.FALSE;
      }
    } else if (Priority.class.isAssignableFrom(type)) {
      return OptionConverter.toPriority(v, null);
    }
    return null;
  }
  protected
  PropertyDescriptor getPropertyDescriptor(String name) {
    if (props == null) introspect();
    for (int i = 0; i < props.length; i++) {
      if (name.equals(props[i].getName())) {
	return props[i];
      }
    }
    return null;
  }
  public
  void activate() {
    if (obj instanceof OptionHandler) {
      ((OptionHandler) obj).activateOptions();
    }
  }
}
"
org.apache.log4j.config.PropertySetterException,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.config;
/**
 * Thrown when an error is encountered whilst attempting to set a property
 * using the {@link PropertySetter} utility class.
 * 
 * @author Anders Kristensen
 * @since 1.1
 */
public class PropertySetterException extends Exception {
  protected Throwable rootCause;
  public
  PropertySetterException(String msg) {
    super(msg);
  }
  public
  PropertySetterException(Throwable rootCause)
  {
    super();
    this.rootCause = rootCause;
  }
  /**
     Returns descriptive text on the cause of this exception.
   */
  public
  String getMessage() {
    String msg = super.getMessage();
    if (msg == null && rootCause != null) {
      msg = rootCause.getMessage();
    }
    return msg;
  }
}"
org.apache.log4j.helpers.AbsoluteTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
/**
   Formats a {@link Date} in the format ""HH:mm:ss,SSS"" for example,
   ""15:49:37,459"".
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class AbsoluteTimeDateFormat extends DateFormat {
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.AbsoluteTimeDateFormat} in layouts. Current
     value is <b>ABSOLUTE</b>.  */
  public final static String ABS_TIME_DATE_FORMAT = ""ABSOLUTE"";
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.DateTimeDateFormat} in layouts.  Current
     value is <b>DATE</b>.
  */
  public final static String DATE_AND_TIME_DATE_FORMAT = ""DATE"";
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.ISO8601DateFormat} in layouts. Current
     value is <b>ISO8601</b>.
  */
  public final static String ISO8601_DATE_FORMAT = ""ISO8601"";
  public
  AbsoluteTimeDateFormat() {
    setCalendar(Calendar.getInstance());
  }
  public
  AbsoluteTimeDateFormat(TimeZone timeZone) {
    setCalendar(Calendar.getInstance(timeZone));
  }
  /**
     Appends to <code>sbuf</code> the time in the format
     ""HH:mm:ss,SSS"" for example, ""15:49:37,459""
     @param date the date to format
     @param sbuf the string buffer to write to
     @param fieldPosition remains untouched
    */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    // We use a previously instantiated Date object to avoid the needless
    // creation of temporary objects. This saves a few micro-secs.
    calendar.setTime(date); 
    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    if(hour < 10) {
      sbuf.append('0');
    }
    sbuf.append(hour);
    sbuf.append(':');
    int mins = calendar.get(Calendar.MINUTE);
    if(mins < 10) {
      sbuf.append('0');
    }
    sbuf.append(mins);
    sbuf.append(':');
    int secs = calendar.get(Calendar.SECOND);
    if(secs < 10) {
      sbuf.append('0');
    }
    sbuf.append(secs);
    sbuf.append(',');
    int millis = calendar.get(Calendar.MILLISECOND);
    if(millis < 100) 
      sbuf.append('0');
    if(millis < 10) 
      sbuf.append('0');
    sbuf.append(millis);
    return sbuf;
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.AppenderAttachableImpl,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Appender;
import java.util.Vector;
import java.util.Enumeration;
/**
   A straightforward implementation of the {@link AppenderAttachable}
   interface.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AppenderAttachableImpl implements AppenderAttachable {
  /** Array of appenders. */
  protected Vector  appenderList;
  /**
     Attach an appender. If the appender is already in the list in
     won't be added again.
  */
  public
  void addAppender(Appender newAppender) {
    // Null values for newAppender parameter are strictly forbidden.
    if(newAppender == null)
      return;
    if(appenderList == null) {
      appenderList = new Vector(1);
    }
    if(!appenderList.contains(newAppender))
      appenderList.addElement(newAppender);
  }
  /**
     Call the <code>doAppend</code> method on all attached appenders.  */
  public
  int appendLoopOnAppenders(LoggingEvent event) {
    int size = 0;
    Appender appender;
    if(appenderList != null) {
      size = appenderList.size();
      for(int i = 0; i < size; i++) {
	appender = (Appender) appenderList.elementAt(i);
	appender.doAppend(event);
      }
    }    
    return size;
  }
  /**
     Get all attached appenders as an Enumeration. If there are no
     attached appenders <code>null</code> is returned.
     @return Enumeration An enumeration of attached appenders.
   */
  public
  Enumeration getAllAppenders() {
    if(appenderList == null)
      return null;
    else 
      return appenderList.elements();    
  }
  /**
     Look for an attached appender named as <code>name</code>.
     <p>Return the appender with that name if in the list. Return null
     otherwise.  
   */
  public
  Appender getAppender(String name) {
     if(appenderList == null || name == null)
      return null;
     int size = appenderList.size();
     Appender appender;
     for(int i = 0; i < size; i++) {
       appender = (Appender) appenderList.elementAt(i);
       if(name.equals(appender.getName()))
	  return appender;
     }
     return null;    
  }
  /**
     Remove all previously attached appenders.
  */
  public
  void removeAllAppenders() {
    if(appenderList != null) {
      int len = appenderList.size();      
      for(int i = 0; i < len; i++) {
	Appender a = (Appender) appenderList.elementAt(i);
	a.close();
      }
      appenderList.removeAllElements();
      appenderList = null;      
    }
  }
  /**
     Remove the appender passed as parameter form the list of attached
     appenders.  */
  public
  void removeAppender(Appender appender) {
    if(appender == null || appenderList == null) 
      return;
    appenderList.removeElement(appender);    
  }
 /**
    Remove the appender with the name passed as parameter form the
    list of appenders.  
  */
  public
  void removeAppender(String name) {
    if(name == null || appenderList == null) return;
    int size = appenderList.size();
    for(int i = 0; i < size; i++) {
      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {
	 appenderList.removeElementAt(i);
	 break;
      }
    }
  }
}
"
org.apache.log4j.helpers.BoundedFIFO,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
// Contributors:     Mathias Bogaert
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   <code>BoundedFIFO</code> serves as the bounded first-in-first-out
   buffer heavily used by the {@link org.apache.log4j.AsyncAppender}.
   @author Ceki G&uuml;lc&uuml; 
   @since version 0.9.1 */
public class BoundedFIFO {
  LoggingEvent[] buf;
  int numElements = 0;
  int first = 0;
  int next = 0;
  int maxSize;
  /**
     Instantiate a new BoundedFIFO with a maximum size passed as argument.
   */
  public
  BoundedFIFO(int maxSize) {
   if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    buf = new LoggingEvent[maxSize];
  }
  /**
     Get the first element in the buffer. Returns <code>null</code> if
     there are no elements in the buffer.  */
  public
  LoggingEvent get() {
    if(numElements == 0) 
      return null;
    LoggingEvent r = buf[first];
    if(++first == maxSize) {
	first = 0;
    }
    numElements--;    
    return r;    
  }
  /**
     Place a {@link LoggingEvent} in the buffer. If the buffer is full
     then the event is <b>silently dropped</b>. It is the caller's
     responsability to make sure that the buffer has free space.  */
  public 
  void put(LoggingEvent o) {
    if(numElements != maxSize) {      
      buf[next] = o;    
      if(++next == maxSize) {
	next = 0;
      }
      numElements++;
    }
  }
  /**
     Get the maximum size of the buffer.
   */
  public 
  int getMaxSize() {
    return maxSize;
  }
  /**
     Return <code>true</code> if the buffer is full, i.e. of the
     number of elements in the buffer equals the buffer size. */
  public 
  boolean isFull() {
    return numElements == maxSize;
  }
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElements;
  } 
  int min(int a, int b) {
    return a < b ? a : b;
  }
  /**
     Resize the buffer to a new size. If the new size is smaller than
     the old size events might be lost.
     @since 1.1
   */
  synchronized
  public 
  void resize(int newSize) {
    if(newSize == maxSize) 
      return;
   LoggingEvent[] tmp = new LoggingEvent[newSize];
   // we should not copy beyond the buf array
   int len1 = maxSize - first;
   // we should not copy beyond the tmp array
   len1 = min(len1, newSize);
   // er.. how much do we actually need to copy?
   // We should not copy more than the actual number of elements.
   len1 = min(len1, numElements);
   // Copy from buf starting a first, to tmp, starting at position 0, len1 elements.
   System.arraycopy(buf, first, tmp, 0, len1);
   // Are there any uncopied elements and is there still space in the new array?
   int len2 = 0;
   if((len1 < numElements) && (len1 < newSize)) {
     len2 = numElements - len1;
     len2 = min(len2, newSize - len1);
     System.arraycopy(buf, 0, tmp, len1, len2);
   }
   this.buf = tmp;
   this.maxSize = newSize;    
   this.first=0;   
   this.numElements = len1+len2;
   this.next = this.numElements;
   if(this.next == this.maxSize) // this should never happen, but again, it just might.
     this.next = 0;
  }
  /**
     Returns <code>true</code> if there is just one element in the
     buffer. In other words, if there were no elements before the last
     {@link #put} operation completed.  */
  public
  boolean wasEmpty() {
    return numElements == 1;
  }
  /**
      Returns <code>true</code> if the number of elements in the
      buffer plus 1 equals the maximum buffer size, returns
      <code>false</code> otherwise. */
  public
  boolean wasFull() {
    return (numElements+1 == maxSize);
  }
}
"
org.apache.log4j.helpers.CountingQuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.File;
import java.io.Writer;
import java.io.FileWriter;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
/**
   Counts the number of bytes written.
   @author Heinz Richter, heinz.richter@frogdot.com
   @since 0.8.1
   */
public class CountingQuietWriter extends QuietWriter {
  protected long count;
  public
  CountingQuietWriter(Writer writer, ErrorHandler eh) {
    super(writer, eh);
  }
  public
  void write(String string) {
    try {
      out.write(string);
      count += string.length();
    }
    catch(IOException e) {
      errorHandler.error(""Write failure."", e, ErrorCode.WRITE_FAILURE);
    }
  }
  public
  long getCount() {
    return count;
  }
  public
  void setCount(long count) {
    this.count = count;
  }
}
"
org.apache.log4j.helpers.CyclicBuffer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   CyclicBuffer is used by other appenders to hold {@link LoggingEvent
   LoggingEvents} for immediate or differed display.
   <p>This buffer gives read access to any element in the buffer not
   just the first or last element.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public class CyclicBuffer {
  LoggingEvent[] ea;
  int first; 
  int last; 
  int numElems;
  int maxSize;
  /**
     Instantiate a new CyclicBuffer of at most <code>maxSize</code> events.
     The <code>maxSize</code> argument must a positive integer.
     @param maxSize The maximum number of elements in the buffer.
  */
  public CyclicBuffer(int maxSize) throws IllegalArgumentException {
    if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    ea = new LoggingEvent[maxSize];
    first = 0;
    last = 0;
    numElems = 0;
  }
  /**
     Add an <code>event</code> as the last event in the buffer.
   */
  public
  void add(LoggingEvent event) {    
    ea[last] = event;    
    if(++last == maxSize)
      last = 0;
    if(numElems < maxSize)
      numElems++;
    else if(++first == maxSize)
      first = 0;
  }
  /**
     Get the <i>i</i>th oldest event currently in the buffer. If
     <em>i</em> is outside the range 0 to the number of elements
     currently in the buffer, then <code>null</code> is returned.
  */
  public
  LoggingEvent get(int i) {
    if(i < 0 || i >= numElems)
      return null;
    return ea[(first + i) % maxSize];
  }
  public 
  int getMaxSize() {
    return maxSize;
  }
  /**
     Get the oldest (first) element in the buffer. The oldest element
     is removed from the buffer.
  */
  public
  LoggingEvent get() {
    LoggingEvent r = null;
    if(numElems > 0) {
      numElems--;
      r = ea[first];
      ea[first] = null;
      if(++first == maxSize)
	first = 0;
    } 
    return r;
  }
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElems;
  } 
  /**
     Resize the cyclic buffer to <code>newSize</code>.
     @throws IllegalArgumentException if <code>newSize</code> is negative.
   */
  public 
  void resize(int newSize) {
    if(newSize < 0) {
      throw new IllegalArgumentException(""Negative array size [""+newSize+
					 ""] not allowed."");
    }
    if(newSize == numElems)
      return; // nothing to do
    LoggingEvent[] temp = new  LoggingEvent[newSize];
    int loopLen = newSize < numElems ? newSize : numElems;
    for(int i = 0; i < loopLen; i++) {
      temp[i] = ea[first];
      ea[first] = null;
      if(++first == numElems) 
	first = 0;
    }
    ea = temp;
    first = 0;
    numElems = loopLen;
    maxSize = newSize;
    if (loopLen == newSize) {
      last = 0;
    } else {
      last = loopLen;
    }
  }
}
"
org.apache.log4j.helpers.DateLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.text.FieldPosition;
/**
   This abstract layout takes care of all the date related options and
   formatting work.
   @author Ceki G&uuml;lc&uuml;
 */
abstract public class DateLayout extends Layout {
  /**
     String constant designating no time information. Current value of
     this constant is <b>NULL</b>.
  */
  public final static String NULL_DATE_FORMAT = ""NULL"";
  /**
     String constant designating relative time. Current value of
     this constant is <b>RELATIVE</b>.
   */
  public final static String RELATIVE_TIME_DATE_FORMAT = ""RELATIVE"";
  protected FieldPosition pos = new FieldPosition(0);
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String DATE_FORMAT_OPTION = ""DateFormat"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String TIMEZONE_OPTION = ""TimeZone"";  
  private String timeZoneID;
  private String dateFormatOption;  
  protected DateFormat dateFormat;
  protected Date date = new Date();
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  String[] getOptionStrings() {
    return new String[] {DATE_FORMAT_OPTION, TIMEZONE_OPTION};
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String option, String value) {
    if(option.equalsIgnoreCase(DATE_FORMAT_OPTION)) {
      dateFormatOption = value.toUpperCase();
    } else if(option.equalsIgnoreCase(TIMEZONE_OPTION)) {
      timeZoneID = value;
    }
  }
  /**
    The value of the <b>DateFormat</b> option should be either an
    argument to the constructor of {@link SimpleDateFormat} or one of
    the srings ""NULL"", ""RELATIVE"", ""ABSOLUTE"", ""DATE"" or ""ISO8601.
   */
  public
  void setDateFormat(String dateFormat) {
    if (dateFormat != null) {
        dateFormatOption = dateFormat.toUpperCase();
    }
    setDateFormat(dateFormatOption, TimeZone.getDefault());
  }
  /**
     Returns value of the <b>DateFormat</b> option.
   */
  public
  String getDateFormat() {
    return dateFormatOption;
  }
  /**
    The <b>TimeZoneID</b> option is a time zone ID string in the format
    expected by the {@link TimeZone#getTimeZone} method.
   */
  public
  void setTimeZone(String timeZone) {
    this.timeZoneID = timeZone;
  }
  /**
     Returns value of the <b>TimeZone</b> option.
   */
  public
  String getTimeZone() {
    return timeZoneID;
  }
  public
  void activateOptions() {
    setDateFormat(dateFormatOption);
    if(timeZoneID != null && dateFormat != null) {
      dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneID));
    }
  }
  public
  void dateFormat(StringBuffer buf, LoggingEvent event) {
    if(dateFormat != null) {
      date.setTime(event.timeStamp);
      dateFormat.format(date, buf, this.pos);
      buf.append(' ');
    }
  }
  /**
     Sets the {@link DateFormat} used to format time and date in the
     zone determined by <code>timeZone</code>.
   */
  public
  void setDateFormat(DateFormat dateFormat, TimeZone timeZone) {
    this.dateFormat = dateFormat;    
    this.dateFormat.setTimeZone(timeZone);
  }
  /**
     Sets the DateFormat used to format date and time in the time zone
     determined by <code>timeZone</code> parameter. The {@link DateFormat} used
     will depend on the <code>dateFormatType</code>.
     <p>The recognized types are {@link #NULL_DATE_FORMAT}, {@link
     #RELATIVE_TIME_DATE_FORMAT} {@link
     AbsoluteTimeDateFormat#ABS_TIME_DATE_FORMAT}, {@link
     AbsoluteTimeDateFormat#DATE_AND_TIME_DATE_FORMAT} and {@link
     AbsoluteTimeDateFormat#ISO8601_DATE_FORMAT}. If the
     <code>dateFormatType</code> is not one of the above, then the
     argument is assumed to be a date pattern for {@link
     SimpleDateFormat}.
  */
  public
  void setDateFormat(String dateFormatType, TimeZone timeZone) {
    if(dateFormatType == null) {
      this.dateFormat = null;
      return;
    } 
    if(dateFormatType.equalsIgnoreCase(NULL_DATE_FORMAT)) {
      this.dateFormat = null;
    } else if (dateFormatType.equalsIgnoreCase(RELATIVE_TIME_DATE_FORMAT)) {
      this.dateFormat =  new RelativeTimeDateFormat();
    } else if(dateFormatType.equalsIgnoreCase(
                             AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
      this.dateFormat =  new AbsoluteTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                        AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
      this.dateFormat =  new DateTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
      this.dateFormat =  new ISO8601DateFormat(timeZone);
    } else {
      this.dateFormat = new SimpleDateFormat(dateFormatType);
      this.dateFormat.setTimeZone(timeZone);
    }
  }
}
"
org.apache.log4j.helpers.DateTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;
/**
   Formats a {@link Date} in the format ""dd MMM YYYY HH:mm:ss,SSS"" for example,
   ""06 Nov 1994 15:49:37,459"". 
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class DateTimeDateFormat extends AbsoluteTimeDateFormat {
  String[] shortMonths;
  public
  DateTimeDateFormat() {
    super();
    shortMonths = new DateFormatSymbols().getShortMonths();
  }
  public
  DateTimeDateFormat(TimeZone timeZone) {
    this();
    setCalendar(Calendar.getInstance(timeZone));
  }
  /**
     Appends to <code>sbuf</code> the date in the format ""dd MMM YYYY
     HH:mm:ss,SSS"" for example, ""06 Nov 1994 08:49:37,459"".
     @param sbuf the string buffer to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    calendar.setTime(date);      
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');        
    sbuf.append(shortMonths[calendar.get(Calendar.MONTH)]);
    sbuf.append(' ');    
    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    sbuf.append(' ');
    return super.format(date, sbuf, fieldPosition);
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.FileWatchdog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */
// Contributors:  Mathias Bogaert
package org.apache.log4j.helpers;
import java.io.File;
import org.apache.log4j.helpers.LogLog;
/**
   Check every now and then that a certain file has not changed. If it
   has, then call the {@link #doOnChange} method.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public abstract class FileWatchdog extends Thread {
  /**
     The default delay between every file modification check, set to 60
     seconds.  */
  static final public long DEFAULT_DELAY = 60000; 
  /**
     The name of the file to observe  for changes.
   */
  protected String filename;
  /**
     The delay to observe between every check. By default set {@link
     #DEFAULT_DELAY}. */
  protected long delay = DEFAULT_DELAY; 
  File file;
  long lastModif = 0; 
  boolean warnedAlready = false;
  boolean interrupted = false;
  protected
  FileWatchdog(String filename) {
    this.filename = filename;
    file = new File(filename);
    setDaemon(true);
    checkAndConfigure();
  }
  /**
     Set the delay to observe between each check of the file changes.
   */
  public
  void setDelay(long delay) {
    this.delay = delay;
  }
  abstract 
  protected 
  void doOnChange();
  protected
  void checkAndConfigure() {
    boolean fileExists;
    try {
      fileExists = file.exists();
    } catch(SecurityException  e) {
      LogLog.warn(""Was not allowed to read check file existance, file:[""+
		  filename+""]."");
      interrupted = true; // there is no point in continuing
      return;
    }
    if(fileExists) {
      long l = file.lastModified(); // this can also throw a SecurityException
      if(l > lastModif) {           // however, if we reached this point this
	lastModif = l;              // is very unlikely.
	doOnChange();
	warnedAlready = false;
      }
    } else {
      if(!warnedAlready) {
	LogLog.debug(""[""+filename+""] does not exist."");
	warnedAlready = true;
      }
    }
  }
  public
  void run() {    
    while(!interrupted) {
      try {
	Thread.currentThread().sleep(delay);
      } catch(InterruptedException e) {
	// no interruption expected
      }
      checkAndConfigure();
    }
  }
}
"
org.apache.log4j.helpers.FormattingInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
/**
   FormattingInfo instances contain the information obtained when parsing
   formatting modifiers in conversion modifiers.
   @author <a href=mailto:jim_cakalic@na.biomerieux.com>Jim Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2   
 */
public class FormattingInfo {
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;
  void reset() {
    min = -1;
    max = 0x7FFFFFFF;
    leftAlign = false;      
  }
  void dump() {
    LogLog.debug(""min=""+min+"", max=""+max+"", leftAlign=""+leftAlign);
  }
}
"
org.apache.log4j.helpers.ISO8601DateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;
// Contributors: Arndt Schoenewald <arndt@ibm23093i821.mc.schoenewald.de>
/**
   Formats a {@link Date} in the format ""YYYY-mm-dd HH:mm:ss,SSS"" for example
   ""1999-11-27 15:49:37,459"".
   <p>Refer to the <a
   href=http://www.cl.cam.ac.uk/~mgk25/iso-time.html>summary of the
   International Standard Date and Time Notation</a> for more
   information on this format.
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class ISO8601DateFormat extends AbsoluteTimeDateFormat {
  public
  ISO8601DateFormat() {
  }
  public
  ISO8601DateFormat(TimeZone timeZone) {
    super(timeZone);
  }
  /**
     Appends a date in the format ""YYYY-mm-dd HH:mm:ss,SSS""
     to <code>sbuf</code>. For example: ""1999-11-27 15:49:37,459"".
     @param sbuf the <code>StringBuffer</code> to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    calendar.setTime(date);      
    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    String month;
    switch(calendar.get(Calendar.MONTH)) {
    case Calendar.JANUARY: month = ""-01-""; break;      
    case Calendar.FEBRUARY: month = ""-02-"";  break;     
    case Calendar.MARCH: month = ""-03-""; break;      
    case Calendar.APRIL: month = ""-04-"";  break;     
    case Calendar.MAY: month = ""-05-""; break;      
    case Calendar.JUNE: month = ""-06-"";  break;     
    case Calendar.JULY: month = ""-07-""; break;      
    case Calendar.AUGUST: month = ""-08-"";  break;     
    case Calendar.SEPTEMBER: month = ""-09-""; break;      
    case Calendar.OCTOBER: month = ""-10-""; break;      
    case Calendar.NOVEMBER: month = ""-11-"";  break;           
    case Calendar.DECEMBER: month = ""-12-"";  break;
    default: month = ""-NA-""; break;
    }
    sbuf.append(month);
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');    
    return super.format(date, sbuf, fieldPosition);
  }
  /**
    This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.Loader,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.net.URL;
//import java.awt.Image;
//import java.awt.Toolkit;
/**
   Load resources (or images) from various sources.
  @author Sven Reimers
  @author Ceki G&uuml;lc&uuml;
 */
public class Loader  { 
  static String TSTR = ""Caught Exception while in Loader.getResource. This may be innocuous."";
  /**
     This method will search for <code>resource</code> in different
     places. The rearch order is as follows:
     <ol>
     <p><li>Search for <code>fully/qualified/clazz/name/resource</code>
     with the {@link ClassLoader} that loaded <code>clazz</code>.
     <p><li>Search for <code>fully/qualified/clazz/name/resource</code>
     with the <code>null</code> (bootstrap) class loader.
     <p><li>Search for <code>resource</code> with the class loader
     that loaded <code>clazz</code>. 
     <pi><li>Try one last time with
     <code>ClassLoader.getSystemResource(resource)</code> 
     </ol>
  */
  static 
  public
  URL getResource(String resource, Class clazz) {
    URL url = null;
    // Is it under CLAZZ/resource somewhere in the classpath?    
    // where CLAZZ is the fully qualified name of clazz where dots have been
    // changed to directory separators
    LogLog.debug(""Trying to find [""+resource+""] using Class.getResource()."");
    try {
      url = clazz.getResource(resource);
      if(url != null) 
	return url;
    } catch (Throwable t) {
      LogLog.warn(TSTR,t);
    }
    // attempt to get the resource under CLAZZ/resource from the
    // system class path. The system class loader should not throw
    // InvalidJarIndexExceptions
    String fullyQualified = resolveName(resource, clazz);
    LogLog.debug(""Trying to find [""+fullyQualified+
		 ""] using ClassLoader.getSystemResource()."");
    url = ClassLoader.getSystemResource(fullyQualified);
    if(url != null) 
      return url;
    // Let the class loader of clazz and parents (by the delagation
    // property) seearch for resource
    ClassLoader loader = clazz.getClassLoader();
    if(loader != null) {
      try {
	LogLog.debug(""Trying to find [""+resource+""] using ""+loader
		     +"" class loader."");
	url = loader.getResource(resource); 
	if(url != null) 
	  return url;
      } catch(Throwable t) {
	LogLog.warn(TSTR, t);
      }
    }
    // Attempt to get the resource from the class path. It may be the
    // case that clazz was loaded by the Extentsion class loader which
    // the parent of the system class loader. Hence the code below.
    LogLog.debug(""Trying to find [""+resource+""] using ClassLoader.getSystemResource()."");
    url = ClassLoader.getSystemResource(resource);
    return url;
  }
  /**
     Add the fully qualified name of a class before resource (replace . with /).
   */
  static
  String resolveName(String resource, Class clazz) {
    String fqcn = clazz.getName();
    int index = fqcn.lastIndexOf('.');
    if (index != -1) {
      fqcn = fqcn.substring(0, index).replace('.', '/');
      resource = fqcn+""/""+resource;
    }
    return resource;
  }
  //public static Image getGIF_Image ( String path ) {
  //  Image img = null;
  //  try {
  //	URL url = ClassLoader.getSystemResource(path);
  //	System.out.println(url);
  //	img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
  //  }
  //  catch (Exception e) {
  //	System.out.println(""Exception occured: "" + e.getMessage() + 
  //			   "" - "" + e );
  //	      
  //  }
  //  return (img);
  //}
  //
  //public static Image getGIF_Image ( URL url ) {
  //  Image img = null;
  //  try {
  //	System.out.println(url);
  //	img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
  //  } catch (Exception e) {
  //	System.out.println(""Exception occured: "" + e.getMessage() + 
  //			   "" - "" + e );
  //	      
  //  }
  //  return (img);
  //}
  //
  //public static URL getHTML_Page ( String path ) {
  //  URL url = null;
  //  return (url = ClassLoader.getSystemResource(path));
  //  }    
}
"
org.apache.log4j.helpers.LogLog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
/**
   This class used to output log statements from within the log4j package.
   <p>Log4j components cannot make log4j logging calls. However, it is
   sometimes useful for the user to learn about what log4j is
   doing. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable.
   <p>All log4j internal debug calls go to <code>System.out</code>
   where as internal error messages are sent to
   <code>System.err</code>. All internal messages are prepended with
   the string ""log4j: "".
   @since 0.8.2
   @author Ceki G&uuml;lc&uuml;
*/
public class LogLog {
  /**
     Defining this value makes log4j print log4j-internal debug
     statements to <code>System.out</code>.
    <p> The value of this string is <b>log4j.debug</b>.
    <p>Note that the search for all option names is case sensitive.  */
  public static final String DEBUG_KEY=""log4j.debug"";
  /**
     Defining this value makes log4j components print log4j-internal
     debug statements to <code>System.out</code>.
    <p> The value of this string is <b>log4j.configDebug</b>.
    <p>Note that the search for all option names is case sensitive.  
    @deprecated Use {@link #DEBUG_KEY} instead.
  */
  public static final String CONFIG_DEBUG_KEY=""log4j.configDebug"";
  protected static boolean debugEnabled = false;  
  /**
     In quietMode not even errors generate any output.
   */
  private static boolean quietMode = false;
  private static final String PREFIX = ""log4j: "";
  private static final String ERR_PREFIX = ""log4j:ERROR "";
  private static final String WARN_PREFIX = ""log4j:WARN "";
  static {
    String key = OptionConverter.getSystemProperty(DEBUG_KEY, null);
    if(key == null) {
      key = OptionConverter.getSystemProperty(CONFIG_DEBUG_KEY, null);
    }
    if(key != null) { 
      debugEnabled = OptionConverter.toBoolean(key, true);
    }
  }
  /**
     Allows to enable/disable log4j internal logging.
   */
  static
  public
  void setInternalDebugging(boolean enabled) {
    debugEnabled = enabled;
  }
  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
    }
  }
  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg, Throwable t) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
      if(t != null)
	t.printStackTrace(System.out);
    }
  }
  /**
     This method is used to output log4j internal error
     statements. There is no way to disable error statements.
     Output goes to <code>System.err</code>.
  */
  public
  static
  void error(String msg) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
  }  
  /**
     This method is used to output log4j internal error
     statements. There is no way to disable error statements.
     Output goes to <code>System.err</code>.  
  */
  public
  static
  void error(String msg, Throwable t) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
  /**
     In quite mode no LogLog generates strictly no output, not even
     for errors. 
     @param quietMode A true for not
  */
  public
  static
  void setQuietMode(boolean quietMode) {
    LogLog.quietMode = quietMode;
  }
  /**
     This method is used to output log4j internal warning
     statements. There is no way to disable warning statements.
     Output goes to <code>System.err</code>.  */
  public
  static
  void warn(String msg) {
    if(quietMode)
      return;
    System.err.println(WARN_PREFIX+msg);
  }  
  /**
     This method is used to output log4j internal warnings. There is
     no way to disable warning statements.  Output goes to
     <code>System.err</code>.  */
  public
  static
  void warn(String msg, Throwable t) {
    if(quietMode)
      return;
    System.err.println(WARN_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
}
"
org.apache.log4j.helpers.NullEnumeration,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.util.Enumeration;
import java.util.NoSuchElementException;
/**
  An always-empty Enumerator.
  @author Anders Kristensen
  @since version 1.0
 */
public class NullEnumeration implements Enumeration {
  private static final NullEnumeration instance = new NullEnumeration();
  private
  NullEnumeration() {
  }
  public
  static
  NullEnumeration getInstance() {
    return instance;
  }
  public
  boolean hasMoreElements() {
    return false;
  }
  public
  Object nextElement() {
    throw new NoSuchElementException();
  }
}
"
org.apache.log4j.helpers.OnlyOnceErrorHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import  org.apache.log4j.spi.ErrorHandler;
/**
   The <code>OnlyOnceErrorHandler</code> implements log4j's default
   error handling policy which consists of emitting a message for the
   first error in an appender and ignoring all following errors.
   <p>The error message is printed on <code>System.err</code>. 
   <p>This policy aims at protecting an otherwise working application
   from being flooded with error messages when logging fails.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class OnlyOnceErrorHandler implements ErrorHandler {
  final String WARN_PREFIX = ""log4j warning: "";
  final String ERROR_PREFIX = ""log4j error: "";
  boolean firstTime = true;
  /**
     Returns <code>null</code> as <code>OnlyOnceErrorHandler</code>
     has no options. 
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
 */
  public
  String[] getOptionStrings() {
    return null;
  }
  /**
     No options to set.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
  }
  /**
     No options to activate.
  */
  public
  void activateOptions() {
  }
  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.  */
  public
  void error(String message, Exception e, int errorCode) { 
    if(firstTime) {
      LogLog.error(message, e);
      firstTime = false;
    }
  }
  /**
     Returns <code>null</code> as <code>OnlyOnceErrorHandler</code>
     has no options.  
  public
  String[] getOptionStrings() {
    return null;
  }*/
  /**
     No options to set.
  public
  void setOption(String key, String value) {
  }
  */
  /**
     No options to get.
  public
  String getOption(String key) {
    return null;
  }
  */
  /**
     Print a the error message passed as parameter on
     <code>System.err</code>.  
  */
  public
  void error(String message) {
    if(firstTime) {
      LogLog.error(message);
      firstTime = false;
    }
  }
}
"
org.apache.log4j.helpers.OptionConverter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.util.Properties;
import java.net.URL;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.PropertyConfigurator;
// Contributors:   Avy Sharell (sharell@online.fr)
//                 Anders Kristensen
//                 Matthieu Verbert (mve@zurich.ibm.com)
/**
   A convenience class to convert property values to specific types.
   @author Ceki G&uuml;lc&uuml;
   @author Simon Kitching;
*/	
public class OptionConverter {
  static String DELIM_START = ""${"";
  static char   DELIM_STOP  = '}';
  static int DELIM_START_LEN = 2;
  static int DELIM_STOP_LEN  = 1;
  static StringBuffer sbuf = new StringBuffer();
  /** OptionConverter is a static class. */
  private OptionConverter() {}
  public
  static
  String[] concatanateArrays(String[] l, String[] r) {
    int len = l.length + r.length;
    String[] a = new String[len];
    System.arraycopy(l, 0, a, 0, l.length);
    System.arraycopy(r, 0, a, l.length, r.length);
    return a;
  }
  public
  static
  String convertSpecialChars(String s) {
    char c;
    int len = s.length();
    StringBuffer sbuf = new StringBuffer(len);
    int i = 0;
    while(i < len) {
      c = s.charAt(i++);
      if (c == '\\') {
	c =  s.charAt(i++);
	if(c == 'n')      c = '\n';
	else if(c == 'r') c = '\r';
	else if(c == 't') c = '\t';
	else if(c == 'f') c = '\f';
	else if(c == '\b') c = '\b';					
	else if(c == '\""') c = '\""';				
	else if(c == '\'') c = '\'';			
	else if(c == '\\') c = '\\';			
      }
      sbuf.append(c);      
    }
    return sbuf.toString();
  }
  /**
     Very similar to <code>System.getProperty</code> except
     that the {@link SecurityException} is hidden.
     @param key The key to search for.
     @param def The default value to return.
     @return the string value of the system property, or the default
     value if there is no property with that key.
     @since 1.1 */
  public
  static
  String getSystemProperty(String key, String def) {
    try {
      return System.getProperty(key, def);
    } catch(Throwable e) { // MS-Java throws com.ms.security.SecurityExceptionEx 
      LogLog.debug(""Was not allowed to read system property \""""+key+""\""."");
      return def;
    }
  }
  public
  static
  Object instantiateByKey(Properties props, String key, Class superClass,
				Object defaultValue) {
    // Get the value of the property in string form
    String className = findAndSubst(key, props);
    if(className == null) {
      LogLog.error(""Could not find value for key "" + key);
      return defaultValue;
    }
    // Trim className to avoid trailing spaces that cause problems.
    return OptionConverter.instantiateByClassName(className.trim(), superClass,
						  defaultValue);
  }
  /**
     If <code>value</code> is ""true"", then <code>true</code> is
     returned. If <code>value</code> is ""false"", then
     <code>true</code> is returned. Otherwise, <code>default</code> is
     returned.
     <p>Case of value is unimportant.  */
  public
  static
  boolean toBoolean(String value, boolean dEfault) {
    if(value == null)
      return dEfault;
    String trimmedVal = value.trim();
    if(""true"".equalsIgnoreCase(trimmedVal)) 
      return true;
    if(""false"".equalsIgnoreCase(trimmedVal))
      return false;
    return dEfault;
  }
  public
  static
  int toInt(String value, int dEfault) {
    if(value != null) {
      String s = value.trim();
      try {
	return Integer.valueOf(s).intValue();
      }
      catch (NumberFormatException e) {
	 LogLog.error(""["" + s + ""] is not in proper int form."");
	e.printStackTrace();
      }
    }
    return dEfault;
  }
  /**
     Converts a standard or custom priority level to a Priority
     object.  <p> If <code>value</code> is of form
     ""priority#classname"", then the specified class' toPriority method
     is called to process the specified priority string; if no '#'
     character is present, then the default {@link org.apache.log4j.Priority}
     class is used to process the priority value.  
     <p> If any error occurs while converting the value to a priority,
     the dflt value (which may be null) is returned.  
     <p> Case of
     value is unimportant for the priority level, but is significant
     for any class name part present.  
     @since 1.1
  */
  public
  static
  Priority toPriority(String value, Priority defaultValue) {
    if(value == null)
      return defaultValue;
    int hashIndex = value.indexOf('#');
    if (hashIndex == -1) {
      // no class name specified : use standard Priority class
      return Priority.toPriority(value, defaultValue);
    }
    Priority result = defaultValue;
    String clazz = value.substring(hashIndex+1);
    String priorityName = value.substring(0, hashIndex);
    LogLog.debug(""toPriority"" + "":class=["" + clazz + ""]"" 
		 + "":pri=["" + priorityName + ""]"");
    try {
      Class customPriority = Class.forName(clazz);
      // get a ref to the specified class' static method
      // toPriority(String, org.apache.log4j.Priority)
      Class[] paramTypes = new Class[] { String.class,
					 org.apache.log4j.Priority.class
                                       };
      java.lang.reflect.Method toPriorityMethod =
                      customPriority.getMethod(""toPriority"", paramTypes);
      // now call the toPriority method, passing priority string + default
      Object[] params = new Object[] {priorityName, defaultValue};
      Object o = toPriorityMethod.invoke(null, params);
      result = (Priority) o;
    } catch(ClassNotFoundException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""] not found."");
    } catch(NoSuchMethodException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""]""
        + "" does not have a constructor which takes one string parameter"", e);
    } catch(java.lang.reflect.InvocationTargetException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""]""
		   + "" could not be instantiated"", e);
    } catch(ClassCastException e) {
      LogLog.warn(""class ["" + clazz
        + ""] is not a subclass of org.apache.log4j.Priority"", e);
    } catch(IllegalAccessException e) {
      LogLog.warn(""class [""+clazz+
		   ""] cannot be instantiated due to access restrictions"", e);
    } catch(Exception e) {
      LogLog.warn(""class [""+clazz+""], priority [""+priorityName+
		   ""] conversion failed."", e);
    }
    return result;
   }
  public
  static
  long toFileSize(String value, long dEfault) {
    if(value == null)
      return dEfault;
    String s = value.trim().toUpperCase();
    long multiplier = 1;
    int index;
    if((index = s.indexOf(""KB"")) != -1) {      
      multiplier = 1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""MB"")) != -1) {
      multiplier = 1024*1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""GB"")) != -1) {
      multiplier = 1024*1024*1024;
      s = s.substring(0, index);
    }    
    if(s != null) {
      try {
	return Long.valueOf(s).longValue() * multiplier;
      }
      catch (NumberFormatException e) {
	LogLog.error(""["" + s + ""] is not in proper int form."");
	LogLog.error(""["" + value + ""] not in expected format."", e);
      }
    }
    return dEfault;
  }
  /**
     Find the value corresponding to <code>key</code> in
     <code>props</code>. Then perform variable substitution on the
     found value.
 */
  public
  static
  String findAndSubst(String key, Properties props) {
    String value = props.getProperty(key);
    if(value == null) 
      return null;      
    try {
      return substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.error(""Bad option value [""+value+""]."", e);
      return value;
    }    
  }
  /**
     Instantiate an object given a class name. Check that the
     <code>className</code> is a subclass of
     <code>superClass</code>. If that test fails or the object could
     not be instantiated, then <code>defaultValue</code> is returned.
     @param className The fully qualified class name of the object to instantiate.
     @param superClass The class to which the new object should belong.
     @param defaultValue The object to return in case of non-fulfillment
   */
  public
  static
  Object instantiateByClassName(String className, Class superClass,
				Object defaultValue) {
    if(className != null) {
      try {
	Class classObj = Class.forName(className);
	if(!superClass.isAssignableFrom(classObj)) {
	  LogLog.error(""A \""""+className+""\"" object is not assignable to a \""""+
		       superClass.getName() + ""\"" variable."");
	  return defaultValue;	  
	}
	return classObj.newInstance();
      }
      catch (Exception e) {
	LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      }
    }
    return defaultValue;    
  }
  /**
     Perform variable substitution in string <code>val</code> from the
     values of keys found in the system propeties.
     <p>The variable substitution delimeters are <b>${</b> and <b>}</b>.
     <p>For example, if the System properties contains ""key=value"", then
     the call
     <pre>
     String s = OptionConverter.substituteVars(""Value of key is ${key}."");
     </pre>
     will set the variable <code>s</code> to ""Value of key is value."".
     <p>If no value could be found for the specified key, then the
     <code>props</code> parameter is searched, if the value could not
     be found there, then substitution defaults to the empty string.
     <p>For example, if system propeties contains no value for the key
     ""inexistentKey"", then the call
     <pre>
     String s = OptionConverter.subsVars(""Value of inexistentKey is [${inexistentKey}]"");
     </pre>
     will set <code>s</code> to ""Value of inexistentKey is []""     
     <p>An {@link java.lang.IllegalArgumentException} is thrown if
     <code>val</code> contains a start delimeter ""${"" which is not
     balanced by a stop delimeter ""}"". </p>
     <p><b>Author</b> Avy Sharell</a></p>
     @param val The string on which variable substitution is performed.
     @throws IllegalArgumentException if <code>val</code> is malformed.
  */
  public static
  String substVars(String val, Properties props) throws
                        IllegalArgumentException {
    sbuf.setLength(0);
    int i = 0;
    int j, k;
    while(true) {
      j=val.indexOf(DELIM_START, i);
      if(j == -1) {
	if(i==0)
	  return val;
	else {
	  sbuf.append(val.substring(i, val.length()));
	  return sbuf.toString();
	}
      }
      else {
	sbuf.append(val.substring(i, j));
	k = val.indexOf(DELIM_STOP, j);
	if(k == -1) {
	  throw new IllegalArgumentException('""'+val+
		      ""\"" has no closing brace. Opening brace at position "" + j 
					     + '.');
	}
	else {
	  j += DELIM_START_LEN;
	  String key = val.substring(j, k);
	  // first try in System properties
	  String replacement = getSystemProperty(key, null);
	  // then try props parameter
	  if(replacement == null && props != null) {
	    replacement =  props.getProperty(key);
	  }
	  if(replacement != null) 
	    sbuf.append(replacement);
	  i = k + DELIM_STOP_LEN;	    
	}
      }
    }
  }
  /**
     Configure log4j given a URL. 
     <p>The URL format is important. Its <em>reference</em> part is
     taken as the class name of the configurator. For example, if you
     invoke your application using the command line
     <pre> java -Dlog4j.configuration=file:/temp/myconfig.xyz#com.myCompany.myConfigurator
     </pre>
     then the log4j will be configured by a new instance of
     <code>com.myCompany.myConfigurator</code> by interpreting the
     file referenced by <code>file:/temp/myconfig.xyz</code>.  The
     configurator you specify <em>must</em> implement the {@link
     Configurator} interface.
     <p>If the URL has no reference part, then the {@link
     PropertyConfigurator} will parse the URL. However, if the URL
     ends with a "".xml"" extension, then the {@link DOMConfigurator}
     will be used to parse the URL.
     <p>All configurations steps are taken on the
     <code>hierarchy</code> passed as parameter.
     @author based on code written by Anders Kristensen
     @since 1.0 */
  static
  public
  void selectAndConfigure(URL url, Hierarchy hierarchy) {
    String clazz = url.getRef();
    Configurator configurator = null;
    if(clazz != null) {
      LogLog.debug(""Preferred configurator class: "" + clazz);
      configurator = (Configurator) instantiateByClassName(clazz, 
							   Configurator.class,
							   null);
      if(configurator == null) {
	LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
	return;
      }
    } else {
      String filename = url.getFile();
      if(filename != null && filename.endsWith("".xml"")) {
	try {
	  configurator = new DOMConfigurator();
	} catch(NoClassDefFoundError e) {
	  LogLog.warn(""Could not find DOMConfigurator!"", e);
	  return;
	}
      } else {
	configurator = new PropertyConfigurator();
      }
    }
    configurator.doConfigure(url, hierarchy);
  }
}
"
org.apache.log4j.helpers.PatternConverter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   <p>PatternConverter is an abtract class that provides the
   formatting functionality that derived classes need.
   <p>Conversion specifiers in a conversion patterns are parsed to
   individual PatternConverters. Each of which is responsible for
   converting a logging event in a converter specific manner.
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2
 */
public abstract class PatternConverter {
  public PatternConverter next;
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;
  protected
  PatternConverter() {  }
  protected
  PatternConverter(FormattingInfo fi) {
    min = fi.min;
    max = fi.max;
    leftAlign = fi.leftAlign;
  }
  /**
     Derived pattern converters must override this method in order to
     convert conversion specifiers in the correct way.
  */
  abstract
  protected
  String convert(LoggingEvent event);
  /**
     A template method for formatting in a converter specific way.
   */
  public
  void format(StringBuffer sbuf, LoggingEvent e) {
    String s = convert(e);
    if(s == null) {
      if(0 < min)
	spacePad(sbuf, min);
      return;
    }
    int len = s.length();
    if(len > max)
      sbuf.append(s.substring(len-max));
    else if(len < min) {
      if(leftAlign) {	
	sbuf.append(s);
	spacePad(sbuf, min-len);
      }
      else {
	spacePad(sbuf, min-len);
	sbuf.append(s);
      }
    }
    else
      sbuf.append(s);
  }	
  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32 spaces
  /**
     Fast space padding method.
  */
  public
  void spacePad(StringBuffer sbuf, int length) {
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org.apache.log4j.helpers.PatternParser,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.Layout;
import org.apache.log4j.NDC;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
// Contributors:   Nelson Minar <(nelson@monkey.org>
//                 Igor E. Poteryaev <jah@mail.ru>  
//                 Reinhard Deschler <reinhard.deschler@web.de> 
/**
   Most of the work of the {@link org.apache.log4j.PatternLayout} class
   is delegated to the PatternParser class.
   <p>It is this class that parses conversion patterns and creates
   a chained list of {@link OptionConverter OptionConverters}.
   @author <a href=mailto:""cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen       
   @since 0.8.2
*/
public class PatternParser {
  private static final char ESCAPE_CHAR = '%';
  private static final int LITERAL_STATE = 0;
  private static final int CONVERTER_STATE = 1;
  private static final int MINUS_STATE = 2;
  private static final int DOT_STATE = 3;
  private static final int MIN_STATE = 4;
  private static final int MAX_STATE = 5;
  static final int FULL_LOCATION_CONVERTER = 1000;
  static final int METHOD_LOCATION_CONVERTER = 1001;
  static final int CLASS_LOCATION_CONVERTER = 1002;
  static final int LINE_LOCATION_CONVERTER = 1003;
  static final int FILE_LOCATION_CONVERTER = 1004;    
  static final int RELATIVE_TIME_CONVERTER = 2000;
  static final int THREAD_CONVERTER = 2001;
  static final int PRIORITY_CONVERTER = 2002;
  static final int NDC_CONVERTER = 2003;
  static final int MESSAGE_CONVERTER = 2004;
  int state;
  protected StringBuffer currentLiteral = new StringBuffer(32);
  protected int patternLength;
  protected int i;
  PatternConverter head;
  PatternConverter tail;
  protected FormattingInfo formattingInfo = new FormattingInfo();
  protected String pattern;
  public
  PatternParser(String pattern) {
    this.pattern = pattern;
    patternLength =  pattern.length();    
    state = LITERAL_STATE;
  }
  private
  void  addToList(PatternConverter pc) {
    if(head == null) {
      head = tail = pc;
    } else {
      tail.next = pc;
      tail = pc;    
    }
  }
  private
  String extractOption() {
    if((i < patternLength) && (pattern.charAt(i) == '{')) {
      int end = pattern.indexOf('}', i);	
      if (end > i) {
	String r = pattern.substring(i + 1, end);
	i = end+1;
	return r;
      }
    }
    return null;
  }
  /**
     The option is expected to be in decimal and positive. In case of
     error, zero is returned.  */
  private
  int extractPrecisionOption() {
    String opt = extractOption();
    int r = 0;
    if(opt != null) {
      try {
	r = Integer.parseInt(opt);
	if(r <= 0) {
	    LogLog.error(
	        ""Precision option ("" + opt + "") isn't a positive integer."");
	    r = 0;
	}
      }      
      catch (NumberFormatException e) {
	LogLog.error(""Category option \""""+opt+""\"" not a decimal integer."", e);
      }      
    }
    return r;    
  }
  public 
  PatternConverter parse() {
    char c;
    i = 0;
    while(i < patternLength) {
      c = pattern.charAt(i++);
      switch(state) {
      case LITERAL_STATE: 
        // In literal state, the last char is always a literal.
        if(i == patternLength) {
          currentLiteral.append(c);
          continue;
        }
        if(c == ESCAPE_CHAR) {      
          // peek at the next char. 
          switch(pattern.charAt(i)) {
          case ESCAPE_CHAR:
            currentLiteral.append(c);
            i++; // move pointer
            break;
          case 'n':
            currentLiteral.append(Layout.LINE_SEP);
            i++; // move pointer
            break;
          default:
            if(currentLiteral.length() != 0) {
              addToList(new LiteralPatternConverter(
                                                  currentLiteral.toString()));
              //LogLog.debug(""Parsed LITERAL converter: \"""" 
              //           +currentLiteral+""\""."");
            }
            currentLiteral.setLength(0); 
            currentLiteral.append(c); // append %
            state = CONVERTER_STATE;
            formattingInfo.reset();
          }
        }
        else {
          currentLiteral.append(c);
        }
        break;
      case CONVERTER_STATE:
	currentLiteral.append(c);
	switch(c) {
	case '-':
	  formattingInfo.leftAlign = true;
	  break;
	case '.':
	  state = DOT_STATE;
	  break;
	default:
	  if(c >= '0' && c <= '9') {
	    formattingInfo.min = c - '0';
	    state = MIN_STATE;
	  }
	  else 
	    finalizeConverter(c);	    
	} // switch
	break;
      case MIN_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.min = formattingInfo.min*10 + (c - '0');
	else if(c == '.')
	  state = DOT_STATE;
	else {
	  finalizeConverter(c);
	}
	break;
      case DOT_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') {
	  formattingInfo.max = c - '0';
	   state = MAX_STATE;
	}
	else {
	  LogLog.error(""Error occured in position ""+i
		     +"".\n Was expecting digit, instead got char \""""+c+""\""."");
	  state = LITERAL_STATE;
	}
	break;
      case MAX_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.max = formattingInfo.max*10 + (c - '0');
	else {
	  finalizeConverter(c);
	  state = LITERAL_STATE;
	}
	break;
      } // switch
    } // while
    if(currentLiteral.length() != 0) {
      addToList(new LiteralPatternConverter(currentLiteral.toString()));
      //LogLog.debug(""Parsed LITERAL converter: \""""+currentLiteral+""\""."");
    }
    return head;
  }
  protected
  void finalizeConverter(char c) {
    PatternConverter pc = null;
    switch(c) {
    case 'c':
      pc = new CategoryPatternConverter(formattingInfo,
					extractPrecisionOption());	
      //LogLog.debug(""CATEGORY converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;     
    case 'C':
      pc = new ClassNamePatternConverter(formattingInfo,
					 extractPrecisionOption());
      //LogLog.debug(""CLASS_NAME converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'd':
      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;
      DateFormat df;
      String dOpt = extractOption();
      if(dOpt != null)
	dateFormatStr = dOpt;
      if(dateFormatStr.equalsIgnoreCase(
                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) 
	df = new  ISO8601DateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
	df = new AbsoluteTimeDateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
	df = new DateTimeDateFormat();
      else {
	try {
	  df = new SimpleDateFormat(dateFormatStr);
	}
	catch (IllegalArgumentException e) {
	  LogLog.error(""Could not instantiate SimpleDateFormat with "" +
		       dateFormatStr, e);
	  df = (DateFormat) OptionConverter.instantiateByClassName(
			           ""org.apache.log4j.helpers.ISO8601DateFormat"",
				   DateFormat.class, null);
	}	
      }
      pc = new DatePatternConverter(formattingInfo, df);
      //LogLog.debug(""DATE converter {""+dateFormatStr+""}."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'F':
      pc = new LocationPatternConverter(formattingInfo,
					FILE_LOCATION_CONVERTER);
      //LogLog.debug(""File name converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'l':
      pc = new LocationPatternConverter(formattingInfo,
					FULL_LOCATION_CONVERTER);
      //LogLog.debug(""Location converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'L':
      pc = new LocationPatternConverter(formattingInfo,
					LINE_LOCATION_CONVERTER);
      //LogLog.debug(""LINE NUMBER converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'm':
      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);
      //LogLog.debug(""MESSAGE converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'M':
      pc = new LocationPatternConverter(formattingInfo,
					METHOD_LOCATION_CONVERTER);
      //LogLog.debug(""METHOD converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'p':
      pc = new BasicPatternConverter(formattingInfo, PRIORITY_CONVERTER);
      //LogLog.debug(""PRIORITY converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'r':
      pc = new BasicPatternConverter(formattingInfo, 
					 RELATIVE_TIME_CONVERTER);
      //LogLog.debug(""RELATIVE time converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 't':
      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);
      //LogLog.debug(""THREAD converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
      /*case 'u':
      if(i < patternLength) {
	char cNext = pattern.charAt(i);
	if(cNext >= '0' && cNext <= '9') {
	  pc = new UserFieldPatternConverter(formattingInfo, cNext - '0');
	  LogLog.debug(""USER converter [""+cNext+""]."");
	  formattingInfo.dump();      
	  currentLiteral.setLength(0);
	  i++;
	}
	else 
	  LogLog.error(""Unexpected char"" +cNext+"" at position ""+i);
      }
      break;*/
    case 'x':
      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);
      //LogLog.debug(""NDC converter."");      
      currentLiteral.setLength(0);
      break;
    default:
      LogLog.error(""Unexpected char ["" +c+""] at position ""+i
		   +"" in conversion patterrn."");
      pc = new LiteralPatternConverter(currentLiteral.toString());
      currentLiteral.setLength(0);
    }
    addConverter(pc);
  }
  protected
  void addConverter(PatternConverter pc) {
    currentLiteral.setLength(0);
    // Add the pattern converter to the list.
    addToList(pc);
    // Next pattern is assumed to be a literal.
    state = LITERAL_STATE;
    // Reset formatting info
    formattingInfo.reset();
  }
  // ---------------------------------------------------------------------
  //                      PatternConverters
  // ---------------------------------------------------------------------
  private static class BasicPatternConverter extends PatternConverter {
    int type;
    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);     
      this.type = type;
    }
    public
    String convert(LoggingEvent event) {
      switch(type) {
      case RELATIVE_TIME_CONVERTER: 
	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));
      case THREAD_CONVERTER:
	return event.getThreadName();
      case PRIORITY_CONVERTER:
	return event.priority.toString();
      case NDC_CONVERTER:  
	return event.getNDC();
      case MESSAGE_CONVERTER: {
	return event.getRenderedMessage();
      }
      default: return null;
      }
    }
  }
  private static class LiteralPatternConverter extends PatternConverter {
    private String literal;
    LiteralPatternConverter(String value) {
      literal = value;
    }
    public
    final
    void format(StringBuffer sbuf, LoggingEvent event) {
      sbuf.append(literal);
    }
    public    
    String convert(LoggingEvent event) {
      return literal;
    }
  }
  private static class DatePatternConverter extends PatternConverter {
    private DateFormat df;
    private Date date;
    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
      super(formattingInfo);
      date = new Date();
      this.df = df;      
    }
    public
    String convert(LoggingEvent event) {
      date.setTime(event.timeStamp);
      String converted = null;
      try {
        converted = df.format(date);
      }
      catch (Exception ex) {
        LogLog.error(""Error occured while converting date."", ex);
      }
      return converted;
    }
  }
  private class LocationPatternConverter extends PatternConverter {
    int type;
    LocationPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }
    public
    String convert(LoggingEvent event) {
      LocationInfo locationInfo = event.getLocationInformation();
      switch(type) {
      case FULL_LOCATION_CONVERTER: 
	return locationInfo.fullInfo;
      case METHOD_LOCATION_CONVERTER: 
	return locationInfo.getMethodName();
      case LINE_LOCATION_CONVERTER: 
	return locationInfo.getLineNumber();
      case FILE_LOCATION_CONVERTER: 
	return locationInfo.getFileName();
      default: return null;
      }
    }
  }
  private static abstract class NamedPatternConverter extends PatternConverter {
    int precision;
    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo);
      this.precision =  precision;      
    }
    abstract
    String getFullyQualifiedName(LoggingEvent event);
    public
    String convert(LoggingEvent event) {
      String n = getFullyQualifiedName(event);
      if(precision <= 0)
	return n;
      else {
	int len = n.length();
	// We substract 1 from 'len' when assigning to 'end' to avoid out of
	// bounds exception in return r.substring(end+1, len). This can happen if
	// precision is 1 and the category name ends with a dot. 
	int end = len -1 ;
	for(int i = precision; i > 0; i--) {	  
	  end = n.lastIndexOf('.', end-1);
	  if(end == -1)
	    return n;
	}
	return n.substring(end+1, len);
      }      
    }
  }
  private class ClassNamePatternConverter extends NamedPatternConverter {
    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    String getFullyQualifiedName(LoggingEvent event) {
      return event.getLocationInformation().getClassName();
    }
  }
  private class CategoryPatternConverter extends NamedPatternConverter {
    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    String getFullyQualifiedName(LoggingEvent event) {
      return event.categoryName;
    }
  }  
}
"
org.apache.log4j.helpers.QuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
/**
   QuietWriter does not throw exceptions when things go
   wrong. Instead, it delegates error handling to its {@link ErrorHandler}. 
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.3
*/
public class QuietWriter extends FilterWriter {
  protected ErrorHandler errorHandler;
  public
  QuietWriter(Writer writer, ErrorHandler errorHandler) {
    super(writer);
    setErrorHandler(errorHandler);
  }
  public
  void write(String string) {
    try {
      out.write(string);
    } catch(IOException e) {
      errorHandler.error(""Failed to write [""+string+""]."", e, 
			 ErrorCode.WRITE_FAILURE);
    }
  }
  public
  void flush() {
    try {
      out.flush();
    } catch(IOException e) {
      errorHandler.error(""Failed to flush writer,"", e, 
			 ErrorCode.FLUSH_FAILURE);
    }	
  }
  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // This is a programming error on the part of the enclosing appender.
      throw new IllegalArgumentException(""Attempted to set null ErrorHandler."");
    } else { 
      this.errorHandler = eh;
    }
  }
}
"
org.apache.log4j.helpers.RelativeTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
/**
   Formats a {@link Date} by printing the number of milliseconds
   elapsed since the start of the application.  This is the fastest
   printing DateFormat in the package.
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class RelativeTimeDateFormat extends DateFormat {
  protected final long startTime;
  public
  RelativeTimeDateFormat() {
    this.startTime = System.currentTimeMillis();
  }
  /**
     Appends to <code>sbuf</code> the number of milliseconds elapsed
     since the start of the application. 
     @since 0.7.5
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    //System.err.println("":""+ date.getTime() + "" - "" + startTime);
    return sbuf.append((date.getTime() - startTime));
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.SyslogQuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
/**
   SyslogQuietWriter extends QuietWriter by prepending the syslog
   priority code before each printed String.
   @since 0.7.3
*/
public class SyslogQuietWriter extends QuietWriter {
  int syslogFacility;
  int priority;
  public
  SyslogQuietWriter(Writer writer, int syslogFacility, ErrorHandler eh) {
    super(writer, eh);
    this.syslogFacility = syslogFacility;
  }
  public
  void setPriority(int priority) {
    this.priority = priority;
  }
  public
  void setSyslogFacility(int syslogFacility) {
    this.syslogFacility = syslogFacility;
  }
  public
  void write(String string) {
    super.write(""<""+(syslogFacility | priority)+"">"" + string);
  }
}
"
org.apache.log4j.helpers.SyslogWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import java.io.IOException;
/**
   SyslogWriter is a wrapper around the java.net.DatagramSocket class
   so that it behaves like a java.io.Writer.
   @since 0.7.3
*/
public class SyslogWriter extends Writer {
  final int SYSLOG_PORT = 514;
  static String syslogHost;
  private InetAddress address;
  private DatagramSocket ds;
  public
  SyslogWriter(String syslogHost) {
    this.syslogHost = syslogHost;
    try {      
      this.address = InetAddress.getByName(syslogHost);
    }
    catch (UnknownHostException e) {
      LogLog.error(""Could not find "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
    try {
      this.ds = new DatagramSocket();
    }
    catch (SocketException e) {
      e.printStackTrace(); 
      LogLog.error(""Could not instantiate DatagramSocket to "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
  }
  public
  void write(char[] buf, int off, int len) throws IOException {
    this.write(new String(buf, off, len));
  }
  public
  void write(String string) throws IOException {
    DatagramPacket packet = new DatagramPacket(string.getBytes(),
					       string.length(), 
					       address, SYSLOG_PORT);
    if(this.ds != null)
      ds.send(packet);
  }
  public
  void flush() {}
  public
  void close() {}
}
"
org.apache.log4j.net.JMSAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import java.util.Properties;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
/**
   A simple appender based on JMS.
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSAppender extends AppenderSkeleton {
  /**
     A string constant used in naming the topic connection factory
     binding name option.  output file. Current value of this string
     constant is <b>TopicConnectionFactoryBindingName</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION 
                                                 = ""TopicConnectionFactoryBindingName"";
  /**
     A string constant used in naming the topic binding name option.
     Current value of this string constant is <b>TopicBindingName</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String TOPIC_BINDING_NAME_OPTION = ""TopicBindingName"";
  TopicConnection  topicConnection;
  TopicSession topicSession;
  TopicPublisher  topicPublisher;
  String topicBindingName;
  String tcfBindingName;
  public 
  JMSAppender() {
  }
 /**
     Retuns the option names for this component, namely the string
     array {@link #TOPIC_BINDING_NAME_OPTION}, {@link
     #TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION} in addition to the
     options of its super class {@link AppenderSkeleton}.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TOPIC_BINDING_NAME_OPTION, 
			  TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION});
  }
 /**
     Set <code>JMSAppender</code> specific options.
     The options of the super class {@link AppenderSkeleton} are also
     recognized.
     <p>The <b>TopicConnectionFactoryBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>TopicConnectionFactory</code> from the JNDI context.
     <p>The <b>TopicBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>Topic</code> from the JNDI context.         
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
 */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);    
    if(key.equals(TOPIC_BINDING_NAME_OPTION)) 
      topicBindingName = value;
    else if(key.equals(TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION)) {
      tcfBindingName = value;
    }
  }
  /**
     The <b>TopicConnectionFactoryBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>TopicConnectionFactory</code> from the JNDI context.
   */
  public
  void setTopicConnectionFactoryBindingName(String tcfBindingName) {
    this.tcfBindingName = tcfBindingName;
  }
  /**
     Returns the value of the <b>TopicConnectionFactoryBindingName</b> option.
   */
  public
  String getTopicConnectionFactoryBindingName() {
    return tcfBindingName;
  }
  /**
     The <b>TopicBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>Topic</code> from the JNDI context.
   */
  public
  void setTopicBindingName(String topicBindingName) {
    this.topicBindingName = topicBindingName;
  }
  /**
     Returns the value of the <b>TopicBindingName</b> option.
   */
  public
  String getTopicBindingName() {
    return topicBindingName;
  }
  public
  void activateOptions() {
    TopicConnectionFactory  topicConnectionFactory;
    try {
      Context ctx = new InitialContext();      
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, tcfBindingName);
      topicConnection = topicConnectionFactory.createTopicConnection();
      topicConnection.start();
      topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      Topic topic = (Topic) lookup(ctx, topicBindingName);
      topicPublisher = topicSession.createPublisher(topic);
      ctx.close();      
    } catch(Exception e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    }
  }
  protected
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }
  protected
  boolean checkEntryConditions() {
    String fail = null;
    if(this.topicConnection == null) {
      fail = ""No TopicConnection"";
    } else if(this.topicSession == null) {
      fail = ""No TopicSession"";
    } else if(this.topicPublisher == null) {
      fail = ""No TopicPublisher"";
    } 
    if(fail != null) {
      errorHandler.error(fail +"" for JMSAppender named [""+name+""]."");      
      return false;
    } else {
      return true;
    }
  }
  /**
     Close this JMSAppender. Closing releases all resources used by the
     appender. A closed appender cannot be re-opened. */
  public 
  synchronized // avoid concurrent append and close operations
  void close() {
    if(this.closed) 
      return;
    LogLog.debug(""Closing appender [""+name+""]."");
    this.closed = true;    
    try {
      if(topicSession != null) 
	topicSession.close();	
      if(topicConnection != null) 
	topicConnection.close();
    } catch(Exception e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);	
    }   
    // Help garbage collection
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }
  /**
     This method called by {@link AppenderSkeleton#doAppend} method to
     do most of the real appending work.  */
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }
    try {
      ObjectMessage msg = topicSession.createObjectMessage();
      msg.setObject(event);
      topicPublisher.publish(msg);
    } catch(Exception e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e, 
			 ErrorCode.GENERIC_FAILURE);
    }
  }
  public
  boolean requiresLayout() {
    return false;
  }  
}
"
org.apache.log4j.net.JMSSink,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.or.MessageRenderer;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
/**
   A simple application receiving the logging events sent by a JMSAppender.
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSSink  {
  static public void main(String[] args) {
    if(args.length != 3) {
      usage(""Wrong number of arguments."");     
    }
    String tcfBindingName = args[0];
    String topicBindingName = args[1];
    PropertyConfigurator.configure(args[2]);
    Category.getDefaultHierarchy().addRenderer(Message.class, 
					       new MessageRenderer());
    try {
      Context ctx = new InitialContext();      
      TopicConnectionFactory topicConnectionFactory;
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, 
							       tcfBindingName);
      TopicConnection topicConnection = 
	                        topicConnectionFactory.createTopicConnection(); 
      topicConnection.start();
      TopicSession topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      Topic topic = (Topic)ctx.lookup(topicBindingName);
      //TopicSubscriber topicSubscriber = topicSession.createSubscriber(topic);
      TopicSubscriber topicSubscriber = 
           topicSession.createDurableSubscriber(topic, ""x"");
      LoggingEvent event;
      Category remoteCategory;    
      while(true) {
	ObjectMessage msg = (ObjectMessage)topicSubscriber.receive();      
	event = (LoggingEvent) msg.getObject();
	remoteCategory = Category.getInstance(event.categoryName);
	remoteCategory.callAppenders(event);	
	// dump the JMSMessage
	// remoteCategory.debug(msg);
      }
    } catch(Exception e) {
      LogLog.error(""Could not read JMS message."", e);
    }
  }
  protected
  static
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }  
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + JMSSink.class.getName()
            + "" TopicConnectionFactoryBindingName TopicBindingName configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.net.SimpleSocketServer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
/**
   A simple {@link SocketNode} based server.
   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SimpleSocketServer port configFile
     where <em>port</em> is a part number where the server listens and
     <em>configFile</em> is a configuration file fed to the {@link
     PropertyConfigurator}.
   </pre>
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */
public class SimpleSocketServer  {
  static Category cat = Category.getInstance(SimpleSocketServer.class.getName());
  static int port;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	cat.info(""Connected to client at "" + socket.getInetAddress());
	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, 
				  Category.getDefaultHierarchy())).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SimpleSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
org.apache.log4j.net.SMTPAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.TriggeringEventEvaluator;
import java.util.Properties;
import java.util.Date;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.AddressException;
import javax.mail.internet.MimeUtility;
/**
   Send an e-mail when a specific logging event occurs, typically on
   errors or fatal errors.
   <p>The number of logging events delivered in this e-mail depend on
   the value of <b>BufferSize</b> option. The
   <code>SMTPAppender</code> keeps only the last
   <code>BufferSize</code> logging events in its cyclic buffer. This
   keeps memory requirements at a reasonable level while still
   delivering useful application context.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class SMTPAppender extends AppenderSkeleton {
  String to;
  String from;
  String subject;
  String smtpHost;
  int bufferSize = 512;
  CyclicBuffer cb = new CyclicBuffer(bufferSize);
  Session session;
  Message msg;
  boolean locationInfo = false;
 /**
     A string constant used in naming the <em>To</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>To</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String TO_OPTION = ""To"";
 /**
     A string constant used in naming the <em>From</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>From</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.     
  */
  public static final String FROM_OPTION = ""From"";
 /**
     A string constant used in naming the <em>Subject</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>Subject</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String SUBJECT_OPTION = ""Subject"";
 /**
     A string constant used in naming the SMTP host that will be
     contacted to send the e-mail. Current value of this string
     constant is <b>SMTPHost</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String SMTP_HOST_OPTION = ""SMTPHost"";
 /**
     A string constant used in naming the cyclic buffer size option.
     Current value of this string constant is <b>BufferSize</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";
 /**
     A string constant used in naming the class of the
     TriggeringEventEvaluator that this SMTPApepdner wll use. Current
     value of this string constant is <b>EvaluatorClass</b>.
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String EVALUATOR_CLASS_OPTION = ""EvaluatorClass"";
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  
     <p>Note that all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  protected TriggeringEventEvaluator evaluator;
  /**
     The default constructor will instantiate the appender with a
     {@link TriggeringEventEvaluator} that will tirgger on events with
     priority ERROR or higher.*/
  public
  SMTPAppender() {
    this(new DefaultEvaluator());
  }
  /**
     Use <code>evaluator</code> passed as parameter as the {@link
     TriggeringEventEvaluator} for this SMTPAppender.  */
  public 
  SMTPAppender(TriggeringEventEvaluator evaluator) {
    this.evaluator = evaluator;
  }
 /**
     Retuns the option names for this component in addition in
     addition to the options of its super class {@link
     AppenderSkeleton}.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TO_OPTION, FROM_OPTION, SUBJECT_OPTION, 
			  SMTP_HOST_OPTION, BUFFER_SIZE_OPTION,  
			  EVALUATOR_CLASS_OPTION, LOCATION_INFO_OPTION });
  }
  /**
     Activate the specified options, such as the smtp host, the
     recipient, from, etc. */
  public
  void activateOptions() {
    Properties props = System.getProperties();
    if (smtpHost != null)
      props.put(""mail.smtp.host"", smtpHost);
     session = Session.getDefaultInstance(props, null);
     //session.setDebug(true);
     msg = new MimeMessage(session);
     try {
       if (from != null)
	 msg.setFrom(getAddress(from));
       else
	 msg.setFrom();
       msg.setRecipients(Message.RecipientType.TO, parseAddress(to));
       if(subject != null)
	 msg.setSubject(subject);
     } catch(MessagingException e) {
       LogLog.error(""Could not activate SMTPAppender options."", e );
     }
  }
  /**
     Perform SMTPAppender specific appending actions, mainly adding
     the event to a cyclic buffer and checking if the event triggers
     an e-mail to be sent. */
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }
    event.getThreadName();
    event.getNDC();
    if(locationInfo) {
      event.getLocationInformation();	
    }
    cb.add(event);    
    if(evaluator.isTriggeringEvent(event)) {
      sendBuffer();
    }
  }
 /**
     This method determines if there is a sense in attempting to append.
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error(""Message object not configured."");
      return false;
    }
    if(this.evaluator == null) {
      errorHandler.error(""No TriggeringEventEvaluator is set for appender [""+
			 name+""]."");
      return false;
    }
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+name+""]."");
      return false;
    }
    return true;
  }
  synchronized
  public
  void close() {
    this.closed = true;
  }
  InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }
  InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }
  /**
     Returns value of the <b>To</b> option.
   */
  public
  String getTo() {
    return to;
  }
  /**
     The <code>SMTPAppender</code> requires a {@link Layout layout}.  
  */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
     Send the contents of the cyclic buffer as an e-mail message.
   */
  protected
  void sendBuffer() {
    // Note: this code already owns the monitor for this
    // appender. This frees us from needing to synchronize on 'cb'.
    try {      
      MimeBodyPart part = new MimeBodyPart();
      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length(); 
      for(int i = 0; i < len; i++) {
	//sbuf.append(MimeUtility.encodeText(layout.format(cb.get())));
	LoggingEvent event = cb.get();
	sbuf.append(layout.format(event));
	if(layout.ignoresThrowable()) {
	  String[] s = event.getThrowableStrRep();
	  if (s != null) {
	    for(int j = 0; j < s.length; j++) {
	      sbuf.append(s[j]);
	    }
	  }
	}
      }
      t = layout.getFooter();
      if(t != null)
	sbuf.append(t);
      part.setContent(sbuf.toString(), layout.getContentType());      
      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);
      msg.setSentDate(new Date());
      Transport.send(msg);      
    } catch(Exception e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    }
  }
  /**
     Returns value of the <b>EvaluatorClass</b> option.
   */
  public
  String getEvaluatorClass() {
    return evaluator == null ? null : evaluator.getClass().getName();
  }
  /**
     Returns value of the <b>From</b> option.
   */
  public
  String getFrom() {
    return from;
  }
  /**
     Returns value of the <b>Subject</b> option.
   */
  public
  String getSubject() {
    return subject;
  }
/**
   @deprecated Use the setter method for the option directly, instead
   of the generic <code>setOption</code> method.  */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    
    if(option.equals(TO_OPTION)) 
      to = value;
    else if (option.equals(FROM_OPTION))
      from = value;
    else if (option.equals(SMTP_HOST_OPTION)) 
      smtpHost = value;
    else if (option.equals(SUBJECT_OPTION)) 
      subject = value;
    else if (option.equals(EVALUATOR_CLASS_OPTION)) {      
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
                                           TriggeringEventEvaluator.class,
                                                       evaluator);    
    } else if (option.equals(BUFFER_SIZE_OPTION)) {
      bufferSize = OptionConverter.toInt(value, bufferSize);    
      cb.resize(bufferSize);
    } else if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
  }
  /**
     The <b>From</b> option takes a string value which should be a
     e-mail address of the sender.
   */
  public
  void setFrom(String from) {
    this.from = from;
  }
  /**
     The <b>Subject</b> option takes a string value which should be a
     the subject of the e-mail message.
   */
  public
  void setSubject(String subject) {
    this.subject = subject;
  }
  /**
     The <b>BufferSize</b>option takes a positive integer
     representing the maximum number of logging events to collect in a
     cyclic buffer. When the <code>BufferSize</code> is reached,
     oldest events are deleted as new events are added to the
     buffer. By default the size of the cyclic buffer is 512 events.
   */
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
    cb.resize(bufferSize);
  }
  /**
     The <b>SMTPHost</b> option takes a string value which should be a
     the host name of the SMTP server that will send the e-mail message.
   */
  public
  void setSMTPHost(String smtpHost) {
    this.smtpHost = smtpHost;
  }
  /**
     Returns value of the <b>SMTPHost</b> option.
   */
  public
  String getSMTPHost() {
    return smtpHost;
  }
  /**
     The <b>To</b> option takes a string value which should be a
     comma separated list of e-mail address of the recipients.
   */
  public
  void setTo(String to) {
    this.to = to;
  }
  /**
     Returns value of the <b>BufferSize</b> option.
   */
  public
  int getBufferSize() {
    return bufferSize;
  }
  /**
     The <b>EvaluatorClass</b> option takes a string value
     repsenting the name of the class implementing the {@link
     TriggeringEventEvaluator} interface. A corresponding object will
     be instantiated and assigned as the triggering event evaluator
     for the SMTPAppender.
   */
  public
  void setEvaluatorClass(String value) {
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
					   TriggeringEventEvaluator.class,
						       evaluator);    
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the layout that formats the events as they are sent out
     in an e-mail is likely to place the wrong location information
     (if present in the format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
   */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  /**
     Returns value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
}
class DefaultEvaluator implements TriggeringEventEvaluator {
  /**
     Is this <code>event</code> the e-mail triggering event?
     <p>This method returns <code>true</code>, if the event priority
     has ERROR priority or higher. Otherwisem it returns
     <code>false</code>. */
  public 
  boolean isTriggeringEvent(LoggingEvent event) {
    return event.priority.isGreaterOrEqual(Priority.ERROR); 
  }
}
"
org.apache.log4j.net.SocketAppender,"//      Copyright 1996-2000, International Business Machines
//      Corporation. All Rights Reserved.
//
//      See the LICENCE file for the terms of distribution.
// Contributors: Dan MacDonald <dan@redknee.com>
package org.apache.log4j.net;
import java.net.InetAddress;
import java.net.Socket;
import java.io.OutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;
/**
    Sends {@link LoggingEvent} objects to a remote a log server,
    usually a {@link SocketNode}.
    <p>The SocketAppender has the following properties:
    <ul>
      <p><li>If sent to a {@link SocketNode}, remote logging is
      non-intrusive as far as the log event is concerned. In other
      words, the event will be logged with the same time stamp, {@link
      org.apache.log4j.NDC}, location info as if it were logged locally by
      the client.
      <p><li>SocketAppenders do not use a layout. They ship a
      serialized {@link LoggingEvent} object to the server side.
      <p><li>Remote logging uses the TCP protocol. Consequently, if
      the server is reachable, then log events will eventually arrive
      at the server.
      <p><li>If the remote server is down, the logging requests are
      simply dropped. However, if and when the server comes back up,
      then event transmission is resumed transparently. This
      transparent reconneciton is performed by a <em>connector</em>
      thread which periodically attempts to connect to the server.
      <p><li>Logging events are automatically <em>buffered</em> by the
      native TCP implementation. This means that if the link to server
      is slow but still faster than the rate of (log) event production
      by the client, the client will not be affected by the slow
      network connection. However, if the network connection is slower
      then the rate of event production, then the client can only
      progress at the network rate. In particular, if the network link
      to the the server is down, the client will be blocked.
      <p>On the other hand, if the network link is up, but the server
      is down, the client will not be blocked when making log requests
      but the log events will be lost due to server unavailability.
      <p><li>Even if a <code>SocketAppender</code> is no longer
      attached to any category, it will not be garbage collected in
      the presence of a connector thread. A connector thread exists
      only if the connection to the server is down. To avoid this
      garbage collection problem, you should {@link #close} the the
      <code>SocketAppender</code> explicitly. See also next item.
      <p>Long lived applications which create/destroy many
      <code>SocketAppender</code> instances should be aware of this
      garbage collection problem. Most other applications can safely
      ignore it.
      <p><li>If the JVM hosting the <code>SocketAppender</code> exits
      before the <code>SocketAppender</code> is closed either
      explicitly or subsequent to garbage collection, then there might
      be untransmitted data in the pipe which might be lost. This is a
      common problem on Windows based systems.
      <p>To avoid lost data, it is usually sufficient to {@link #close}
      the <code>SocketAppender</code> either explicitly or by calling
      the {@link Category#shutdown} method before exiting the
      application.  
     </ul>
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */
public class SocketAppender extends AppenderSkeleton {
  /**
     A string constant used in naming the option for setting the the
     host name of the remote server.  Current value of this string
     constant is <b>RemoteHost</b>. See the {@link #setOption} method
     for the meaning of this option.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String REMOTE_HOST_OPTION = ""RemoteHost"";
 /**
     A string constant used in naming the option for setting the the
     port to contect on the remote server.  Current value of this string
     constant is <b>Port</b>.  See the {@link #setOption} method
     for the meaning of this option.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String PORT_OPTION = ""Port"";
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  See the {@link #setOption} method
     for the meaning of this option.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  /**
     A string constant used in naming the option for setting the delay
     between each reconneciton attempt to remote server.  Current
     value a of this string constant is <b>ReconnectionDelay</b>.  See
     the {@link #setOption} method for the meaning of this option.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String RECONNECTION_DELAY_OPTION = ""ReconnectionDelay"";
  /**
     The default port number of remote logging server (4560).
  */
  static final int DEFAULT_PORT                 = 4560;
  /**
     The default reconnection delay (30000 milliseconds or 30 seconds).
  */
  static final int DEFAULT_RECONNECTION_DELAY   = 30000;
  /**
     We remember host name as String in addition to the resolved
     InetAddress so that it can be returned via getOption().
  */
  String remoteHost;
  InetAddress address;
  int port = DEFAULT_PORT;
  ObjectOutputStream oos;
  int reconnectionDelay = DEFAULT_RECONNECTION_DELAY;
  boolean locationInfo = false;
  private Connector connector;
  int counter = 0; 
  // reset the ObjectOutputStream every 70 calls
  //private static final int RESET_FREQUENCY = 70;
  private static final int RESET_FREQUENCY = 1;
  public SocketAppender() {
  }
  /**
     Connects to remote server at <code>address</code> and <code>port</code>.
  */
  public
  SocketAppender(InetAddress address, int port) {
    this.address = address;
    this.remoteHost = address.getHostName();
    this.port = port;
    connect(address, port);
  }
  /**
     Connects to remote server at <code>host</code> and <code>port</code>.
  */
  public
  SocketAppender(String host, int port) { 
    this.port = port;
    this.address = getAddressByName(host);
    this.remoteHost = host;
    connect(address, port);
  }
  /**
     Retuns the option names for this component, namely the string
     array consisting of {{@link #REMOTE_HOST_OPTION}, {@link
     #PORT_OPTION}, {@link #LOCATION_INFO_OPTION}, {@link
     #RECONNECTION_DELAY_OPTION}} in addition to the options of its
     super class {@link AppenderSkeleton}.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
    */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
                          new String[] {REMOTE_HOST_OPTION, PORT_OPTION, 
					LOCATION_INFO_OPTION,
					RECONNECTION_DELAY_OPTION});
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method.
   */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    
    if(option.equals(REMOTE_HOST_OPTION)) {
      address = getAddressByName(value);
      remoteHost = value;
    } else if (option.equals(PORT_OPTION)) {
      port = OptionConverter.toInt(value, port);
    } else if (option.equals(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);    
    } else if (option.equals(RECONNECTION_DELAY_OPTION)) {
      reconnectionDelay = OptionConverter.toInt(value, reconnectionDelay);  
    }
  }
  /**
     Connect to the specified <b>RemoteHost</b> and <b>Port</b>. 
  */
  public
  void activateOptions() {
    connect(address, port);
  }
  /**
     Close this appender. 
     <p>This will mark the appender as closed and
     call then {@link #cleanUp} method.
  */
  synchronized
  public
  void close() {
    if(closed)
      return;
    this.closed = true;
    cleanUp();
  }
  /**
     Drop the connection to the remote host and release the underlying
     connector thread if it has been created
   */
  public 
  void cleanUp() {
    if(oos != null) {
      try {
	oos.close();
      }
      catch(IOException e) {
	LogLog.error(""Could not close oos."", e);
      }
      oos = null;      
    }
    if(connector != null) {
      //LogLog.debug(""Interrupting the connector."");      
      connector.interrupted = true;
      connector = null;  // allow gc
    }
  }
  void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      // First, close the previous connection if any.
      cleanUp();          
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    }
    catch(IOException e) {
      LogLog.error(""Could not connect to remote log4j server at [""
		   +address.getHostName()+""]. We will try again later."", e);
      fireConnector();
    }
  }
  public
  void append(LoggingEvent event) {
    if(event == null)
      return;
    if(address==null) {
      errorHandler.error(""No remote host is set for SocketAppender named \""""+
			this.name+""\""."");
      return;
    }
    if(oos != null) {
      try {
	if(locationInfo) {
	   event.getLocationInformation();	
	} 
	oos.writeObject(event);
	//LogLog.debug(""=========Flushing."");
	oos.flush();
	if(++counter >= RESET_FREQUENCY) {
	  counter = 0;
	  // Failing to reset the object output stream every now and
	  // then creates a serious memory leak.
	  //System.err.println(""Doing oos.reset()"");
	  oos.reset();
	}
      }
      catch(IOException e) {
	oos = null;
	LogLog.warn(""Detected problem with connection: ""+e);
	if(reconnectionDelay > 0) {
	  fireConnector();
	}
      }
    }
  }
  void fireConnector() {
    if(connector == null) {
      LogLog.debug(""Starting a new connector thread."");
      connector = new Connector();
      connector.setDaemon(true);
      connector.setPriority(Thread.MIN_PRIORITY);
      connector.start();      
    }
  }
  static
  InetAddress getAddressByName(String host) {
    try {
      return InetAddress.getByName(host);
    }	
    catch(Exception e) {
      LogLog.error(""Could not find address of [""+host+""]."", e);
      return null;
    }
  }
  /**
     The SocketAppender does not use a layout. Hence, this method returns
     <code>false</code>.
  */
  public
  boolean requiresLayout() {
    return false;
  }
  /**
     The <b>RemoteHost</b> option takes a string value which should be
     the host name of the server where a {@link SocketNode} is running.
   */
  public
  void setRemoteHost(String host) {
    address = getAddressByName(host);
    remoteHost = host;
  }
  /**
     Returns value of the <b>RemoteHost</b> option.
   */
  public
  String getRemoteHost() {
    return remoteHost;
  }
  /**
     The <b>Port</b> option takes a positive integer representing
     the port where the server is waiting for connections.
   */
  public
  void setPort(int port) {
    this.port = port;
  }
  /**
     Returns value of the <b>Port</b> option.
   */
  public
  int getPort() {
    return port;
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. If true,
     the information sent to the remote host will include location
     information. By default no location information is sent to the server.
   */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  /**
     Returns value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  /**
     The <b>ReconnectionDelay</b> option takes a positive integer
     representing the number of milliseconds to wait between each
     failed connection attempt to the server. The default value of
     this option is 30000 which corresponds to 30 seconds.
     <p>Setting this option to zero turns off reconnection
     capability.
   */
  public
  void setReconnectionDelay(int delay) {
    this.reconnectionDelay = delay;
  }
  /**
     Returns value of the <b>ReconnectionDelay</b> option.
   */
  public
  int getReconnectionDelay() {
    return reconnectionDelay;
  }
  /**
     The Connector will reconnect when the server becomes available
     again.  It does this by attempting to open a new connection every
     <code>reconnectionDelay</code> milliseconds.
     <p>It stops trying whenever a connection is established. It will
     restart to try reconnect to the server when previpously open
     connection is droppped.
     @author  Ceki G&uuml;lc&uuml; 
     @since 0.8.4
  */
  class Connector extends Thread {
    boolean interrupted = false;
    public
    void run() {
      Socket socket;      
      while(!interrupted) {
	try {
	  sleep(reconnectionDelay);
	  LogLog.debug(""Attempting connection to ""+address.getHostName());
	  socket = new Socket(address, port);
	  synchronized(this) {
	    oos = new ObjectOutputStream(socket.getOutputStream()); 
	    connector = null;
	    break;
	  }
	}
	catch(InterruptedException e) {
	  LogLog.debug(""Connector interrupted. Leaving loop."");
	  return;
	}
	catch(java.net.ConnectException e) {
	  LogLog.debug(""Remote host ""+address.getHostName()
		       +"" refused connection."");
	}
	catch(IOException e) {	  
	  LogLog.debug(""Could not connect to "" + address.getHostName()+
		       "". Exception is "" + e);
	}
      }
      //LogLog.debug(""Exiting Connector.run() method."");
    }
    /**
       public
       void finalize() {
       LogLog.debug(""Connector finalize() has been called."");
       }
    */
  }
}
"
org.apache.log4j.net.SocketNode,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of usage and distribution.
package org.apache.log4j.net;
import java.net.InetAddress;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.InputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
// Contributors:  Moses Hohman <mmhohman@rainbow.uchicago.edu>
/**
   Read {@link LoggingEvent} objects sent from a remote client using
   Sockets (TCP). These logging events are logged according to local
   policy, as if they were generated locally.
   <p>For example, the socket node might decide to log events to a
   local file and also resent them to a second socket node.
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4
*/
public class SocketNode implements Runnable {
  Socket socket;
  Hierarchy hierarchy;
  ObjectInputStream ois;
  static Category cat = Category.getInstance(SocketNode.class.getName());
  public 
  SocketNode(Socket socket, Hierarchy hierarchy) {
    this.socket = socket;
    this.hierarchy = hierarchy;
    try {
      ois = new ObjectInputStream(socket.getInputStream());
    }
    catch(Exception e) {
      cat.error(""Could not open ObjectInputStream to ""+socket, e);
    }
  }
  //public
  //void finalize() {
  //System.err.println(""-------------------------Finalize called"");
  // System.err.flush();
  //}
  public void run() {
    LoggingEvent event;
    Category remoteCategory;
    try {
      while(true) {	
	event = (LoggingEvent) ois.readObject();	
	remoteCategory = hierarchy.getInstance(event.categoryName);
	event.category = remoteCategory;
	if(event.priority.isGreaterOrEqual(remoteCategory.getChainedPriority())) {
	  remoteCategory.callAppenders(event);	
	}
      }
    }
    catch(java.io.EOFException e) {
      cat.info(""Caught java.io.EOFException closing conneciton."");
    }
    catch(java.net.SocketException e) {
      cat.info(""Caught java.net.SocketException closing conneciton."");
    }
    catch(Exception e) {
      cat.error(""Unexpected exception. Closing conneciton."", e);
    }
    try {
      ois.close();
    }
    catch(Exception e) {
      cat.info(""Could not close connection."", e);	
    }  
  }
}
"
org.apache.log4j.net.SocketServer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.io.IOException;
import java.io.File;
import java.util.Hashtable;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.RootCategory;
/**
   A {@link SocketNode} based server that uses a different hierarchy
   for each client.
   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SocketServer port configFile configDir
     where <b>port</b> is a part number where the server listens,
           <b>configFile</b> is a configuration file fed to the {@link PropertyConfigurator} and
           <b>configDir</b> is a path to a directory containing configuration files, possibly one for each client host.
     </pre>
     <p>The <code>configFile</code> is used to configure the log4j
     default hierarchy that the <code>SocketServer</code> will use to
     report on its actions.
     <p>When a new connection is opened from a previously unknown
     host, say <code>foo.bar.net</code>, then the
     <code>SocketServer</code> will search for a configuration file
     called <code>foo.bar.net.lcf</code> under the directory
     <code>configDir</code> that was passed as the third argument. If
     the file can be found, then a new hierarchy is instantiated and
     configured using the configuration file
     <code>foo.bar.net.lcf</code>. If and when the host
     <code>foo.bar.net</code> opens another connection to the server,
     then the previously configured hierarchy is used.
     <p>In case there is no file called <code>foo.bar.net.lcf</code>
     under the directory <code>configDir</code>, then the
     <em>generic</em> hierarchy is used. The generic hierarchy is
     configured using a configuration file called
     <code>generic.lcf</code> under the <code>configDir</code>
     directory. If no such file exists, then the generic hierarchy will be
     identical to the log4j default hierarchy.
     <p>Having different client hosts log using different hierarchies
     ensures the total independence of the clients with respect to
     their logging settings. 
     <p>Currently, the hierarchy that will be used for a given request
     depends on the IP address of the client host. For example, two
     separate applicatons running on the same host and logging to the
     same server will share the same hierarchy. This is perfectly safe
     except that it might not provide the right amount of independence
     between applications. The <code>SocketServer</code> is intended
     as an example to be enhanced in order to implement more elaborate
     policies.
    @author  Ceki G&uuml;lc&uuml;
    @since 1.0 */
public class SocketServer  {
  static String GENERIC = ""generic"";
  static String CONFIG_FILE_EXT = "".lcf"";
  static Category cat = Category.getInstance(SocketServer.class);  
  static SocketServer server;
  static int port;
  // key=inetAddress, value=hierarchy
  Hashtable hierarchyMap;
  Hierarchy genericHierarchy;
  File dir;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1], argv[2]);
    else 
      usage(""Wrong number of arguments."");     
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	InetAddress inetAddress =  socket.getInetAddress();
	cat.info(""Connected to client at "" + inetAddress);
	Hierarchy h = (Hierarchy) server.hierarchyMap.get(inetAddress);
	if(h == null) {
	  h = server.configureHierarchy(inetAddress);
	} 
	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, h)).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SocketServer.class.getName() + "" port configFile directory"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile, String dirStr) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);
    File dir = new File(dirStr);    
    if(!dir.isDirectory()) {
      usage(""[""+dirStr+""] is not a directory."");
    }
    server = new SocketServer(dir);
  }
  public
  SocketServer(File directory) {
    this.dir = directory;
    hierarchyMap = new Hashtable(11);
  }
  // This method assumes that there is no hiearchy for inetAddress
  // yet. It will configure one and return it.
  Hierarchy configureHierarchy(InetAddress inetAddress) {
    cat.info(""Locating configuration file for ""+inetAddress);
    // We assume that the toSting method of InetAddress returns is in
    // the format hostname/d1.d2.d3.d4 e.g. torino/192.168.1.1
    String s = inetAddress.toString();
    int i = s.indexOf(""/"");
    if(i == -1) {
      cat.warn(""Could not parse the inetAddress [""+inetAddress+
	       ""]. Using default hierarchy."");
      return genericHierarchy();
    } else {
      String key = s.substring(0, i);
      File configFile = new File(dir, key+CONFIG_FILE_EXT);
      if(configFile.exists()) {
	Hierarchy h = new Hierarchy(new RootCategory(Priority.DEBUG));
	hierarchyMap.put(inetAddress, h);
	new PropertyConfigurator().doConfigure(configFile.getAbsolutePath(), h);
	return h;	
      } else {
	cat.warn(""Could not find config file [""+configFile+""]."");
	return genericHierarchy();
      }
    }
  }
  Hierarchy genericHierarchy() {
    if(genericHierarchy == null) {
      File f = new File(dir, GENERIC+CONFIG_FILE_EXT);
      if(f.exists()) {
	genericHierarchy = new Hierarchy(new RootCategory(Priority.DEBUG));
	new PropertyConfigurator().doConfigure(f.getAbsolutePath(), genericHierarchy);
      } else {
	cat.warn(""Could not find config file [""+f+
		 ""]. Will use the default hierarchy."");
	genericHierarchy = Category.getDefaultHierarchy();
      }
    }
    return genericHierarchy;
  }
}
"
org.apache.log4j.net.SyslogAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.SyslogWriter;
import org.apache.log4j.helpers.SyslogQuietWriter;
// Contributors: Yves Bossel <ybossel@opengets.cl>
//               Christopher Taylor <cstaylor@pacbell.net>
/**
    Use SyslogAppender to send log messages to a remote syslog daemon.
    @author Ceki G&uuml;lc&uuml;
    @author Anders Kristensen
 */
public class SyslogAppender extends AppenderSkeleton {
  // The following constants are extracted from a syslog.h file
  // copyrighted by the Regents of the University of California
  // I hope nobody at Berkley gets offended.
  /** Kernel messages */
  final static public int LOG_KERN     = 0; 
  /** Random user-level messages */
  final static public int LOG_USER     = 1<<3; 
  /** Mail system */
  final static public int LOG_MAIL     = 2<<3; 
  /** System daemons */
  final static public int LOG_DAEMON   = 3<<3; 
  /** security/authorization messages */
  final static public int LOG_AUTH     = 4<<3; 
  /** messages generated internally by syslogd */
  final static public int LOG_SYSLOG   = 5<<3; 
  /** line printer subsystem */  
  final static public int LOG_LPR      = 6<<3; 
  /** network news subsystem */
  final static public int LOG_NEWS     = 7<<3; 
  /** UUCP subsystem */
  final static public int LOG_UUCP     = 8<<3; 
  /** clock daemon */
  final static public int LOG_CRON     = 9<<3; 
  /** security/authorization  messages (private) */
  final static public int LOG_AUTHPRIV = 10<<3; 
  /** ftp daemon */
  final static public int LOG_FTP      = 11<<3; 
  // other codes through 15 reserved for system use
  /** reserved for local use */
  final static public int LOG_LOCAL0 = 16<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL1 = 17<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL2 = 18<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL3 = 19<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL4 = 20<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL5 = 21<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL6 = 22<<3; 
  /** reserved for local use*/
  final static public int LOG_LOCAL7 = 23<<3; 
   /**
     A string constant used in naming the option for setting the
     syslog server.  Current value of this string constant is
     <b>SyslogHost</b>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
     @since 0.8.1 */
  public static final String SYSLOG_HOST_OPTION = ""SyslogHost"";
   /**
     A string constant used in naming the option for setting facility
     type.  Current value of this string constant is <b>Facility</b>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
     @since 0.8.1 */
  public static final String FACILITY_OPTION = ""Facility"";  
   /**
     A string constant used in naming the option for setting whether
     the facility name is printed or not.  Current value of this
     string constant is <b>FacilityPrinting</b>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
     @since 0.8.1 */
  public static final String FACILITY_PRINTING_OPTION = ""FacilityPrinting"";  
  protected static final int SYSLOG_HOST_OI = 0;
  protected static final int FACILITY_OI = 1;
  static final String TAB = ""    "";
  // Have LOG_USER as default
  int syslogFacility = LOG_USER;
  String facilityStr;  
  boolean facilityPrinting = false;
  //SyslogTracerPrintWriter stp;
  SyslogQuietWriter sqw;  
  String syslogHost;
  public
  SyslogAppender() {
    this.initSyslogFacilityStr();
  }
  public
  SyslogAppender(Layout layout, int syslogFacility) {
    this.layout = layout;
    this.syslogFacility = syslogFacility;    
    this.initSyslogFacilityStr();
  }
  public
  SyslogAppender(Layout layout, String syslogHost, int syslogFacility) {
    this(layout, syslogFacility);
    setSyslogHost(syslogHost);
  }
  /**
     Returns the option names for this component, namely the string
     array consisting of {{@link #SYSLOG_HOST_OPTION}, {@link
     #FACILITY_OPTION}, {@link #FACILITY_PRINTING_OPTION}}.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
     @since 0.8.1 */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		      new String[] {SYSLOG_HOST_OPTION, FACILITY_OPTION,
			            FACILITY_PRINTING_OPTION});
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    
    if(option.equals(SYSLOG_HOST_OPTION)) 
      this.setSyslogHost(value);
    else if(option.equals(FACILITY_PRINTING_OPTION))
      facilityPrinting = OptionConverter.toBoolean(value, facilityPrinting);
    else if(option.equals(FACILITY_OPTION)) {
      this.setFacility(value);
    }
  }
  /**
     Release any resources held by this SyslogAppender.
     @since 0.8.4
   */
  synchronized
  public
  void close() {
    closed = true;
    // A SyslogWriter is UDP based and needs no opening. Hence, it
    // can't be closed. We just unset the variables here.    
    sqw = null;
  }
  private
  void initSyslogFacilityStr() {
    facilityStr = getFacilityString(this.syslogFacility);
    if (facilityStr == null) {
      System.err.println(""\"""" + syslogFacility +
                  ""\"" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
      facilityStr = ""user:"";
    } else {
      facilityStr += "":"";
    }
  }	   
  /**
     Returns the specified syslog facility as a lower-case String,
     e.g. ""kern"", ""user"", etc.
  */
  public
  static
  String getFacilityString(int syslogFacility) {
    switch(syslogFacility) {
    case LOG_KERN:      return ""kern"";
    case LOG_USER:      return ""user"";
    case LOG_MAIL:      return ""mail"";
    case LOG_DAEMON:    return ""daemon"";
    case LOG_AUTH:      return ""auth"";
    case LOG_SYSLOG:    return ""syslog"";
    case LOG_LPR:       return ""lpr"";
    case LOG_NEWS:      return ""news"";
    case LOG_UUCP:      return ""uucp"";
    case LOG_CRON:      return ""cron"";
    case LOG_AUTHPRIV:  return ""authpriv"";
    case LOG_FTP:       return ""ftp"";
    case LOG_LOCAL0:    return ""local0"";
    case LOG_LOCAL1:    return ""local1"";
    case LOG_LOCAL2:    return ""local2"";
    case LOG_LOCAL3:    return ""local3"";
    case LOG_LOCAL4:    return ""local4"";
    case LOG_LOCAL5:    return ""local5"";
    case LOG_LOCAL6:    return ""local6"";
    case LOG_LOCAL7:    return ""local7"";
    default:            return null;
    }	   
  }	   
  /**
     Returns the integer value corresponding to the named syslog
     facility, or -1 if it couldn't be recognized.
     @param facilityName one of the strings KERN, USER, MAIL, DAEMON,
            AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP, LOCAL0,
            LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7.
            The matching is case-insensitive.
     @since 1.1
  */
  public
  static
  int getFacility(String facilityName) {
    if(facilityName != null) {
      facilityName = facilityName.trim();
    }
    if(""KERN"".equalsIgnoreCase(facilityName)) {
      return LOG_KERN;
    } else if(""USER"".equalsIgnoreCase(facilityName)) {
      return LOG_USER;
    } else if(""MAIL"".equalsIgnoreCase(facilityName)) {
      return LOG_MAIL;
    } else if(""DAEMON"".equalsIgnoreCase(facilityName)) {
      return LOG_DAEMON;
    } else if(""AUTH"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTH;
    } else if(""SYSLOG"".equalsIgnoreCase(facilityName)) {
      return LOG_SYSLOG;
    } else if(""LPR"".equalsIgnoreCase(facilityName)) {
      return LOG_LPR;
    } else if(""NEWS"".equalsIgnoreCase(facilityName)) {
      return LOG_NEWS;
    } else if(""UUCP"".equalsIgnoreCase(facilityName)) {
      return LOG_UUCP;
    } else if(""CRON"".equalsIgnoreCase(facilityName)) {
      return LOG_CRON;
    } else if(""AUTHPRIV"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTHPRIV;
    } else if(""FTP"".equalsIgnoreCase(facilityName)) {
      return LOG_FTP;
    } else if(""LOCAL0"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL0;
    } else if(""LOCAL1"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL1;
    } else if(""LOCAL2"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL2;
    } else if(""LOCAL3"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL3;
    } else if(""LOCAL4"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL4;
    } else if(""LOCAL5"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL5;
    } else if(""LOCAL6"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL6;
    } else if(""LOCAL7"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL7;
    } else {
      return -1;
    }
  }
  public
  void append(LoggingEvent event) {
    if(!isAsSevereAsThreshold(event.priority))
      return;
    // We must not attempt to append if sqw is null.
    if(sqw == null) {
      errorHandler.error(""No syslog host is set for SyslogAppedender named \""""+
			this.name+""\""."");
      return;
    }
    String buffer = (facilityPrinting? facilityStr : """") +
                          layout.format(event);
    sqw.setPriority(event.priority.getSyslogEquivalent());    
    sqw.write(buffer);
    String[] s = event.getThrowableStrRep();
    if (s != null) {
      int len = s.length;
      if(len > 0) {
	sqw.write(s[0]);
	for(int i = 1; i < len; i++) {
	    sqw.write(TAB+s[i].substring(1));
	}	
      }
    }
  }
  /**
     This method returns immediately as options are activated when they
     are set.
     @see #setOption
  */
  public
  void activateOptions() {
  }
  /**
     The SyslogAppender requires a layout. Hence, this method returns
     <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
    The <b>SyslogHost</b> option is the name of the the syslog host
    where log output should go.
    <b>WARNING</b> If the SyslogHost is not set, then this appender
    will fail. 
   */
  public
  void setSyslogHost(String syslogHost) {
    this.sqw = new SyslogQuietWriter(new SyslogWriter(syslogHost), 
				     syslogFacility, errorHandler);
    //this.stp = new SyslogTracerPrintWriter(sqw);    
    this.syslogHost = syslogHost;
  }
  /**
     Returns the value of the <b>SyslogHost</b> option.
   */
  public
  String getSyslogHost() {
    return syslogHost;
  }
  /**
     Set the syslog facility. This is the <b>Facility</b> option.
     <p>The <code>facilityName</code> parameter must be one of the
     strings KERN, USER, MAIL, DAEMON, AUTH, SYSLOG, LPR, NEWS, UUCP,
     CRON, AUTHPRIV, FTP, LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4,
     LOCAL5, LOCAL6, LOCAL7. Case is unimportant.
     @since 0.8.1 */
  public
  void setFacility(String facilityName) {
    if(facilityName == null)
      return;
    syslogFacility = getFacility(facilityName);
    if (syslogFacility == -1) {
      System.err.println(""[""+facilityName +
                  ""] is an unknown syslog facility. Defaulting to [USER]."");
      syslogFacility = LOG_USER;
    }
    this.initSyslogFacilityStr();
    // If there is already a sqw, make it use the new facility.
    if(sqw != null) {
      sqw.setSyslogFacility(this.syslogFacility);
    }
  }
  /**
     Returns the value of the <b>Facility</b> option.
   */
  public
  String getFacility() {
    return getFacilityString(syslogFacility);
  }
  /**
    If the <b>FacilityPrinting</b> option is set to true, the printed
    message will include the facility name of the application. It is
    <em>false</em> by default.
   */
  public
  void setFacilityPrinting(boolean on) {
    facilityPrinting = on;
  }
  /**
     Returns the value of the <b>FacilityPrinting</b> option.
   */
  public
  boolean getFacilityPrinting() {
    return facilityPrinting;
  }
}
"
org.apache.log4j.net.test.Loop,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.*;
import org.apache.log4j.net.SocketAppender;
public class Loop {
  public static void main(String[] args) {
    Category root = Category.getRoot();
    Category cat = Category.getInstance(Loop.class.getName());
    if(args.length != 2) 
      usage(""Wrong number of arguments."");     
    String host = args[0];
    int port = 0;
    try {
      port = Integer.valueOf(args[1]).intValue();
    }
    catch (NumberFormatException e) {
        usage(""Argument ["" + args[1]  + ""] is not in proper int form."");
    }
    SocketAppender sa = new SocketAppender(host, port);
    Layout layout = new PatternLayout(""%5p [%t] %x %c - %m\n"");
    Appender so = new ConsoleAppender(layout, ""System.out"");
    root.addAppender(sa);
    root.addAppender(so);
    int i = 0;
    while(true) {
      NDC.push(""""+ (i++));
      cat.debug(""Debug message."");
      root.info(""Info message."");
      NDC.pop();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +Loop.class.getName() + "" host port"");
    System.exit(1);
  }
}
"
org.apache.log4j.net.test.SMTPMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.*;
import java.io.IOException;
import java.io.InputStreamReader;
public class SMTPMin {
  static Category cat = Category.getInstance(SMTPMin.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");     
    NDC.push(""some context"");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SMTPMin.class.getName()
		       + "" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    Category.shutdown();
    Thread.currentThread().getThreadGroup().list();
  }
}
"
org.apache.log4j.net.test.SocketMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
import java.io.InputStreamReader;
public class SocketMin {
  static Category cat = Category.getInstance(SyslogMin.class.getName());
  static SocketAppender s;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    NDC.push(""some context"");
    if(argv[2].equals(""true""))
      loop();
    else
      test();
    s.close();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SocketMin.class 
		       + "" host port true|false"");
    System.exit(1);
  }
  static
  void init(String host, String portStr) {
    Category root = Category.getRoot();
    BasicConfigurator.configure();
    try {
      int port   = Integer.parseInt(portStr);
      cat.info(""Creating socket appender (""+host+"",""+port+"")."");
      s = new SocketAppender(host, port);
      s.setName(""S"");
      root.addAppender(s);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    catch(Exception e) {
      System.err.println(""Could not start!"");
      e.printStackTrace();
      System.exit(1);
    }
  }
  static
  void loop() {
    Category root = Category.getRoot();
    InputStreamReader in = new InputStreamReader(System.in);
    System.out.println(""Type 'q' to quit"");
    int i;
    int k = 0;
    while (true) {
      cat.debug(""Message "" + k++);
      cat.info(""Message "" + k++);
      cat.warn(""Message "" + k++);
      cat.error(""Message "" + k++, new Exception(""Just testing""));
      try {i = in.read(); }
      catch(Exception e) { return; }
      if(i == -1) break;
      if(i == 'q') break;
      if(i == 'r') {
	System.out.println(""Removing appender S"");
	root.removeAppender(""S"");
      }
    }
  }
  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.net.test.SyslogMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
public class SyslogMin {
  static Category CAT = Category.getInstance(SyslogMin.class.getName());
  public 
  static 
  void main(String argv[]) {
      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test(""someHost"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SyslogMin.class + "" configFile"");
    System.exit(1);
  }
  static
  void ProgramInit(String configFile) {
    int port = 0;
    PropertyConfigurator.configure(configFile);
  }
  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    CAT.debug( ""Message "" + i++);
    CAT.info( ""Message "" + i++);
    CAT.warn( ""Message "" + i++);
    CAT.error( ""Message "" + i++);
    CAT.log(Priority.FATAL, ""Message "" + i++);
    CAT.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.nt.NTEventLogAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.nt;
import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import java.io.*;
/**
   Append to the NT event log system. 
   <p><b>WARNING</b> This appender can only be installed and used on a
   Windows system.
   <p>Do not forget to place the file NTEventLogAppender.dll in a
   directory that is on the PATH of the Windows system. Otherwise, you
   will get a java.lang.UnsatisfiedLinkError.
   @author <a href=""mailto:cstaylor@pacbell.net"">Chris Taylor</a>
   @author <a href=""mailto:jim_cakalic@na.biomerieux.com"">Jim Cakalic</a> */
public class NTEventLogAppender extends AppenderSkeleton {
  private int _handle = 0;
  /**
     The string constant used in naming the source of the event. The
     current value of this constant is <b>Source</b>.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String SOURCE_OPTION = ""Source"";
  private String source = null;
  private String server = null;
  private static final int FATAL  = Priority.FATAL.toInt();
  private static final int ERROR  = Priority.ERROR.toInt();
  private static final int WARN   = Priority.WARN.toInt();
  private static final int INFO   = Priority.INFO.toInt();
  private static final int DEBUG  = Priority.DEBUG.toInt();
  public NTEventLogAppender() {
    this(null, null, null);
  }
  public NTEventLogAppender(String source) {
    this(null, source, null);
  }
  public NTEventLogAppender(String server, String source) {
    this(server, source, null);
  }
  public NTEventLogAppender(Layout layout) {
    this(null, null, layout);
  }
  public NTEventLogAppender(String source, Layout layout) {
    this(null, source, layout);
  }
  public NTEventLogAppender(String server, String source, Layout layout) {
    if (source == null) {
      source = ""Log4j"";
    }
    if (layout == null) {
      this.layout = new TTCCLayout();
    } else {
      this.layout = layout;
    }
    try {
      _handle = registerEventSource(server, source);
    } catch (Exception e) {
      e.printStackTrace();
      _handle = 0;
    }
  }
  /**
     Returns the option names for this component.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
   **/
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {SOURCE_OPTION});
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    if(key.equalsIgnoreCase(SOURCE_OPTION)) {
      // Set the source for the NT Evetns
      source = value.trim();
    }
  }
  public
  void close() {
    // unregister ...
  }
  public
  void activateOptions() {    
    if (source != null) {
      try {
	_handle = registerEventSource(server, source);
      } catch (Exception e) {
	LogLog.error(""Could not register event source."", e);
	_handle = 0;
      }
    }
  }
  public void append(LoggingEvent event) {
    StringBuffer sbuf = new StringBuffer();    
    sbuf.append(layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {	
	  sbuf.append(s[0]);
	}	
      }
    }
    // Normalize the log message priority into the supported categories
    int nt_category = event.priority.toInt();
    // Anything above FATAL or below DEBUG is labeled as INFO.
    //if (nt_category > FATAL || nt_category < DEBUG) {
    //  nt_category = INFO;
    //}
    reportEvent(_handle, sbuf.toString(), nt_category);
  }
  public 
  void finalize() {
    deregisterEventSource(_handle);
    _handle = 0;
  }
  /**
     The <b>Source</b> option which names the source of the event. The
     current value of this constant is <b>Source</b>.
   */
  public
  void setSource(String source) {
    this.source = source.trim();
  }
  public
  String getSource() {
    return source;
  }
/**
     The <code>NTEventLogAppender</code> requires a layout. Hence,
     this method always returns <code>true</code>. */
  public
  boolean requiresLayout() {
    return true;
  }
  native private int registerEventSource(String server, String source);
  native private void reportEvent(int handle, String message, int priority);
  native private void deregisterEventSource(int handle);
  static {
    System.loadLibrary(""NTEventLogAppender"");
  }
}   
"
org.apache.log4j.nt.test.NTMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.nt.test;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.nt.NTEventLogAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
public class NTMin {
  static Category cat = Category.getInstance(NTMin.class.getName());
  public 
  static 
  void main(String argv[]) {
    //if(argv.length == 1) {
    init();
    //}
    //else {
    //Usage(""Wrong number of arguments."");
    //}
      test(""someHost"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + NTMin.class + """");
    System.exit(1);
  }
  static
  void init() {
    BasicConfigurator.configure(new NTEventLogAppender());
  }
  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.or.DefaultRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
/**
   The default Renderer renders objects by calling their
   <code>toString</code> method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
class DefaultRenderer implements ObjectRenderer {
  DefaultRenderer() {
  }
  /**
     Render the object passed as parameter by calling its
     <code>toString</code> method.  */
  public
  String doRender(Object o) {
    return o.toString();
  }
}  
"
org.apache.log4j.or.MessageRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.LogLog;
import javax.jms.Message;
import javax.jms.JMSException;
import javax.jms.DeliveryMode;
import java.util.Enumeration;
/**
   Render <code>javax.jms.Message</code> objects.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class MessageRenderer implements ObjectRenderer {
  public
  MessageRenderer() {
  }
  /**
     Render a {@link Message}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof Message) {  
      StringBuffer sbuf = new StringBuffer();
      Message m = (Message) o;
      try {
	sbuf.append(""DeliveryMode="");
	switch(m.getJMSDeliveryMode()) {
	case DeliveryMode.NON_PERSISTENT : 	
	  sbuf.append(""NON_PERSISTENT"");
	  break;
	case DeliveryMode.PERSISTENT : 	
	  sbuf.append(""PERSISTENT"");
	  break;
	default: sbuf.append(""UNKNOWN"");
	}
	sbuf.append("", CorrelationID="");
	sbuf.append(m.getJMSCorrelationID());
	sbuf.append("", Destination="");
	sbuf.append(m.getJMSDestination());
	sbuf.append("", Expiration="");
	sbuf.append(m.getJMSExpiration());
	sbuf.append("", MessageID="");
	sbuf.append(m.getJMSMessageID());
	sbuf.append("", Priority="");
	sbuf.append(m.getJMSPriority());
	sbuf.append("", Redelivered="");
	sbuf.append(m.getJMSRedelivered());
	sbuf.append("", ReplyTo="");
	sbuf.append(m.getJMSReplyTo());
	sbuf.append("", Timestamp="");
	sbuf.append(m.getJMSTimestamp());
	sbuf.append("", Type="");
	sbuf.append(m.getJMSType());
	//Enumeration enum = m.getPropertyNames();
	//while(enum.hasMoreElements()) {
	//  String key = (String) enum.nextElement();
	//  sbuf.append(""; ""+key+""="");
	//  sbuf.append(m.getStringProperty(key));
	//}
      } catch(JMSException e) {
	LogLog.error(""Could not parse Message."", e);
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
org.apache.log4j.or.ObjectRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
/**
   Implement this interface in order to render objects as strings.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public interface ObjectRenderer {
  /**
     Render the object passed as parameter as a String.
   */
  public
  String doRender(Object o);
}
"
org.apache.log4j.or.RendererMap,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import java.util.Hashtable;
/**
   Map class objects to an {@link ObjectRenderer}.
   @author Ceki G&uuml;lc&uuml;
   @since version 1.0 */
public class RendererMap {
  Hashtable map;
  static ObjectRenderer defaultRenderer = new DefaultRenderer();
  public
  RendererMap() {
    map = new Hashtable();
  }
  /**
     Find the appropriate renderer for the class type of the
     <code>o</code> parameter. This is accomplished by calling the
     {@link #get(Class)} method. Once a renderer is found, it is
     applied on the object <code>o</code> and the result is returned
     as a {@link String}. */
  public
  String findAndRender(Object o) {
    if(o == null)
      return null;
    else 
      return get(o.getClass()).doRender(o);
  }
  /**
     Syntactic sugar method that calls {@link #get(Class)} with the
     class of the object parameter. */
  public 
  ObjectRenderer get(Object o) {
    if(o == null) 
      return null;
    else
      return get(o.getClass());
  }
  /**
     Search the parents of <code>clazz</code> for a renderer. The
     renderer closest in the hierarchy will be returned. If no
     renderers could be found, then the default renderer is returned.          
     <p>The search first looks for a renderer configured for
     <code>clazz</code>. If a renderer could not be found, then the
     search continues by looking at all the interfaces implemented by
     <code>clazz</code> including the super-interfaces of each
     interface.  If a renderer cannot be found, then the search looks
     for a renderer defined for the parent (superclass) of
     <code>clazz</code>. If that fails, then all the interfaces
     implemented by the parent of <code>clazz</code> are searched and
     so on.
     <p>For example, if A0, A1, A2 are classes and X0, X1, X2, Y0, Y1
     are interfaces where A2 extends A1 which in turn extends A0 and
     similarly X2 extends X1 which extends X0 and Y1 extends Y0. Let
     us also assume that A1 implements the Y0 interface and that A2
     implements the X2 interface.
     <p>The table below shows the results returned by the
     <code>get(A2.class)</code> method depending on the renderers
     added to the map.
     <p><table border=""1"">
     <tr><th>Added renderers</th><th>Value returned by <code>get(A2.class)</code></th>
     <tr><td><code>A0Renderer</code>
         <td align=""center""><code>A0Renderer</code>  
     <tr><td><code>A0Renderer, A1Renderer</code>
         <td align=""center""><code>A1Renderer</code>  
     <tr><td><code>X0Renderer</code>
         <td align=""center""><code>X0Renderer</code>  
     <tr><td><code>A1Renderer, X0Renderer</code>
         <td align=""center""><code>X0Renderer</code>  
     </table>
     <p>This search algorithm is not the most natural, although it is
     particularly easy to implement. Future log4j versions
     <em>may</em> implement a more intuitive search
     algorithm. However, the present algorithm should be acceptable in
     the vast majority of circumstances.
 */
  public
  ObjectRenderer get(Class clazz) {
    //System.out.println(""\nget: ""+clazz);    
    ObjectRenderer r = null;
    for(Class c = clazz; c != null; c = c.getSuperclass()) {
      //System.out.println(""Searching for class: ""+c);
      r = (ObjectRenderer) map.get(c);
      if(r != null) {
	return r;
      }      
      r = searchInterfaces(c);
      if(r != null)
	return r;
    }
    return defaultRenderer;
  }  
  ObjectRenderer searchInterfaces(Class c) {
    //System.out.println(""Searching interfaces of class: ""+c);
    ObjectRenderer r = (ObjectRenderer) map.get(c);
    if(r != null) {
      return r;
    } else {
      Class[] ia = c.getInterfaces();
      for(int i = 0; i < ia.length; i++) {
	r = searchInterfaces(ia[i]);
	if(r != null)
	  return r; 
      }
    }
    return null;
  }
  public
  ObjectRenderer getDefaultRenderer() {
    return defaultRenderer;
  }
  public
  void clear() {
    map.clear();
  }
  /**
     Register an {@link ObjectRenderer} for <code>clazz</code>.     
  */
  public
  void put(Class clazz, ObjectRenderer or) {
    map.put(clazz, or);
  }
}
"
org.apache.log4j.or.ThreadGroupRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import org.apache.log4j.Layout;
/**
   Render {@link ThreadGroup} objects in a format similar to the
   information output by the {@link ThreadGroup#list} method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class ThreadGroupRenderer implements ObjectRenderer {
  public
  ThreadGroupRenderer() {
  }
  /**
     Render a {@link ThreadGroup} object similar to the way that the
     {@link ThreadGroup#list} method output information. 
     <p>The output of a simple program consisting of one
     <code>main</code> thread is:
     <pre>
     java.lang.ThreadGroup[name=main, maxpri=10]
         Thread=[main,5,false]
     </pre>
     <p>The boolean value in thread information is the value returned
     by {@link Thread#isDaemon}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof ThreadGroup) {
      StringBuffer sbuf = new StringBuffer();
      ThreadGroup tg = (ThreadGroup) o;
      sbuf.append(""java.lang.ThreadGroup[name="");
      sbuf.append(tg.getName());
      sbuf.append("", maxpri="");
      sbuf.append(tg.getMaxPriority());
      sbuf.append(""]"");
      Thread[] t = new Thread[tg.activeCount()];
      tg.enumerate(t);
      for(int i = 0; i < t.length; i++) {
	sbuf.append(Layout.LINE_SEP);	
	sbuf.append(""   Thread=["");
	sbuf.append(t[i].getName());
	sbuf.append("","");
	sbuf.append(t[i].getPriority());
	sbuf.append("","");
	sbuf.append(t[i].isDaemon());
	sbuf.append(""]"");
      }
      return sbuf.toString();
    } else {
      // this is the best we can do
      return o.toString();
    }    
  }
}  
"
org.apache.log4j.performance.ConcatVsArray,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import java.util.Date;
/**
   Measure difference in performance of string concatenation versus
   creating an anonymous string array.
   <p>You should be able to see that anonymous string array
   construction is significatnly faster than string concatenation. The
   difference increases proportionally with the length of the strings
   to be concatanated.
   @author Ceki G&uuml;lc&uuml;
 */
public class ConcatVsArray {
  static
  void  Usage() {
    System.err.println(""Usage: java org.apache.log4j.performance.ConcatVsArray "" +
		       ""string1 string2 runLength\n"" +
		       ""       where runLength is an integer."");
    System.exit(1);
  }
  public static void main(String args[]) {
    if(args.length != 3) {
      Usage();
    }    
    String s1 = args[0];
    String s2 = args[1];
    int runLength = 0;
    try {
      runLength = Integer.parseInt(args[2]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      
    double micros;
    String[] sa;
    long before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      sa = new String[]{s1, s2};
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The anonymous array loop took around "" + micros + "" microseconds."");
    String s;    
    before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      s = s1 + s2;
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The append loop took around "" + micros + "" microseconds."");
  }
}
"
org.apache.log4j.performance.ListVsVector,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
import java.util.Vector;
/**
   Compares the performance of looping through a list versus a Vector.
   Chain looping is *20* times faster than vector access on JDK 1.1.7B on NT
*/
public class ListVsVector {
  static int RUN_LENGTH = 1000000;
  static Vector v = new Vector();
  static Chain head;
  static String tmp;
  static
  public 
  void main(String[] args) {
    v.addElement(""aaa"");
    v.addElement(""bbb"");
    v.addElement(""ccc"");
    v.addElement(""ddd"");
    v.addElement(""eee"");
    Chain c = new Chain(""aaa"");
    head = c;
    c.next = new Chain(""bbb""); c = c.next;
    c.next = new Chain(""ccc""); c = c.next;
    c.next = new Chain(""ddd""); c = c.next;
    c.next = new Chain(""eee"");
    double t;
    t = loopChain();
    System.out.println(""Looping thourgh the chain took "" + t);
    t = loopVector();
    System.out.println(""Looping thourgh the vector took "" + t);
  }
  static
  double loopChain() {
    long before = System.currentTimeMillis();
    Chain c;
    for(int i = 0; i < RUN_LENGTH; i++) {
      c = head;
      while(c != null) {
	tmp = c.s;
	c = c.next;
      }
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double loopVector() {
    long before = System.currentTimeMillis();
    int size = v.size();
    for(int i = 0; i < RUN_LENGTH; i++) {
      for(int j = 0; j < size; j++)
	tmp = (String) v.elementAt(j);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static class Chain {
    public String s;
    public Chain next;
    Chain(String s) {
      this.s = s;
    }
    void setNext(Chain c) {
      next = c;
    }
  }
}
"
org.apache.log4j.performance.Logging,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of distribution.
package org.apache.log4j.performance;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.NDC;
import org.apache.log4j.performance.NOPWriter;
import java.util.Enumeration;
/**
   Measure the performance of logging.
   <p>Experimental results are listed below in units of
   <b>micro-seconds</b>. Measurements were done on a AMD Duron clocked
   at 800Mhz running Windows 2000 and Sun's 1.3 JDK.
<p><table border=1>
<tr>
<th>Layout 
<th>NullAppender 
<th>FileAppender
<th>FileAppender (no flush)
<th>AsyncAppender (no flush)
<tr>
<td>SimpleLayout 
<td>4
<td>21
<td>16
<td>31
<tr>
<td>PatternLayout ""%p - %m%n"" 
<td>4
<td>21
<td>16
<td>31
<tr>
<td>PatternLayout ""%-5p - %m%n""
<td>4
<td>NA
<td>NA
<td>NA
<tr>
<td>TTCCLayout/RELATIVE
<td>10
<td>37
<td>31
<td>45
<tr>
<td>PatternLayout ""%r [%t] %-5p %c{2} %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %.10c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %.20c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %c - %m%n""
<td>9
<td>36
<td>29
<td>45
<tr>
<td>TTCCLayout/ISO8601
<td>25
<td>58
<td>51
<td>68
<tr>
<td>PatternLayout ""%d{ISO8601} [%t] %-5p %c %x - %m%n""
<td>28
<td>62
<td>55
<td>73
<tr>
<td>PatternLayout ""%d{yyyy-MM-dd HH:mm:ss,SSS} [%t] %-5p %c %x - %m%n""
<td>46
<td>82
<td>72
<td>91
<tr>
<td>PatternLayout ""%l - %m%n""
<td> 1353
<td> 1565
<td> 1474 
<td> 1459 
<tr>
<td>PatternLayout ""%C.%M.%L - %m%n""
<td>1379 
<td>NA
<td>NA
<td>NA
</table>
   <p>The results of the measurements (should) show that:
   <ol>
   <li><b>The PatternLayout perforance is very close to the performance of
   a dedicated layout of equivalent format.</b>
   <p><li>Format specifiers in conversion patterns have almost no impact
   on performance.
   <p>Formating time and date information is costly. Using relative
   time has the least impact on performance. It is recommended that to
   use log4j specific date formatters such as the {@link
   org.apache.log4j.helpers.ISO8601DateFormat} instead of the standard {@link
   java.text.SimpleDateFormat} because of its poor performance. See
   the <b>%d</b> conversion character in {@link
   org.apache.log4j.PatternLayout}.
   <p><li>Avoiding the flush operation at the end of each append
   results in a performance gain of 10 to 20 percent. However, there
   is safety tradeoff invloved in skipping flushing. Indeed, when
   flushing is skipped, then it is likely that the last few log events
   will not be recorded on disk when the application exits. This is a
   high price to pay even for a 20% performance gain.
   <p><li>The <code>AsyncAppender</code> does not automatically
   increase performance. On the contrary, it significantly degrades
   performance. The performance tests done here very quickly fill up
   the bounded buffer of the <code>AsyncAppender</code> and there is
   cosiderable overhead in managing this bounded buffer.
   <p>On the other hand, had we interleaved logging operations with
   long blocking and non CPU-intensive operations, such as I/O,
   network access, sleeping threads, then the
   <code>AsyncAppender</code> would have tremendously reduced the cost
   of logging in terms of overall application runtime.
   <p>In a variant of this test, we have inserted a short sleep
   operation between every 10 log operations. When the total slept
   time is substracted, logging with the <code>AsyncLogger</code>
   takes no time at all. In other words, logging is done for ""free"".
   <p><li>Extracting location information is (comparatively) very
   slow. It should be avoided unless performace is not a concern.
   </ol>
   @author Ceki G&uuml;lc&uuml;
 */
public class Logging {
  static int runLength;
  static int delay = -1;
  /**
     A delay is applied after every <code>burstLen</code> log
     requests.  The default value of this constant is 100.  */
  static  int burstLen = 100;
  static int DELAY_MULT = 1000/burstLen;
  static Category cat = Category.getInstance(""A0123456789.B0123456789.C0123456789"");
  static
  void  Usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java ""+Logging.class.getName()+"" confFile runLength [delay] [burstLen]\n""+
      ""        confFile is an XML configuration file and\n""+
      ""        runLength (integer) is the length of test loop.\n""+
      ""        delay is the time in millisecs to wait every bustLen log requests."");
    System.exit(1);
  }
  /**
     <b>Usage:</b> <code>java org.apache.log4j.performance.Logging confFile runLength [delay] [burstLen]</code>
     <p><code>confFile</code> is an XML configuration file and
      <code>runLength</code> (integer) is the length of test loop,
      <code>delay</code> is the time in millisecs to sleep every
      <code>bustLen</code> log requests.
      <p>This application just prints the average time it took to log.
   */
  public static void main(String argv[]) {
    if(argv.length == 2)
      init(argv[0], argv[1], null, null);
    else if( argv.length == 4)
      init(argv[0], argv[1], argv[2], argv[3]);
    else
      Usage(""Wrong number of arguments."");
    NDC.push(""some context"");
    double delta;
    String msg = ""ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890"";
     if(delay <= 0) 
      delta = NoDelayLoop(cat, msg);
    else
      delta = DelayedLoop(cat, msg);
    System.out.print((int)delta); 
    Category.shutdown();
  }
  /**
    Program wide initialization method.
    */
  static
  void init(String configFile, String runLengthStr, String delayStr, 
	    String burstLenStr) {
    try {
      runLength   = Integer.parseInt(runLengthStr);
      if(delayStr != null) {
	delay = Integer.parseInt(delayStr);
      }
      if(delayStr != null) {
	burstLen = Integer.parseInt(burstLenStr);
	DELAY_MULT = 1000/burstLen;	
      }      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
    }      
    DOMConfigurator.configure(configFile);
  }
  static
  double NoDelayLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
    }
    return ((System.currentTimeMillis() - before)*1000.0)/runLength;    
  }
  static
  double DelayedLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    int j = 0;
    Thread currentThread = Thread.currentThread();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
      if(j++ == burstLen) {
	j = 0;
	try{currentThread.sleep(delay);}catch(Exception e){}
      }
    }
    double actualTime = ((System.currentTimeMillis()-before)*1000.0/runLength);
    System.out.println(""actual time: ""+actualTime);
    return (actualTime - delay*DELAY_MULT); 
  }  
}
"
org.apache.log4j.performance.NewVsSetLen,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
/**
   This program compares the cost of creating a new StringBuffer and
   converting it to a String versus keeping the same StringBuffer,
   setting its size to zero and then converting it to String.
   <p>The table below gives some figures.
<p>   <table border=""1"" cellpadding=""4"">
   <tr BGCOLOR=""#33CCFF"">
     <th BGCOLOR=""#CCCCCC"" rowspan=""2"">Total Message length
     <th colspan=""2"" align=""center"">0
     <th colspan=""2"" align=""center"">1
     <th colspan=""2"" align=""center"">2
     <th colspan=""2"" align=""center"">4
     <th colspan=""2"" align=""center"">8
   </tr>
   <tr BGCOLOR=""#3366FF"">
     <td>New Buffer</td> <td>setLength</td> 
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">256 
   <td>33 <td>22 
   <td>34 <td>22
   <td>34 <td>22
   <td>34 <td>22 
   <td>33 <td>23
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1024 
   <td>58 <td>41
   <td>59 <td>45
   <td>59 <td>48
   <td>59 <td>51 
   <td>60 <td>44
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">4096 
   <td>146 <td>132
   <td>138 <td>132
   <td>144 <td>126
   <td>142 <td>132
   <td>136 <td>132 
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">16384 
   <td>617 <td>593 
   <td>593 <td>609
   <td>601 <td>617
   <td>601 <td>632 
   <td>593 <td>632
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">65536 
   <td>3218 <td>3281
   <td>3093 <td>3125 
   <td>3125 <td>3156
   <td>3125 <td>3281 
   <td>3062 <td>3562
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">262144 
   <td>14750 <td>15125
   <td>14000 <td>15500 
   <td>14000 <td>16125 
   <td>14000 <td>18000 
   <td>14000 <td>21375 
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1048576 
   <td>87500 <td>80000
   <td>60500 <td>82000 
   <td>57000 <td>93000 
   <td>57500 <td>118500 
   <td>57500 <td>168500 
   </tr>
   <caption ALIGN=""BOTTOM"">Performance comparisons of new buffer
   creation versus setLength(0) approach for various message sizes and
   secondary loop lengths.
   </caption>
   </table>
   <p>The tests copy a message to a destination string buffer and then
   copy a 256 character buffer to another buffer the number of times
   as specified by the secondary loop length.
   <p>The <code>setLength(0)</code> method is usually faster. However,
   after copying a large string it becomes slow even when copying
   small strings.
   <p>This is due to a peculiarity in the <code>copy</code> method in
   StringBuffer class which creates a character array of the same
   length as the old buffer even if the vast majority of those
   characters are unused. 
   <p>The tests were performed on Linux using IBM's JDK 1.1.8.
   <p>The test script is a crude model of what might happen in
   reality. If you remain unconvinced of its results, then please send
   your alternative measurement scenario.
*/
public class NewVsSetLen {
  static String s;
  static int BIGBUF_LEN = 1048576;
  static int SBUF_LEN = 256;
  static int RUN_LENGTH = BIGBUF_LEN/4;
  static char[] sbuf = new char[SBUF_LEN];
  static char[] bigbuf = new char[BIGBUF_LEN];
  {
    for(int i = 0; i < SBUF_LEN; i++) {
      sbuf[i] = (char) (i);
    }
    for(int i = 0; i < BIGBUF_LEN; i++) {
      bigbuf[i] = (char) (i);
    }
  }
  static
  public 
  void main(String[] args) {    
    int t;
    for(int len = SBUF_LEN; len <= BIGBUF_LEN; len*=4, RUN_LENGTH /= 4) {
      System.out.println(""<td>""+len+""\n"");
      for(int second = 0; second < 16;) {
	System.out.println(""SECOND loop=""+second +"", RUN_LENGTH=""
			   +RUN_LENGTH+"", len=""+len);
	t = (int)newBuffer(len, second);;
	System.out.print(""<td>"" + t);
	t = (int)setLen(len, second);
	System.out.println("" <td>"" + t + "" \n"");
	if(second == 0) {
	  second = 1;
	} else {
	  second *= 2;
	}
      }
    }
  }
  static
  double newBuffer(int size, int second) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < RUN_LENGTH; i++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
    }
    for(int x = 0; x <  second; x++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double setLen(int size, int second) {
    long before = System.currentTimeMillis();
    StringBuffer buf = new StringBuffer(SBUF_LEN);
    for(int i = 0; i < RUN_LENGTH; i++) {
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
      buf.setLength(0);
    }
    for(int x = 0; x < second; x++) {
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
      buf.setLength(0);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org.apache.log4j.performance.NOPWriter,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import java.io.Writer;
import java.io.IOException;
/**
  Extends {@link Writer} with methods that return immediately without
  doing anything. This class is used to measure the cost of
  constructing a log message but not actually writing to the
  OutputStream.
  @author  Ceki G&uuml;lc&uuml;
*/
public class NOPWriter extends Writer {
  //public
  //NOPWriter() {
  //}
  public
  void write(char[] cbuf) throws IOException {}
  public
  void write(char[] cbuf, int off, int len) throws IOException {}
  public
  void write(int b) throws IOException {}
  public 
  void write(String s) throws IOException {} 
  public 
  void write(String s, int off, int len) throws IOException {} 
  public 
  void flush() throws IOException {
  }
  public 
  void close() throws IOException {
    System.err.println(""Close called."");
  }
}
"
org.apache.log4j.performance.NotLogging,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
/**
   Measure the performance of evaluating whether to log or not to log,
   but not actually logging.
   <p>This program takes two arguments, a string which should be
   ""true"" for testing shipped code performance and ""false"" for testing
   debug-enabled performance the second argument is the run length of
   the measurement loops.
   <p>The results of the measurement (should) show that
   <ul>
   <p>
   <li>Category evaluation is independent of the length of the category name.
   <p>
   <li>As expected, using the {@link Category#isDebugEnabled
   isDebugEnabled} and {@link Category#isInfoEnabled isInfoEnabled}
   methods eliminates the overhead of message argument construction.
   <p> <li>Message argument construction can be an important slowing
   factor while evaluating whether to log or not.
   </ul>
   @author Ceki G&uuml;lc&uuml;
*/
public class NotLogging {
  static int runLength;
  final static int INITIAL_HASH_SIZE = 101; 
  static String  SHORT_MSG = ""Hello World"";
  static Category SHORT_CAT = Category.getInstance(""A0123456789"");
  static Category MEDIUM_CAT= Category.getInstance(""A0123456789.B0123456789"");
  static Category LONG_CAT  = 
                   Category.getInstance(""A0123456789.B0123456789.C0123456789"");
  static Category INEXISTENT_SHORT_CAT = Category.getInstance(""I0123456789"");
  static Category INEXISTENT_MEDIUM_CAT=
                                Category.getInstance(""I0123456789.B0123456789"");
  static Category INEXISTENT_LONG_CAT= 
                     Category.getInstance(""I0123456789.B0123456789.C0123456789"");
  static Category[] CAT_ARRAY = new Category[] {SHORT_CAT, MEDIUM_CAT, 
						LONG_CAT, INEXISTENT_SHORT_CAT,
						INEXISTENT_MEDIUM_CAT,
						INEXISTENT_LONG_CAT};
  static
  void  Usage() {
    System.err.println(
      ""Usage: java org.apache.log4j.test.NotLogging true|false runLength\n"" +
      ""true indicates shipped code, false indicates code in development"" +
      ""  where runLength is an int representing the run length of loops\n""+
      ""We suggest that runLength be at least 100'000."");
    System.exit(1);
  }
  public static void main(String argv[]) {
    if(argv.length != 2) {
      Usage();
    }    
    ProgramInit(argv);
    double delta;
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = SimpleMessage(CAT_ARRAY[i], SHORT_MSG, runLength);
      System.out.println(""Simple argument,          "" + delta 
			 + "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = FullyOptimizedComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Fully optimized complex,  "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = ComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Complex message argument, "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
  }
  /**
    Program wide initialization method.  */
  static
  void ProgramInit(String[] args) {
    try {
      runLength = Integer.parseInt(args[1]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      
    ConsoleAppender appender = new ConsoleAppender(new SimpleLayout());
    if(""false"".equals(args[0]))
      ;       
    else if (""true"".equals(args[0])) {
      System.out.println(""Flagging as shipped code."");
      Category.getDefaultHierarchy().disableInfo();
    }
    else 
      Usage();
    SHORT_CAT.setPriority(Priority.INFO);      
    Category.getRoot().setPriority(Priority.INFO);
  }    
  static
  double SimpleMessage(Category category, String msg, long runLength) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(msg);
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
  static
  double FullyOptimizedComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      if(category.isDebugEnabled())
	category.debug(""Message"" + i + 
		  "" bottles of beer standing on the wall."");
    }    
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
  static
  double ComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(""Message"" + i +
		"" bottles of beer standing on the wall."");
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
}
"
org.apache.log4j.performance.NullAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;
/**
   A bogus appender which calls the format method of its layout object
   but does not write the result anywhere.   
 */
public class NullAppender extends AppenderSkeleton {
  public static String s;
  public String t;	
  public
  NullAppender() {}
  public
  NullAppender(Layout layout) {
    this.layout = layout;
  }
  public
  void close() {}
  public
  void doAppend(LoggingEvent event) {
    if(layout != null) {
      t = layout.format(event);
      s = t;
    }
  }
  public
  void append(LoggingEvent event) {
  }
  /**
     This is a bogus appender but it still uses a layout.
  */
  public
  boolean requiresLayout() {
    return true;
  }  
}
"
org.apache.log4j.performance.SystemTime,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
/**
   Measures the time required to make a System.currentTimeMillis() and
   Thread.currentThread().getName() calls.
   <p>On an 233Mhz NT machine (JDK 1.1.7B) the
   System.currentTimeMillis() call takes under half a microsecond to
   complete whereas the Thread.currentThread().getName() call takes
   about 4 micro-seconds.
*/
public class SystemTime {
  static int RUN_LENGTH = 1000000;
  static
  public 
  void main(String[] args) {    
    double t = systemCurrentTimeLoop();
    System.out.println(""Average System.currentTimeMillis() call took "" + t);
    t = currentThreadNameloop();
    System.out.println(""Average Thread.currentThread().getName() call took "" 
		       + t);
  }
  static
  double systemCurrentTimeLoop() {
    long before = System.currentTimeMillis();
    long l;
    for(int i = 0; i < RUN_LENGTH; i++) {
      l = System.currentTimeMillis();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double currentThreadNameloop() {
    long before = System.currentTimeMillis();
    String t;
    for(int i = 0; i < RUN_LENGTH; i++) {
      t = Thread.currentThread().getName();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org.apache.log4j.spi.AppenderAttachable,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Appender;
import java.util.Enumeration;
/**
   Interface for attaching appenders to objects.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public interface AppenderAttachable {
  /**
     Add an appender.
   */
  public
  void addAppender(Appender newAppender);
  /**
     Get all previously added appenders as an Enumeration.  */
  public
  Enumeration getAllAppenders();
  /**
     Get an appender by name.
   */
  public
  Appender getAppender(String name);
  /**
     Remove all previously added appenders.
  */
  void removeAllAppenders();
  /**
     Remove the appender passed as parameter from the list of appenders.
  */
   void removeAppender(Appender appender);
 /**
    Remove the appender with the name passed as parameter from the
    list of appenders.  
  */
 void
 removeAppender(String name);   
}
"
org.apache.log4j.spi.CategoryFactory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Category;
/**
  Implement this interface to create new instances of Category or
  a sub-class of Category.
  <p>See {@link org.apache.log4j.examples.MyCategory} for an example.
  @author Ceki G&uuml;lc&uuml;
  @since version 0.8.5
 */
public interface CategoryFactory {
  public
  Category makeNewCategoryInstance(String name);
}
"
org.apache.log4j.spi.Configurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Hierarchy;
import java.net.URL;
/**
   Implemented by classes capable of configuring log4j using a URL.
   @since 1.0
   @author Anders Kristensen
 */
public interface Configurator {
  /**
     Interpret a resource pointed by a URL and set up log4j accordingly.
     The configuration is done relative to the <code>hierarchy</code>
     parameter.
     @param url The URL to parse
     @param hierarchy The hierarchy to operation upon.
   */
  void doConfigure(URL url, Hierarchy hierarchy);
}
"
org.apache.log4j.spi.ErrorCode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
/**
   This interface defines commonly encoutered error codes.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public interface ErrorCode {
  public final int GENERIC_FAILURE = 0;
  public final int WRITE_FAILURE = 1;
  public final int FLUSH_FAILURE = 2;
  public final int CLOSE_FAILURE = 3;
  public final int FILE_OPEN_FAILURE = 4;
  public final int MISSING_LAYOUT = 5;
  public final int ADDRESS_PARSE_FAILURE = 6;
}
"
org.apache.log4j.spi.ErrorHandler,"/**
  Copyright (c) 2000, Ceki Gulcu
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the ""Software""), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
package org.apache.log4j.spi;
import org.apache.log4j.Appender;
/**
   Appenders may delegate their error handling to ErrorHandlers.
   <p>Error handling is a particularly tedious to get right because by
   definition errors are hard to predict and to reproduce. 
   <p>Please take the time to contact the author in case you discover
   that errors are not properly handled. You are most welcome to
   suggest new error handling policies or criticize existing policies.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public interface ErrorHandler extends OptionHandler {
  /**
     This method should handle the error. Information about the error
     condition is passed a parameter.
     @param message The message assoicated with the error.
     @param e The Exption that was thrown when the error occured.
     @param errorCode The error code associated with the error.
  */
  void error(String message, Exception e, int errorCode);
  /**
     This method prints the error message passed as a parameter.
  */
  void error(String message);
}
"
org.apache.log4j.spi.Filter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.spi.LoggingEvent;
/**
   Users should extend this class to implement customized logging
   event filtering. Note that {@link org.apache.log4j.Category} and {@link
   org.apache.log4j.AppenderSkeleton}, the parent class of all standard
   appenders, have built-in filtering rules. It is suggested that you
   first use and understand the built-in rules before rushing to write
   your own custom filters.
   <p>This abstract class assumes and also imposes that filters be
   organized in a linear chain. The {@link #decide
   decide(LoggingEvent)} method of each filter is called sequentially,
   in the order of their addition to the chain.
   <p>The {@link #decide decide(LoggingEvent)} method must return one
   of the integer constants {@link #DENY}, {@link #NEUTRAL} or {@link
   #ACCEPT}.
   <p>If the value {@link #DENY} is returned, then the log event is
   dropped immediately without consulting with the remaining
   filters. 
   <p>If the value {@link #NEUTRAL} is returned, then the next filter
   in the chain is consulted. If there are no more filters in the
   chain, then the log event is logged. Thus, in the presence of no
   filters, the default behaviour is to log all logging events.
   <p>If the value {@link #ACCEPT} is returned, then the log
   event is logged without consulting the remaining filters. 
   <p>The philosophy of log4j filters is largely inspired from the
   Linux ipchains. 
   <p>Note that filtering is only supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}. The {@link
   org.apache.log4j.PropertyConfigurator PropertyConfigurator} does not
   support filters.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public abstract class Filter implements OptionHandler {
  /**
     Points to the next filter in the filter chain.
   */
  public Filter next;
  /**
     The log event must be dropped immediately without consulting
     with the remaining filters, if any, in the chain.  */
  public static final int DENY    = -1;
  /**
     This filter is neutral with respect to the log event. The
     remaining filters, if any, should be consulted for a final decision.
  */
  public static final int NEUTRAL = 0;
  /**
     The log event must be logged immediately without consulting with
     the remaining filters, if any, in the chain.  */
  public static final int ACCEPT  = 1;
  /**
     Usually filters options become active when set. We provide a
     default do-nothing implementation for convenience.
  */
  public
  void activateOptions() {
  }
  /**     
     <p>If the decision is <code>DENY</code>, then the event will be
     dropped. If the decision is <code>NEUTRAL</code>, then the next
     filter, if any, will be invoked. If the decision is ACCEPT then
     the event will be logged without consulting with other filters in
     the chain.
     @param event The LoggingEvent to decide upon.
     @param decision The decision of the filter.  */
  abstract
  public
  int decide(LoggingEvent event);
}
"
org.apache.log4j.spi.LocationInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contributors: Mathias Rupprecht <mmathias.rupprecht@fja.com>
package org.apache.log4j.spi;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Layout;
/**
   The internal representation of caller location information.
   @since 0.8.3
*/
public class LocationInfo implements java.io.Serializable {
  /**
     Caller's line number.
  */
  transient String lineNumber;
  /**
     Caller's file name.
  */
  transient String fileName;
  /**
     Caller's fully qualified class name.
  */
  transient String className;
  /**
     Caller's method name.
  */
  transient String methodName;
  /**
     All available caller information, in the format
     <code>fully.qualified.classname.of.caller.methodName(Filename.java:line)</code>
    */
  public String fullInfo;
  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);
  /**
     When location information is not available the constant
     <code>NA</code> is returned. Current value of this string
     constant is <b>?</b>.  */
  public final static String NA = ""?"";
  static final long serialVersionUID = -1325822038990805636L;
  // Check if we are running in IBM's visual age.
  static boolean inVisualAge = false;
  static {
    try {
      Class dummy = Class.forName(""com.ibm.uvm.tools.DebugSupport"");
      inVisualAge = true;
      LogLog.debug(""Detected IBM VisualAge environment."");
    } catch(Throwable e) { 
      // nothing to do
    }
  }
  /**
     Instantiate location information based on a Throwable. We
     expect the Throwable <code>t</code>, to be in the format
       <pre>
        java.lang.Throwable
        ...
          at org.apache.log4j.PatternLayout.format(PatternLayout.java:413)
          at org.apache.log4j.FileAppender.doAppend(FileAppender.java:183)
        at org.apache.log4j.Category.callAppenders(Category.java:131)
        at org.apache.log4j.Category.log(Category.java:512)
        at callers.fully.qualified.className.methodName(FileName.java:74)
	...
       </pre>
       <p>However, we can also deal with JIT compilers that ""lose"" the
       location information, especially between the parentheses.
    */
    public LocationInfo(Throwable t, String fqnOfCallingClass) {
      if(t == null)
	return;
/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
      String s;
      // Protect against multiple access to sw.
      synchronized(sw) {
	t.printStackTrace(pw);
	s = sw.toString();
	sw.getBuffer().setLength(0);
      }
      //System.out.println(""s is [""+s+""]."");
      int ibegin, iend;
      // Given the current structure of the package, the line
      // containing ""org.apache.log4j.Category."" should be printed just
      // before the caller.
      // This method of searching may not be fastest but it's safer
      // than counting the stack depth which is not guaranteed to be
      // constant across JVM implementations.      
      ibegin = s.lastIndexOf(fqnOfCallingClass);
      if(ibegin == -1) return;
      ibegin = s.indexOf(Layout.LINE_SEP, ibegin); if(ibegin == -1) return;
      ibegin+= Layout.LINE_SEP_LEN;
      // determine end of line
      iend = s.indexOf(Layout.LINE_SEP, ibegin); if(iend == -1) return;
      // VA has a different stack trace format which doesn't 
      // need to skip the inital 'at'
      if(!inVisualAge) {
	// back up to first blank character
	ibegin = s.lastIndexOf(""at "", iend); if(ibegin == -1) return;
	// Add 3 to skip ""at "";
	ibegin += 3;
      }
      // everything between is the requested stack item
      this.fullInfo = s.substring(ibegin, iend);
    }
    /**
       Return the fully qualified class name of the caller making the
       logging request.
    */
    public
    String getClassName() {      
      if(fullInfo == null) return NA;      
      if(className == null) {
	// Starting the search from '(' is safer because there is
	// potentially a dot between the parentheses.
	int iend = fullInfo.lastIndexOf('(');
	if(iend == -1) 
	  className = NA;
	else {
	  iend = fullInfo.lastIndexOf('.', iend);
	  // This is because a stack trace in VisualAge looks like:
          //java.lang.RuntimeException
	  //  java.lang.Throwable()
	  //  java.lang.Exception()
	  //  java.lang.RuntimeException()
	  //  void test.test.B.print()
	  //  void test.test.A.printIndirect()
	  //  void test.test.Run.main(java.lang.String [])
          int ibegin = 0;
	  if (inVisualAge) {
	    ibegin = fullInfo.lastIndexOf(' ', iend)+1;
          }
	  if(iend == -1) 
	    className = NA;
	  else
	    className = this.fullInfo.substring(ibegin, iend);
	}
      }
      return className;
    }
    /**
       Return the file name of the caller.
       <p>This information is not always available.
    */
    public 
    String getFileName() {
      if(fullInfo == null) return NA;
      if(fileName == null) {
	int iend = fullInfo.lastIndexOf(':');	
	if(iend == -1)
	  fileName = NA;
	else {
	  int ibegin = fullInfo.lastIndexOf('(', iend - 1);
	  fileName = this.fullInfo.substring(ibegin + 1, iend);
	}	
      }
      return fileName;
    }
    /**
       Returns the line number of the caller.
       <p>This information is not always available.       
    */
    public 
    String getLineNumber() {
      if(fullInfo == null) return NA;
      if(lineNumber == null) {
	int iend = fullInfo.lastIndexOf(')');	
	int ibegin = fullInfo.lastIndexOf(':', iend -1);
	if(ibegin == -1)
	  lineNumber = NA;
	else 
	  lineNumber = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return lineNumber;
    }
    /**
       Returns the method name of the caller.
    */
    public
    String getMethodName() {
      if(fullInfo == null) return NA;            
      if(methodName == null) {
	int iend = fullInfo.lastIndexOf('(');	
	int ibegin = fullInfo.lastIndexOf('.', iend);
	if(ibegin == -1)
	  methodName = NA;
	else
	  methodName = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return methodName;
    }
}
"
org.apache.log4j.spi.LoggingEvent,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import org.apache.log4j.helpers.LogLog;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.util.Hashtable;
// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Wolf Siberski
//                 Anders Kristensen <akristensen@dynamicsoft.com>
/**
   The internal representation of logging events. When an affirmative
   decision is made to log then a <code>LoggingEvent</code> instance
   is created. This instance is passed around to the different log4j
   components.
   <p>This class is of concern to those wishing to extend log4j. 
   @author Ceki G&uuml;lc&uuml;
   @author James P. Cakalic
   @since 0.8.2 */
public class LoggingEvent implements java.io.Serializable {
  private static long startTime = System.currentTimeMillis();
  /** Fully qualified name of the calling category class. */
  transient public final String fqnOfCategoryClass;
  /** The category of the logging event. The category field is not
  serialized for performance reasons. 
  <p>It is set by the LoggingEvent constructor or set by a remote
  entity after deserialization. */
  transient public Category category;
  /** The category name. */
  public final String categoryName;
  /** Priority of logging event. Priority cannot be serializable
      because it is a flyweight.  Due to its special seralization it
      cannot be declared final either. */
  transient public Priority priority;
  /** The nested diagnostic context (NDC) of logging event. */
  private String ndc;
  /** Have we tried to do an NDC lookup? If we did, there is no need
      to do it again.  Note that its value is always false when
      serialized. Thus, a receiving SocketNode will never use it's own
      (incorrect) NDC. See also writeObject method. */
  private boolean ndcLookupRequired = true;
  /** The application supplied message of logging event. */
  transient private Object message;
  /** The application supplied message rendered through the log4j
      objet rendering mechanism.*/
  private String renderedMessage;
  /** The name of thread in which this logging event was generated. */
  private String threadName;
  /** This 
      variable contains information about this event's throwable  
  */
  private ThrowableInformation throwableInfo;
  /** The number of milliseconds elapsed from 1/1/1970 until logging event
      was created. */
  public final long timeStamp;
  /** Location information for the caller. */
  private LocationInfo locationInfo;
  // Damn serialization
  static final long serialVersionUID = -868428216207166145L;
  static final Integer[] PARAM_ARRAY = new Integer[1];
  static final String TO_PRIORITY = ""toPriority"";
  static final Class[] TO_PRIORITY_PARAMS = new Class[] {int.class};
  static final Hashtable methodCache = new Hashtable(3); // use a tiny table
  /**
     Instantiate a LoggingEvent from the supplied parameters.
     <p>Except {@link #timeStamp} all the other fields of
     <code>LoggingEvent</code> are filled when actually needed.
     <p>
     @param category The category of this event.
     @param priority The priority of this event.
     @param message  The message of this event.
     @param throwable The throwable of this event.  */
  public LoggingEvent(String fqnOfCategoryClass, Category category, 
		      Priority priority, Object message, Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.category = category;
    this.categoryName = category.getName();
    this.priority = priority;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable);
    }
    timeStamp = System.currentTimeMillis();
  }  
  /**
     Set the location information for this logging event. The collected
     information is cached for future use.
   */
  public
  LocationInfo getLocationInformation() {
    if(locationInfo == null) {
      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);
    }
    return locationInfo;
  }
  /**
     Return the message for this logging event. 
     <p>Before serialization, the returned object is the message
     passed by the user to generate the logging event. After
     serialization, the returned value equals the String form of the
     message possibly after object rendering. 
     @since 1.1 */
  public
  Object getMessage() {
    if(message != null) {
      return message;
    } else {
      return getRenderedMessage();
    }
  }
  public
  String getNDC() {
    if(ndcLookupRequired) {
      ndcLookupRequired = false;
      ndc = NDC.get();
    }
    return ndc; 
  }
  public
  String getRenderedMessage() {
     if(renderedMessage == null && message != null) {
       if(message instanceof String) 
	 renderedMessage = (String) message;
       else {
	 renderedMessage=
            category.getHierarchy().getRendererMap().findAndRender(message);
       }
     }
     return renderedMessage;
  }  
  /**
     Returns the time when the application started, in milliseconds
     elapsed since 01.01.1970.  */
  public
  static 
  long getStartTime() {
    return startTime;
  }
  public
  String getThreadName() {
    if(threadName == null)
      threadName = (Thread.currentThread()).getName();
    return threadName;
  }
  /**
     Returns the throwable information contained within this
     event. May be <code>null</code> if there is no such information.
     <p>Note that the {@link Throwable} object contained within a
     {@link ThrowableInformation} does not survive serialization.
     @since 1.1 */
  public
  ThrowableInformation getThrowableInformation() {
    return throwableInfo;
  }
  /**
     Return this event's throwable's string[] representaion.
  */
  public 
  String[] getThrowableStrRep() {
    if(throwableInfo ==  null)
      return null;
    else 
      return throwableInfo.getThrowableStrRep();
  }
  private 
  void readPriority(ObjectInputStream ois) 
                      throws java.io.IOException, ClassNotFoundException {
    int p = ois.readInt();
    try {
      String className = (String) ois.readObject();      
      if(className == null) {
	priority = Priority.toPriority(p);
      } else {
	Method m = (Method) methodCache.get(className);	
	if(m == null) {
	  Class clazz = Class.forName(className);
	  m = clazz.getDeclaredMethod(TO_PRIORITY, TO_PRIORITY_PARAMS);
	  methodCache.put(className, m);
	}      
	PARAM_ARRAY[0] = new Integer(p);
	priority = (Priority) m.invoke(null,  PARAM_ARRAY);
      }
    } catch(Exception e) {
	LogLog.warn(""Priority deserialization failed, reverting to default."", e);
	priority = Priority.toPriority(p);
    }
  }
  private void readObject(ObjectInputStream ois)
                        throws java.io.IOException, ClassNotFoundException {
    ois.defaultReadObject();    
    readPriority(ois);
    // Make sure that no location info is available to Layouts
    if(locationInfo == null)
      locationInfo = new LocationInfo(null, null);
  }
  private
  void writeObject(ObjectOutputStream oos) throws java.io.IOException {
    // Aside from returning the current thread name the wgetThreadName
    // method sets the threadName variable.
    this.getThreadName();    
    // This sets the renders the message in case it wasn't up to now.
    this.getRenderedMessage();
    // This call has a side effect of setting this.ndc and
    // setting ndcLookupRequired to false if not already false.
    this.getNDC();
    // This sets the throwable sting representation of the event throwable.
    this.getThrowableStrRep();
    oos.defaultWriteObject();
    // serialize this event's priority
    writePriority(oos);
  }
  private 
  void writePriority(ObjectOutputStream oos) throws java.io.IOException {
    oos.writeInt(priority.toInt());
    Class clazz = priority.getClass();
    if(clazz == Priority.class) {
      oos.writeObject(null);
    } else {
      // writing directly the Class object would be nicer, except that
      // serialized a Class object can not be read back by JDK
      // 1.1.x. We have to resort to this hack instead.
      oos.writeObject(clazz.getName());
    }
  }
}
"
org.apache.log4j.spi.OptionHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.FileAppender;
/**
   A string based interface to configure package components.
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.1
 */
public interface OptionHandler {
  /**
     Activate the options that were previously set with calls to option
     setters.
     <p>This allows to defer activiation of the options until all
     options have been set. This is required for components which have
     related options that remain ambigous until all are set.
     <p>For example, the FileAppender has the
     {@link FileAppender#setFile File} and
     {@link FileAppender#setAppend Append} options both of which are
     ambigous until the other is also set.
  */
  void activateOptions();
  /**
     Return list of strings that the OptionHandler instance recognizes.
     @deprecated We now use JavaBeans style getters/setters.
   */
  String[] getOptionStrings();
  /**
     Set <code>option</code> to <code>value</code>.
     <p>The handling of each option depends on the OptionHandler
     instance. Some options may become active immediately whereas
     other may be activated only when {@link #activateOptions} is
     called.
     @deprecated We now use JavaBeans style getters/setters.
  */
  void setOption(String option, String value);
}
"
org.apache.log4j.spi.RootCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import  org.apache.log4j.Category;
import  org.apache.log4j.Priority;
import  org.apache.log4j.helpers.LogLog;
// Contibutors: Mathias Bogaert
/**
   RootCategory sits at the top of the category hierachy. It is a
   regular category except that it provides several guarantees.
   <p>First, it cannot be assigned a <code>null</code>
   priority. Second, since root category cannot have a parent, the
   {@link #getChainedPriority} method always returns the value of the
   priority field without walking the hierarchy.
   @author Ceki G&uuml;lc&uuml;
 */
final public class RootCategory extends Category {
  /**
     The root category names itself as ""root"". However, the root
     category cannot be retrieved by name.  
  */
  public
  RootCategory(Priority priority) {
    super(""root"");
    setPriority(priority);
  }
  /**
     Return the assigned priority value without walking the category
     hierarchy.
  */
  final
  public 
  Priority getChainedPriority() {
    return priority;
  }
  /**
     Setting a null value to the priority of the root category may have catastrophic
     results. We prevent this here.
     @since 0.8.3 */
  final  
  public
  void setPriority(Priority priority) {
    if(priority == null) {
      LogLog.error(""You have tried to set a null priority to root."",
		   new Throwable());
    }
    else {
      this.priority = priority;
    }
  }
}
"
org.apache.log4j.spi.ThrowableInformation,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import java.io.Writer;
import java.io.PrintWriter;
import java.util.Vector;
/**
 */
public class ThrowableInformation implements java.io.Serializable {
  private transient Throwable throwable;
  private String[] rep;
  static private VectorWriter vw = new VectorWriter();
  public
  ThrowableInformation(Throwable throwable) {
    this.throwable = throwable;
  }
  public
  Throwable getThrowable() {
    return throwable;
  }
  public
  String[] getThrowableStrRep() {
    if(rep != null) {
      return (String[]) rep.clone();
    } else {
      throwable.printStackTrace(vw);
      rep = vw.toStringArray();
      vw.clear();
      return rep;
    }
  }
}
class VectorWriter extends PrintWriter {
  private Vector v;
  VectorWriter() {
    super(new NullWriter());
    v = new Vector();
  }
  public
  void println(Object o) {      
    v.addElement(o.toString());
  }
  // JDK 1.1.x apprenly uses this form of println while in
  // printStackTrace()
  public
  void println(char[] s) {
    v.addElement(new String(s));
  }
  public  
  void println(String s) {
    v.addElement(s);
  }
  public
  String[] toStringArray() {
    int len = v.size();
    String[] sa = new String[len];
    for(int i = 0; i < len; i++) {
      sa[i] = (String) v.elementAt(i);
    }
    return sa;
  }
  public
  void clear() {
    v.setSize(0);
  }
}  
class NullWriter extends Writer {    
  public 
  void close() {
  }
  public 
  void flush() {
  }
  public
  void write(char[] cbuf, int off, int len) {
  }
}
"
org.apache.log4j.spi.TriggeringEventEvaluator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
/**
   Implementions of this interface allow certain appenders to decide
   when to perform an appender specific action.
  <p>For example the {@link org.apache.log4j.net.SMTPAppender} sends
  an email when the {@link #isTriggeringEvent} method returns
  <code>true</code> and adds the event to an internal buffer when the
  returned result is <code>false</code>.
  @author Ceki G&uuml;lc&uuml;
  @since version 1.0
 */
public interface TriggeringEventEvaluator {
  /**
     Is this the triggering event?
   */
  public boolean isTriggeringEvent(LoggingEvent event);
}
"
org.apache.log4j.test.AsyncAppenderTest,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.xml.DOMConfigurator;
/**
   Test the coordination of the AsyncAppender with its Dispatcher.
   @author  Ceki G&uuml;lc&uuml;
*/
public class AsyncAppenderTest {
  static Category cat = Category.getInstance(AsyncAppenderTest.class);
  static int delayBeforeClose;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile, String delayBeforeCloseStr) {
    DOMConfigurator.configure(configFile);
    try {
      delayBeforeClose   = Integer.parseInt(delayBeforeCloseStr);
    } catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not convert [""+delayBeforeCloseStr+""] to Integer."");
    }      
  }
  static
  void test() {    
    Category root = Category.getRoot();    
    for(int i = 0; i < 100; i++) {      
      root.debug(""Message "" + i);        
    }
    try{Thread.currentThread().sleep(delayBeforeClose);}catch(Exception e){}
    Category.shutdown();
  }
}
"
org.apache.log4j.test.Base64,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.test;
class Base64 {
  final static int MAX_LINE = 76;
  static byte[] asciiEncoding =
    //A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q  
    {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
    //R  S ...                        Z   a   b   c    d    e    f    g
    82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,
    //h    i    j    k    l    m    n    o    p    q    r    s   t     u
    104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
    //v    w    x    y    z   0   1   2   3   4   5   6   7   8   9   +   /
    118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47}; 
  static char[] charEnc = new char[64];
  static {
    for(int i = 0; i < 26; i ++) {
      charEnc[i] = (char) ('A' + i);
      charEnc[i+26] = (char) ('a' + i);
    }
    for(int i = 0; i < 10; i ++) {
      charEnc[i+52] = (char) ('0' + i);
    }
    charEnc[62] = '+';
    charEnc[63] = '/';
  }
  static
  String toString(byte[] inbuf) {
    return toString(inbuf, 0, inbuf.length);
  }
  /**
   */
  static
  String toString(byte[] inbuf, int offset, int length) {
    StringBuffer output = new StringBuffer((length)*4/3 + 1);
    int in;
    char[] out = new char[4];
    int i = offset;
    boolean ended = false;
    int last = offset + length;
    int j;
    int bitsRead;
    while(!ended) {
      in = 0;
      bitsRead = 0;
      for(j = 0; j < 3; j++) {
	if(i == last) {
	  ended = true;
	  break;
	}
	in = (in << 8) | (inbuf[i++] & 0xFF);
	bitsRead += 8;
      }
      while(bitsRead >= 6) {
	bitsRead -= 6;
	output.append(charEnc[(in >>> bitsRead) & 0x3F]);
      }
      if(bitsRead == 4) {
	output.append(charEnc[(in & 0x0F) << 2]);
	output.append(""="");
      }
      else if (bitsRead == 2) {
	output.append(charEnc[(in & 0x03) << 4]);
	output.append(""=="");
      }
    }
    return output.toString();
  }
  public static void main(String[] args) {
    byte[] inbuf = new byte[MAX_LINE];
    while(true) {
      try {
	int read = System.in.read(inbuf, 0, MAX_LINE);
	if(read == -1) break;
	System.out.println(""Read "" + read + "" chars."");
	System.out.println(Base64.toString(inbuf, 0, read));
      }
      catch (Exception e) {
	System.out.println(""Exception "" + e);
      }
    }
  }
}
"
org.apache.log4j.test.CategoryWrapper,"package org.apache.log4j.test;
import org.apache.log4j.*;
/**
   This is just to test that wrapper can work. This implementation is
   actually quite bad and should be avoided.
*/
public class CategoryWrapper {
  Category c;
  static String FQCN = CategoryWrapper.class.getName();
  CategoryWrapper(String name) {
    c = Category.getInstance(name);
  }
  public 
  static 
  void main(String argv[]) {    
    Layout layout = new PatternLayout(""%p [%t] %C %F - %m\n"");
    Appender out = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_OUT);
    CategoryWrapper w1 = new CategoryWrapper(""c1"");
    w1.addAppender(out);
    w1.print(""hello"");
  }
  public 
  void addAppender(Appender appender) {
    c.addAppender(appender);
  }
  public 
  void print(String msg) {
    // You have to supply the fully qualified named of the wrapper
    // class to the specially tailored category.log method for
    // PatternLayout's %C conversion pattern to work.
    // We have to add the "".print"" string because the invocation of
    // wrapper.print method is made from the wrapper itself (main
    // method). This is highly unusual. The fqcn of the wrapper is
    // normally sufficient.
    c.log(FQCN+"".print"", Priority.DEBUG, msg, null);
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+CategoryWrapper.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.ConfigurationFileParsing,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
public class ConfigurationFileParsing {
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) {
      NDC.push(""testing"");
      PropertyConfigurator.configure(argv[0]);
      Category root = Category.getRoot();
      root.debug(""Message 1"");
      root.debug(""Message 2"");      
      NDC.pop();
      Category.shutdown();
    }
    else {
      Usage(""Wrong number of arguments."");
    }
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ConfigurationFileParsing.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.DefaultInit,"package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
public class DefaultInit {
  static Category cat = Category.getInstance(DefaultInit.class.getName());
  public static void main( String[] argv) {
    cat.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.DefaultInit "");
    System.exit(1);
  }
}
"
org.apache.log4j.test.DelayedLoop,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
/**
   This test program sits in a loop and logs things. Its logging is
   configured by a configuration file. Changes to this configuration
   file are monitored and when a change occurs, the config file is re-read.
   @author Ceki G&uuml;lc&uuml; */
public class DelayedLoop {
  static Category cat = Category.getInstance(DelayedLoop.class);
  static int loopLength;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DelayedLoop.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    if(configFile.endsWith(""xml"")) {
      DOMConfigurator.configureAndWatch(configFile, 3000);
    } else {
      PropertyConfigurator.configureAndWatch(configFile, 3000);
    }
  }
  static
  void test() {
    int i = 0;
    while(true) {
      cat.debug(""MSG ""+i++);
      try {
	Thread.currentThread().sleep(1000);
      } catch(Exception e) {}
    }
  }
}
"
org.apache.log4j.test.Finalize,"package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Enumeration;
public class Finalize {
  static Category CAT = Category.getInstance(Finalize.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Finalize.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    InputStreamReader in = new InputStreamReader(System.in);	    
    Category root = Category.getRoot();
    System.out.println(""Type 'q' to quit"");
    int j = 0;
    while (true) {
      System.gc();      
      try {i = in.read(); }
      catch(Exception e) { return; }
      System.gc();
      System.out.println(""Read [""+i+""]."");
      if(i == -1)
	break;
      else if(i == 'q')
	break;
      else 
	root.debug(""Hello "" + (++j));
    } 
    //foo(root);
    root.removeAllAppenders();
    System.gc(); delay(3000);
    System.gc(); delay(3000);    
    System.gc(); delay(3000);  System.gc();
  }
  static
  void foo(Category cat) {    
    Enumeration enum = cat.getAllAppenders();
    while(enum != null && enum.hasMoreElements()) {
      ((org.apache.log4j.Appender) enum.nextElement()).close();
    }
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.Hello,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
/**
   Very simple log4j usage example.
   @author  Ceki G&uuml;lc&uuml;   
 */
public class Hello {
  static Category cat = Category.getInstance(Hello.class);
  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    cat.debug(""Hello world."");
    cat.info(""What a beatiful day."");
  }
}
"
org.apache.log4j.test.L7D,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
// 
//      See the LICENCE file for the terms of distribution.
package org.apache.log4j.test; 
import org.apache.log4j.*;
import java.util.*;
import java.text.*;
/**
   This class is a simple test of the localization routines in
   Category class.
   @author Ceki G&uuml;lc&uuml;, IBM Zurich Research Laboratory */
public class L7D {
  static ResourceBundle[] bundles;
  public 
  static 
  void main(String args[]) {
    if(args.length == 3) 
      init(args[0], args[1], args[2]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + L7D.class.getName() +
			""configFile ISO639LanguageCode ISO2166CountryCode"");
    System.exit(1);
  }
  static
  void init(String configFile, String lanCode, String countryCode) {
    PropertyConfigurator.configure(configFile);
    bundles = new ResourceBundle[3];
    try {
      bundles[0] = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
      bundles[1] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
      bundles[2] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH"")); 
    }
    catch(MissingResourceException e) {
      e.printStackTrace();
    }
  }
  static
  void test() { 
    Category root = Category.getRoot();
    for(int i = 0; i < bundles.length; i++) {
      root.setResourceBundle(bundles[i]);
      root.l7dlog(Priority.DEBUG, ""bogus1"", null);            
      root.l7dlog(Priority.INFO, ""test"", null);
      root.l7dlog(Priority.WARN, ""hello_world"", null);
      root.l7dlog(Priority.DEBUG, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.ERROR, ""bogusMsg"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);      
      root.l7dlog(Priority.ERROR, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.INFO, ""bogus2"", null);
    }
  }
}
"
org.apache.log4j.test.Min,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.Appender;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.TTCCLayout;
import org.apache.log4j.Priority;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import java.io.IOException;
/**
   This class tests the functionality of the Log class and the
   different layouts.
   @author  Ceki G&uuml;lc&uuml;
*/
public class Min {
  public 
  static 
  void main(String argv[]) {
      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test1();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.Min "" +
			""simple|ttcc"");
    System.exit(1);
  }
  /**
    Program wide initialization method.
    */
  static
  void ProgramInit(String layoutType) {
    Appender appender = null;	
    Layout layout = null;
    if(layoutType.equals(""simple"")) 
      layout = new SimpleLayout();
    else if(layoutType.equals(""ttcc"")) {
      layout = new TTCCLayout(AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT);
    }
    else 
      Usage(""Wrong layoutType ["" + layoutType +""]."");
    appender = new ConsoleAppender(layout, ""System.out"");
    BasicConfigurator.configure(appender);
  }
  static
  void test1() {
    int i = 0;
    // In the lines below, the category names are chosen as an aid in
    // remembering their priority values. In general, the category
    // names should have no bearing to priority values.
    Category ERR = Category.getInstance(""ERR"");
    ERR.setPriority(Priority.ERROR);
    Category INF = Category.getInstance(""INF"");
    INF.setPriority(Priority.INFO);
    Category INF_ERR = Category.getInstance(""INF.ERR"");
    INF_ERR.setPriority(Priority.ERROR);
    Category DEB = Category.getInstance(""DEB"");
    DEB.setPriority(Priority.DEBUG);
    // Note: categories with undefined priority 
    Category INF_UNDEF = Category.getInstance(""INF.UNDEF"");
    Category INF_ERR_UNDEF = Category.getInstance(""INF.ERR.UNDEF"");    
    Category UNDEF = Category.getInstance(""UNDEF"");   
    // These should all log.----------------------------
    ERR.log(Priority.FATAL, ""Message "" + i); i++;  //0
    ERR.error( ""Message "" + i); i++;          
    INF.log(Priority.FATAL, ""Message "" + i); i++; // 2
    INF.error( ""Message "" + i); i++;         
    INF.warn ( ""Message "" + i); i++; 
    INF.info ( ""Message "" + i); i++;
    INF_UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  //6
    INF_UNDEF.error( ""Message "" + i); i++;         
    INF_UNDEF.warn ( ""Message "" + i); i++; 
    INF_UNDEF.info ( ""Message "" + i); i++; 
    INF_ERR.log(Priority.FATAL, ""Message "" + i); i++;  // 10
    INF_ERR.error( ""Message "" + i); i++;  
     INF_ERR_UNDEF.log(Priority.FATAL, ""Message "" + i); i++; 
    INF_ERR_UNDEF.error( ""Message "" + i); i++;             
    DEB.log(Priority.FATAL, ""Message "" + i); i++;  //14
    DEB.error( ""Message "" + i); i++;         
    DEB.warn ( ""Message "" + i); i++; 
    DEB.info ( ""Message "" + i); i++; 
    DEB.debug( ""Message "" + i); i++; 
    // defaultPriority=DEBUG
    UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  // 19
    UNDEF.error(""Message "" + i); i++;         
    UNDEF.warn (""Message "" + i); i++; 
    UNDEF.info (""Message "" + i); i++; 
    UNDEF.debug(""Message "" + i, new Exception(""Just testing."")); i++;    
    // -------------------------------------------------
    // The following should not log
    ERR.warn(""Message "" + i);  i++; 
    ERR.info(""Message "" + i);  i++; 
    ERR.debug(""Message "" + i);  i++; 
    INF.debug(""Message "" + i);  i++; 
    INF_UNDEF.debug(""Message "" + i); i++; 
    INF_ERR.warn(""Message "" + i);  i++; 
    INF_ERR.info(""Message "" + i);  i++; 
    INF_ERR.debug(""Message "" + i); i++; 
    INF_ERR_UNDEF.warn(""Message "" + i);  i++; 
    INF_ERR_UNDEF.info(""Message "" + i);  i++; 
    INF_ERR_UNDEF.debug(""Message "" + i); i++; 
    // -------------------------------------------------
    INF.info(""Messages should bear numbers 0 through 23."");
  }     
}
"
org.apache.log4j.test.MultipleAppenders,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Appender;
import java.util.Enumeration;
import java.util.Vector;
public class MultipleAppenders {
  public 
  static 
  void main(String argv[]) {
    // A1 and A2 should be added to root by reading the config file
    PropertyConfigurator.configure(argv[0]);
    Category root = Category.getRoot();
    Enumeration e1 = root.getAllAppenders();
    Vector v = new Vector(1);
    while(e1.hasMoreElements()) {
      Appender a = (Appender) e1.nextElement();
      v.addElement(a);
      String appenderName = a.getName();	
      if(a != root.getAppender(appenderName)) {
	System.out.println(appenderName + "" lookup failed. Exiting."");
	System.exit(1);
      }
      // attempt to add the existing appender
      root.addAppender(a);
    }
    // attempt to add a null appender
    root.addAppender(null);
    Enumeration e2 = root.getAllAppenders();
    for(int i = 0; i < v.size(); i++) {
      if(v.elementAt(i) != e2.nextElement()) {
      }
    }
    if(e2.hasMoreElements()){
      System.out.println(""Failure, e2 has remaining elements. Exiting."");
      System.exit(1);      
    }
    System.out.println(""OK"");
  }
}
"
org.apache.log4j.test.PatternTest,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
/**
   This class is a test of the PatternLayout class.
   @author Ceki G&uuml;lc&uuml;
*/
public class PatternTest {
  static Category CAT = Category.getInstance(PatternTest.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + PatternTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    CAT.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    CAT.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    CAT.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    CAT.error(""Message "" + ++i);
    root.error(""Message "" + i);
    CAT.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    CAT.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    CAT.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    
    CAT.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    
    CAT.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    CAT.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    
    Category.shutdown();
  }
}
"
org.apache.log4j.test.PrintProperties,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */
package org.apache.log4j.test;
import java.io.*;
import org.apache.log4j.config.PropertyPrinter;
/**
   Prints the configuration of the log4j default hierarchy
   (which needs to be auto-initialized) as a propoperties file
   on System.out.
   @author  Anders Kristensen
 */
public class PrintProperties {
  public
  static
  void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out), true);
  }
}"
org.apache.log4j.test.ROFile,"package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;
public class ROFile {
  static Category cat = Category.getInstance(ROFile.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + ROFile.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    cat.debug(""Message "" + ++i);
  }
}
"
org.apache.log4j.test.Shallow,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
// NOTICE: Some tests are sensitive to line numbers!
package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.util.Enumeration;
/** 
   This class is a shallow test of the various appenders and
   layouts. It also tests their reading of the configuration file.
   @author  Ceki G&uuml;lc&uuml;
*/
public class Shallow {
  static Category cat = Category.getInstance(Shallow.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName()+""configFile"");
    System.exit(1);
  }
  static 
  void init(String configFile) {
    if(configFile.endsWith("".xml""))
      DOMConfigurator.configure(configFile);
    else 
      PropertyConfigurator.configure(configFile);
  }
  static 
  void test() {
    int i = -1; 
    NDC.push(""NDC""); 
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    cat.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    
    cat.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    
    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    cat.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    
    // It is always a good idea to call this method when exiting an
    // application.
    Category.shutdown();
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.ShippedCodeFlagTest,"package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;
public class ShippedCodeFlagTest {
  static Category CAT=Category.getInstance(ShippedCodeFlagTest.class.getName());
  public static void main( String[] argv) {
    String type = null;
    if(argv.length == 1) 
      type = argv[0];
    else 
      Usage(""Wrong number of arguments."");
    if(type.equals(""basic"")) {
       System.out.println(""System property \""""+
			  BasicConfigurator.DISABLE_OVERRIDE_KEY +
			  ""\"" is set to [""+
		  System.getProperty(BasicConfigurator.DISABLE_OVERRIDE_KEY)
			  +""]."");
       BasicConfigurator.configure(new ConsoleAppender(new SimpleLayout(),
						 ConsoleAppender.SYSTEM_OUT));
    }
    else { 
      PropertyConfigurator.configure(type);
    }
    Category.getDefaultHierarchy().disableInfo();       
    CAT.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.ShippedCodeFlagTest "" +
			""basic|configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.ShortSocketServer,"package org.apache.log4j.test;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.net.SocketNode;
import org.apache.log4j.net.SocketServer;
/**
*/
public class ShortSocketServer  {
  static Category cat = Category.getInstance(ShortSocketServer.class.getName());
  static int port;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) {
      init(argv[0], argv[1]);
    } else {
      usage(""Wrong number of arguments."");     
    }
    try {
      LogLog.debug(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      LogLog.debug(""Waiting to accept a new client."");
      Socket socket = serverSocket.accept();
      LogLog.debug(""Connected to client at "" + socket.getInetAddress());
      LogLog.debug(""Starting new socket node."");	
      SocketNode sn = new SocketNode(socket, Category.getDefaultHierarchy());
      Thread t = new Thread(sn);
      t.start(); 
      t.join();
    }
    catch(Exception e) {
      cat.error(""Error while in main."", e);
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +ShortSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile) {
    try {
      port   = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
org.apache.log4j.test.SocketAppenderTest,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.test; 
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
import org.apache.log4j.xml.examples.XCategory;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.util.Enumeration;
/**
   @author  Ceki G&uuml;lc&uuml;
*/
public class SocketAppenderTest {
  static XCategory cat = (XCategory) XCategory.getInstance(SocketAppenderTest.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ SocketAppenderTest.class.getName()+
			"" configFile"");
    System.exit(1);
  }
  static 
  void init(String configFile) {
    if(configFile.endsWith("".xml""))
      DOMConfigurator.configure(configFile);
    else 
      PropertyConfigurator.configure(configFile);
  }
  static 
  void test() {
    int i = -1; 
    NDC.push(""NDC""); 
    Category root = Category.getRoot();
    cat.trace(""Message "" + ++i);
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + ++i);
    cat.info(""Message "" + ++i);
    cat.warn(""Message "" + ++i);
    cat.lethal(""Message "" + ++i); //5
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.error(""Message "" + ++i, e);
    Category.shutdown();
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.SpacePad,"package org.apache.log4j.test;
public class SpacePad {
  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32
  static public void main(String[] args) {
    StringBuffer sbuf = new StringBuffer();
    for(int i = 0; i < 35; i++) {
      sbuf.setLength(0);
      sbuf.append(""\"""");
      spacePad(sbuf, i);
      sbuf.append(""\"""");
      System.out.println(sbuf.toString());
    }
    sbuf.setLength(0);
    sbuf.append(""\"""");
    spacePad(sbuf, 67);
    sbuf.append(""\"""");
    System.out.println(sbuf.toString());
  }
  static
  public
  void spacePad(StringBuffer sbuf, int length) {
    //LogLog.debug(""Padding with "" + length + "" spaces."");
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org.apache.log4j.test.StressAsyncAppender,"//  Copyright 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.util.Random;
import java.util.Stack;
/**
   Stress test {@link AsyncAppender}.
 */
public class StressAsyncAppender extends Thread {
  static Category root = Category.getRoot();  
  static Random random = new Random(101);
  static final int LOOP_LENGTH = 24;
  static final int BRANCHING_FACTOR = 4;
  static int maxThreads;  
  static long msgCounter = 0;
  static int threadCounter = 0;  
  static double LOG_2 = Math.log(2);
  static Object lock = new Object();
  public 
  static 
  void main(String args[]) {
    if(args.length != 1) {
      usage();
    }
    DOMConfigurator.configure(""xml/stressAsyncAppender.xml"");
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);
	// wait until all threads are finished
	try {
	  root.debug(""About to wait for notification."");
	  lock.wait();
	  root.debug(""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println(""Usage: java ""+ StressAsyncAppender.class.getName() +
			"" MAX_THREADS"");
    System.exit(1);
  }
  public
  StressAsyncAppender() {
  }
  public
  void run() {
    int loopLength = StressAsyncAppender.randomInt(LOOP_LENGTH);
    root.debug(""In run loop, loopLength = ""+loopLength);
    // half of the way, create new childres
    int createIndex = loopLength/2;
    for(int i = 0; i <= loopLength; i++) {
      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      synchronized(lock) {      
	root.debug(""Message number "" + msgCounter++);	
      }
      //delay(1+randomInt(4)*100);
    }    
    synchronized(lock) {
      StressAsyncAppender.threadCounter--;
      root.debug(""Exiting run loop. "" + threadCounter);
      if(StressAsyncAppender.threadCounter <= 0) {
	root.debug(""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }
  }
  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;
    synchronized(lock) {
      n = maxThreadsConstrained(n);    
      root.debug(""Creating "" + n+ "" child StressAsyncAppender threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressAsyncAppender, threadCounter = "" + (++threadCounter));
	new StressAsyncAppender().start();
      }
    }
  }
  static
  public
  int maxThreadsConstrained(int a) {
    int maxAllowed = StressAsyncAppender.maxThreads - 
                                                 StressAsyncAppender.threadCounter;
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  void delay(long millis) {
    try {
      Thread.currentThread().sleep(millis);
    } catch(Exception e) {}
  }
}
"
org.apache.log4j.test.StressNDC,"//      Copyright 1996-1999, International Business Machines 
//      Corporation and others. All Rights Reserved.
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.util.Random;
import java.util.Stack;
/**
   Stress test {@link NDC}.
 */
public class StressNDC extends Thread {
  static Category root = Category.getRoot();  
  static Random random = new Random(101);
  static final int LOOP_LENGTH = 24;
  static final int PUSH_MISS = LOOP_LENGTH/2;      
  static final int POP_MISS = PUSH_MISS*2;    
  static final int BRANCHING_FACTOR = 4 + 1; // add 1 to the number you want
  static int maxThreads;  
  static int msgCounter = 0;
  static int threadCounter = 0;  
  static double LOG_2 = Math.log(2);
  static Object lock = new Object();
  public 
  static 
  void main(String args[]) {
    root.setPriority(Priority.DEBUG);
    BasicConfigurator.configure();
    if(args.length != 1) {
      usage();
    }
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    root.debug( ""push(IP=127.0.0.1)"");
    NDC.push(""IP=127.0.0.1"");
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);
	// wait until all threads are finished
	try {
	  root.debug( ""About to wait for notification."");
	  lock.wait();
	  root.debug( ""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println( ""Usage: java org.apache.log4j.test.StressNDC "" +
			""MAX_THREADS"");
    System.exit(1);
  }
  Stack parentDC;
  public
  StressNDC(Stack parentDC) {
    this.setName(randomID());
    this.parentDC = parentDC;
  }
  public
  void run() {
    NDC.inherit(parentDC);
    int loopLength = StressNDC.randomInt(LOOP_LENGTH);
    root.debug(""In run loop.debug( loopLength = ""+loopLength);
    int createIndex = loopLength/2;
    for(int i = 0; i <= loopLength; i++) {
      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      if(randomInt(PUSH_MISS) == 0) {
	String id = randomID();
	root.debug( ""push(""+id+"")""); 
	NDC.push(id);
      }      
      root.debug( ""Message number "" + StressNDC.msgCounter++);	
      if(randomInt(POP_MISS) == 0) {
	root.debug( ""pop()"");
	NDC.pop();
      }
    }    
    synchronized(lock) {
      StressNDC.threadCounter--;
      root.debug( ""Exiting run loop. "" + threadCounter);
      if(StressNDC.threadCounter <= 0) {
	root.debug( ""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }
    // We sometimes forget to remove references
    if((loopLength % 2) == 0) {
      root.debug(""Removing NDC for this thread."");
      NDC.remove();
    }
  }
  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;
    synchronized(lock) {
      n = maxThreadsConstained(n);    
      root.debug(""Creating "" + n+ "" child StressNDC threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressNDC, threadCounter = "" + (++threadCounter));
	new StressNDC(NDC.cloneStack()).start();
      }
    }
  }
  static
  public
  int maxThreadsConstained(int a) {
    int maxAllowed = StressNDC.maxThreads - StressNDC.threadCounter;      
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  static
  String randomID() {
    return Integer.toHexString(random.nextInt()& 0xFFFFFF);
  }
}
"
org.apache.log4j.test.SysoutConfigurator,"package org.apache.log4j.test;
import java.util.Properties;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;
/**
 * This configurator simply always adds a FileAppender writing to
 * System.out to the root Category and ignores whatever is in the
 * properties file.
 */
public class SysoutConfigurator implements Configurator {
  public
  void
  doConfigure(java.net.URL url, Hierarchy hierarchy) {
    Category.getRoot().addAppender(
        new ConsoleAppender(
            new SimpleLayout(), ConsoleAppender.SYSTEM_OUT));
  }
}
"
org.apache.log4j.test.UnitTestBoundedFIFO,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
//
// Log4j uses the JUnit framework for internal unit testing. JUnit
// available from
//
//     http://www.junit.org
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.BoundedFIFO;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
/**
   Unit test the {@link BoundedFIFO}.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public class UnitTestBoundedFIFO extends TestCase {
  static Category cat = Category.getInstance(""x"");
  static int MAX = 1000;  
  static LoggingEvent[] e = new LoggingEvent[MAX];
  {
    for (int i = 0; i < MAX; i++) {
      e[i] =  new LoggingEvent("""", cat, Priority.DEBUG, ""e""+i, null);
    }
  }
  public UnitTestBoundedFIFO(String name) {
    super(name);
  }
  public
  void setUp() {
  }
  /**
     Pattern: +++++..-----..
   */
  public
  void test1() {
    for(int size = 1; size <= 128; size *=2) {
      BoundedFIFO bf = new BoundedFIFO(size);
      assertEquals(bf.getMaxSize(), size);
      assertNull(bf.get());
      int i;
      int j;
      int k;
      for(i = 1; i < 2*size; i++) {      
	for(j = 0; j < i; j++) {
	  //System.out.println(""Putting ""+e[j]);
	  bf.put(e[j]); assertEquals(bf.length(), j < size ?  j+1 : size);
	}
	int max = size < j ? size : j;
	j--;
	for(k = 0; k <= j; k++) {	  
	  //System.out.println(""max=""+max+"", j=""+j+"", k=""+k);
	  assertEquals(bf.length(), max - k > 0 ? max - k : 0); 
	  Object r = bf.get();
	  //System.out.println(""Got ""+r);
	  if(k >= size) 
	    assertNull(r);
	  else 
	    assertEquals(r, e[k]);
	}
      }
      //System.out.println(""Passed size=""+size);
    }
  }
  /**
     Pattern: ++++--++--++
   */
  public
  void test2() {
    int size = 3;
    BoundedFIFO bf = new BoundedFIFO(size);
    bf.put(e[0]);	
    assertEquals(bf.get(), e[0]);
    assertNull(bf.get());
    bf.put(e[1]); assertEquals(bf.length(), 1);
    bf.put(e[2]); assertEquals(bf.length(), 2);
    bf.put(e[3]); assertEquals(bf.length(), 3);
    assertEquals(bf.get(), e[1]); assertEquals(bf.length(), 2);
    assertEquals(bf.get(), e[2]); assertEquals(bf.length(), 1);
    assertEquals(bf.get(), e[3]); assertEquals(bf.length(), 0);
    assertNull(bf.get()); assertEquals(bf.length(), 0);
  }
  int min(int a, int b) {
    return a < b ? a : b;
  }
  /**
     Pattern ++++++++++++++++++++ (insert only);
   */
  public
  void testResize1() {
    int size = 10;
    for(int n = 1; n < size*2; n++) {
      for(int i = 0; i < size*2; i++) {
        BoundedFIFO bf = new BoundedFIFO(size);
        for(int f = 0; f < i; f++) {
          bf.put(e[f]);
        }
        bf.resize(n);
        int expectedSize = min(n, min(i, size));
        assertEquals(bf.length(), expectedSize);
        for(int c = 0; c < expectedSize; c++) {
          assertEquals(bf.get(), e[c]);
        }
      }
    }
  }
  /**
     Pattern ++...+ --...-
   */
  public
  void testResize2() {
    int size = 10;
    for(int n = 1; n < size*2; n++) {
      for(int i = 0; i < size*2; i++) {
	for(int d = 0; d < min(i,size); d++) {
	  BoundedFIFO bf = new BoundedFIFO(size);
	  for(int p = 0; p < i; p++) {
	    bf.put(e[p]);
	  }
	  for(int g = 0; g < d; g++) {
	    bf.get();
	  }
	  // x = the number of elems in 
	  int x = bf.length();
	  bf.resize(n);
	  int expectedSize = min(n, x);
	  assertEquals(bf.length(), expectedSize);
	  for(int c = 0; c < expectedSize; c++) {
	    assertEquals(bf.get(), e[c+d]);
	  }
	  assertNull(bf.get());
	}
      }
    }
  }
  /**
     Pattern: i inserts, d deletes, r inserts
   */
  public
  void testResize3() {
    int size = 10;
    for(int n = 1; n < size*2; n++) {
      for(int i = 0; i < size; i++) {
	for(int d = 0; d < i; d++) {
	  for(int r = 0; r < d; r++) {
	    BoundedFIFO bf = new BoundedFIFO(size);
	    for(int p0 = 0; p0 < i; p0++)
	      bf.put(e[p0]);
	    for(int g = 0; g < d; g++) 
	      bf.get();	    
	    for(int p1 = 0; p1 < r; p1++) 
	      bf.put(e[i+p1]);
	    int x =  bf.length();
	    bf.resize(n);
	    int expectedSize = min(n, x);
	    assertEquals(bf.length(), expectedSize);
	    for(int c = 0; c < expectedSize; c++) {
	      assertEquals(bf.get(), e[c+d]);
	    }
	    //assertNull(bf.get());
	  }
	}
      }
    }
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestBoundedFIFO(""test1""));
    suite.addTest(new UnitTestBoundedFIFO(""test2""));
    suite.addTest(new UnitTestBoundedFIFO(""testResize1""));
    suite.addTest(new UnitTestBoundedFIFO(""testResize2""));
    suite.addTest(new UnitTestBoundedFIFO(""testResize3""));
    return suite;
  }
}
"
org.apache.log4j.test.UnitTestCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.FileAppender;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.RootCategory;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.Test;
import java.util.Enumeration;
import java.util.ResourceBundle;
import java.util.Locale;
/**
   Used for internal unit testing the Category class.
   @author Ceki G&uuml;lc&uuml;
*/
public class UnitTestCategory extends TestCase {
  Category cat;
  Appender a1;
  Appender a2;
  ResourceBundle rbUS;
  ResourceBundle rbFR; 
  ResourceBundle rbCH; 
  // A short message.
  static String MSG = ""M"";
  public UnitTestCategory(String name) {
    super(name);
  }
  public
  void setUp() {
    rbUS = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
    assertNotNull(rbUS);
    rbFR = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
    assertNotNull(""Got a null resource bundle."", rbFR);
    rbCH = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH""));
    assertNotNull(""Got a null resource bundle."", rbCH);
  }
  public
  void tearDown() {
    // Regular users should not use the clear method lightly!
    Category.getDefaultHierarchy().clear();
    BasicConfigurator.resetConfiguration();
    a1 = null;
    a2 = null;
  }
  /**
     Add an appender and see if it can be retrieved.
  */
  public
  void testAppender1() {
    cat = Category.getInstance(""test"");
    a1 = new FileAppender();
    a1.setName(""testAppender1"");             
    cat.addAppender(a1);
    Enumeration enum = cat.getAllAppenders();
    Appender aHat = (Appender) enum.nextElement();    
    assertEquals(a1, aHat);    
  }
  /**
     Add an appender X, Y, remove X and check if Y is the only
     remaining appender.
  */
  public
  void testAppender2() {
    a1 = new FileAppender();
    a1.setName(""testAppender2.1"");           
    a2 = new FileAppender();
    a2.setName(""testAppender2.2"");           
    cat = Category.getInstance(""test"");
    cat.addAppender(a1);
    cat.addAppender(a2);    
    cat.removeAppender(""testAppender2.1"");
    Enumeration enum = cat.getAllAppenders();
    Appender aHat = (Appender) enum.nextElement();    
    assertEquals(a2, aHat);
    assert(!enum.hasMoreElements());
  }
  /**
     Test if category a.b inherits its appender from a.
   */
  public
  void testAdditivity1() {
    Category a = Category.getInstance(""a"");
    Category ab = Category.getInstance(""a.b"");
    CountingAppender ca = new CountingAppender();
    a.addAppender(ca);
                   assertEquals(ca.counter, 0);
    ab.debug(MSG); assertEquals(ca.counter, 1);
    ab.info(MSG);  assertEquals(ca.counter, 2);
    ab.warn(MSG);  assertEquals(ca.counter, 3);
    ab.error(MSG); assertEquals(ca.counter, 4);    
  }
  /**
     Test multiple additivity.
   */
  public
  void testAdditivity2() {
    Category a = Category.getInstance(""a"");
    Category ab = Category.getInstance(""a.b"");
    Category abc = Category.getInstance(""a.b.c"");
    Category x   = Category.getInstance(""x"");
    CountingAppender ca1 = new CountingAppender();
    CountingAppender ca2 = new CountingAppender();
    a.addAppender(ca1);
    abc.addAppender(ca2);
    assertEquals(ca1.counter, 0); 
    assertEquals(ca2.counter, 0);        
    ab.debug(MSG);  
    assertEquals(ca1.counter, 1); 
    assertEquals(ca2.counter, 0);        
    abc.debug(MSG);
    assertEquals(ca1.counter, 2); 
    assertEquals(ca2.counter, 1);        
    x.debug(MSG);
    assertEquals(ca1.counter, 2); 
    assertEquals(ca2.counter, 1);    
  }
  /**
     Test additivity flag.
   */
  public
  void testAdditivity3() {
    Category root = Category.getRoot();    
    Category a = Category.getInstance(""a"");
    Category ab = Category.getInstance(""a.b"");
    Category abc = Category.getInstance(""a.b.c"");
    Category x   = Category.getInstance(""x"");
    CountingAppender caRoot = new CountingAppender();
    CountingAppender caA = new CountingAppender();
    CountingAppender caABC = new CountingAppender();
    root.addAppender(caRoot);
    a.addAppender(caA);
    abc.addAppender(caABC);
    assertEquals(caRoot.counter, 0); 
    assertEquals(caA.counter, 0); 
    assertEquals(caABC.counter, 0);        
    ab.setAdditivity(false);
    a.debug(MSG);  
    assertEquals(caRoot.counter, 1); 
    assertEquals(caA.counter, 1); 
    assertEquals(caABC.counter, 0);        
    ab.debug(MSG);  
    assertEquals(caRoot.counter, 1); 
    assertEquals(caA.counter, 1); 
    assertEquals(caABC.counter, 0);        
    abc.debug(MSG);  
    assertEquals(caRoot.counter, 1); 
    assertEquals(caA.counter, 1); 
    assertEquals(caABC.counter, 1);        
  }
  public
  void testDisable1() {
    CountingAppender caRoot = new CountingAppender();
    Category root = Category.getRoot();    
    root.addAppender(caRoot);
    Hierarchy h = Category.getDefaultHierarchy();
    h.disableDebug();
    assertEquals(caRoot.counter, 0);     
    root.debug(MSG); assertEquals(caRoot.counter, 0);  
    root.info(MSG); assertEquals(caRoot.counter, 1);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 2);  
    root.warn(MSG); assertEquals(caRoot.counter, 3);  
    h.disableInfo();
    root.debug(MSG); assertEquals(caRoot.counter, 3);  
    root.info(MSG); assertEquals(caRoot.counter, 3);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 4);  
    root.error(MSG); assertEquals(caRoot.counter, 5);  
    root.log(Priority.ERROR, MSG); assertEquals(caRoot.counter, 6);  
    h.disableAll();
    root.debug(MSG); assertEquals(caRoot.counter, 6);  
    root.info(MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 6);  
    root.error(MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.FATAL, MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.FATAL, MSG); assertEquals(caRoot.counter, 6);  
    h.disable(Priority.FATAL);
    root.debug(MSG); assertEquals(caRoot.counter, 6);  
    root.info(MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 6);  
    root.error(MSG); assertEquals(caRoot.counter, 6);
    root.log(Priority.ERROR, MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.FATAL, MSG); assertEquals(caRoot.counter, 6);  
  }
  public
  void testRB1() {
    Category root = Category.getRoot(); 
    root.setResourceBundle(rbUS);
    ResourceBundle t = root.getResourceBundle();
    assertSame(t, rbUS);
    Category x = Category.getInstance(""x"");
    Category x_y = Category.getInstance(""x.y"");
    Category x_y_z = Category.getInstance(""x.y.z"");
    t = x.getResourceBundle();     assertSame(t, rbUS);
    t = x_y.getResourceBundle();   assertSame(t, rbUS);
    t = x_y_z.getResourceBundle(); assertSame(t, rbUS);
  }
  public
  void testRB2() {
    Category root = Category.getRoot(); 
    root.setResourceBundle(rbUS);
    ResourceBundle t = root.getResourceBundle();
    assertSame(t, rbUS);
    Category x = Category.getInstance(""x"");
    Category x_y = Category.getInstance(""x.y"");
    Category x_y_z = Category.getInstance(""x.y.z"");
    x_y.setResourceBundle(rbFR);
    t = x.getResourceBundle();     assertSame(t, rbUS);
    t = x_y.getResourceBundle();   assertSame(t, rbFR);
    t = x_y_z.getResourceBundle(); assertSame(t, rbFR);    
  }
  public
  void testRB3() {
    Category root = Category.getRoot(); 
    root.setResourceBundle(rbUS);
    ResourceBundle t = root.getResourceBundle();
    assertSame(t, rbUS);
    Category x = Category.getInstance(""x"");
    Category x_y = Category.getInstance(""x.y"");
    Category x_y_z = Category.getInstance(""x.y.z"");
    x_y.setResourceBundle(rbFR);
    x_y_z.setResourceBundle(rbCH);
    t = x.getResourceBundle();     assertSame(t, rbUS);
    t = x_y.getResourceBundle();   assertSame(t, rbFR);
    t = x_y_z.getResourceBundle(); assertSame(t, rbCH);    
  }
  public
  void testExists() {
    Category a = Category.getInstance(""a"");
    Category a_b = Category.getInstance(""a.b"");
    Category a_b_c = Category.getInstance(""a.b.c"");
    Category t;
    t = Category.exists(""xx"");    assertNull(t);
    t = Category.exists(""a"");     assertSame(a, t);
    t = Category.exists(""a.b"");   assertSame(a_b, t);
    t = Category.exists(""a.b.c""); assertSame(a_b_c, t);
  }
  public
  void testHierarchy1() {
    Hierarchy h = new Hierarchy( new RootCategory(Priority.ERROR));
    Category a0 = h.getInstance(""a"");
    assertEquals(""a"", a0.getName());
    assertNull(a0.getPriority());
    assertSame(Priority.ERROR, a0.getChainedPriority());
    Category a1 = h.getInstance(""a"");
    assertSame(a0, a1);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestCategory(""testAppender1""));
    suite.addTest(new UnitTestCategory(""testAppender2""));
    suite.addTest(new UnitTestCategory(""testAdditivity1""));        
    suite.addTest(new UnitTestCategory(""testAdditivity2""));        
    suite.addTest(new UnitTestCategory(""testAdditivity3""));        
    suite.addTest(new UnitTestCategory(""testDisable1""));        
    suite.addTest(new UnitTestCategory(""testRB1""));        
    suite.addTest(new UnitTestCategory(""testRB2""));        
    suite.addTest(new UnitTestCategory(""testRB3""));        
    suite.addTest(new UnitTestCategory(""testExists""));        
    suite.addTest(new UnitTestCategory(""testHierarchy1""));        
    return suite;
  }
  static private class CountingAppender extends AppenderSkeleton {
    int counter;
    CountingAppender() {
      counter = 0;
    }
    public void close() {
    }
    public
    void append(LoggingEvent event) {
      counter++;
    }
    public 
    boolean requiresLayout() {
      return true;
    }
  }
}
"
org.apache.log4j.test.UnitTestCyclicBuffer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
//
// Log4j uses the JUnit framework for internal unit testing. JUnit
// available from
//
//     http://www.junit.org
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.CyclicBuffer;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
/**
   Unit test the {@link CyclicBuffer}.
   @author Ceki G&uuml;lc&uuml;</a> 
   @since 0.9.0
*/
public class UnitTestCyclicBuffer extends TestCase {
  static Category cat = Category.getInstance(""x"");
  static int MAX = 1000;
  static LoggingEvent[] e = new LoggingEvent[MAX];
  {
    for (int i = 0; i < MAX; i++) {
      e[i] =  new LoggingEvent("""", cat, Priority.DEBUG, ""e""+i, null);
    }
  }
  public UnitTestCyclicBuffer(String name) {
    super(name);
  }
  public
  void setUp() {
  }
  public
  void test0() {
    int size = 2;
    CyclicBuffer cb = new CyclicBuffer(size);    
    assertEquals(cb.getMaxSize(), size);    
    cb.add(e[0]);
    assertEquals(cb.length(), 1);    
    assertEquals(cb.get(), e[0]); assertEquals(cb.length(), 0);
    assertNull(cb.get()); assertEquals(cb.length(), 0);
    cb = new CyclicBuffer(size);    
    cb.add(e[0]);
    cb.add(e[1]);
    assertEquals(cb.length(), 2);    
    assertEquals(cb.get(), e[0]); assertEquals(cb.length(), 1);
    assertEquals(cb.get(), e[1]); assertEquals(cb.length(), 0);
    assertNull(cb.get()); assertEquals(cb.length(), 0);
  }
  /**
     Test a buffer of size 1,2,4,8,..,128
   */
  public
  void test1() {
    for(int bufSize = 1; bufSize <= 128; bufSize *=2) 
      doTest1(bufSize);
  }
  void doTest1(int size) {
    //System.out.println(""Doing test with size = ""+size);
    CyclicBuffer cb = new CyclicBuffer(size);
    assertEquals(cb.getMaxSize(), size);
    for(int i = -(size+10); i < (size+10); i++) {
      assertNull(cb.get(i));
    }
    for(int i = 0; i < MAX; i++) {
      cb.add(e[i]);
      int limit = i < size-1 ? i : size-1;
      //System.out.println(""\nLimit is "" + limit + "", i=""+i);
      for(int j = limit; j >= 0; j--) {
	//System.out.println(""i= ""+i+"", j=""+j);
	assertEquals(cb.get(j), e[i-(limit-j)]);
      }
      assertNull(cb.get(-1));
      assertNull(cb.get(limit+1));
    }
  }
  public
  void testResize() {
    for(int isize = 1; isize <= 128; isize *=2) {      
      doTestResize(isize, isize/2+1, isize/2+1);
      doTestResize(isize, isize/2+1, isize+10);
      doTestResize(isize, isize+10, isize/2+1);
      doTestResize(isize, isize+10, isize+10);
    }
  }
  void doTestResize(int initialSize, int numberOfAdds, int newSize) {
    //System.out.println(""initialSize = ""+initialSize+"", numberOfAdds=""
    //	       +numberOfAdds+"", newSize=""+newSize);
    CyclicBuffer cb = new CyclicBuffer(initialSize);
    for(int i = 0; i < numberOfAdds; i++) {
      cb.add(e[i]);
    }    
    cb.resize(newSize);
    int offset = numberOfAdds - initialSize;
    if(offset< 0)
      offset = 0;
    int len = newSize < numberOfAdds ? newSize : numberOfAdds;
    len = len < initialSize ? len : initialSize;
    //System.out.println(""Len = ""+len+"", offset=""+offset);
    for(int j = 0; j < len; j++) {
      assertEquals(cb.get(j), e[offset+j]);
    }
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestCyclicBuffer(""test0""));
    suite.addTest(new UnitTestCyclicBuffer(""test1""));
    suite.addTest(new UnitTestCyclicBuffer(""testResize""));
    return suite;
  }
}
"
org.apache.log4j.test.UnitTestDRFA,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Altough located under org/apache/log4j/test, org.apache.log4j is
// the correct package.
package org.apache.log4j;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
import org.apache.log4j.*;
public class UnitTestDRFA extends TestCase {
  public UnitTestDRFA(String name) {
    super(name);
  }
  public
  void testComputeCheckPeriod() {
    DailyRollingFileAppender drfa = new DailyRollingFileAppender();
    drfa.setName(""testComputeCheckPeriod"");
    drfa.setDatePattern(""yyyy-MM-dd.'log'"");
    assertEquals(drfa.computeCheckPeriod(), 
		 DailyRollingFileAppender.TOP_OF_DAY);
    drfa.setDatePattern(""yyyy-MM-dd mm.'log'"");
    assertEquals(drfa.computeCheckPeriod(), 
		 DailyRollingFileAppender.TOP_OF_MINUTE);
    drfa.setDatePattern(""yyyy-MM-dd a.'log'"");
    assertEquals(drfa.computeCheckPeriod(), 
		 DailyRollingFileAppender.HALF_DAY);
    drfa.setDatePattern(""yyyy-MM-dd HH.'log'"");
    assertEquals(drfa.computeCheckPeriod(), 
		 DailyRollingFileAppender.TOP_OF_HOUR);
    drfa.setDatePattern(""yyyy-MM.'log'"");
    assertEquals(drfa.computeCheckPeriod(), 
		 DailyRollingFileAppender.TOP_OF_MONTH);
    drfa.setDatePattern(""'log'HH'log'"");
    assertEquals(drfa.computeCheckPeriod(), 
		 DailyRollingFileAppender.TOP_OF_HOUR);
  }
  public
  void testRC1() {  
    RollingCalendar rc = new RollingCalendar();
    rc.setType(DailyRollingFileAppender.TOP_OF_DAY);
    Calendar c = Calendar.getInstance();
    // jan, mar, may, july, aug, oct, dec have 31 days
    int [] M31 = {0,2,4,6,7,9,11}; 
    for(int i = 0; i < M31.length; i ++) {
      for(int d = 1; d <=31; d++) {
	for(int h = 0; h < 23; h++) {
	  c.clear();
	  c.set(Calendar.YEAR, 20);
	  c.set(Calendar.MONTH, Calendar.JANUARY + M31[i]);
	  c.set(Calendar.DAY_OF_MONTH, d); 
	  c.set(Calendar.HOUR_OF_DAY, h);
	  c.set(Calendar.MINUTE, 10); 
	  c.set(Calendar.SECOND, 10);
	  c.set(Calendar.MILLISECOND, 88);
	  c.setTime(rc.getNextCheckDate(c.getTime()));
	  if(d == 31) {
	    assertEquals(c.get(Calendar.MONTH),(Calendar.JANUARY+M31[i]+1)%12);
	    assertEquals(c.get(Calendar.DAY_OF_MONTH), 1);
	  } else {
	    assertEquals(c.get(Calendar.MONTH), Calendar.JANUARY+M31[i]);
	    assertEquals(c.get(Calendar.DAY_OF_MONTH), d+1);
	  }
	  assertEquals(c.get(Calendar.HOUR_OF_DAY), 0);
	  assertEquals(c.get(Calendar.MINUTE), 0);
	  assertEquals(c.get(Calendar.SECOND), 0);
	  assertEquals(c.get(Calendar.MILLISECOND), 0);
	}
      }
    }
  }
  public
  void testRC2() {  
    RollingCalendar rc = new RollingCalendar();
    rc.setType(DailyRollingFileAppender.TOP_OF_HOUR);
    Calendar c = Calendar.getInstance();
    TimeZone tz = c.getTimeZone();
    // jan, mar, may, july, aug, oct, dec have 31 days
    int [] M31 = {0,2,4,6,7,9,11}; 
    for(int i = 0; i < M31.length; i ++) {
      System.out.println(""Month = ""+(M31[i]+1));
      for(int d = 1; d <= 31; d++) {
	for(int h = 0; h < 23; h++) {
	  for(int m = 0; m <= 59; m++) {
	    c.clear();
	    c.set(Calendar.YEAR, 20);
	    c.set(Calendar.MONTH, Calendar.JANUARY + M31[i]);
	    c.set(Calendar.DAY_OF_MONTH, d); 
	    c.set(Calendar.HOUR_OF_DAY, h);
	    c.set(Calendar.MINUTE, m); 
	    c.set(Calendar.SECOND, 12);
	    c.set(Calendar.MILLISECOND, 88);
	    boolean dltState0 = c.getTimeZone().inDaylightTime(c.getTime());
	    c.setTime(rc.getNextCheckDate(c.getTime()));	    
	    boolean dltState1 = c.getTimeZone().inDaylightTime(c.getTime());
	    assertEquals(c.get(Calendar.MILLISECOND), 0);
	    assertEquals(c.get(Calendar.SECOND), 0);
	    assertEquals(c.get(Calendar.MINUTE), 0);
	    if(dltState0 == dltState1) {
	      assertEquals(c.get(Calendar.HOUR_OF_DAY), (h+1)%24);
	    } else {
	      // returning to standard time
	      if(dltState0) {
		assertEquals(c.get(Calendar.HOUR_OF_DAY), h);
	      } else { // switching to day light saving time
		//System.err.println(""m=""+m+"", h=""+h+"", d=""+d+"", i=""+i);
		//if(h==2) {
		// System.err.println(c);
		//}
		//assertEquals(c.get(Calendar.HOUR_OF_DAY), (h+2)%24);
	      }
	    }
	    if(h == 23) {
	      assertEquals(c.get(Calendar.DAY_OF_MONTH), (d+1)%32);
	      if(d == 31) {
		assertEquals(c.get(Calendar.MONTH), 
			     (Calendar.JANUARY+M31[i]+1)%12);
	      } else {
		assertEquals(c.get(Calendar.MONTH), 
			     Calendar.JANUARY+M31[i]);
	      }
	    } else {
	      assertEquals(c.get(Calendar.DAY_OF_MONTH), d);
	      assertEquals(c.get(Calendar.MONTH), Calendar.JANUARY+M31[i]);
	    }
	  }
	}
      }
    }
  }
  public
  void testRC3() {  
    RollingCalendar rc = new RollingCalendar();
    rc.setType(DailyRollingFileAppender.TOP_OF_MINUTE);
    int[] S = {0, 1, 5, 10, 21, 30, 59};
    int[] M = {0, 1, 5, 10, 21, 30, 59};
    Calendar c = Calendar.getInstance();
    // jan, mar, may, july, aug, oct, dec have 31 days
    int [] M31 = {2,9,0,4,6,7,11}; 
    for(int i = 0; i < M31.length; i ++) {
      System.out.println(""Month = ""+(M31[i]+1));
      for(int d = 1; d <= 31; d++) {
	for(int h = 0; h < 23; h++) {
	  for(int m = 0; m < M.length; m++) {
	    for(int s = 0; s < S.length; s++) {
	      c.clear();
	      c.set(Calendar.YEAR, 20);
	      c.set(Calendar.MONTH, Calendar.JANUARY + M31[i]);
	      c.set(Calendar.DAY_OF_MONTH, d); 
	      c.set(Calendar.HOUR_OF_DAY, h);
	      c.set(Calendar.MINUTE, M[m]); 
	      c.set(Calendar.SECOND, S[s]);
	      c.set(Calendar.MILLISECOND, 88);
	      c.add(Calendar.MILLISECOND, 1);
	      boolean dltState0 = c.getTimeZone().inDaylightTime(c.getTime());
	      c.setTime(rc.getNextCheckDate(c.getTime()));
	      c.add(Calendar.MILLISECOND, 0);
	      boolean dltState1 = c.getTimeZone().inDaylightTime(c.getTime());
	      assertEquals(c.get(Calendar.MILLISECOND), 0);
	      assertEquals(c.get(Calendar.SECOND), 0);
	      assertEquals(c.get(Calendar.MINUTE), (M[m]+1)%60);
	      if(M[m] == 59) {
		if(dltState0 == dltState1) {
		  assertEquals(c.get(Calendar.HOUR_OF_DAY), (h+1)%24); 
		}
		if(h == 23) {
		  assertEquals(c.get(Calendar.DAY_OF_MONTH), (d+1)%32);
		  if(d == 31) {
		      assertEquals(c.get(Calendar.MONTH), 
		    	 (Calendar.JANUARY+M31[i]+1)%12);
		  } else {
		    assertEquals(c.get(Calendar.MONTH), 
		    	 Calendar.JANUARY+M31[i]);
		  }
		} else {
		  assertEquals(c.get(Calendar.DAY_OF_MONTH), d);
		}
	      } else {
		// allow discrepancies only if we are switching from std to dls time
		if(c.get(Calendar.HOUR_OF_DAY) != h) {
		  c.add(Calendar.HOUR_OF_DAY, +1);
		  boolean dltState2 = c.getTimeZone().inDaylightTime(c.getTime());
		  if(dltState1 == dltState2) {
		    fail(""No switch""); 
		  } 
		}		
		assertEquals(c.get(Calendar.DAY_OF_MONTH), d);
		assertEquals(c.get(Calendar.MONTH), Calendar.JANUARY+M31[i]);
	      }
	    }
	  }
	}
      }
    }
  }
  public 
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestDRFA(""testComputeCheckPeriod""));
    suite.addTest(new UnitTestDRFA(""testRC1""));
    //suite.addTest(new UnitTestDRFA(""testRC2""));
    suite.addTest(new UnitTestDRFA(""testRC3""));
    return suite;
  }
}
"
org.apache.log4j.test.UnitTestOptionConverter,"// Log4j uses the JUnit framework for internal unit testing. JUnit
// is available from ""http://www.junit.org"".
package org.apache.log4j.test;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.Priority;
import org.apache.log4j.xml.examples.XPriority;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.Test;
import java.util.Properties;
/**
   Test variable substitution code.   
   @author Ceki G&uuml;lc&uuml;
   @since 1.0
*/
public class UnitTestOptionConverter extends TestCase {
  Properties props;
  public UnitTestOptionConverter(String name) {
    super(name);
  }
  public
  void setUp() {
    props = new Properties();
    props.put(""TOTO"", ""wonderful"");
    props.put(""key1"", ""value1"");
    props.put(""key2"", ""value2"");
    System.setProperties(props);
  }  
  public
  void tearDown() {
    props = null;
  }
  public
  void varSubstTest1() {
    String r;
    r = OptionConverter.substVars(""hello world."", null);
    assertEquals(""hello world."", r);
    r = OptionConverter.substVars(""hello ${TOTO} world."", null);
    assertEquals(""hello wonderful world."", r);
  }
  public
  void varSubstTest2() {
    String r;
    r = OptionConverter.substVars(""Test2 ${key1} mid ${key2} end."", null);
    assertEquals(""Test2 value1 mid value2 end."", r);
  }
  public
  void varSubstTest3() {
    String r;
    r = OptionConverter.substVars(
				     ""Test3 ${unset} mid ${key1} end."", null);
    assertEquals(""Test3  mid value1 end."", r);
  }
  public
  void varSubstTest4() {
    String res;
    String val = ""Test4 ${incomplete "";
    try {
      res = OptionConverter.substVars(val, null);
    }
    catch(IllegalArgumentException e) {
      String errorMsg = e.getMessage();
      //System.out.println('['+errorMsg+']');
      assertEquals('""'+val+ ""\"" has no closing brace. Opening brace at position 6."", errorMsg);
    }
  }
  public
  void toPriorityTest1() {
    String val = ""INFO"";
    Priority p = OptionConverter.toPriority(val, null);
    assertEquals(p, Priority.INFO);
  }
  public
  void toPriorityTest2() {
    String val = ""INFO#org.apache.log4j.xml.examples.XPriority"";
    Priority p = OptionConverter.toPriority(val, null);
    assertEquals(p, Priority.INFO);
  }
  public
  void toPriorityTest3() {
    String val = ""TRACE#org.apache.log4j.xml.examples.XPriority"";
    Priority p = OptionConverter.toPriority(val, null);    
    assertEquals(p, XPriority.TRACE);
  }
  public
  void toPriorityTest4() {
    String val = ""TR#org.apache.log4j.xml.examples.XPriority"";
    Priority p = OptionConverter.toPriority(val, null);    
    assertEquals(p, null);
  }
  public
  void toPriorityTest5() {
    String val = ""INFO#org.apache.log4j.xml.TOTO"";
    Priority p = OptionConverter.toPriority(val, null);    
    assertEquals(p, null);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestOptionConverter(""varSubstTest1""));
    suite.addTest(new UnitTestOptionConverter(""varSubstTest2""));
    suite.addTest(new UnitTestOptionConverter(""varSubstTest3""));
    suite.addTest(new UnitTestOptionConverter(""varSubstTest4""));
    suite.addTest(new UnitTestOptionConverter(""toPriorityTest1""));
    suite.addTest(new UnitTestOptionConverter(""toPriorityTest2""));
    suite.addTest(new UnitTestOptionConverter(""toPriorityTest3""));
    suite.addTest(new UnitTestOptionConverter(""toPriorityTest4""));
    suite.addTest(new UnitTestOptionConverter(""toPriorityTest5""));
    return suite;
  }
}
"
org.apache.log4j.test.UnitTestOR,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
//
// Log4j uses the JUnit framework for internal unit testing. JUnit
// available from
//
//     http://www.junit.org
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
import java.io.Serializable;
/**
   Unit test the {@link ObjectRenderer}.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class UnitTestOR extends TestCase {
  static UTObjectRenderer aor;
  static UTObjectRenderer bor;
  static UTObjectRenderer xor;
  static UTObjectRenderer yor;
  static UTObjectRenderer oor;
  static UTObjectRenderer nor;
  static UTObjectRenderer ior;
  static UTObjectRenderer cor;
  static UTObjectRenderer sor;
  public UnitTestOR(String name) {
    super(name);
  }
  public
  void setUp() {
    aor = new UTObjectRenderer(""A"");
    bor = new UTObjectRenderer(""B"");
    xor = new UTObjectRenderer(""X"");    
    yor = new UTObjectRenderer(""Y"");    
    oor = new UTObjectRenderer(""Object"");
    nor = new UTObjectRenderer(""Number"");
    ior = new UTObjectRenderer(""Integer"");
    cor = new UTObjectRenderer(""Comparable"");
    sor = new UTObjectRenderer(""Serializable"");
  }
  // Add: no renderer
  // Expect: defaultRenderer
  public
  void test1() {
    RendererMap map = new RendererMap();
    ObjectRenderer dr = map.getDefaultRenderer();
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, dr);
  }
  // Add: Integer renderer
  // Expect: Integer renderer
  public
  void test2() {
    RendererMap map = new RendererMap();
    map.put(Integer.class, ior);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, ior);
  }
  // Add: Number renderer
  // Expect: Number
  public
  void test3() {
    RendererMap map = new RendererMap();
    map.put(Number.class, ior);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, ior);
  }
  // Add: Object renderer
  // Result: Object
  public
  void test4() {
    RendererMap map = new RendererMap();
    map.put(Object.class, oor);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, oor);
  }
  // Add: Object, Number, Integer
  // Expect: Integer
  public
  void test5() {
    RendererMap map = new RendererMap();
    map.put(Object.class, oor);
    map.put(Number.class, nor);
    map.put(Integer.class, ior);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, ior);
  }
  // Add: Object, Number
  // Expect: Number
  public
  void test6() {
    RendererMap map = new RendererMap();
    map.put(Object.class, oor);
    map.put(Number.class, nor);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, nor);
  }
  // Add: Comparable
  // Expect: Comparable
  public
  void test7() {
    RendererMap map = new RendererMap();
    map.put(Comparable.class, cor);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, cor);
  }
  // Add: Serializable
  // Expect: Serializablee
  public
  void test8() {
    RendererMap map = new RendererMap();
    map.put(Serializable.class, sor); 
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, sor);
  }
  // Add: Y
  // Expect: Y
  public
  void test9() {
    RendererMap map = new RendererMap();
    map.put(Y.class, yor); 
    ObjectRenderer r = map.get(B.class);
    assertEquals(r, yor);
  }
  // Add: X
  // Expect: X
  public
  void test10() {
    RendererMap map = new RendererMap();
    map.put(X.class, xor); 
    ObjectRenderer r = map.get(B.class);
    assertEquals(r, xor);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestOR(""test1""));
    suite.addTest(new UnitTestOR(""test2""));
    suite.addTest(new UnitTestOR(""test3""));
    suite.addTest(new UnitTestOR(""test4""));
    suite.addTest(new UnitTestOR(""test5""));
    suite.addTest(new UnitTestOR(""test6""));
    suite.addTest(new UnitTestOR(""test7""));
    suite.addTest(new UnitTestOR(""test8""));
    suite.addTest(new UnitTestOR(""test9""));
    suite.addTest(new UnitTestOR(""test10""));
    return suite;
  }
}
class UTObjectRenderer implements ObjectRenderer {
  String name;
  UTObjectRenderer(String name) {
    this.name = name;
  }
  public
  String doRender(Object o) {
    return name;
  }
  public
  String toString() {
    return(""UTObjectRenderer: ""+name);
  }
}
interface X  {
}
interface Y extends X {
}
class A implements Y  {
}
class B extends A  {
}
"
org.apache.log4j.varia.DenyAllFilter,"//  Copyright (c) 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.varia;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
/**
   This filter drops all logging events. 
   <p>You can add this filter to the to the end of a filter chain to
   switch from the default ""accept all unless instructed otherwise""
   filtering behaviour to a ""deny all unless instructed otherwise""
   behaviour.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class DenyAllFilter extends Filter {
  /**
     Returns <code>null</code> as there are no options.
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return null;
  }
  /**
     No options to set.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
  }
  /**
     Always returns the integer constant {@link Filter#DENY}
     regardless of the {@link LoggingEvent} parameter.
     @param event The LoggingEvent to filter.
     @return Always returns {@link Filter#DENY}.
  */
  public
  int decide(LoggingEvent event) {
    return Filter.DENY;
  }
}
"
org.apache.log4j.varia.ExternallyRolledFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.varia;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.RollingFileAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
/**
   This appender listens on a socket on the port specified by the
   {@link #PORT_OPTION} for a ""RollOver"" message. When such a message
   is received, the underlying log file is rolled over and an 
   acknowledgement message is sent back to the process initiating
   the roll over.
   <p>This method of triggering roll over has the advantage of being
   operating system independent, fast and reliable.
   <p>A simple application {@link Roller} is provided to initiate the
   roll over.
   <p>Note that the intiator is not authenticated. Anyone can trigger
   a rollover. In production environments, it is recommended that you
   add some form of protection to prevent undesired rollovers.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class ExternallyRolledFileAppender extends RollingFileAppender {
  /**
     A string constant used in naming the option for setting the port
     for listening to external roll over messages. Current value of
     this string constant is <b>Port</b>.  
     <p>All option keys are case sensitive. 
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  static final public String PORT_OPTION = ""Port"";
  /**
     The string constant sent to initiate a roll over.   Current value of
     this string constant is <b>RollOver</b>.  
  */
  static final public String ROLL_OVER = ""RollOver"";
  /**
     The string constant sent to acknowledge a roll over.   Current value of
      this string constant is <b>OK</b>.
  */
  static final public String OK = ""OK"";
  int port = 0;
  HUP hup;
  /**
     The default constructor does nothing but calls its super-class
     constructor.  */
  public
  ExternallyRolledFileAppender() { 
  }
  /**
     Returns the option names for this component, namely {@link
     #PORT_OPTION} in addition to the options of its super class {@link
     RollingFileAppender#getOptionStrings FileAppender}. 
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
 */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {PORT_OPTION});
  }
  /**
     Set ExternallyRolledFileAppender specific options.
     In addition to {@link org.apache.log4j.FileAppender#setOption FileAppender
     options} and {@link RollingFileAppender#setOption RollingFileAppender
     options}, ExternallyRolledFileAppender recognizes the option
     <b>Port</b>.
     <p>The <b>Port</b> option is used for setting the port for 
     listening to external roll over messages.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
  public
  void setOption(String option, String value) {
    super.setOption(option, value);    
    if(option.equalsIgnoreCase(PORT_OPTION)) {
      port = OptionConverter.toInt(value, port);
      LogLog.debug(""Port option set to ""+port); 
    }
  }
  /**
     The <b>Port</b> option is used for setting the port for 
     listening to external roll over messages.
   */
  public
  void setPort(int port) {
    this.port = port;
  }
  /**
     Returns value of the <b>Port</b> option.
   */
  public
  int getPort() {
    return port;
  }
  /**
     Start listening on the port specified by a preceding call to
     {@link #setOption}.  */
  public
  void activateOptions() {
    super.activateOptions();
    if(port != 0) {
      if(hup != null) {
	hup.interrupt();
      }
      hup = new HUP(this, port);      
      hup.setDaemon(true);
      hup.start();
    }
  }
}
class HUP extends Thread {
  int port;
  ExternallyRolledFileAppender er;
  HUP(ExternallyRolledFileAppender er, int port) {
    this.er = er;
    this.port = port;
  }
  public
  void run() {
    while(!isInterrupted()) {
      try {	
	ServerSocket serverSocket = new ServerSocket(port);
	while(true) {
	  Socket socket = serverSocket.accept();
	  LogLog.debug(""Connected to client at "" + socket.getInetAddress());
	  new Thread(new HUPNode(socket, er)).start();
	}
      }
      catch(Exception e) {
	e.printStackTrace();
      }
    } 
  }
}
class HUPNode implements Runnable {
  Socket socket;
  DataInputStream dis;
  DataOutputStream dos;
  ExternallyRolledFileAppender er;
  public
  HUPNode(Socket socket, ExternallyRolledFileAppender er) {
    this.socket = socket;
    this.er = er;
    try {
      dis = new DataInputStream(socket.getInputStream());
      dos = new DataOutputStream(socket.getOutputStream());
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  public void run() {
    try {
      String line = dis.readUTF();
      LogLog.debug(""Got external roll over signal."");      
      if(ExternallyRolledFileAppender.ROLL_OVER.equals(line)) {
	synchronized(er) {
	  er.rollOver();
	}
	dos.writeUTF(ExternallyRolledFileAppender.OK);
      }
      else {
	dos.writeUTF(""Expecting [RollOver] string."");
      }
      dos.close();
    }
    catch(Exception e) {
      LogLog.error(""Unexpected exception. Exiting HUPNode."", e);
    }    
  }
}
"
org.apache.log4j.varia.PriorityMatchFilter,"//  Copyright (c) 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.varia;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on priority matching.
   <p>The filter admits two options <b>PriorityToMatch</b> and
   <b>AcceptOnMatch</b>. If there is an exact match between the value
   of the PriorityToMatch option and the priority of the {@link
   LoggingEvent}, then the {@link #decide} method returns {@link
   Filter#ACCEPT} in case the <b>AcceptOnMatch</b> option value is set
   to <code>true</code>, if it is <code>false</code> then {@link
   Filter#DENY} is returned. If there is no match, {@link
   Filter#NEUTRAL} is returned.
   <p>See configuration files <a
   href=""../xml/doc-files/test11.xml"">test11.xml</a> and <a
   href=""../xml/doc-files/test12.xml"">test12.xml</a> for an example of
   seeting up a <code>PriorityMatchFilter</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public class PriorityMatchFilter extends Filter {
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String PRIORITY_TO_MATCH_OPTION = ""PriorityToMatch"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
  /**
     Do we return ACCEPT when a match occurs. Default is
     <code>true</code>.  */
  boolean acceptOnMatch = true;
  /**
   */
  Priority priorityToMatch;
  /**
     @deprecated We now use JavaBeans introspection to configure
     components.
  */
  public
  String[] getOptionStrings() {
    return new String[] {PRIORITY_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
     @deprecated We now use JavaBeans introspection to configure
     components. 
  */
  public
  void setOption(String key, String value) {    
    if(key.equalsIgnoreCase(PRIORITY_TO_MATCH_OPTION)) {
      priorityToMatch = Priority.toPriority(value, null);
    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
  public
  void setPriorityToMatch(String priority) {
    priorityToMatch = Priority.toPriority(priority, null);
  }
  public
  String getPriorityToMatch() {
    return priorityToMatch == null ? null : priorityToMatch.toString();
  }
  public
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }
  /**
     Return the decision of this filter.
     Returns {@link Filter#NEUTRAL} if the <b>PriorityToMatch</b>
     option is not set.  Otherwise, the returned decision is defined
     according to the following table:
     <p><table border=1>
     <tr><th rowspan=""2"" BGCOLOR=""#AAAAFF"">Did a priority match occur?</th>
     	 <th colspan=""2"" BGCOLOR=""#CCCCCC"">AcceptOnMatch setting</th>
     <tr><td BGCOLOR=""#CCCCCC"" align=""center"">TRUE</td>
     	 <td BGCOLOR=""#CCCCCC"" align=""center"">FALSE</td>
     <tr><td BGCOLOR=""#AAAAFF"" align=""center"">TRUE</td>
     	 <td>{@link Filter#ACCEPT}</td><td>{@link Filter#DENY}</td>
     <tr><td BGCOLOR=""#AAAAFF"" align=""center"">FALSE</td>
     	 <td>{@link Filter#DENY}</td><td>{@link Filter#ACCEPT}</td>
     	 <caption align=""bottom"">Filter decision in function of whether a match
     	 occured and the AcceptOnMatch settings</caption> 
    </table> */
  public
  int decide(LoggingEvent event) {
    if(this.priorityToMatch == null) {
      return Filter.NEUTRAL;
    }
    boolean matchOccured = false;
    if(this.priorityToMatch == event.priority) {
      matchOccured = true;
    }
    if(this.acceptOnMatch ^ matchOccured) {
      return Filter.DENY;
    } else {
      return Filter.ACCEPT;
    }
  }
}
"
org.apache.log4j.varia.PriorityRangeFilter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.varia;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on priority matching, which can be
   used to reject messages with priorities outside a certain range.
   <p>The filter admits three options <b>PriorityMin</b>, <b>PriorityMax</b>
   and <b>AcceptOnMatch</b>.
   <p>If the priority of the {@link LoggingEvent} is not between Min and Max
   (inclusive), then {@link Filter#DENY} is returned.
   <p> If the Logging event priority is within the specified range, then if
   <b>AcceptOnMatch</b> is true, {@link Filter#ACCEPT} is returned, and if
   <b>AcceptOnMatch</b> is false, {@link Filter#NEUTRAL} is returned.
   <p>If <code>PriorityMin</code>w is not defined, then there is no
   minimum acceptable priority (ie a priority is never rejected for
   being too ""low""/unimportant).  If <code>PriorityMax</code> is not
   defined, then there is no maximum acceptable priority (ie a
   priority is never rejected for beeing too ""high""/important).
   <p>Refer to the {@link
   org.apache.log4j.AppenderSkeleton#setThreshold setThreshold} method
   available to <code>all</code> appenders extending {@link
   org.apache.log4j.AppenderSkeleton} for a more convenient way to
   filter out events by priority.
   @author Simon Kitching
   @author based on code by Ceki G&uuml;lc&uuml; 
*/
public class PriorityRangeFilter extends Filter {
  /**
     Do we return ACCEPT when a match occurs. Default is
     <code>false</code>, so that later filters get run by default  */
  boolean acceptOnMatch = false;
  Priority priorityMin;
  Priority priorityMax;
  /**
     Return the decision of this filter.
   */
  public
  int decide(LoggingEvent event) {
    if(this.priorityMin != null) {
      if (event.priority.isGreaterOrEqual(priorityMin) == false) {
        // priority of event is less than minimum
        return Filter.DENY;
      }
    }
    if(this.priorityMax != null) {
      if (event.priority.toInt() > priorityMax.toInt()) {
        // priority of event is greater than maximum
        // Alas, there is no Priority.isGreater method. and using
        // a combo of isGreaterOrEqual && !Equal seems worse than
        // checking the int values of the priority objects..
        return Filter.DENY;
      }
    }
    if (acceptOnMatch) {
      // this filter set up to bypass later filters and always return
      // accept if priority in range
      return Filter.ACCEPT;
    }
    else {
      // event is ok for this filter; allow later filters to have a look..
      return Filter.NEUTRAL;
    }
  }
 /**
     Get the value of the <code>PriorityMax</code> option.  */
  public
  Priority getPriorityMax() {
    return priorityMax;
  }
  /**
     Get the value of the <code>PriorityMin</code> option.  */
  public
  Priority getPriorityMin() {
    return priorityMin;
  }
  /**
     Get the value of the <code>AcceptOnMatch</code> option.
   */
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }
  /**
     Set the <code>PriorityMax</code> option.
   */
  public
  void setPriorityMax(Priority priorityMax) {
    this.priorityMax =  priorityMax;
  }
  /**
     Set the <code>PriorityMin</code> option.
   */
  public
  void setPriorityMin(Priority priorityMin) {
    this.priorityMin =  priorityMin;
  }
  /**
     Set the <code>AcceptOnMatch</code> option.
   */  
  public 
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  /**
     @deprecated We now use JavaBeans introspection to configure
     components. 
   */
  public
  String[] getOptionStrings() {
    return new String[] {
      PRIORITY_MIN_OPTION,
      PRIORITY_MAX_OPTION,
      ACCEPT_ON_MATCH_OPTION};
  }
  /**
     @deprecated We now use JavaBeans introspection to configure
     components. 
   */
  public
  void setOption(String key, String value) {
    if(key.equalsIgnoreCase(PRIORITY_MIN_OPTION)) {
      priorityMin = OptionConverter.toPriority(value, null);
    }
    else if (key.equalsIgnoreCase(PRIORITY_MAX_OPTION)) {
      priorityMax = OptionConverter.toPriority(value, null);
    }
    else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
  /** See class comments  */
  public static final String PRIORITY_MIN_OPTION = ""PriorityMin"";
  /** See class comments  */
  public static final String PRIORITY_MAX_OPTION = ""PriorityMax"";
  /** See class comments  */
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
}
"
org.apache.log4j.varia.Roller,"// Copyright 2000, Ceki Gulcu. 
package org.apache.log4j.varia;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
/**
   A simple application to send roll over messages to a potentially
   remote {@link ExternallyRolledFileAppender}. 
   <p>It takes two arguments, the <code>host_name</code> and
   <code>port_number</code> where the
   <code>ExternallyRolledFileAppender</code> is listening.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class Roller {
  static Category cat = Category.getInstance(Roller.class.getName());
  static String host;
  static int port;
  // Static class.
  Roller() {
  }
  /**
     Send a ""RollOver"" message to
     <code>ExternallyRolledFileAppender</code> on <code>host</code>
     and <code>port</code>.
   */
  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    roll();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Roller.class.getName() +
			""host_name port_number"");
    System.exit(1);
  }
  static 
  void init(String hostArg, String portArg) {
    host = hostArg;
    try {
      port =  Integer.parseInt(portArg);
    }
    catch(java.lang.NumberFormatException e) {
      usage(""Second argument ""+portArg+"" is not a valid integer."");
    }
  }
  static
  void roll() {
    try {
      Socket socket = new Socket(host, port);
      DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
      DataInputStream dis = new DataInputStream(socket.getInputStream());
      dos.writeUTF(ExternallyRolledFileAppender.ROLL_OVER);
      String rc = dis.readUTF();
      if(ExternallyRolledFileAppender.OK.equals(rc)) {
	cat.info(""Roll over signal acknowledged by remote appender."");
      } else {
	cat.warn(""Unexpected return code ""+rc+"" from remote entity."");
	System.exit(2);
      }
    } catch(IOException e) {
      cat.error(""Could not send roll signal on host ""+host+"" port ""+port+"" ."",
		e);
      System.exit(2);
    }
    System.exit(0);
  }
}
"
org.apache.log4j.varia.StringMatchFilter,"//  Copyright (c) 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.varia;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on string matching.
   <p>The filter admits two options <b>StringToMatch</b> and
   <b>AcceptOnMatch</b>. If there is a match between the value of the
   StringToMatch option and the message of the {@link LoggingEvent},
   then the {@link #decide} method returns {@link Filter#ACCEPT} if
   the <b>AcceptOnMatch</b> option value is true, if it is false then
   {@link Filter#DENY} is returned. If there is no match, {@link
   Filter#NEUTRAL} is returned.
   <p>See configuration files <a
   href=""../xml/doc-files/test6.xml"">test6.xml</a>, <a
   href=""../xml/doc-files/test7.xml"">test7.xml</a>, <a
   href=""../xml/doc-files/test8.xml"">test8.xml</a>, <a
   href=""../xml/doc-files/test9.xml"">test9.xml</a>, and <a
   href=""../xml/doc-files/test10.xml"">test10.xml</a> for examples of
   seeting up a <code>StringMatchFilter</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class StringMatchFilter extends Filter {
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String STRING_TO_MATCH_OPTION = ""StringToMatch"";
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
   */
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
  boolean acceptOnMatch = true;
  String stringToMatch;
  /**
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return new String[] {STRING_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};
  }
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) { 
    if(key.equalsIgnoreCase(STRING_TO_MATCH_OPTION)) {
      stringToMatch = value;
    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
  public
  void setStringToMatch(String s) {
    stringToMatch = s;
  }
  public
  String getStringToMatch() {
    return stringToMatch;
  }
  public
  void setAcceptOnMatch(boolean acceptOnMatch) {
    this.acceptOnMatch = acceptOnMatch;
  }
  public
  boolean getAcceptOnMatch() {
    return acceptOnMatch;
  }
  /**
     Returns {@link Filter#NEUTRAL} is there is no string match.
   */
  public
  int decide(LoggingEvent event) {
    String msg = event.getRenderedMessage();
    if(msg == null ||  stringToMatch == null)
      return Filter.NEUTRAL;
    if( msg.indexOf(stringToMatch) == -1 ) {
      return Filter.NEUTRAL;
    } else { // we've got a match
      if(acceptOnMatch) {
	return Filter.ACCEPT;
      } else {
	return Filter.DENY;
      }
    }
  }
}
"
org.apache.log4j.varia.test.Loop,"package org.apache.log4j.varia.test; 
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
/**
   This test program reads a config file and attempts to log to the
   appenders specified as many times as specified by the second
   loopLength parameter.
   @author Ceki G&uuml;lc&uuml; */
public class Loop {
  static Category cat = Category.getInstance(Loop.class.getName());
  static int loopLength;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Loop.class.getName() +
			""configFile loopLength"");
    System.exit(1);
  }
  static
  void init(String configFile, String loopStr) {
    PropertyConfigurator.configure(configFile);
    try {
      loopLength   = Integer.parseInt(loopStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret loopLength [""+ loopStr +""]."");
    }
  }
  static
  void test() {
    for(int i=0; i < loopLength; i++) {
      Thread.yield();
      cat.debug(""MSG ""+i);
    }
  }
}
"
org.apache.log4j.xml.DOMConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml;
import java.util.*;
import java.net.URL;
import org.w3c.dom.*;
import java.lang.reflect.Method;
import org.apache.log4j.Category;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.Appender;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.config.PropertySetter;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.FileWatchdog;
import org.xml.sax.InputSource;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.FactoryConfigurationError;
/**
   Use this class to initialize the log4j environment using a DOM tree.
   <p>The DTD is specified in <a
   href=""doc-files/log4j.dtd""><b>log4j.dtd</b></a>.
   <p>Sometimes it is useful to see how log4j is reading configuration
   files. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable on the java command line.
   <p>There are sample XML files included in the package.
   @author Christopher Taylor
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.3 */
public class DOMConfigurator extends BasicConfigurator implements Configurator {
  static final String CONFIGURATION_TAG = ""log4j:configuration"";
  static final String OLD_CONFIGURATION_TAG = ""configuration"";
  static final String RENDERER_TAG      = ""renderer"";
  static final String APPENDER_TAG 	= ""appender"";
  static final String APPENDER_REF_TAG 	= ""appender-ref"";  
  static final String PARAM_TAG    	= ""param"";
  static final String LAYOUT_TAG	= ""layout"";
  static final String CATEGORY		= ""category"";
  static final String NAME_ATTR		= ""name"";
  static final String CLASS_ATTR        = ""class"";
  static final String VALUE_ATTR	= ""value"";
  static final String ROOT_TAG		= ""root"";
  static final String PRIORITY_TAG	= ""priority"";
  static final String FILTER_TAG	= ""filter"";
  static final String ERROR_HANDLER_TAG	= ""errorHandler"";
  static final String REF_ATTR		= ""ref"";
  static final String ADDITIVITY_ATTR    = ""additivity"";  
  static final String DISABLE_OVERRIDE_ATTR = ""disableOverride"";
  static final String DISABLE_ATTR       = ""disable"";
  static final String CONFIG_DEBUG_ATTR  = ""configDebug"";
  static final String INTERNAL_DEBUG_ATTR  = ""debug"";
  static final String RENDERING_CLASS_ATTR = ""renderingClass"";
  static final String RENDERED_CLASS_ATTR = ""renderedClass"";
  static final String EMPTY_STR = """";
  static final Class[] ONE_STRING_PARAM = new Class[] {String.class};
  final static String dbfKey = ""javax.xml.parsers.DocumentBuilderFactory"";
  // key: appenderName, value: appender
  Hashtable appenderBag;
  Properties props;
  /**
     No argument constructor.
  */
  public
  DOMConfigurator () { 
    appenderBag = new Hashtable();
  }
  /**
     Used internally to parse appenders by IDREF.
   */
  protected
  Appender findAppenderByReference(Element appenderRef) {    
    String appenderName = subst(appenderRef.getAttribute(REF_ATTR));
    Appender appender = (Appender) appenderBag.get(appenderName);
    if(appender != null) {
      return appender;
    } else {
      Document doc = appenderRef.getOwnerDocument();
      // Doesn't work on DOM Level 1 :
      // Element element = doc.getElementById(appenderName);
      // Endre's hack:
      Element element = null;
      NodeList list = doc.getElementsByTagName(""appender"");
      for (int t=0; t<list.getLength(); t++) {
	Node node = list.item(t);
	NamedNodeMap map= node.getAttributes();
	Node attrNode = map.getNamedItem(""name"");
	if (appenderName.equals(attrNode.getNodeValue())) {
	  element = (Element) node;
	  break;
	}
      }
      // Hack finished.
      if(element == null) {
	LogLog.error(""No appender named [""+appenderName+""] could be found.""); 
	return null;
      } else {
	appender = parseAppender(element);
	appenderBag.put(appenderName, appender);
	return appender;
      }
    } 
  }
  /**
     Used internally to parse an appender element.
   */
  protected
  Appender parseAppender (Element appenderElement) {
    String className = subst(appenderElement.getAttribute(CLASS_ATTR));
    LogLog.debug(""Class name: ["" + className+']');    
    try {
      Object instance 	= Class.forName(className).newInstance();
      Appender appender	= (Appender)instance;
      PropertySetter propSetter = new PropertySetter(appender);
      appender.setName(subst(appenderElement.getAttribute(NAME_ATTR)));
      NodeList children	= appenderElement.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	/* We're only interested in Elements */
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element)currentNode;
	  // Parse appender parameters 
	  if (currentElement.getTagName().equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	  // Set appender layout
	  else if (currentElement.getTagName().equals(LAYOUT_TAG)) {
	    appender.setLayout(parseLayout(currentElement));
	  }
	  // Add filters
	  else if (currentElement.getTagName().equals(FILTER_TAG)) {
	    parseFilters(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {
	    parseErrorHandler(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {
	    String refName = subst(currentElement.getAttribute(REF_ATTR));
	    if(appender instanceof AppenderAttachable) {
	      AppenderAttachable aa = (AppenderAttachable) appender;
	      LogLog.debug(""Attaching appender named [""+ refName+
			   ""] to appender named [""+ appender.getName()+""]."");
	      aa.addAppender(findAppenderByReference(currentElement));
	    } else {
	      LogLog.error(""Requesting attachment of appender named [""+
			   refName+ ""] to appender named [""+ appender.getName()+
                ""] which does not implement org.apache.log4j.spi.AppenderAttachable."");
	    }
	  }
	}
      }
      propSetter.activate();
      return appender;
    }
    /* Yes, it's ugly.  But all of these exceptions point to the same
       problem: we can't create an Appender */
    catch (Exception oops) {
      LogLog.error(""Could not create an Appender. Reported error follows."",
		   oops);
      return null;
    }
  }
  /**
     Used internally to parse an {@link ErrorHandler} element.
   */
  protected
  void parseErrorHandler(Element element, Appender appender) {
    ErrorHandler eh = (ErrorHandler) OptionConverter.instantiateByClassName(
                                       subst(element.getAttribute(CLASS_ATTR)),
                                       org.apache.log4j.spi.ErrorHandler.class, 
 				       null);
    if(eh != null) {
      PropertySetter propSetter = new PropertySetter(eh);
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	}
      }
      propSetter.activate();
      appender.setErrorHandler(eh);
    }
  }
  /**
     Used internally to parse a filter element.
   */
  protected
  void parseFilters(Element element, Appender appender) {
    String clazz = subst(element.getAttribute(CLASS_ATTR));
    Filter filter = (Filter) OptionConverter.instantiateByClassName(clazz,
                                                Filter.class, null);
    if(filter != null) {
      PropertySetter propSetter = new PropertySetter(filter);
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	}
      }
      propSetter.activate();
      appender.addFilter(filter);
    }    
  }
  /**
     Used internally to parse an category element.
  */
  protected
  void parseCategory (Element categoryElement, Hierarchy hierarchy) {
    // Create a new org.apache.log4j.Category object from the <category> element.
    String catName = subst(categoryElement.getAttribute(NAME_ATTR));
    Category cat;    
    String className = subst(categoryElement.getAttribute(CLASS_ATTR));
    if(EMPTY_STR.equals(className)) {
      LogLog.debug(""Retreiving an instance of org.apache.log4j.Category."");
      cat = hierarchy.getInstance(catName);
    }
    else {
      LogLog.debug(""Desired category sub-class: [""+className+']');
       try {	 
	 Class clazz = Class.forName(className);
	 Method getInstanceMethod = clazz.getMethod(""getInstance"", 
						    ONE_STRING_PARAM);
	 cat = (Category) getInstanceMethod.invoke(null, new Object[] {catName});
       } catch (Exception oops) {
	 LogLog.error(""Could not retrieve category [""+catName+
		      ""]. Reported error follows."", oops);
	 return;
       }
    }
    // Setting up a category needs to be an atomic operation, in order
    // to protect potential log operations while category
    // configuration is in progress.
    synchronized(cat) {
      boolean additivity = OptionConverter.toBoolean(
                           subst(categoryElement.getAttribute(ADDITIVITY_ATTR)),
			   true);
      LogLog.debug(""Setting [""+cat.getName()+""] additivity to [""+additivity+""]."");
      cat.setAdditivity(additivity);
      parseChildrenOfCategoryElement(categoryElement, cat, false);
    }
  }
  /**
     Used internally to parse the roor category element.
  */
  protected
  void parseRoot (Element rootElement, Hierarchy hierarchy) {
    Category root = hierarchy.getRoot();
    // category configuration needs to be atomic
    synchronized(root) {    
      parseChildrenOfCategoryElement(rootElement, root, true);
    }
  }
  /**
     Used internally to parse the children of a category element.
  */
  protected
  void parseChildrenOfCategoryElement(Element catElement,
				      Category cat, boolean isRoot) {
    PropertySetter propSetter = new PropertySetter(cat);
    // Remove all existing appenders from cat. They will be
    // reconstructed if need be.
    cat.removeAllAppenders();
    NodeList children 	= catElement.getChildNodes();
    final int length 	= children.getLength();
    for (int loop = 0; loop < length; loop++) {
      Node currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	Element currentElement = (Element) currentNode;
	String tagName = currentElement.getTagName();
	if (tagName.equals(APPENDER_REF_TAG)) {
	  Element appenderRef = (Element) currentNode;
	  Appender appender = findAppenderByReference(appenderRef);
	  String refName =  subst(appenderRef.getAttribute(REF_ATTR));
	  if(appender != null)
	    LogLog.debug(""Adding appender named [""+ refName+ 
			 ""] to category [""+cat.getName()+""]."");
	  else 
	    LogLog.debug(""Appender named [""+ refName + ""] not found."");
	  cat.addAppender(appender);
	} else if(tagName.equals(PRIORITY_TAG)) {
	  parsePriority(currentElement, cat, isRoot);	
	} else if(tagName.equals(PARAM_TAG)) {
          setParameter(currentElement, propSetter);
	}
      }
    }
    propSetter.activate();
  }
  /**
     Used internally to parse a layout element.
  */  
  protected
  Layout parseLayout (Element layout_element) {
    String className = subst(layout_element.getAttribute(CLASS_ATTR));
    LogLog.debug(""Parsing layout of class: \""""+className+""\"""");		 
    try {
      Object instance 	= Class.forName(className).newInstance();
      Layout layout   	= (Layout)instance;
      PropertySetter propSetter = new PropertySetter(layout);
      NodeList params 	= layout_element.getChildNodes();
      final int length 	= params.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = (Node)params.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
            setParameter(currentElement, propSetter);
	  }
	}
      }
      propSetter.activate();
      return layout;
    }
    catch (Exception oops) {
      LogLog.error(""Could not create the Layout. Reported error follows."",
		   oops);
      return null;
    }
  }
  protected 
  void parseRenderer(Element element, Hierarchy hierarchy) {
    String renderingClass = subst(element.getAttribute(RENDERING_CLASS_ATTR));
    String renderedClass = subst(element.getAttribute(RENDERED_CLASS_ATTR));
    addRenderer(hierarchy, renderedClass, renderingClass);
  }
  /**
     Used internally to parse a priority  element.
  */
  protected
  void parsePriority(Element element, Category cat, boolean isRoot) {
    String catName = cat.getName();
    if(isRoot) {
      catName = ""root"";
    }
    String priStr = subst(element.getAttribute(VALUE_ATTR));
    LogLog.debug(""Priority value for ""+catName+"" is  [""+priStr+""]."");
    if(BasicConfigurator.INHERITED.equals(priStr)) {
      if(isRoot) {
	LogLog.error(""Root priority cannot be inherited. Ignoring directive."");
      } else {
	cat.setPriority(null);
      }
    }
    else {
      String className = subst(element.getAttribute(CLASS_ATTR));      
      if(EMPTY_STR.equals(className)) {      
	cat.setPriority(Priority.toPriority(priStr));
      } else {
	LogLog.debug(""Desired Priority sub-class: [""+className+']');
	try {	 
	  Class clazz = Class.forName(className);
	  Method toPriorityMethod = clazz.getMethod(""toPriority"", 
						    ONE_STRING_PARAM);
	  Priority pri = (Priority) toPriorityMethod.invoke(null, 
						    new Object[] {priStr});
	  cat.setPriority(pri);
	} catch (Exception oops) {
	  LogLog.error(""Could not create priority [""+priStr+
		       ""]. Reported error follows."", oops);
	  return;
	}
      }
    }
    LogLog.debug(catName + "" priority set to "" + cat.getPriority());    
  }
  protected
  void setParameter(Element elem, PropertySetter propSetter) {
    String name = subst(elem.getAttribute(NAME_ATTR));
    String value = (elem.getAttribute(VALUE_ATTR));
    value = subst(OptionConverter.convertSpecialChars(value));
    propSetter.setProperty(name, value);
  }
  /**
     Configure log4j using a <code>configuration</code> element as
     defined in the log4j.dtd. 
  */
  static
  public
  void configure (Element element) {
    DOMConfigurator configurator = new DOMConfigurator();
    configurator.parse(element, Category.getDefaultHierarchy());
  }
 /**
     Like {@link #configureAndWatch(String, long)} except that the
     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
     used. 
     @param configFilename A log4j configuration file in XML format.
  */
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }
  /**
     Read the configuration file <code>configFilename</code> if it
     exists. Moreover, a thread will be created that will periodically
     check if <code>configFilename</code> has been created or
     modified. The period is determined by the <code>delay</code>
     argument. If a change or file creation is detected, then
     <code>configFilename</code> is read to configure log4j.  
      @param configFilename A log4j configuration file in XML format.
      @param delay The delay in milliseconds to wait between each check.
  */
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    XMLWatchdog xdog = new XMLWatchdog(configFilename);
    xdog.setDelay(delay);
    xdog.start();
  }
  public
  void doConfigure(String filename, Hierarchy hierarchy) {
    FileInputStream fis = null;
    try {
      fis = new FileInputStream(filename);
      doConfigure(fis, hierarchy);
    } catch(IOException e) {
      LogLog.error(""Could not open [""+filename+""]."", e);
    } finally {
      if (fis != null) {
	try {
	  fis.close();
	} catch(java.io.IOException e) {
	  LogLog.error(""Could not close [""+filename+""]."", e);
	}
      }
    }
  }
  public
  void doConfigure(URL url, Hierarchy hierarchy) {
    try {
      doConfigure(url.openStream(), hierarchy);
    } catch(IOException e) {
      LogLog.error(""Could not open [""+url+""]."", e);
    }
  }
  /**
     Configure log4j by reading in a log4j.dtd compliant XML
     configuration file.
  */
  public
  void doConfigure(InputStream inputStream, Hierarchy hierarchy) 
                                          throws FactoryConfigurationError {
    DocumentBuilderFactory dbf = null;
    try { 
      LogLog.debug(""System property is :""+
  	                        OptionConverter.getSystemProperty(dbfKey, null)); 
      dbf = DocumentBuilderFactory.newInstance();
      LogLog.debug(""Standard DocumentBuilderFactory search succeded."");
      LogLog.debug(""DocumentBuilderFactory is: ""+dbf.getClass().getName());
    } catch(FactoryConfigurationError fce) {
      Exception e = fce.getException();
      LogLog.debug(""Could not instantiate a DocumentBuilderFactory."", e);
      throw fce;
    }
    try {
      // This makes ID/IDREF attributes to have a meaning. Don't ask
      // me why.
      dbf.setValidating(true);
      //dbf.setNamespaceAware(true);
      DocumentBuilder docBuilder = dbf.newDocumentBuilder();
      //docBuilder.setErrorHandler(new ReportParserError());
      InputSource inputSource = new InputSource(inputStream);
      Class clazz = this.getClass();
      URL dtdURL = clazz.getResource(""/org/apache/log4j/xml/log4j.dtd"");
      if(dtdURL == null) {
	LogLog.error(""Could not find [log4j.dtd]. Used [""+clazz.getClassLoader()+
		     ""] class loader in the search."");
      }
      else {
	LogLog.debug(""URL to log4j.dtd is ["" + dtdURL.toString()+""]."");
	inputSource.setSystemId(dtdURL.toString());
      }
      Document doc = docBuilder.parse(inputSource);
      parse(doc.getDocumentElement(), hierarchy);
    } catch (Exception e) {
      // I know this is miserable...
      LogLog.error(""Could not parse input stream [""+inputStream+""]."", e);
    }
  }
  /**
     This is the static version of {@link #doConfigure(String, Hierarchy)}.x
   */
  static
  public
  void configure(String filename) throws FactoryConfigurationError {
    new DOMConfigurator().doConfigure(filename, Category.getDefaultHierarchy());
  }
  /**
     Used internally to configure the log4j framework by parsing a DOM
     tree of XML elements based on <a
     href=""doc-files/log4j.dtd"">log4j.dtd</a>.
  */
  protected
  void parse(Element element, Hierarchy hierarchy) {
    String rootElementName = element.getTagName();
    if (!rootElementName.equals(CONFIGURATION_TAG)) {
      if(rootElementName.equals(OLD_CONFIGURATION_TAG)) {
	LogLog.warn(""The <""+OLD_CONFIGURATION_TAG+
		     ""> element has been deprecated."");
	LogLog.warn(""Use the <""+CONFIGURATION_TAG+""> element instead."");
      } else {
	LogLog.error(""DOM element is - not a <""+CONFIGURATION_TAG+""> element."");
	return;
      }
    }
    String debugAttrib = subst(element.getAttribute(INTERNAL_DEBUG_ATTR));
    LogLog.debug(""debug attribute= \"""" + debugAttrib +""\""."");
    // if the log4j.dtd is not specified in the XML file, then the
    // ""debug"" attribute is returned as the empty string.
    if(!debugAttrib.equals("""") && !debugAttrib.equals(""null"")) {      
      LogLog.setInternalDebugging(OptionConverter.toBoolean(debugAttrib, true));
    }
    else 
      LogLog.debug(""Ignoring "" + INTERNAL_DEBUG_ATTR + "" attribute."");
    String confDebug = subst(element.getAttribute(CONFIG_DEBUG_ATTR));
    if(!confDebug.equals("""") && !confDebug.equals(""null"")) {      
      LogLog.warn(""The \""""+CONFIG_DEBUG_ATTR+""\"" attribute is deprecated."");
      LogLog.warn(""Use the \""""+INTERNAL_DEBUG_ATTR+""\"" attribute instead."");
      LogLog.setInternalDebugging(OptionConverter.toBoolean(confDebug, true));
    }
    String override = subst(element.getAttribute(DISABLE_OVERRIDE_ATTR));
    LogLog.debug(""Disable override=\"""" + override +""\""."");
    // if the log4j.dtd is not specified in the XML file, then the
    // DISABLE_OVERRIDE attribute is returned as the empty string when
    // it is not specified in the XML file.
    if(!override.equals("""") && !override.equals(""null"")) {
      hierarchy.overrideAsNeeded(override);
    }
    String disableStr = subst(element.getAttribute(DISABLE_ATTR));
    LogLog.debug(""Disable =\"""" + disableStr +""\""."");
    if(!"""".equals(disableStr) && !""null"".equals(disableStr)) {
      hierarchy.disable(disableStr);
    }
    //Hashtable appenderBag = new Hashtable(11);
    /* Building Appender objects, placing them in a local namespace
       for future reference */
    NodeList children = element.getChildNodes();
    final int length = children.getLength();
    for (int loop = 0; loop < length; loop++) {
      Node currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	Element currentElement = (Element) currentNode;
	String tagName = currentElement.getTagName();
	if (tagName.equals(CATEGORY)) {
	  parseCategory(currentElement, hierarchy);
	} else if (tagName.equals(ROOT_TAG)) {
	  parseRoot(currentElement, hierarchy);
	} else if(tagName.equals(RENDERER_TAG)) {
	  parseRenderer(currentElement, hierarchy);
	}
      }
    }
  }
  protected
  String subst(String value) {
    try {
      return OptionConverter.substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.warn(""Could not perform variable substitution."", e);
      return value;
    }
  }
}
class XMLWatchdog extends FileWatchdog {
  XMLWatchdog(String filename) {
    super(filename);
  }
  /**
     Call {@link PropertyConfigurator#configure(String)} with the
     <code>filename</code> to reconfigure log4j. */
  public
  void doOnChange() {
    new DOMConfigurator().doConfigure(filename, Category.getDefaultHierarchy());
  }
}
"
org.apache.log4j.xml.XMLLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contributors:   Mathias Bogaert
package org.apache.log4j.xml;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.DateLayout;
/**
   The output of the XMLLayout consists of a series of log4j:event
   elements as defined in the <a
   href=""doc-files/log4j.dtd"">log4j.dtd</a>. It does not output a
   complete well-formed XML file. The output is designed to be
   included as an <em>external entity</em> in a separate file to form
   a correct XML file.
   <p>For example, if <code>abc</code> is the name of the file where
   the XMLLayout ouput goes, then a well-formed XML file would be:
   <pre>
   &lt;?xml version=""1.0"" ?&gt;
   &lt;!DOCTYPE log4j:eventSet SYSTEM ""log4j.dtd"" [&lt;!ENTITY data SYSTEM ""abc""&gt;]&gt;
   &lt;log4j:eventSet xmlns:log4j=""http://jakarta.apache.org/log4j""&gt;
       &nbsp;&nbsp;&data;
   &lt;/log4j:eventSet&gt;
   </pre>
   <p>This approach enforces the independence of the XMLLayout and the
   appender where it is embedded.
   @author Ceki  G&uuml;lc&uuml;
   @since 0.9.0 */
public class XMLLayout extends Layout {
  /**
     This is a string constant to name the option for setting the
     location information flag. Current value of this string constant
     is <b>LocationInfo</b>. 
     <p>See the {@link #setOption(java.lang.String, java.lang.String)}
     method for the meaning of this option.  
     <p>Note all option keys are case sensitive.
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  private  final int DEFAULT_SIZE = 256;
  private final int UPPER_LIMIT = 2048;
  private StringBuffer buf = new StringBuffer(DEFAULT_SIZE);
  private boolean locationInfo = false;
  /**
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return new String[]{LOCATION_INFO_OPTION};
  }
  /**
     The XMLLayout specific options are:
     <p>The <b>LocationInfo</b> option takes a boolean value. If true,
     the output will include location information. By default no
     location information is sent to the server.
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    if (key.equals(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);    
    } 
  }
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 
     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  /**
     Returns the current value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  public
  void activateOptions() {
  }
  /**
     Formats a {@link LoggingEvent} in conformance with the log4j.dtd.  */
  public
  String format(LoggingEvent event) {
    // Reset working buffer. If the buffer is too large, then we need a new
    // one in order to avoid the penalty of creating a large array.
    if(buf.capacity() > UPPER_LIMIT) {
      buf = new StringBuffer(DEFAULT_SIZE);
    } else {
      buf.setLength(0);
    }
    // We yield to the \r\n heresy.
    buf.append(""<log4j:event category=\"""");
    buf.append(event.categoryName);
    buf.append(""\"" timestamp=\"""");
    buf.append(event.timeStamp);
    buf.append(""\"" priority=\"""");
    buf.append(event.priority);
    buf.append(""\"" thread=\"""");
    buf.append(event.getThreadName());
    buf.append(""\"">\r\n"");
       buf.append(""<log4j:message><![CDATA["");
       buf.append(event.getRenderedMessage());
       buf.append(""]]></log4j:message>\r\n"");       
       String ndc = event.getNDC();
       if(ndc != null) {
	 buf.append(""<log4j:NDC><![CDATA["");
	 buf.append(ndc);
	 buf.append(""]]></log4j:NDC>\r\n"");       
       }
       String[] s = event.getThrowableStrRep();
       if(s != null) {
	 buf.append(""<log4j:throwable><![CDATA["");
	 for(int i = 0; i < s.length; i++) {
	   buf.append(s[i]);
	 }
	 buf.append(""]]></log4j:throwable>\r\n"");
       }
       if(locationInfo) { 
	 LocationInfo locationInfo = event.getLocationInformation();	
	 buf.append(""<log4j:locationInfo class=\"""");
	 buf.append(locationInfo.getClassName());
	 buf.append(""\"" method=\"""");
	 buf.append(locationInfo.getMethodName());
	 buf.append(""\"" file=\"""");
	 buf.append(locationInfo.getFileName());
	 buf.append(""\"" line=\"""");
	 buf.append(locationInfo.getLineNumber());
	 buf.append(""\""/>\r\n"");
       }
    buf.append(""</log4j:event>\r\n\r\n"");
    return buf.toString();
  }
  /**
     The XMLLayout prints and does not ignore exceptions. Hence the
     return value <code>false</code>.
  */
  public
  boolean ignoresThrowable() {
    return false;
  }
}
"
org.apache.log4j.xml.examples.ReportParserError,"package org.apache.log4j.xml.examples;
import org.apache.log4j.helpers.LogLog;
/**
   This class is needed for validating a log4j.dtd derived XML file.
   @author Joe Kesselman
   @since 0.8.3
 */
public class ReportParserError implements org.xml.sax.ErrorHandler {
  void report(String msg, org.xml.sax.SAXParseException e) {
    LogLog.error(msg+e.getMessage()+ ""\n\tat line=""+ e.getLineNumber()+
		 "" col=""+e.getColumnNumber()+ "" of ""+
		 ""SystemId=\""""+e.getSystemId()+
		 ""\"" PublicID = \""""+e.getPublicId()+'\""');
  }
  public void warning(org.xml.sax.SAXParseException e) {
    report(""WARNING: "", e);
  }
  public void error(org.xml.sax.SAXParseException e) {
    report(""ERROR: "", e);
  }
  public void fatalError(org.xml.sax.SAXParseException e) {
    report(""FATAL: "", e);
  }
}
"
org.apache.log4j.xml.examples.XCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml.examples;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.xml.examples.XPriority;
/**
   A simple example showing Category sub-classing. It shows the
   minimum steps necessary to implement one's {@link CategoryFactory}.
   Note that sub-classes follow the hiearchy even if its categories
   belong to different classes.
   <p>See <b><a href=""doc-files/XCategory.java"">source code</a></b>
   for more details. See also <a
   href=""doc-files/extension1.xml"">extension1.xml</a> and <a
   href=""doc-files/extension2.xml"">extension2.xml</a> XML
   configuration files.
   <p>
 */
public class XCategory extends Category implements OptionHandler {
  final private static String FQCN = XCategory.class.getName();
  // It's enough to instantiate a factory once and for all.
  private static XFactory factory = new XFactory();
  public static final String SUFFIX_OPTION = ""Suffix"";
  String suffix = """";
  /**
     Just calls the parent constuctor.
   */
  protected XCategory(String name) {
    super(name);
  }
  /** 
     Nothing to activate.
   */
  public
  void activateOptions() {
  }
  /**
     Overrides the standard debug method by appending the value of
     suffix variable to each message.  
  */
  public 
  void debug(String message) {
    super.debug(message + "" "" + suffix);
  }
  /**
     This method overrides {@link Category#getInstance} by supplying
     its own factory type as a parameter.
   */
  public 
  static
  Category getInstance(String name) {
    return Category.getInstance(name, factory); 
  }
  /**
     This method overrides {@link Category#getInstance(Class)} by supplying
     its own factory type as a parameter.
   */
  public 
  static
  Category getInstance(Class clazz) {
    return getInstance(clazz.getName(), factory); 
  }
 /**
    Retuns the option names for this component, namely the string
    {@link #SUFFIX_OPTION}.
 */
  public
  String[] getOptionStrings() {
    return (new String[] {SUFFIX_OPTION});
  }
  /**
     We introduce a new printing method in order to support {@link
     XPriority#LETHAL}.  */
  public
  void lethal(String message, Throwable t) { 
    // disable is a static variable defined in Category class
    if(hierarchy.isDisabled(XPriority.LETHAL_INT)) 
      return;
    if(XPriority.LETHAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.LETHAL, message, t);
  }
  /**
     We introduce a new printing method in order to support {@link
     XPriority#LETHAL}.  */
  public
  void lethal(String message) { 
    // disable is a static variable defined in Category class
    if(hierarchy.isDisabled(XPriority.LETHAL_INT)) 
      return;
    if(XPriority.LETHAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.LETHAL, message, null);
  }
 /**
     Set XCategory specific options.
     <p>The <b>Suffix</b> option is the only recognized option. It
     takes a string value.
     */
  public
  void setOption(String option, String value) {
    if(option == null) {
      return;
    }
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      this.suffix = value;
      LogLog.debug(""Setting suffix to""+suffix);
    }
  }
  public
  String getOption(String option) {
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      return this.suffix;
    }
    return null;
  }
  /**
     We introduce a new printing method that takes the TRACE priority.
  */
  public
  void trace(String message, Throwable t) { 
    // disable is defined in Category
    if(hierarchy.isDisabled(XPriority.TRACE_INT))
      return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.TRACE, message, t);
  }
  /**
     We introduce a new printing method that takes the TRACE priority.
  */
  public
  void trace(String message) { 
    // disable is defined in Category
    if(hierarchy.isDisabled(XPriority.TRACE_INT))
      return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(FQCN, this, XPriority.TRACE, 
				     message, null));
  }
  // Any sub-class of Category must also have its own implementation of 
  // CategoryFactory.
  public static class XFactory implements CategoryFactory {
    public XFactory() {
    }
    public
    Category makeNewCategoryInstance(String name) {
      return new XCategory(name);
    }
  }
}
"
org.apache.log4j.xml.examples.XMLSample,"package org.apache.log4j.xml.examples;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.net.*;
/**
   This <a href=""doc-files/XMLSample.java"">example code</a> shows how to
   read an XML based configuration file using a DOM parser.
   <p>Sample XML files <a href=""doc-files/sample1.xml"">sample1.xml</a>
   and <a href=""doc-files/sample2.xml"">sample2.xml</a> are provided.
   <p>Note that the log4j.dtd is not in the local directory.
   It is found by the class loader.
   @author Ceki G&uuml;lc&uuml;
*/
public class XMLSample {
  static Category cat = Category.getInstance(XMLSample.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    sample();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + XMLSample.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void sample() {
    int i = -1;
    Category root = Category.getRoot();    
    cat.debug(""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);        
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
  }
}
"
org.apache.log4j.xml.examples.XPriority,"package org.apache.log4j.xml.examples;
import org.apache.log4j.Priority;
/**
   This class introduces a new priority level called TRACE. TRACE has
   lower priority than DEBUG.
 */
public class XPriority extends Priority {
  static final int  TRACE_INT   = Priority.DEBUG_INT - 1;
  static final int  LETHAL_INT  = Priority.FATAL_INT + 1;
  private static String TRACE_STR  = ""TRACE"";
  private static String LETHAL_STR  = ""LETHAL"";
  public static final XPriority TRACE = new XPriority(TRACE_INT, TRACE_STR, 7);
  public static final XPriority LETHAL = new XPriority(LETHAL_INT, LETHAL_STR, 
						       0);
  protected
  XPriority(int level, String strLevel, int syslogEquiv) {
    super(level, strLevel, syslogEquiv);
  }
  public
  static
  Priority toPriority(String sArg, Priority defaultValue) {
    if(sArg == null) {
      return defaultValue;
    }
    String stringVal = sArg.toUpperCase();
    if(stringVal.equals(TRACE_STR)) {
      return XPriority.TRACE;
    } else if(stringVal.equals(LETHAL_STR)) {
      return XPriority.LETHAL;
    }
    return Priority.toPriority(sArg, defaultValue);    
  }
  public
  static
  Priority toPriority(int i) throws  IllegalArgumentException {
    switch(i) {
    case TRACE_INT: return XPriority.TRACE;
    case LETHAL_INT: return XPriority.LETHAL;
    }
    return Priority.toPriority(i);
  }
}
"
org.apache.log4j.xml.examples.XTest,"package org.apache.log4j.xml.examples;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.net.*;
/**
   A simple example showing Category sub-classing. It shows the
   minimum steps necessary to implement one's {@link
   org.apache.log4j.spi.CategoryFactory} and that sub-classes can follow the
   hiearchy
   See <b><a href=""doc-files/XCategory.java"">source
   code</a></b> for more details.
 */
public class XTest {
  /**
     This program will just print 
     <pre>
       DEBUG [main] some.cat - Hello world.
     </pre>
     and exit.
   */
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    sample();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + XTest.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void sample() {
    int i = -1;
    XCategory cat = (XCategory) XCategory.getInstance(""some.cat"");    
    Category root = Category.getRoot();    
    cat.trace(""Message "" + ++i);
    cat.debug(""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);        
    cat.fatal(""Message "" + ++i);        
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
  }
}
"
org.apache.log4j.xml.test.DisableOverrideTest,"package org.apache.log4j.xml.test;
import org.apache.log4j.Category;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
//import org.xml.sax.InputSource;
//import org.apache.log4j.xml.examples.ReportParserError;
//import org.apache.xerces.parsers.DOMParser;
public class DisableOverrideTest {
  static Category CAT = Category.getInstance(DisableOverrideTest.class);
  public static void main( String[] argv) {
    String configFile = null;
    if(argv.length == 1) 
      configFile = argv[0];
    else 
      Usage(""Wrong number of arguments."");
    DOMConfigurator.configure(configFile);
    Category.getDefaultHierarchy().disableInfo();       
    CAT.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ DisableOverrideTest.class.getName() +
		       ""configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.xml.test.DOMTest,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml.test;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
//import org.apache.log4j.xml.examples.ReportParserError;
//import org.apache.xerces.parsers.DOMParser;
//import java.io.FileInputStream;
//import org.xml.sax.InputSource;
/**
   @author Ceki G&uuml;lc&uuml;
*/
public class DOMTest {
  static Category cat = Category.getInstance(DOMTest.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DOMTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
    //try {
      //DOMParser domParser = new DOMParser();
      //domParser.setFeature(""http://xml.org/sax/features/validation"", true);
      //domParser.setFeature(""http://xml.org/sax/features/namespaces"", true); 
      //domParser.setErrorHandler(new ReportParserError());      
      //domParser.parse(new InputSource(configFile));
      //DOMConfigurator.configure(domParser.getDocument().getDocumentElement() );
      //}
    //catch(Exception e) {
    //System.err.println(""Could not initialize test program."");
    //e.printStackTrace();
    //System.exit(1);		
    //}
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    Category.shutdown();
  }
}
"
org.apache.log4j.xml.test.SubClassTest,"package org.apache.log4j.xml.test;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.xml.examples.ReportParserError;
import org.apache.log4j.xml.examples.XCategory;
//import org.apache.xerces.parsers.DOMParser;
//import java.io.FileInputStream;
//import org.xml.sax.InputSource;
/**
   @author Ceki G&uuml;lc&uuml;
*/
public class SubClassTest {
  static XCategory cat = (XCategory) 
                        XCategory.getInstance(SubClassTest.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SubClassTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    cat.trace(""Message "" + ++i);
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);
    cat.info (""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);    
    cat.log(Priority.FATAL, ""Message "" + ++i);    
    Exception e = new Exception(""Just testing"");
    cat.trace(""Message "" + ++i, e);
    cat.debug(""Message "" + ++i, e);
    cat.error(""Message "" + ++i, e); 
  }
}
"
